!function(c){var t={};function X(n){if(t[n])return t[n].exports;var e=t[n]={i:n,l:!1,exports:{}};return c[n].call(e.exports,e,e.exports,X),e.l=!0,e.exports}X.m=c,X.c=t,X.d=function(c,t,n){X.o(c,t)||Object.defineProperty(c,t,{enumerable:!0,get:n})},X.r=function(c){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(c,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(c,"__esModule",{value:!0})},X.t=function(c,t){if(1&t&&(c=X(c)),8&t)return c;if(4&t&&"object"==typeof c&&c&&c.__esModule)return c;var n=Object.create(null);if(X.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:c}),2&t&&"string"!=typeof c)for(var e in c)X.d(n,e,function(t){return c[t]}.bind(null,e));return n},X.n=function(c){var t=c&&c.__esModule?function(){return c.default}:function(){return c};return X.d(t,"a",t),t},X.o=function(c,t){return Object.prototype.hasOwnProperty.call(c,t)},X.p="",X(X.s=1)}([function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== "undefined")\n\t\t&& (console.error || console.log)("[Script Loader]", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== "undefined" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== "undefined") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog("EvalError: No eval function available");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcz9mMmI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xuXHRmdW5jdGlvbiBsb2coZXJyb3IpIHtcblx0XHQodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0JiYgKGNvbnNvbGUuZXJyb3IgfHwgY29uc29sZS5sb2cpKFwiW1NjcmlwdCBMb2FkZXJdXCIsIGVycm9yKTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBJRSA9PCA4XG5cdGZ1bmN0aW9uIGlzSUUoKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBhdHRhY2hFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJ1bmRlZmluZWRcIjtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzSUUoKSkge1xuXHRcdFx0ZXhlY1NjcmlwdChzcmMpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGV2YWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2coXCJFdmFsRXJyb3I6IE5vIGV2YWwgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRsb2coZXJyb3IpO1xuXHR9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var script_loader_jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var script_loader_jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(script_loader_jquery__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var script_loader_jquery_validation_dist_jquery_validate_min__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);\n/* harmony import */ var script_loader_jquery_validation_dist_jquery_validate_min__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(script_loader_jquery_validation_dist_jquery_validate_min__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var script_loader_jquery_validation_unobtrusive_dist_jquery_validate_unobtrusive_min__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);\n/* harmony import */ var script_loader_jquery_validation_unobtrusive_dist_jquery_validate_unobtrusive_min__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(script_loader_jquery_validation_unobtrusive_dist_jquery_validate_unobtrusive_min__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var script_loader_bootstrap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);\n/* harmony import */ var script_loader_bootstrap__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(script_loader_bootstrap__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);\n/* harmony import */ var bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var font_awesome_css_font_awesome_min_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);\n/* harmony import */ var font_awesome_css_font_awesome_min_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(font_awesome_css_font_awesome_min_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var script_loader_cldrjs_dist_cldr_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);\n/* harmony import */ var script_loader_cldrjs_dist_cldr_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(script_loader_cldrjs_dist_cldr_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var script_loader_cldrjs_dist_cldr_event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(14);\n/* harmony import */ var script_loader_cldrjs_dist_cldr_event_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(script_loader_cldrjs_dist_cldr_event_js__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var script_loader_cldrjs_dist_cldr_supplemental_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(16);\n/* harmony import */ var script_loader_cldrjs_dist_cldr_supplemental_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(script_loader_cldrjs_dist_cldr_supplemental_js__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var script_loader_cldrjs_dist_cldr_unresolved_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(18);\n/* harmony import */ var script_loader_cldrjs_dist_cldr_unresolved_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(script_loader_cldrjs_dist_cldr_unresolved_js__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var script_loader_globalize_dist_globalize_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(20);\n/* harmony import */ var script_loader_globalize_dist_globalize_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(script_loader_globalize_dist_globalize_js__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var script_loader_globalize_dist_globalize_number_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(22);\n/* harmony import */ var script_loader_globalize_dist_globalize_number_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(script_loader_globalize_dist_globalize_number_js__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var script_loader_globalize_dist_globalize_currency_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(24);\n/* harmony import */ var script_loader_globalize_dist_globalize_currency_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(script_loader_globalize_dist_globalize_currency_js__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var script_loader_globalize_dist_globalize_date_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(26);\n/* harmony import */ var script_loader_globalize_dist_globalize_date_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(script_loader_globalize_dist_globalize_date_js__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var script_loader_globalize_dist_globalize_message_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(28);\n/* harmony import */ var script_loader_globalize_dist_globalize_message_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(script_loader_globalize_dist_globalize_message_js__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var script_loader_globalize_dist_globalize_plural_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(30);\n/* harmony import */ var script_loader_globalize_dist_globalize_plural_js__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(script_loader_globalize_dist_globalize_plural_js__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var script_loader_globalize_dist_globalize_relative_time_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(32);\n/* harmony import */ var script_loader_globalize_dist_globalize_relative_time_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(script_loader_globalize_dist_globalize_relative_time_js__WEBPACK_IMPORTED_MODULE_16__);\n/* harmony import */ var script_loader_globalize_dist_globalize_unit_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(34);\n/* harmony import */ var script_loader_globalize_dist_globalize_unit_js__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(script_loader_globalize_dist_globalize_unit_js__WEBPACK_IMPORTED_MODULE_17__);\n/* harmony import */ var script_loader_flatpickr_dist_flatpickr_min__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(36);\n/* harmony import */ var script_loader_flatpickr_dist_flatpickr_min__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(script_loader_flatpickr_dist_flatpickr_min__WEBPACK_IMPORTED_MODULE_18__);\n/* harmony import */ var script_loader_flatpickr_dist_l10n_ru_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(38);\n/* harmony import */ var script_loader_flatpickr_dist_l10n_ru_js__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(script_loader_flatpickr_dist_l10n_ru_js__WEBPACK_IMPORTED_MODULE_19__);\n/* harmony import */ var script_loader_flatpickr_dist_l10n_et_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(40);\n/* harmony import */ var script_loader_flatpickr_dist_l10n_et_js__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(script_loader_flatpickr_dist_l10n_et_js__WEBPACK_IMPORTED_MODULE_20__);\n/* harmony import */ var flatpickr_dist_flatpickr_min_css__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(42);\n/* harmony import */ var flatpickr_dist_flatpickr_min_css__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(flatpickr_dist_flatpickr_min_css__WEBPACK_IMPORTED_MODULE_21__);\n// Please see documentation at https://docs.microsoft.com/aspnet/core/client-side/bundling-and-minification\r\n// for details on configuring this project to bundle and minify static web assets.\r\n// Write your JavaScript code.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3d3d3Jvb3QvanMvc2l0ZS50cz8zNWIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBsZWFzZSBzZWUgZG9jdW1lbnRhdGlvbiBhdCBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9hc3BuZXQvY29yZS9jbGllbnQtc2lkZS9idW5kbGluZy1hbmQtbWluaWZpY2F0aW9uXHJcbi8vIGZvciBkZXRhaWxzIG9uIGNvbmZpZ3VyaW5nIHRoaXMgcHJvamVjdCB0byBidW5kbGUgYW5kIG1pbmlmeSBzdGF0aWMgd2ViIGFzc2V0cy5cclxuXHJcbi8vIFdyaXRlIHlvdXIgSmF2YVNjcmlwdCBjb2RlLlxyXG5cclxuaW1wb3J0ICdzY3JpcHQtbG9hZGVyIWpxdWVyeSc7XHJcbmltcG9ydCAnc2NyaXB0LWxvYWRlciFqcXVlcnktdmFsaWRhdGlvbi9kaXN0L2pxdWVyeS52YWxpZGF0ZS5taW4nO1xyXG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhanF1ZXJ5LXZhbGlkYXRpb24tdW5vYnRydXNpdmUvZGlzdC9qcXVlcnkudmFsaWRhdGUudW5vYnRydXNpdmUubWluJztcclxuXHJcblxyXG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhcG9wcGVyLmpzL2Rpc3QvcG9wcGVyLm1pbi5qcyc7XHJcblxyXG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhYm9vdHN0cmFwJztcclxuaW1wb3J0ICdib290c3RyYXAvZGlzdC9jc3MvYm9vdHN0cmFwLm1pbi5jc3MnO1xyXG5cclxuaW1wb3J0ICdmb250LWF3ZXNvbWUvY3NzL2ZvbnQtYXdlc29tZS5taW4uY3NzJztcclxuXHJcbmltcG9ydCAnc2NyaXB0LWxvYWRlciFjbGRyanMvZGlzdC9jbGRyLmpzJztcclxuaW1wb3J0ICdzY3JpcHQtbG9hZGVyIWNsZHJqcy9kaXN0L2NsZHIvZXZlbnQuanMnO1xyXG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhY2xkcmpzL2Rpc3QvY2xkci9zdXBwbGVtZW50YWwuanMnO1xyXG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhY2xkcmpzL2Rpc3QvY2xkci91bnJlc29sdmVkLmpzJztcclxuXHJcbmltcG9ydCAnc2NyaXB0LWxvYWRlciFnbG9iYWxpemUvZGlzdC9nbG9iYWxpemUuanMnO1xyXG5cclxuaW1wb3J0ICdzY3JpcHQtbG9hZGVyIWdsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9udW1iZXIuanMnO1xyXG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL2N1cnJlbmN5LmpzJztcclxuaW1wb3J0ICdzY3JpcHQtbG9hZGVyIWdsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9kYXRlLmpzJztcclxuaW1wb3J0ICdzY3JpcHQtbG9hZGVyIWdsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9tZXNzYWdlLmpzJztcclxuaW1wb3J0ICdzY3JpcHQtbG9hZGVyIWdsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9wbHVyYWwuanMnO1xyXG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3JlbGF0aXZlLXRpbWUuanMnO1xyXG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3VuaXQuanMnO1xyXG5cclxuaW1wb3J0ICdzY3JpcHQtbG9hZGVyIWZsYXRwaWNrci9kaXN0L2ZsYXRwaWNrci5taW4nO1xyXG5pbXBvcnQgJ3NjcmlwdC1sb2FkZXIhZmxhdHBpY2tyL2Rpc3QvbDEwbi9ydS5qcyc7XHJcbmltcG9ydCAnc2NyaXB0LWxvYWRlciFmbGF0cGlja3IvZGlzdC9sMTBuL2V0LmpzJztcclxuaW1wb3J0ICdmbGF0cGlja3IvZGlzdC9mbGF0cGlja3IubWluLmNzcyc7XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(3))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanM/NTY5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXGpxdWVyeVxcXFxkaXN0XFxcXGpxdWVyeS5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},function(module,exports){eval('module.exports = "/*!\\n * jQuery JavaScript Library v3.5.1\\n * https://jquery.com/\\n *\\n * Includes Sizzle.js\\n * https://sizzlejs.com/\\n *\\n * Copyright JS Foundation and other contributors\\n * Released under the MIT license\\n * https://jquery.org/license\\n *\\n * Date: 2020-05-04T22:49Z\\n */\\n( function( global, factory ) {\\n\\n\\t\\"use strict\\";\\n\\n\\tif ( typeof module === \\"object\\" && typeof module.exports === \\"object\\" ) {\\n\\n\\t\\t// For CommonJS and CommonJS-like environments where a proper `window`\\n\\t\\t// is present, execute the factory and get jQuery.\\n\\t\\t// For environments that do not have a `window` with a `document`\\n\\t\\t// (such as Node.js), expose a factory as module.exports.\\n\\t\\t// This accentuates the need for the creation of a real `window`.\\n\\t\\t// e.g. var jQuery = require(\\"jquery\\")(window);\\n\\t\\t// See ticket #14549 for more info.\\n\\t\\tmodule.exports = global.document ?\\n\\t\\t\\tfactory( global, true ) :\\n\\t\\t\\tfunction( w ) {\\n\\t\\t\\t\\tif ( !w.document ) {\\n\\t\\t\\t\\t\\tthrow new Error( \\"jQuery requires a window with a document\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn factory( w );\\n\\t\\t\\t};\\n\\t} else {\\n\\t\\tfactory( global );\\n\\t}\\n\\n// Pass this if window is not defined yet\\n} )( typeof window !== \\"undefined\\" ? window : this, function( window, noGlobal ) {\\n\\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\\n// enough that all such attempts are guarded in a try block.\\n\\"use strict\\";\\n\\nvar arr = [];\\n\\nvar getProto = Object.getPrototypeOf;\\n\\nvar slice = arr.slice;\\n\\nvar flat = arr.flat ? function( array ) {\\n\\treturn arr.flat.call( array );\\n} : function( array ) {\\n\\treturn arr.concat.apply( [], array );\\n};\\n\\n\\nvar push = arr.push;\\n\\nvar indexOf = arr.indexOf;\\n\\nvar class2type = {};\\n\\nvar toString = class2type.toString;\\n\\nvar hasOwn = class2type.hasOwnProperty;\\n\\nvar fnToString = hasOwn.toString;\\n\\nvar ObjectFunctionString = fnToString.call( Object );\\n\\nvar support = {};\\n\\nvar isFunction = function isFunction( obj ) {\\n\\n      // Support: Chrome <=57, Firefox <=52\\n      // In some browsers, typeof returns \\"function\\" for HTML <object> elements\\n      // (i.e., `typeof document.createElement( \\"object\\" ) === \\"function\\"`).\\n      // We don\'t want to classify *any* DOM node as a function.\\n      return typeof obj === \\"function\\" && typeof obj.nodeType !== \\"number\\";\\n  };\\n\\n\\nvar isWindow = function isWindow( obj ) {\\n\\t\\treturn obj != null && obj === obj.window;\\n\\t};\\n\\n\\nvar document = window.document;\\n\\n\\n\\n\\tvar preservedScriptAttributes = {\\n\\t\\ttype: true,\\n\\t\\tsrc: true,\\n\\t\\tnonce: true,\\n\\t\\tnoModule: true\\n\\t};\\n\\n\\tfunction DOMEval( code, node, doc ) {\\n\\t\\tdoc = doc || document;\\n\\n\\t\\tvar i, val,\\n\\t\\t\\tscript = doc.createElement( \\"script\\" );\\n\\n\\t\\tscript.text = code;\\n\\t\\tif ( node ) {\\n\\t\\t\\tfor ( i in preservedScriptAttributes ) {\\n\\n\\t\\t\\t\\t// Support: Firefox 64+, Edge 18+\\n\\t\\t\\t\\t// Some browsers don\'t support the \\"nonce\\" property on scripts.\\n\\t\\t\\t\\t// On the other hand, just using `getAttribute` is not enough as\\n\\t\\t\\t\\t// the `nonce` attribute is reset to an empty string whenever it\\n\\t\\t\\t\\t// becomes browsing-context connected.\\n\\t\\t\\t\\t// See https://github.com/whatwg/html/issues/2369\\n\\t\\t\\t\\t// See https://html.spec.whatwg.org/#nonce-attributes\\n\\t\\t\\t\\t// The `node.getAttribute` check was added for the sake of\\n\\t\\t\\t\\t// `jQuery.globalEval` so that it can fake a nonce-containing node\\n\\t\\t\\t\\t// via an object.\\n\\t\\t\\t\\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\\n\\t\\t\\t\\tif ( val ) {\\n\\t\\t\\t\\t\\tscript.setAttribute( i, val );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdoc.head.appendChild( script ).parentNode.removeChild( script );\\n\\t}\\n\\n\\nfunction toType( obj ) {\\n\\tif ( obj == null ) {\\n\\t\\treturn obj + \\"\\";\\n\\t}\\n\\n\\t// Support: Android <=2.3 only (functionish RegExp)\\n\\treturn typeof obj === \\"object\\" || typeof obj === \\"function\\" ?\\n\\t\\tclass2type[ toString.call( obj ) ] || \\"object\\" :\\n\\t\\ttypeof obj;\\n}\\n/* global Symbol */\\n// Defining this global in .eslintrc.json would create a danger of using the global\\n// unguarded in another place, it seems safer to define global only for this module\\n\\n\\n\\nvar\\n\\tversion = \\"3.5.1\\",\\n\\n\\t// Define a local copy of jQuery\\n\\tjQuery = function( selector, context ) {\\n\\n\\t\\t// The jQuery object is actually just the init constructor \'enhanced\'\\n\\t\\t// Need init if jQuery is called (just allow error to be thrown if not included)\\n\\t\\treturn new jQuery.fn.init( selector, context );\\n\\t};\\n\\njQuery.fn = jQuery.prototype = {\\n\\n\\t// The current version of jQuery being used\\n\\tjquery: version,\\n\\n\\tconstructor: jQuery,\\n\\n\\t// The default length of a jQuery object is 0\\n\\tlength: 0,\\n\\n\\ttoArray: function() {\\n\\t\\treturn slice.call( this );\\n\\t},\\n\\n\\t// Get the Nth element in the matched element set OR\\n\\t// Get the whole matched element set as a clean array\\n\\tget: function( num ) {\\n\\n\\t\\t// Return all the elements in a clean array\\n\\t\\tif ( num == null ) {\\n\\t\\t\\treturn slice.call( this );\\n\\t\\t}\\n\\n\\t\\t// Return just the one element from the set\\n\\t\\treturn num < 0 ? this[ num + this.length ] : this[ num ];\\n\\t},\\n\\n\\t// Take an array of elements and push it onto the stack\\n\\t// (returning the new matched element set)\\n\\tpushStack: function( elems ) {\\n\\n\\t\\t// Build a new jQuery matched element set\\n\\t\\tvar ret = jQuery.merge( this.constructor(), elems );\\n\\n\\t\\t// Add the old object onto the stack (as a reference)\\n\\t\\tret.prevObject = this;\\n\\n\\t\\t// Return the newly-formed element set\\n\\t\\treturn ret;\\n\\t},\\n\\n\\t// Execute a callback for every element in the matched set.\\n\\teach: function( callback ) {\\n\\t\\treturn jQuery.each( this, callback );\\n\\t},\\n\\n\\tmap: function( callback ) {\\n\\t\\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\\n\\t\\t\\treturn callback.call( elem, i, elem );\\n\\t\\t} ) );\\n\\t},\\n\\n\\tslice: function() {\\n\\t\\treturn this.pushStack( slice.apply( this, arguments ) );\\n\\t},\\n\\n\\tfirst: function() {\\n\\t\\treturn this.eq( 0 );\\n\\t},\\n\\n\\tlast: function() {\\n\\t\\treturn this.eq( -1 );\\n\\t},\\n\\n\\teven: function() {\\n\\t\\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\\n\\t\\t\\treturn ( i + 1 ) % 2;\\n\\t\\t} ) );\\n\\t},\\n\\n\\todd: function() {\\n\\t\\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\\n\\t\\t\\treturn i % 2;\\n\\t\\t} ) );\\n\\t},\\n\\n\\teq: function( i ) {\\n\\t\\tvar len = this.length,\\n\\t\\t\\tj = +i + ( i < 0 ? len : 0 );\\n\\t\\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\\n\\t},\\n\\n\\tend: function() {\\n\\t\\treturn this.prevObject || this.constructor();\\n\\t},\\n\\n\\t// For internal use only.\\n\\t// Behaves like an Array\'s method, not like a jQuery method.\\n\\tpush: push,\\n\\tsort: arr.sort,\\n\\tsplice: arr.splice\\n};\\n\\njQuery.extend = jQuery.fn.extend = function() {\\n\\tvar options, name, src, copy, copyIsArray, clone,\\n\\t\\ttarget = arguments[ 0 ] || {},\\n\\t\\ti = 1,\\n\\t\\tlength = arguments.length,\\n\\t\\tdeep = false;\\n\\n\\t// Handle a deep copy situation\\n\\tif ( typeof target === \\"boolean\\" ) {\\n\\t\\tdeep = target;\\n\\n\\t\\t// Skip the boolean and the target\\n\\t\\ttarget = arguments[ i ] || {};\\n\\t\\ti++;\\n\\t}\\n\\n\\t// Handle case when target is a string or something (possible in deep copy)\\n\\tif ( typeof target !== \\"object\\" && !isFunction( target ) ) {\\n\\t\\ttarget = {};\\n\\t}\\n\\n\\t// Extend jQuery itself if only one argument is passed\\n\\tif ( i === length ) {\\n\\t\\ttarget = this;\\n\\t\\ti--;\\n\\t}\\n\\n\\tfor ( ; i < length; i++ ) {\\n\\n\\t\\t// Only deal with non-null/undefined values\\n\\t\\tif ( ( options = arguments[ i ] ) != null ) {\\n\\n\\t\\t\\t// Extend the base object\\n\\t\\t\\tfor ( name in options ) {\\n\\t\\t\\t\\tcopy = options[ name ];\\n\\n\\t\\t\\t\\t// Prevent Object.prototype pollution\\n\\t\\t\\t\\t// Prevent never-ending loop\\n\\t\\t\\t\\tif ( name === \\"__proto__\\" || target === copy ) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Recurse if we\'re merging plain objects or arrays\\n\\t\\t\\t\\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\\n\\t\\t\\t\\t\\t( copyIsArray = Array.isArray( copy ) ) ) ) {\\n\\t\\t\\t\\t\\tsrc = target[ name ];\\n\\n\\t\\t\\t\\t\\t// Ensure proper type for the source value\\n\\t\\t\\t\\t\\tif ( copyIsArray && !Array.isArray( src ) ) {\\n\\t\\t\\t\\t\\t\\tclone = [];\\n\\t\\t\\t\\t\\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\\n\\t\\t\\t\\t\\t\\tclone = {};\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tclone = src;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcopyIsArray = false;\\n\\n\\t\\t\\t\\t\\t// Never move original objects, clone them\\n\\t\\t\\t\\t\\ttarget[ name ] = jQuery.extend( deep, clone, copy );\\n\\n\\t\\t\\t\\t// Don\'t bring in undefined values\\n\\t\\t\\t\\t} else if ( copy !== undefined ) {\\n\\t\\t\\t\\t\\ttarget[ name ] = copy;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the modified object\\n\\treturn target;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Unique for each copy of jQuery on the page\\n\\texpando: \\"jQuery\\" + ( version + Math.random() ).replace( /\\\\D/g, \\"\\" ),\\n\\n\\t// Assume jQuery is ready without the ready module\\n\\tisReady: true,\\n\\n\\terror: function( msg ) {\\n\\t\\tthrow new Error( msg );\\n\\t},\\n\\n\\tnoop: function() {},\\n\\n\\tisPlainObject: function( obj ) {\\n\\t\\tvar proto, Ctor;\\n\\n\\t\\t// Detect obvious negatives\\n\\t\\t// Use toString instead of jQuery.type to catch host objects\\n\\t\\tif ( !obj || toString.call( obj ) !== \\"[object Object]\\" ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tproto = getProto( obj );\\n\\n\\t\\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\\n\\t\\tif ( !proto ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Objects with prototype are plain iff they were constructed by a global Object function\\n\\t\\tCtor = hasOwn.call( proto, \\"constructor\\" ) && proto.constructor;\\n\\t\\treturn typeof Ctor === \\"function\\" && fnToString.call( Ctor ) === ObjectFunctionString;\\n\\t},\\n\\n\\tisEmptyObject: function( obj ) {\\n\\t\\tvar name;\\n\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t},\\n\\n\\t// Evaluates a script in a provided context; falls back to the global one\\n\\t// if not specified.\\n\\tglobalEval: function( code, options, doc ) {\\n\\t\\tDOMEval( code, { nonce: options && options.nonce }, doc );\\n\\t},\\n\\n\\teach: function( obj, callback ) {\\n\\t\\tvar length, i = 0;\\n\\n\\t\\tif ( isArrayLike( obj ) ) {\\n\\t\\t\\tlength = obj.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in obj ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn obj;\\n\\t},\\n\\n\\t// results is for internal usage only\\n\\tmakeArray: function( arr, results ) {\\n\\t\\tvar ret = results || [];\\n\\n\\t\\tif ( arr != null ) {\\n\\t\\t\\tif ( isArrayLike( Object( arr ) ) ) {\\n\\t\\t\\t\\tjQuery.merge( ret,\\n\\t\\t\\t\\t\\ttypeof arr === \\"string\\" ?\\n\\t\\t\\t\\t\\t[ arr ] : arr\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.call( ret, arr );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n\\t},\\n\\n\\tinArray: function( elem, arr, i ) {\\n\\t\\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\tmerge: function( first, second ) {\\n\\t\\tvar len = +second.length,\\n\\t\\t\\tj = 0,\\n\\t\\t\\ti = first.length;\\n\\n\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\tfirst[ i++ ] = second[ j ];\\n\\t\\t}\\n\\n\\t\\tfirst.length = i;\\n\\n\\t\\treturn first;\\n\\t},\\n\\n\\tgrep: function( elems, callback, invert ) {\\n\\t\\tvar callbackInverse,\\n\\t\\t\\tmatches = [],\\n\\t\\t\\ti = 0,\\n\\t\\t\\tlength = elems.length,\\n\\t\\t\\tcallbackExpect = !invert;\\n\\n\\t\\t// Go through the array, only saving the items\\n\\t\\t// that pass the validator function\\n\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\tcallbackInverse = !callback( elems[ i ], i );\\n\\t\\t\\tif ( callbackInverse !== callbackExpect ) {\\n\\t\\t\\t\\tmatches.push( elems[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn matches;\\n\\t},\\n\\n\\t// arg is for internal usage only\\n\\tmap: function( elems, callback, arg ) {\\n\\t\\tvar length, value,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tret = [];\\n\\n\\t\\t// Go through the array, translating each of the items to their new values\\n\\t\\tif ( isArrayLike( elems ) ) {\\n\\t\\t\\tlength = elems.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Go through every key on the object,\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in elems ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Flatten any nested arrays\\n\\t\\treturn flat( ret );\\n\\t},\\n\\n\\t// A global GUID counter for objects\\n\\tguid: 1,\\n\\n\\t// jQuery.support is not used in Core but other projects attach their\\n\\t// properties to it so it needs to exist.\\n\\tsupport: support\\n} );\\n\\nif ( typeof Symbol === \\"function\\" ) {\\n\\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\\n}\\n\\n// Populate the class2type map\\njQuery.each( \\"Boolean Number String Function Array Date RegExp Object Error Symbol\\".split( \\" \\" ),\\nfunction( _i, name ) {\\n\\tclass2type[ \\"[object \\" + name + \\"]\\" ] = name.toLowerCase();\\n} );\\n\\nfunction isArrayLike( obj ) {\\n\\n\\t// Support: real iOS 8.2 only (not reproducible in simulator)\\n\\t// `in` check used to prevent JIT error (gh-2145)\\n\\t// hasOwn isn\'t used here due to false negatives\\n\\t// regarding Nodelist length in IE\\n\\tvar length = !!obj && \\"length\\" in obj && obj.length,\\n\\t\\ttype = toType( obj );\\n\\n\\tif ( isFunction( obj ) || isWindow( obj ) ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn type === \\"array\\" || length === 0 ||\\n\\t\\ttypeof length === \\"number\\" && length > 0 && ( length - 1 ) in obj;\\n}\\nvar Sizzle =\\n/*!\\n * Sizzle CSS Selector Engine v2.3.5\\n * https://sizzlejs.com/\\n *\\n * Copyright JS Foundation and other contributors\\n * Released under the MIT license\\n * https://js.foundation/\\n *\\n * Date: 2020-03-14\\n */\\n( function( window ) {\\nvar i,\\n\\tsupport,\\n\\tExpr,\\n\\tgetText,\\n\\tisXML,\\n\\ttokenize,\\n\\tcompile,\\n\\tselect,\\n\\toutermostContext,\\n\\tsortInput,\\n\\thasDuplicate,\\n\\n\\t// Local document vars\\n\\tsetDocument,\\n\\tdocument,\\n\\tdocElem,\\n\\tdocumentIsHTML,\\n\\trbuggyQSA,\\n\\trbuggyMatches,\\n\\tmatches,\\n\\tcontains,\\n\\n\\t// Instance-specific data\\n\\texpando = \\"sizzle\\" + 1 * new Date(),\\n\\tpreferredDoc = window.document,\\n\\tdirruns = 0,\\n\\tdone = 0,\\n\\tclassCache = createCache(),\\n\\ttokenCache = createCache(),\\n\\tcompilerCache = createCache(),\\n\\tnonnativeSelectorCache = createCache(),\\n\\tsortOrder = function( a, b ) {\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t},\\n\\n\\t// Instance methods\\n\\thasOwn = ( {} ).hasOwnProperty,\\n\\tarr = [],\\n\\tpop = arr.pop,\\n\\tpushNative = arr.push,\\n\\tpush = arr.push,\\n\\tslice = arr.slice,\\n\\n\\t// Use a stripped-down indexOf as it\'s faster than native\\n\\t// https://jsperf.com/thor-indexof-vs-for/5\\n\\tindexOf = function( list, elem ) {\\n\\t\\tvar i = 0,\\n\\t\\t\\tlen = list.length;\\n\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\tif ( list[ i ] === elem ) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t},\\n\\n\\tbooleans = \\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\\" +\\n\\t\\t\\"ismap|loop|multiple|open|readonly|required|scoped\\",\\n\\n\\t// Regular expressions\\n\\n\\t// http://www.w3.org/TR/css3-selectors/#whitespace\\n\\twhitespace = \\"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\\",\\n\\n\\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\\n\\tidentifier = \\"(?:\\\\\\\\\\\\\\\\[\\\\\\\\da-fA-F]{1,6}\\" + whitespace +\\n\\t\\t\\"?|\\\\\\\\\\\\\\\\[^\\\\\\\\r\\\\\\\\n\\\\\\\\f]|[\\\\\\\\w-]|[^\\\\0-\\\\\\\\x7f])+\\",\\n\\n\\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\\n\\tattributes = \\"\\\\\\\\[\\" + whitespace + \\"*(\\" + identifier + \\")(?:\\" + whitespace +\\n\\n\\t\\t// Operator (capture 2)\\n\\t\\t\\"*([*^$|!~]?=)\\" + whitespace +\\n\\n\\t\\t// \\"Attribute values must be CSS identifiers [capture 5]\\n\\t\\t// or strings [capture 3 or capture 4]\\"\\n\\t\\t\\"*(?:\'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\'])*)\'|\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\"|(\\" + identifier + \\"))|)\\" +\\n\\t\\twhitespace + \\"*\\\\\\\\]\\",\\n\\n\\tpseudos = \\":(\\" + identifier + \\")(?:\\\\\\\\((\\" +\\n\\n\\t\\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\\n\\t\\t// 1. quoted (capture 3; capture 4 or capture 5)\\n\\t\\t\\"(\'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\'])*)\'|\\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\\")|\\" +\\n\\n\\t\\t// 2. simple (capture 6)\\n\\t\\t\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\\" + attributes + \\")*)|\\" +\\n\\n\\t\\t// 3. anything else (capture 2)\\n\\t\\t\\".*\\" +\\n\\t\\t\\")\\\\\\\\)|)\\",\\n\\n\\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\\n\\trwhitespace = new RegExp( whitespace + \\"+\\", \\"g\\" ),\\n\\trtrim = new RegExp( \\"^\\" + whitespace + \\"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\\" +\\n\\t\\twhitespace + \\"+$\\", \\"g\\" ),\\n\\n\\trcomma = new RegExp( \\"^\\" + whitespace + \\"*,\\" + whitespace + \\"*\\" ),\\n\\trcombinators = new RegExp( \\"^\\" + whitespace + \\"*([>+~]|\\" + whitespace + \\")\\" + whitespace +\\n\\t\\t\\"*\\" ),\\n\\trdescend = new RegExp( whitespace + \\"|>\\" ),\\n\\n\\trpseudo = new RegExp( pseudos ),\\n\\tridentifier = new RegExp( \\"^\\" + identifier + \\"$\\" ),\\n\\n\\tmatchExpr = {\\n\\t\\t\\"ID\\": new RegExp( \\"^#(\\" + identifier + \\")\\" ),\\n\\t\\t\\"CLASS\\": new RegExp( \\"^\\\\\\\\.(\\" + identifier + \\")\\" ),\\n\\t\\t\\"TAG\\": new RegExp( \\"^(\\" + identifier + \\"|[*])\\" ),\\n\\t\\t\\"ATTR\\": new RegExp( \\"^\\" + attributes ),\\n\\t\\t\\"PSEUDO\\": new RegExp( \\"^\\" + pseudos ),\\n\\t\\t\\"CHILD\\": new RegExp( \\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\\" +\\n\\t\\t\\twhitespace + \\"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\\" + whitespace + \\"*(?:([+-]|)\\" +\\n\\t\\t\\twhitespace + \\"*(\\\\\\\\d+)|))\\" + whitespace + \\"*\\\\\\\\)|)\\", \\"i\\" ),\\n\\t\\t\\"bool\\": new RegExp( \\"^(?:\\" + booleans + \\")$\\", \\"i\\" ),\\n\\n\\t\\t// For use in libraries implementing .is()\\n\\t\\t// We use this for POS matching in `select`\\n\\t\\t\\"needsContext\\": new RegExp( \\"^\\" + whitespace +\\n\\t\\t\\t\\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\\" + whitespace +\\n\\t\\t\\t\\"*((?:-\\\\\\\\d)?\\\\\\\\d*)\\" + whitespace + \\"*\\\\\\\\)|)(?=[^-]|$)\\", \\"i\\" )\\n\\t},\\n\\n\\trhtml = /HTML$/i,\\n\\trinputs = /^(?:input|select|textarea|button)$/i,\\n\\trheader = /^h\\\\d$/i,\\n\\n\\trnative = /^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,\\n\\n\\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\\n\\trquickExpr = /^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,\\n\\n\\trsibling = /[+~]/,\\n\\n\\t// CSS escapes\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\\n\\trunescape = new RegExp( \\"\\\\\\\\\\\\\\\\[\\\\\\\\da-fA-F]{1,6}\\" + whitespace + \\"?|\\\\\\\\\\\\\\\\([^\\\\\\\\r\\\\\\\\n\\\\\\\\f])\\", \\"g\\" ),\\n\\tfunescape = function( escape, nonHex ) {\\n\\t\\tvar high = \\"0x\\" + escape.slice( 1 ) - 0x10000;\\n\\n\\t\\treturn nonHex ?\\n\\n\\t\\t\\t// Strip the backslash prefix from a non-hex escape sequence\\n\\t\\t\\tnonHex :\\n\\n\\t\\t\\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\\n\\t\\t\\t// Support: IE <=11+\\n\\t\\t\\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\\n\\t\\t\\t// surrogate pair\\n\\t\\t\\thigh < 0 ?\\n\\t\\t\\t\\tString.fromCharCode( high + 0x10000 ) :\\n\\t\\t\\t\\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\\n\\t},\\n\\n\\t// CSS string/identifier serialization\\n\\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\\n\\trcssescape = /([\\\\0-\\\\x1f\\\\x7f]|^-?\\\\d)|^-$|[^\\\\0-\\\\x1f\\\\x7f-\\\\uFFFF\\\\w-]/g,\\n\\tfcssescape = function( ch, asCodePoint ) {\\n\\t\\tif ( asCodePoint ) {\\n\\n\\t\\t\\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\\n\\t\\t\\tif ( ch === \\"\\\\0\\" ) {\\n\\t\\t\\t\\treturn \\"\\\\uFFFD\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Control characters and (dependent upon position) numbers get escaped as code points\\n\\t\\t\\treturn ch.slice( 0, -1 ) + \\"\\\\\\\\\\" +\\n\\t\\t\\t\\tch.charCodeAt( ch.length - 1 ).toString( 16 ) + \\" \\";\\n\\t\\t}\\n\\n\\t\\t// Other potentially-special ASCII characters get backslash-escaped\\n\\t\\treturn \\"\\\\\\\\\\" + ch;\\n\\t},\\n\\n\\t// Used for iframes\\n\\t// See setDocument()\\n\\t// Removing the function wrapper causes a \\"Permission Denied\\"\\n\\t// error in IE\\n\\tunloadHandler = function() {\\n\\t\\tsetDocument();\\n\\t},\\n\\n\\tinDisabledFieldset = addCombinator(\\n\\t\\tfunction( elem ) {\\n\\t\\t\\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \\"fieldset\\";\\n\\t\\t},\\n\\t\\t{ dir: \\"parentNode\\", next: \\"legend\\" }\\n\\t);\\n\\n// Optimize for push.apply( _, NodeList )\\ntry {\\n\\tpush.apply(\\n\\t\\t( arr = slice.call( preferredDoc.childNodes ) ),\\n\\t\\tpreferredDoc.childNodes\\n\\t);\\n\\n\\t// Support: Android<4.0\\n\\t// Detect silently failing push.apply\\n\\t// eslint-disable-next-line no-unused-expressions\\n\\tarr[ preferredDoc.childNodes.length ].nodeType;\\n} catch ( e ) {\\n\\tpush = { apply: arr.length ?\\n\\n\\t\\t// Leverage slice if possible\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tpushNative.apply( target, slice.call( els ) );\\n\\t\\t} :\\n\\n\\t\\t// Support: IE<9\\n\\t\\t// Otherwise append directly\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tvar j = target.length,\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\t// Can\'t trust NodeList.length\\n\\t\\t\\twhile ( ( target[ j++ ] = els[ i++ ] ) ) {}\\n\\t\\t\\ttarget.length = j - 1;\\n\\t\\t}\\n\\t};\\n}\\n\\nfunction Sizzle( selector, context, results, seed ) {\\n\\tvar m, i, elem, nid, match, groups, newSelector,\\n\\t\\tnewContext = context && context.ownerDocument,\\n\\n\\t\\t// nodeType defaults to 9, since context defaults to document\\n\\t\\tnodeType = context ? context.nodeType : 9;\\n\\n\\tresults = results || [];\\n\\n\\t// Return early from calls with invalid selector or context\\n\\tif ( typeof selector !== \\"string\\" || !selector ||\\n\\t\\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\\n\\n\\t\\treturn results;\\n\\t}\\n\\n\\t// Try to shortcut find operations (as opposed to filters) in HTML documents\\n\\tif ( !seed ) {\\n\\t\\tsetDocument( context );\\n\\t\\tcontext = context || document;\\n\\n\\t\\tif ( documentIsHTML ) {\\n\\n\\t\\t\\t// If the selector is sufficiently simple, try using a \\"get*By*\\" DOM method\\n\\t\\t\\t// (excepting DocumentFragment context, where the methods don\'t exist)\\n\\t\\t\\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\\n\\n\\t\\t\\t\\t// ID selector\\n\\t\\t\\t\\tif ( ( m = match[ 1 ] ) ) {\\n\\n\\t\\t\\t\\t\\t// Document context\\n\\t\\t\\t\\t\\tif ( nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tif ( ( elem = context.getElementById( m ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\t\\tif ( elem.id === m ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Element context\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\\n\\t\\t\\t\\t\\t\\t\\tcontains( context, elem ) &&\\n\\t\\t\\t\\t\\t\\t\\telem.id === m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Type selector\\n\\t\\t\\t\\t} else if ( match[ 2 ] ) {\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByTagName( selector ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t\\t// Class selector\\n\\t\\t\\t\\t} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&\\n\\t\\t\\t\\t\\tcontext.getElementsByClassName ) {\\n\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByClassName( m ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Take advantage of querySelectorAll\\n\\t\\t\\tif ( support.qsa &&\\n\\t\\t\\t\\t!nonnativeSelectorCache[ selector + \\" \\" ] &&\\n\\t\\t\\t\\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&\\n\\n\\t\\t\\t\\t// Support: IE 8 only\\n\\t\\t\\t\\t// Exclude object elements\\n\\t\\t\\t\\t( nodeType !== 1 || context.nodeName.toLowerCase() !== \\"object\\" ) ) {\\n\\n\\t\\t\\t\\tnewSelector = selector;\\n\\t\\t\\t\\tnewContext = context;\\n\\n\\t\\t\\t\\t// qSA considers elements outside a scoping root when evaluating child or\\n\\t\\t\\t\\t// descendant combinators, which is not what we want.\\n\\t\\t\\t\\t// In such cases, we work around the behavior by prefixing every selector in the\\n\\t\\t\\t\\t// list with an ID selector referencing the scope context.\\n\\t\\t\\t\\t// The technique has to be used as well when a leading combinator is used\\n\\t\\t\\t\\t// as such selectors are not recognized by querySelectorAll.\\n\\t\\t\\t\\t// Thanks to Andrew Dupont for this technique.\\n\\t\\t\\t\\tif ( nodeType === 1 &&\\n\\t\\t\\t\\t\\t( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {\\n\\n\\t\\t\\t\\t\\t// Expand context for sibling selectors\\n\\t\\t\\t\\t\\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\\n\\t\\t\\t\\t\\t\\tcontext;\\n\\n\\t\\t\\t\\t\\t// We can use :scope instead of the ID hack if the browser\\n\\t\\t\\t\\t\\t// supports it & if we\'re not changing the context.\\n\\t\\t\\t\\t\\tif ( newContext !== context || !support.scope ) {\\n\\n\\t\\t\\t\\t\\t\\t// Capture the context ID, setting it first if necessary\\n\\t\\t\\t\\t\\t\\tif ( ( nid = context.getAttribute( \\"id\\" ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\tnid = nid.replace( rcssescape, fcssescape );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tcontext.setAttribute( \\"id\\", ( nid = expando ) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prefix every selector in the list\\n\\t\\t\\t\\t\\tgroups = tokenize( selector );\\n\\t\\t\\t\\t\\ti = groups.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tgroups[ i ] = ( nid ? \\"#\\" + nid : \\":scope\\" ) + \\" \\" +\\n\\t\\t\\t\\t\\t\\t\\ttoSelector( groups[ i ] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnewSelector = groups.join( \\",\\" );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tpush.apply( results,\\n\\t\\t\\t\\t\\t\\tnewContext.querySelectorAll( newSelector )\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t} catch ( qsaError ) {\\n\\t\\t\\t\\t\\tnonnativeSelectorCache( selector, true );\\n\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\tif ( nid === expando ) {\\n\\t\\t\\t\\t\\t\\tcontext.removeAttribute( \\"id\\" );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// All others\\n\\treturn select( selector.replace( rtrim, \\"$1\\" ), context, results, seed );\\n}\\n\\n/**\\n * Create key-value caches of limited size\\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\\n *\\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\\n *\\tdeleting the oldest entry\\n */\\nfunction createCache() {\\n\\tvar keys = [];\\n\\n\\tfunction cache( key, value ) {\\n\\n\\t\\t// Use (key + \\" \\") to avoid collision with native prototype properties (see Issue #157)\\n\\t\\tif ( keys.push( key + \\" \\" ) > Expr.cacheLength ) {\\n\\n\\t\\t\\t// Only keep the most recent entries\\n\\t\\t\\tdelete cache[ keys.shift() ];\\n\\t\\t}\\n\\t\\treturn ( cache[ key + \\" \\" ] = value );\\n\\t}\\n\\treturn cache;\\n}\\n\\n/**\\n * Mark a function for special use by Sizzle\\n * @param {Function} fn The function to mark\\n */\\nfunction markFunction( fn ) {\\n\\tfn[ expando ] = true;\\n\\treturn fn;\\n}\\n\\n/**\\n * Support testing using an element\\n * @param {Function} fn Passed the created element and returns a boolean result\\n */\\nfunction assert( fn ) {\\n\\tvar el = document.createElement( \\"fieldset\\" );\\n\\n\\ttry {\\n\\t\\treturn !!fn( el );\\n\\t} catch ( e ) {\\n\\t\\treturn false;\\n\\t} finally {\\n\\n\\t\\t// Remove from its parent by default\\n\\t\\tif ( el.parentNode ) {\\n\\t\\t\\tel.parentNode.removeChild( el );\\n\\t\\t}\\n\\n\\t\\t// release memory in IE\\n\\t\\tel = null;\\n\\t}\\n}\\n\\n/**\\n * Adds the same handler for all of the specified attrs\\n * @param {String} attrs Pipe-separated list of attributes\\n * @param {Function} handler The method that will be applied\\n */\\nfunction addHandle( attrs, handler ) {\\n\\tvar arr = attrs.split( \\"|\\" ),\\n\\t\\ti = arr.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tExpr.attrHandle[ arr[ i ] ] = handler;\\n\\t}\\n}\\n\\n/**\\n * Checks document order of two siblings\\n * @param {Element} a\\n * @param {Element} b\\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\\n */\\nfunction siblingCheck( a, b ) {\\n\\tvar cur = b && a,\\n\\t\\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\\n\\t\\t\\ta.sourceIndex - b.sourceIndex;\\n\\n\\t// Use IE sourceIndex if available on both nodes\\n\\tif ( diff ) {\\n\\t\\treturn diff;\\n\\t}\\n\\n\\t// Check if b follows a\\n\\tif ( cur ) {\\n\\t\\twhile ( ( cur = cur.nextSibling ) ) {\\n\\t\\t\\tif ( cur === b ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn a ? 1 : -1;\\n}\\n\\n/**\\n * Returns a function to use in pseudos for input types\\n * @param {String} type\\n */\\nfunction createInputPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn name === \\"input\\" && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for buttons\\n * @param {String} type\\n */\\nfunction createButtonPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn ( name === \\"input\\" || name === \\"button\\" ) && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for :enabled/:disabled\\n * @param {Boolean} disabled true for :disabled; false for :enabled\\n */\\nfunction createDisabledPseudo( disabled ) {\\n\\n\\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\\n\\treturn function( elem ) {\\n\\n\\t\\t// Only certain elements can match :enabled or :disabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\\n\\t\\tif ( \\"form\\" in elem ) {\\n\\n\\t\\t\\t// Check for inherited disabledness on relevant non-disabled elements:\\n\\t\\t\\t// * listed form-associated elements in a disabled fieldset\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\\n\\t\\t\\t// * option elements in a disabled optgroup\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\\n\\t\\t\\t// All such elements have a \\"form\\" property.\\n\\t\\t\\tif ( elem.parentNode && elem.disabled === false ) {\\n\\n\\t\\t\\t\\t// Option elements defer to a parent optgroup if present\\n\\t\\t\\t\\tif ( \\"label\\" in elem ) {\\n\\t\\t\\t\\t\\tif ( \\"label\\" in elem.parentNode ) {\\n\\t\\t\\t\\t\\t\\treturn elem.parentNode.disabled === disabled;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: IE 6 - 11\\n\\t\\t\\t\\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\\n\\t\\t\\t\\treturn elem.isDisabled === disabled ||\\n\\n\\t\\t\\t\\t\\t// Where there is no isDisabled, check manually\\n\\t\\t\\t\\t\\t/* jshint -W018 */\\n\\t\\t\\t\\t\\telem.isDisabled !== !disabled &&\\n\\t\\t\\t\\t\\tinDisabledFieldset( elem ) === disabled;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\n\\t\\t// Try to winnow out elements that can\'t be disabled before trusting the disabled property.\\n\\t\\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn\'t\\n\\t\\t// even exist on them, let alone have a boolean value.\\n\\t\\t} else if ( \\"label\\" in elem ) {\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t}\\n\\n\\t\\t// Remaining elements are neither :enabled nor :disabled\\n\\t\\treturn false;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for positionals\\n * @param {Function} fn\\n */\\nfunction createPositionalPseudo( fn ) {\\n\\treturn markFunction( function( argument ) {\\n\\t\\targument = +argument;\\n\\t\\treturn markFunction( function( seed, matches ) {\\n\\t\\t\\tvar j,\\n\\t\\t\\t\\tmatchIndexes = fn( [], seed.length, argument ),\\n\\t\\t\\t\\ti = matchIndexes.length;\\n\\n\\t\\t\\t// Match elements found at the specified indexes\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\\n\\t\\t\\t\\t\\tseed[ j ] = !( matches[ j ] = seed[ j ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t} );\\n}\\n\\n/**\\n * Checks a node for validity as a Sizzle context\\n * @param {Element|Object=} context\\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\\n */\\nfunction testContext( context ) {\\n\\treturn context && typeof context.getElementsByTagName !== \\"undefined\\" && context;\\n}\\n\\n// Expose support vars for convenience\\nsupport = Sizzle.support = {};\\n\\n/**\\n * Detects XML nodes\\n * @param {Element|Object} elem An element or a document\\n * @returns {Boolean} True iff elem is a non-HTML XML node\\n */\\nisXML = Sizzle.isXML = function( elem ) {\\n\\tvar namespace = elem.namespaceURI,\\n\\t\\tdocElem = ( elem.ownerDocument || elem ).documentElement;\\n\\n\\t// Support: IE <=8\\n\\t// Assume HTML when documentElement doesn\'t yet exist, such as inside loading iframes\\n\\t// https://bugs.jquery.com/ticket/4833\\n\\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \\"HTML\\" );\\n};\\n\\n/**\\n * Sets document-related variables once based on the current document\\n * @param {Element|Object} [doc] An element or document object to use to set the document\\n * @returns {Object} Returns the current document\\n */\\nsetDocument = Sizzle.setDocument = function( node ) {\\n\\tvar hasCompare, subWindow,\\n\\t\\tdoc = node ? node.ownerDocument || node : preferredDoc;\\n\\n\\t// Return early if doc is invalid or already selected\\n\\t// Support: IE 11+, Edge 17 - 18+\\n\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t// two documents; shallow comparisons work.\\n\\t// eslint-disable-next-line eqeqeq\\n\\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\\n\\t\\treturn document;\\n\\t}\\n\\n\\t// Update global variables\\n\\tdocument = doc;\\n\\tdocElem = document.documentElement;\\n\\tdocumentIsHTML = !isXML( document );\\n\\n\\t// Support: IE 9 - 11+, Edge 12 - 18+\\n\\t// Accessing iframe documents after unload throws \\"permission denied\\" errors (jQuery #13936)\\n\\t// Support: IE 11+, Edge 17 - 18+\\n\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t// two documents; shallow comparisons work.\\n\\t// eslint-disable-next-line eqeqeq\\n\\tif ( preferredDoc != document &&\\n\\t\\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\\n\\n\\t\\t// Support: IE 11, Edge\\n\\t\\tif ( subWindow.addEventListener ) {\\n\\t\\t\\tsubWindow.addEventListener( \\"unload\\", unloadHandler, false );\\n\\n\\t\\t// Support: IE 9 - 10 only\\n\\t\\t} else if ( subWindow.attachEvent ) {\\n\\t\\t\\tsubWindow.attachEvent( \\"onunload\\", unloadHandler );\\n\\t\\t}\\n\\t}\\n\\n\\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\\n\\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\\n\\t// IE/Edge & older browsers don\'t support the :scope pseudo-class.\\n\\t// Support: Safari 6.0 only\\n\\t// Safari 6.0 supports :scope but it\'s an alias of :root there.\\n\\tsupport.scope = assert( function( el ) {\\n\\t\\tdocElem.appendChild( el ).appendChild( document.createElement( \\"div\\" ) );\\n\\t\\treturn typeof el.querySelectorAll !== \\"undefined\\" &&\\n\\t\\t\\t!el.querySelectorAll( \\":scope fieldset div\\" ).length;\\n\\t} );\\n\\n\\t/* Attributes\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Support: IE<8\\n\\t// Verify that getAttribute really returns attributes and not properties\\n\\t// (excepting IE8 booleans)\\n\\tsupport.attributes = assert( function( el ) {\\n\\t\\tel.className = \\"i\\";\\n\\t\\treturn !el.getAttribute( \\"className\\" );\\n\\t} );\\n\\n\\t/* getElement(s)By*\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Check if getElementsByTagName(\\"*\\") returns only elements\\n\\tsupport.getElementsByTagName = assert( function( el ) {\\n\\t\\tel.appendChild( document.createComment( \\"\\" ) );\\n\\t\\treturn !el.getElementsByTagName( \\"*\\" ).length;\\n\\t} );\\n\\n\\t// Support: IE<9\\n\\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\\n\\n\\t// Support: IE<10\\n\\t// Check if getElementById returns elements by name\\n\\t// The broken getElementById methods don\'t pick up programmatically-set names,\\n\\t// so use a roundabout getElementsByName test\\n\\tsupport.getById = assert( function( el ) {\\n\\t\\tdocElem.appendChild( el ).id = expando;\\n\\t\\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\\n\\t} );\\n\\n\\t// ID filter and find\\n\\tif ( support.getById ) {\\n\\t\\tExpr.filter[ \\"ID\\" ] = function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn elem.getAttribute( \\"id\\" ) === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\tExpr.find[ \\"ID\\" ] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \\"undefined\\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar elem = context.getElementById( id );\\n\\t\\t\\t\\treturn elem ? [ elem ] : [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} else {\\n\\t\\tExpr.filter[ \\"ID\\" ] =  function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar node = typeof elem.getAttributeNode !== \\"undefined\\" &&\\n\\t\\t\\t\\t\\telem.getAttributeNode( \\"id\\" );\\n\\t\\t\\t\\treturn node && node.value === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\t// Support: IE 6 - 7 only\\n\\t\\t// getElementById is not reliable as a find shortcut\\n\\t\\tExpr.find[ \\"ID\\" ] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \\"undefined\\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar node, i, elems,\\n\\t\\t\\t\\t\\telem = context.getElementById( id );\\n\\n\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t// Verify the id attribute\\n\\t\\t\\t\\t\\tnode = elem.getAttributeNode( \\"id\\" );\\n\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Fall back on getElementsByName\\n\\t\\t\\t\\t\\telems = context.getElementsByName( id );\\n\\t\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\t\\twhile ( ( elem = elems[ i++ ] ) ) {\\n\\t\\t\\t\\t\\t\\tnode = elem.getAttributeNode( \\"id\\" );\\n\\t\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t// Tag\\n\\tExpr.find[ \\"TAG\\" ] = support.getElementsByTagName ?\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tif ( typeof context.getElementsByTagName !== \\"undefined\\" ) {\\n\\t\\t\\t\\treturn context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// DocumentFragment nodes don\'t have gEBTN\\n\\t\\t\\t} else if ( support.qsa ) {\\n\\t\\t\\t\\treturn context.querySelectorAll( tag );\\n\\t\\t\\t}\\n\\t\\t} :\\n\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tvar elem,\\n\\t\\t\\t\\ttmp = [],\\n\\t\\t\\t\\ti = 0,\\n\\n\\t\\t\\t\\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\\n\\t\\t\\t\\tresults = context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// Filter out possible comments\\n\\t\\t\\tif ( tag === \\"*\\" ) {\\n\\t\\t\\t\\twhile ( ( elem = results[ i++ ] ) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\ttmp.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t};\\n\\n\\t// Class\\n\\tExpr.find[ \\"CLASS\\" ] = support.getElementsByClassName && function( className, context ) {\\n\\t\\tif ( typeof context.getElementsByClassName !== \\"undefined\\" && documentIsHTML ) {\\n\\t\\t\\treturn context.getElementsByClassName( className );\\n\\t\\t}\\n\\t};\\n\\n\\t/* QSA/matchesSelector\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// QSA and matchesSelector support\\n\\n\\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\\n\\trbuggyMatches = [];\\n\\n\\t// qSa(:focus) reports false when true (Chrome 21)\\n\\t// We allow this because of a bug in IE8/9 that throws an error\\n\\t// whenever `document.activeElement` is accessed on an iframe\\n\\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\\n\\t// See https://bugs.jquery.com/ticket/13378\\n\\trbuggyQSA = [];\\n\\n\\tif ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {\\n\\n\\t\\t// Build QSA regex\\n\\t\\t// Regex strategy adopted from Diego Perini\\n\\t\\tassert( function( el ) {\\n\\n\\t\\t\\tvar input;\\n\\n\\t\\t\\t// Select is set to empty string on purpose\\n\\t\\t\\t// This is to test IE\'s treatment of not explicitly\\n\\t\\t\\t// setting a boolean content attribute,\\n\\t\\t\\t// since its presence should be enough\\n\\t\\t\\t// https://bugs.jquery.com/ticket/12359\\n\\t\\t\\tdocElem.appendChild( el ).innerHTML = \\"<a id=\'\\" + expando + \\"\'></a>\\" +\\n\\t\\t\\t\\t\\"<select id=\'\\" + expando + \\"-\\\\r\\\\\\\\\' msallowcapture=\'\'>\\" +\\n\\t\\t\\t\\t\\"<option selected=\'\'></option></select>\\";\\n\\n\\t\\t\\t// Support: IE8, Opera 11-12.16\\n\\t\\t\\t// Nothing should be selected when empty strings follow ^= or $= or *=\\n\\t\\t\\t// The test attribute must be unknown in Opera but \\"safe\\" for WinRT\\n\\t\\t\\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\\n\\t\\t\\tif ( el.querySelectorAll( \\"[msallowcapture^=\'\']\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\"[*^$]=\\" + whitespace + \\"*(?:\'\'|\\\\\\"\\\\\\")\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Boolean attributes and \\"value\\" are not treated correctly\\n\\t\\t\\tif ( !el.querySelectorAll( \\"[selected]\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\"\\\\\\\\[\\" + whitespace + \\"*(?:value|\\" + booleans + \\")\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\\n\\t\\t\\tif ( !el.querySelectorAll( \\"[id~=\\" + expando + \\"-]\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\"~=\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE 11+, Edge 15 - 18+\\n\\t\\t\\t// IE 11/Edge don\'t find elements on a `[name=\'\']` query in some cases.\\n\\t\\t\\t// Adding a temporary attribute to the document before the selection works\\n\\t\\t\\t// around the issue.\\n\\t\\t\\t// Interestingly, IE 10 & older don\'t seem to have the issue.\\n\\t\\t\\tinput = document.createElement( \\"input\\" );\\n\\t\\t\\tinput.setAttribute( \\"name\\", \\"\\" );\\n\\t\\t\\tel.appendChild( input );\\n\\t\\t\\tif ( !el.querySelectorAll( \\"[name=\'\']\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\"\\\\\\\\[\\" + whitespace + \\"*name\\" + whitespace + \\"*=\\" +\\n\\t\\t\\t\\t\\twhitespace + \\"*(?:\'\'|\\\\\\"\\\\\\")\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Webkit/Opera - :checked should return selected option elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( !el.querySelectorAll( \\":checked\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\":checked\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Safari 8+, iOS 8+\\n\\t\\t\\t// https://bugs.webkit.org/show_bug.cgi?id=136851\\n\\t\\t\\t// In-page `selector#id sibling-combinator selector` fails\\n\\t\\t\\tif ( !el.querySelectorAll( \\"a#\\" + expando + \\"+*\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\".#.+[+~]\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Firefox <=3.6 - 5 only\\n\\t\\t\\t// Old Firefox doesn\'t throw on a badly-escaped identifier.\\n\\t\\t\\tel.querySelectorAll( \\"\\\\\\\\\\\\f\\" );\\n\\t\\t\\trbuggyQSA.push( \\"[\\\\\\\\r\\\\\\\\n\\\\\\\\f]\\" );\\n\\t\\t} );\\n\\n\\t\\tassert( function( el ) {\\n\\t\\t\\tel.innerHTML = \\"<a href=\'\' disabled=\'disabled\'></a>\\" +\\n\\t\\t\\t\\t\\"<select disabled=\'disabled\'><option/></select>\\";\\n\\n\\t\\t\\t// Support: Windows 8 Native Apps\\n\\t\\t\\t// The type and name attributes are restricted during .innerHTML assignment\\n\\t\\t\\tvar input = document.createElement( \\"input\\" );\\n\\t\\t\\tinput.setAttribute( \\"type\\", \\"hidden\\" );\\n\\t\\t\\tel.appendChild( input ).setAttribute( \\"name\\", \\"D\\" );\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Enforce case-sensitivity of name attribute\\n\\t\\t\\tif ( el.querySelectorAll( \\"[name=d]\\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\"name\\" + whitespace + \\"*[*^$|!~]?=\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( el.querySelectorAll( \\":enabled\\" ).length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\":enabled\\", \\":disabled\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE9-11+\\n\\t\\t\\t// IE\'s :disabled selector does not pick up the children of disabled fieldsets\\n\\t\\t\\tdocElem.appendChild( el ).disabled = true;\\n\\t\\t\\tif ( el.querySelectorAll( \\":disabled\\" ).length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \\":enabled\\", \\":disabled\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Opera 10 - 11 only\\n\\t\\t\\t// Opera 10-11 does not throw on post-comma invalid pseudos\\n\\t\\t\\tel.querySelectorAll( \\"*,:x\\" );\\n\\t\\t\\trbuggyQSA.push( \\",.*:\\" );\\n\\t\\t} );\\n\\t}\\n\\n\\tif ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||\\n\\t\\tdocElem.webkitMatchesSelector ||\\n\\t\\tdocElem.mozMatchesSelector ||\\n\\t\\tdocElem.oMatchesSelector ||\\n\\t\\tdocElem.msMatchesSelector ) ) ) ) {\\n\\n\\t\\tassert( function( el ) {\\n\\n\\t\\t\\t// Check to see if it\'s possible to do matchesSelector\\n\\t\\t\\t// on a disconnected node (IE 9)\\n\\t\\t\\tsupport.disconnectedMatch = matches.call( el, \\"*\\" );\\n\\n\\t\\t\\t// This should fail with an exception\\n\\t\\t\\t// Gecko does not error, returns false instead\\n\\t\\t\\tmatches.call( el, \\"[s!=\'\']:x\\" );\\n\\t\\t\\trbuggyMatches.push( \\"!=\\", pseudos );\\n\\t\\t} );\\n\\t}\\n\\n\\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \\"|\\" ) );\\n\\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( \\"|\\" ) );\\n\\n\\t/* Contains\\n\\t---------------------------------------------------------------------- */\\n\\thasCompare = rnative.test( docElem.compareDocumentPosition );\\n\\n\\t// Element contains another\\n\\t// Purposefully self-exclusive\\n\\t// As in, an element does not contain itself\\n\\tcontains = hasCompare || rnative.test( docElem.contains ) ?\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tvar adown = a.nodeType === 9 ? a.documentElement : a,\\n\\t\\t\\t\\tbup = b && b.parentNode;\\n\\t\\t\\treturn a === bup || !!( bup && bup.nodeType === 1 && (\\n\\t\\t\\t\\tadown.contains ?\\n\\t\\t\\t\\t\\tadown.contains( bup ) :\\n\\t\\t\\t\\t\\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\\n\\t\\t\\t) );\\n\\t\\t} :\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tif ( b ) {\\n\\t\\t\\t\\twhile ( ( b = b.parentNode ) ) {\\n\\t\\t\\t\\t\\tif ( b === a ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t/* Sorting\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Document order sorting\\n\\tsortOrder = hasCompare ?\\n\\tfunction( a, b ) {\\n\\n\\t\\t// Flag for duplicate removal\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// Sort on method existence if only one input has compareDocumentPosition\\n\\t\\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\\n\\t\\tif ( compare ) {\\n\\t\\t\\treturn compare;\\n\\t\\t}\\n\\n\\t\\t// Calculate position if both inputs belong to the same document\\n\\t\\t// Support: IE 11+, Edge 17 - 18+\\n\\t\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t\\t// two documents; shallow comparisons work.\\n\\t\\t// eslint-disable-next-line eqeqeq\\n\\t\\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\\n\\t\\t\\ta.compareDocumentPosition( b ) :\\n\\n\\t\\t\\t// Otherwise we know they are disconnected\\n\\t\\t\\t1;\\n\\n\\t\\t// Disconnected nodes\\n\\t\\tif ( compare & 1 ||\\n\\t\\t\\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\\n\\n\\t\\t\\t// Choose the first element that is related to our preferred document\\n\\t\\t\\t// Support: IE 11+, Edge 17 - 18+\\n\\t\\t\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t\\t\\t// two documents; shallow comparisons work.\\n\\t\\t\\t// eslint-disable-next-line eqeqeq\\n\\t\\t\\tif ( a == document || a.ownerDocument == preferredDoc &&\\n\\t\\t\\t\\tcontains( preferredDoc, a ) ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE 11+, Edge 17 - 18+\\n\\t\\t\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t\\t\\t// two documents; shallow comparisons work.\\n\\t\\t\\t// eslint-disable-next-line eqeqeq\\n\\t\\t\\tif ( b == document || b.ownerDocument == preferredDoc &&\\n\\t\\t\\t\\tcontains( preferredDoc, b ) ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Maintain original order\\n\\t\\t\\treturn sortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\t\\t}\\n\\n\\t\\treturn compare & 4 ? -1 : 1;\\n\\t} :\\n\\tfunction( a, b ) {\\n\\n\\t\\t// Exit early if the nodes are identical\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\taup = a.parentNode,\\n\\t\\t\\tbup = b.parentNode,\\n\\t\\t\\tap = [ a ],\\n\\t\\t\\tbp = [ b ];\\n\\n\\t\\t// Parentless nodes are either documents or disconnected\\n\\t\\tif ( !aup || !bup ) {\\n\\n\\t\\t\\t// Support: IE 11+, Edge 17 - 18+\\n\\t\\t\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t\\t\\t// two documents; shallow comparisons work.\\n\\t\\t\\t/* eslint-disable eqeqeq */\\n\\t\\t\\treturn a == document ? -1 :\\n\\t\\t\\t\\tb == document ? 1 :\\n\\t\\t\\t\\t/* eslint-enable eqeqeq */\\n\\t\\t\\t\\taup ? -1 :\\n\\t\\t\\t\\tbup ? 1 :\\n\\t\\t\\t\\tsortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\n\\t\\t// If the nodes are siblings, we can do a quick check\\n\\t\\t} else if ( aup === bup ) {\\n\\t\\t\\treturn siblingCheck( a, b );\\n\\t\\t}\\n\\n\\t\\t// Otherwise we need full lists of their ancestors for comparison\\n\\t\\tcur = a;\\n\\t\\twhile ( ( cur = cur.parentNode ) ) {\\n\\t\\t\\tap.unshift( cur );\\n\\t\\t}\\n\\t\\tcur = b;\\n\\t\\twhile ( ( cur = cur.parentNode ) ) {\\n\\t\\t\\tbp.unshift( cur );\\n\\t\\t}\\n\\n\\t\\t// Walk down the tree looking for a discrepancy\\n\\t\\twhile ( ap[ i ] === bp[ i ] ) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn i ?\\n\\n\\t\\t\\t// Do a sibling check if the nodes have a common ancestor\\n\\t\\t\\tsiblingCheck( ap[ i ], bp[ i ] ) :\\n\\n\\t\\t\\t// Otherwise nodes in our document sort first\\n\\t\\t\\t// Support: IE 11+, Edge 17 - 18+\\n\\t\\t\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t\\t\\t// two documents; shallow comparisons work.\\n\\t\\t\\t/* eslint-disable eqeqeq */\\n\\t\\t\\tap[ i ] == preferredDoc ? -1 :\\n\\t\\t\\tbp[ i ] == preferredDoc ? 1 :\\n\\t\\t\\t/* eslint-enable eqeqeq */\\n\\t\\t\\t0;\\n\\t};\\n\\n\\treturn document;\\n};\\n\\nSizzle.matches = function( expr, elements ) {\\n\\treturn Sizzle( expr, null, null, elements );\\n};\\n\\nSizzle.matchesSelector = function( elem, expr ) {\\n\\tsetDocument( elem );\\n\\n\\tif ( support.matchesSelector && documentIsHTML &&\\n\\t\\t!nonnativeSelectorCache[ expr + \\" \\" ] &&\\n\\t\\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\\n\\t\\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\\n\\n\\t\\ttry {\\n\\t\\t\\tvar ret = matches.call( elem, expr );\\n\\n\\t\\t\\t// IE 9\'s matchesSelector returns false on disconnected nodes\\n\\t\\t\\tif ( ret || support.disconnectedMatch ||\\n\\n\\t\\t\\t\\t// As well, disconnected nodes are said to be in a document\\n\\t\\t\\t\\t// fragment in IE 9\\n\\t\\t\\t\\telem.document && elem.document.nodeType !== 11 ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\t\\t} catch ( e ) {\\n\\t\\t\\tnonnativeSelectorCache( expr, true );\\n\\t\\t}\\n\\t}\\n\\n\\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\\n};\\n\\nSizzle.contains = function( context, elem ) {\\n\\n\\t// Set document vars if needed\\n\\t// Support: IE 11+, Edge 17 - 18+\\n\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t// two documents; shallow comparisons work.\\n\\t// eslint-disable-next-line eqeqeq\\n\\tif ( ( context.ownerDocument || context ) != document ) {\\n\\t\\tsetDocument( context );\\n\\t}\\n\\treturn contains( context, elem );\\n};\\n\\nSizzle.attr = function( elem, name ) {\\n\\n\\t// Set document vars if needed\\n\\t// Support: IE 11+, Edge 17 - 18+\\n\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t// two documents; shallow comparisons work.\\n\\t// eslint-disable-next-line eqeqeq\\n\\tif ( ( elem.ownerDocument || elem ) != document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\\n\\n\\t\\t// Don\'t get fooled by Object.prototype properties (jQuery #13807)\\n\\t\\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\\n\\t\\t\\tfn( elem, name, !documentIsHTML ) :\\n\\t\\t\\tundefined;\\n\\n\\treturn val !== undefined ?\\n\\t\\tval :\\n\\t\\tsupport.attributes || !documentIsHTML ?\\n\\t\\t\\telem.getAttribute( name ) :\\n\\t\\t\\t( val = elem.getAttributeNode( name ) ) && val.specified ?\\n\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n};\\n\\nSizzle.escape = function( sel ) {\\n\\treturn ( sel + \\"\\" ).replace( rcssescape, fcssescape );\\n};\\n\\nSizzle.error = function( msg ) {\\n\\tthrow new Error( \\"Syntax error, unrecognized expression: \\" + msg );\\n};\\n\\n/**\\n * Document sorting and removing duplicates\\n * @param {ArrayLike} results\\n */\\nSizzle.uniqueSort = function( results ) {\\n\\tvar elem,\\n\\t\\tduplicates = [],\\n\\t\\tj = 0,\\n\\t\\ti = 0;\\n\\n\\t// Unless we *know* we can detect duplicates, assume their presence\\n\\thasDuplicate = !support.detectDuplicates;\\n\\tsortInput = !support.sortStable && results.slice( 0 );\\n\\tresults.sort( sortOrder );\\n\\n\\tif ( hasDuplicate ) {\\n\\t\\twhile ( ( elem = results[ i++ ] ) ) {\\n\\t\\t\\tif ( elem === results[ i ] ) {\\n\\t\\t\\t\\tj = duplicates.push( i );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile ( j-- ) {\\n\\t\\t\\tresults.splice( duplicates[ j ], 1 );\\n\\t\\t}\\n\\t}\\n\\n\\t// Clear input after sorting to release objects\\n\\t// See https://github.com/jquery/sizzle/pull/225\\n\\tsortInput = null;\\n\\n\\treturn results;\\n};\\n\\n/**\\n * Utility function for retrieving the text value of an array of DOM nodes\\n * @param {Array|Element} elem\\n */\\ngetText = Sizzle.getText = function( elem ) {\\n\\tvar node,\\n\\t\\tret = \\"\\",\\n\\t\\ti = 0,\\n\\t\\tnodeType = elem.nodeType;\\n\\n\\tif ( !nodeType ) {\\n\\n\\t\\t// If no nodeType, this is expected to be an array\\n\\t\\twhile ( ( node = elem[ i++ ] ) ) {\\n\\n\\t\\t\\t// Do not traverse comment nodes\\n\\t\\t\\tret += getText( node );\\n\\t\\t}\\n\\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\\n\\n\\t\\t// Use textContent for elements\\n\\t\\t// innerText usage removed for consistency of new lines (jQuery #11153)\\n\\t\\tif ( typeof elem.textContent === \\"string\\" ) {\\n\\t\\t\\treturn elem.textContent;\\n\\t\\t} else {\\n\\n\\t\\t\\t// Traverse its children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tret += getText( elem );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if ( nodeType === 3 || nodeType === 4 ) {\\n\\t\\treturn elem.nodeValue;\\n\\t}\\n\\n\\t// Do not include comment or processing instruction nodes\\n\\n\\treturn ret;\\n};\\n\\nExpr = Sizzle.selectors = {\\n\\n\\t// Can be adjusted by the user\\n\\tcacheLength: 50,\\n\\n\\tcreatePseudo: markFunction,\\n\\n\\tmatch: matchExpr,\\n\\n\\tattrHandle: {},\\n\\n\\tfind: {},\\n\\n\\trelative: {\\n\\t\\t\\">\\": { dir: \\"parentNode\\", first: true },\\n\\t\\t\\" \\": { dir: \\"parentNode\\" },\\n\\t\\t\\"+\\": { dir: \\"previousSibling\\", first: true },\\n\\t\\t\\"~\\": { dir: \\"previousSibling\\" }\\n\\t},\\n\\n\\tpreFilter: {\\n\\t\\t\\"ATTR\\": function( match ) {\\n\\t\\t\\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\\n\\n\\t\\t\\t// Move the given value to match[3] whether quoted or unquoted\\n\\t\\t\\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] ||\\n\\t\\t\\t\\tmatch[ 5 ] || \\"\\" ).replace( runescape, funescape );\\n\\n\\t\\t\\tif ( match[ 2 ] === \\"~=\\" ) {\\n\\t\\t\\t\\tmatch[ 3 ] = \\" \\" + match[ 3 ] + \\" \\";\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match.slice( 0, 4 );\\n\\t\\t},\\n\\n\\t\\t\\"CHILD\\": function( match ) {\\n\\n\\t\\t\\t/* matches from matchExpr[\\"CHILD\\"]\\n\\t\\t\\t\\t1 type (only|nth|...)\\n\\t\\t\\t\\t2 what (child|of-type)\\n\\t\\t\\t\\t3 argument (even|odd|\\\\d*|\\\\d*n([+-]\\\\d+)?|...)\\n\\t\\t\\t\\t4 xn-component of xn+y argument ([+-]?\\\\d*n|)\\n\\t\\t\\t\\t5 sign of xn-component\\n\\t\\t\\t\\t6 x of xn-component\\n\\t\\t\\t\\t7 sign of y-component\\n\\t\\t\\t\\t8 y of y-component\\n\\t\\t\\t*/\\n\\t\\t\\tmatch[ 1 ] = match[ 1 ].toLowerCase();\\n\\n\\t\\t\\tif ( match[ 1 ].slice( 0, 3 ) === \\"nth\\" ) {\\n\\n\\t\\t\\t\\t// nth-* requires argument\\n\\t\\t\\t\\tif ( !match[ 3 ] ) {\\n\\t\\t\\t\\t\\tSizzle.error( match[ 0 ] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// numeric x and y parameters for Expr.filter.CHILD\\n\\t\\t\\t\\t// remember that false/true cast respectively to 0/1\\n\\t\\t\\t\\tmatch[ 4 ] = +( match[ 4 ] ?\\n\\t\\t\\t\\t\\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\\n\\t\\t\\t\\t\\t2 * ( match[ 3 ] === \\"even\\" || match[ 3 ] === \\"odd\\" ) );\\n\\t\\t\\t\\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \\"odd\\" );\\n\\n\\t\\t\\t\\t// other types prohibit arguments\\n\\t\\t\\t} else if ( match[ 3 ] ) {\\n\\t\\t\\t\\tSizzle.error( match[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match;\\n\\t\\t},\\n\\n\\t\\t\\"PSEUDO\\": function( match ) {\\n\\t\\t\\tvar excess,\\n\\t\\t\\t\\tunquoted = !match[ 6 ] && match[ 2 ];\\n\\n\\t\\t\\tif ( matchExpr[ \\"CHILD\\" ].test( match[ 0 ] ) ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Accept quoted arguments as-is\\n\\t\\t\\tif ( match[ 3 ] ) {\\n\\t\\t\\t\\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \\"\\";\\n\\n\\t\\t\\t// Strip excess characters from unquoted arguments\\n\\t\\t\\t} else if ( unquoted && rpseudo.test( unquoted ) &&\\n\\n\\t\\t\\t\\t// Get excess from tokenize (recursively)\\n\\t\\t\\t\\t( excess = tokenize( unquoted, true ) ) &&\\n\\n\\t\\t\\t\\t// advance to the next closing parenthesis\\n\\t\\t\\t\\t( excess = unquoted.indexOf( \\")\\", unquoted.length - excess ) - unquoted.length ) ) {\\n\\n\\t\\t\\t\\t// excess is a negative index\\n\\t\\t\\t\\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\\n\\t\\t\\t\\tmatch[ 2 ] = unquoted.slice( 0, excess );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Return only captures needed by the pseudo filter method (type and argument)\\n\\t\\t\\treturn match.slice( 0, 3 );\\n\\t\\t}\\n\\t},\\n\\n\\tfilter: {\\n\\n\\t\\t\\"TAG\\": function( nodeNameSelector ) {\\n\\t\\t\\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn nodeNameSelector === \\"*\\" ?\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t} :\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\"CLASS\\": function( className ) {\\n\\t\\t\\tvar pattern = classCache[ className + \\" \\" ];\\n\\n\\t\\t\\treturn pattern ||\\n\\t\\t\\t\\t( pattern = new RegExp( \\"(^|\\" + whitespace +\\n\\t\\t\\t\\t\\t\\")\\" + className + \\"(\\" + whitespace + \\"|$)\\" ) ) && classCache(\\n\\t\\t\\t\\t\\t\\tclassName, function( elem ) {\\n\\t\\t\\t\\t\\t\\t\\treturn pattern.test(\\n\\t\\t\\t\\t\\t\\t\\t\\ttypeof elem.className === \\"string\\" && elem.className ||\\n\\t\\t\\t\\t\\t\\t\\t\\ttypeof elem.getAttribute !== \\"undefined\\" &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\telem.getAttribute( \\"class\\" ) ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\"\\"\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t} );\\n\\t\\t},\\n\\n\\t\\t\\"ATTR\\": function( name, operator, check ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar result = Sizzle.attr( elem, name );\\n\\n\\t\\t\\t\\tif ( result == null ) {\\n\\t\\t\\t\\t\\treturn operator === \\"!=\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !operator ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult += \\"\\";\\n\\n\\t\\t\\t\\t/* eslint-disable max-len */\\n\\n\\t\\t\\t\\treturn operator === \\"=\\" ? result === check :\\n\\t\\t\\t\\t\\toperator === \\"!=\\" ? result !== check :\\n\\t\\t\\t\\t\\toperator === \\"^=\\" ? check && result.indexOf( check ) === 0 :\\n\\t\\t\\t\\t\\toperator === \\"*=\\" ? check && result.indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \\"$=\\" ? check && result.slice( -check.length ) === check :\\n\\t\\t\\t\\t\\toperator === \\"~=\\" ? ( \\" \\" + result.replace( rwhitespace, \\" \\" ) + \\" \\" ).indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \\"|=\\" ? result === check || result.slice( 0, check.length + 1 ) === check + \\"-\\" :\\n\\t\\t\\t\\t\\tfalse;\\n\\t\\t\\t\\t/* eslint-enable max-len */\\n\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\"CHILD\\": function( type, what, _argument, first, last ) {\\n\\t\\t\\tvar simple = type.slice( 0, 3 ) !== \\"nth\\",\\n\\t\\t\\t\\tforward = type.slice( -4 ) !== \\"last\\",\\n\\t\\t\\t\\tofType = what === \\"of-type\\";\\n\\n\\t\\t\\treturn first === 1 && last === 0 ?\\n\\n\\t\\t\\t\\t// Shortcut for :nth-*(n)\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn !!elem.parentNode;\\n\\t\\t\\t\\t} :\\n\\n\\t\\t\\t\\tfunction( elem, _context, xml ) {\\n\\t\\t\\t\\t\\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\\n\\t\\t\\t\\t\\t\\tdir = simple !== forward ? \\"nextSibling\\" : \\"previousSibling\\",\\n\\t\\t\\t\\t\\t\\tparent = elem.parentNode,\\n\\t\\t\\t\\t\\t\\tname = ofType && elem.nodeName.toLowerCase(),\\n\\t\\t\\t\\t\\t\\tuseCache = !xml && !ofType,\\n\\t\\t\\t\\t\\t\\tdiff = false;\\n\\n\\t\\t\\t\\t\\tif ( parent ) {\\n\\n\\t\\t\\t\\t\\t\\t// :(first|last|only)-(child|of-type)\\n\\t\\t\\t\\t\\t\\tif ( simple ) {\\n\\t\\t\\t\\t\\t\\t\\twhile ( dir ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( ( node = node[ dir ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Reverse direction for :only-* (if we haven\'t yet done so)\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = dir = type === \\"only\\" && !start && \\"nextSibling\\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tstart = [ forward ? parent.firstChild : parent.lastChild ];\\n\\n\\t\\t\\t\\t\\t\\t// non-xml :nth-child(...) stores cache data on `parent`\\n\\t\\t\\t\\t\\t\\tif ( forward && useCache ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Seek `elem` from a previously-cached index\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\tnode = parent;\\n\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || ( node[ expando ] = {} );\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t( outerCache[ node.uniqueID ] = {} );\\n\\n\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex && cache[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Fallback to seeking `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// When found, cache indexes on `parent` and break\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( node.nodeType === 1 && ++diff && node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Use previously-cached element index if available\\n\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || ( node[ expando ] = {} );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( outerCache[ node.uniqueID ] = {} );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// xml :nth-child(...)\\n\\t\\t\\t\\t\\t\\t\\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\\n\\t\\t\\t\\t\\t\\t\\tif ( diff === false ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Use the same loop as above to seek `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++diff ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Cache the index of each encountered element\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( node[ expando ] = {} );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( outerCache[ node.uniqueID ] = {} );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Incorporate the offset, then check against cycle size\\n\\t\\t\\t\\t\\t\\tdiff -= last;\\n\\t\\t\\t\\t\\t\\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\\"PSEUDO\\": function( pseudo, argument ) {\\n\\n\\t\\t\\t// pseudo-class names are case-insensitive\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#pseudo-classes\\n\\t\\t\\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\\n\\t\\t\\t// Remember that setFilters inherits from pseudos\\n\\t\\t\\tvar args,\\n\\t\\t\\t\\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\\n\\t\\t\\t\\t\\tSizzle.error( \\"unsupported pseudo: \\" + pseudo );\\n\\n\\t\\t\\t// The user may use createPseudo to indicate that\\n\\t\\t\\t// arguments are needed to create the filter function\\n\\t\\t\\t// just as Sizzle does\\n\\t\\t\\tif ( fn[ expando ] ) {\\n\\t\\t\\t\\treturn fn( argument );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// But maintain support for old signatures\\n\\t\\t\\tif ( fn.length > 1 ) {\\n\\t\\t\\t\\targs = [ pseudo, pseudo, \\"\\", argument ];\\n\\t\\t\\t\\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\\n\\t\\t\\t\\t\\tmarkFunction( function( seed, matches ) {\\n\\t\\t\\t\\t\\t\\tvar idx,\\n\\t\\t\\t\\t\\t\\t\\tmatched = fn( seed, argument ),\\n\\t\\t\\t\\t\\t\\t\\ti = matched.length;\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tidx = indexOf( seed, matched[ i ] );\\n\\t\\t\\t\\t\\t\\t\\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} ) :\\n\\t\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\t\\treturn fn( elem, 0, args );\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn fn;\\n\\t\\t}\\n\\t},\\n\\n\\tpseudos: {\\n\\n\\t\\t// Potentially complex pseudos\\n\\t\\t\\"not\\": markFunction( function( selector ) {\\n\\n\\t\\t\\t// Trim the selector passed to compile\\n\\t\\t\\t// to avoid treating leading and trailing\\n\\t\\t\\t// spaces as combinators\\n\\t\\t\\tvar input = [],\\n\\t\\t\\t\\tresults = [],\\n\\t\\t\\t\\tmatcher = compile( selector.replace( rtrim, \\"$1\\" ) );\\n\\n\\t\\t\\treturn matcher[ expando ] ?\\n\\t\\t\\t\\tmarkFunction( function( seed, matches, _context, xml ) {\\n\\t\\t\\t\\t\\tvar elem,\\n\\t\\t\\t\\t\\t\\tunmatched = matcher( seed, null, xml, [] ),\\n\\t\\t\\t\\t\\t\\ti = seed.length;\\n\\n\\t\\t\\t\\t\\t// Match elements unmatched by `matcher`\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( ( elem = unmatched[ i ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\tseed[ i ] = !( matches[ i ] = elem );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} ) :\\n\\t\\t\\t\\tfunction( elem, _context, xml ) {\\n\\t\\t\\t\\t\\tinput[ 0 ] = elem;\\n\\t\\t\\t\\t\\tmatcher( input, null, xml, results );\\n\\n\\t\\t\\t\\t\\t// Don\'t keep the element (issue #299)\\n\\t\\t\\t\\t\\tinput[ 0 ] = null;\\n\\t\\t\\t\\t\\treturn !results.pop();\\n\\t\\t\\t\\t};\\n\\t\\t} ),\\n\\n\\t\\t\\"has\\": markFunction( function( selector ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn Sizzle( selector, elem ).length > 0;\\n\\t\\t\\t};\\n\\t\\t} ),\\n\\n\\t\\t\\"contains\\": markFunction( function( text ) {\\n\\t\\t\\ttext = text.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\\n\\t\\t\\t};\\n\\t\\t} ),\\n\\n\\t\\t// \\"Whether an element is represented by a :lang() selector\\n\\t\\t// is based solely on the element\'s language value\\n\\t\\t// being equal to the identifier C,\\n\\t\\t// or beginning with the identifier C immediately followed by \\"-\\".\\n\\t\\t// The matching of C against the element\'s language value is performed case-insensitively.\\n\\t\\t// The identifier C does not have to be a valid language name.\\"\\n\\t\\t// http://www.w3.org/TR/selectors/#lang-pseudo\\n\\t\\t\\"lang\\": markFunction( function( lang ) {\\n\\n\\t\\t\\t// lang value must be a valid identifier\\n\\t\\t\\tif ( !ridentifier.test( lang || \\"\\" ) ) {\\n\\t\\t\\t\\tSizzle.error( \\"unsupported lang: \\" + lang );\\n\\t\\t\\t}\\n\\t\\t\\tlang = lang.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar elemLang;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tif ( ( elemLang = documentIsHTML ?\\n\\t\\t\\t\\t\\t\\telem.lang :\\n\\t\\t\\t\\t\\t\\telem.getAttribute( \\"xml:lang\\" ) || elem.getAttribute( \\"lang\\" ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\telemLang = elemLang.toLowerCase();\\n\\t\\t\\t\\t\\t\\treturn elemLang === lang || elemLang.indexOf( lang + \\"-\\" ) === 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t};\\n\\t\\t} ),\\n\\n\\t\\t// Miscellaneous\\n\\t\\t\\"target\\": function( elem ) {\\n\\t\\t\\tvar hash = window.location && window.location.hash;\\n\\t\\t\\treturn hash && hash.slice( 1 ) === elem.id;\\n\\t\\t},\\n\\n\\t\\t\\"root\\": function( elem ) {\\n\\t\\t\\treturn elem === docElem;\\n\\t\\t},\\n\\n\\t\\t\\"focus\\": function( elem ) {\\n\\t\\t\\treturn elem === document.activeElement &&\\n\\t\\t\\t\\t( !document.hasFocus || document.hasFocus() ) &&\\n\\t\\t\\t\\t!!( elem.type || elem.href || ~elem.tabIndex );\\n\\t\\t},\\n\\n\\t\\t// Boolean properties\\n\\t\\t\\"enabled\\": createDisabledPseudo( false ),\\n\\t\\t\\"disabled\\": createDisabledPseudo( true ),\\n\\n\\t\\t\\"checked\\": function( elem ) {\\n\\n\\t\\t\\t// In CSS3, :checked should return both checked and selected elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\tvar nodeName = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn ( nodeName === \\"input\\" && !!elem.checked ) ||\\n\\t\\t\\t\\t( nodeName === \\"option\\" && !!elem.selected );\\n\\t\\t},\\n\\n\\t\\t\\"selected\\": function( elem ) {\\n\\n\\t\\t\\t// Accessing this property makes selected-by-default\\n\\t\\t\\t// options in Safari work properly\\n\\t\\t\\tif ( elem.parentNode ) {\\n\\t\\t\\t\\t// eslint-disable-next-line no-unused-expressions\\n\\t\\t\\t\\telem.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.selected === true;\\n\\t\\t},\\n\\n\\t\\t// Contents\\n\\t\\t\\"empty\\": function( elem ) {\\n\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#empty-pseudo\\n\\t\\t\\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\\n\\t\\t\\t//   but not by others (comment: 8; processing instruction: 7; etc.)\\n\\t\\t\\t// nodeType < 6 works because attributes (2) do not appear as children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tif ( elem.nodeType < 6 ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\t\\"parent\\": function( elem ) {\\n\\t\\t\\treturn !Expr.pseudos[ \\"empty\\" ]( elem );\\n\\t\\t},\\n\\n\\t\\t// Element/input types\\n\\t\\t\\"header\\": function( elem ) {\\n\\t\\t\\treturn rheader.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\\"input\\": function( elem ) {\\n\\t\\t\\treturn rinputs.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\\"button\\": function( elem ) {\\n\\t\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn name === \\"input\\" && elem.type === \\"button\\" || name === \\"button\\";\\n\\t\\t},\\n\\n\\t\\t\\"text\\": function( elem ) {\\n\\t\\t\\tvar attr;\\n\\t\\t\\treturn elem.nodeName.toLowerCase() === \\"input\\" &&\\n\\t\\t\\t\\telem.type === \\"text\\" &&\\n\\n\\t\\t\\t\\t// Support: IE<8\\n\\t\\t\\t\\t// New HTML5 attribute values (e.g., \\"search\\") appear with elem.type === \\"text\\"\\n\\t\\t\\t\\t( ( attr = elem.getAttribute( \\"type\\" ) ) == null ||\\n\\t\\t\\t\\t\\tattr.toLowerCase() === \\"text\\" );\\n\\t\\t},\\n\\n\\t\\t// Position-in-collection\\n\\t\\t\\"first\\": createPositionalPseudo( function() {\\n\\t\\t\\treturn [ 0 ];\\n\\t\\t} ),\\n\\n\\t\\t\\"last\\": createPositionalPseudo( function( _matchIndexes, length ) {\\n\\t\\t\\treturn [ length - 1 ];\\n\\t\\t} ),\\n\\n\\t\\t\\"eq\\": createPositionalPseudo( function( _matchIndexes, length, argument ) {\\n\\t\\t\\treturn [ argument < 0 ? argument + length : argument ];\\n\\t\\t} ),\\n\\n\\t\\t\\"even\\": createPositionalPseudo( function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t} ),\\n\\n\\t\\t\\"odd\\": createPositionalPseudo( function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 1;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t} ),\\n\\n\\t\\t\\"lt\\": createPositionalPseudo( function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ?\\n\\t\\t\\t\\targument + length :\\n\\t\\t\\t\\targument > length ?\\n\\t\\t\\t\\t\\tlength :\\n\\t\\t\\t\\t\\targument;\\n\\t\\t\\tfor ( ; --i >= 0; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t} ),\\n\\n\\t\\t\\"gt\\": createPositionalPseudo( function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; ++i < length; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t} )\\n\\t}\\n};\\n\\nExpr.pseudos[ \\"nth\\" ] = Expr.pseudos[ \\"eq\\" ];\\n\\n// Add button/input type pseudos\\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\\n\\tExpr.pseudos[ i ] = createInputPseudo( i );\\n}\\nfor ( i in { submit: true, reset: true } ) {\\n\\tExpr.pseudos[ i ] = createButtonPseudo( i );\\n}\\n\\n// Easy API for creating new setFilters\\nfunction setFilters() {}\\nsetFilters.prototype = Expr.filters = Expr.pseudos;\\nExpr.setFilters = new setFilters();\\n\\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\\n\\tvar matched, match, tokens, type,\\n\\t\\tsoFar, groups, preFilters,\\n\\t\\tcached = tokenCache[ selector + \\" \\" ];\\n\\n\\tif ( cached ) {\\n\\t\\treturn parseOnly ? 0 : cached.slice( 0 );\\n\\t}\\n\\n\\tsoFar = selector;\\n\\tgroups = [];\\n\\tpreFilters = Expr.preFilter;\\n\\n\\twhile ( soFar ) {\\n\\n\\t\\t// Comma and first run\\n\\t\\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\\n\\t\\t\\tif ( match ) {\\n\\n\\t\\t\\t\\t// Don\'t consume trailing commas as valid\\n\\t\\t\\t\\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\\n\\t\\t\\t}\\n\\t\\t\\tgroups.push( ( tokens = [] ) );\\n\\t\\t}\\n\\n\\t\\tmatched = false;\\n\\n\\t\\t// Combinators\\n\\t\\tif ( ( match = rcombinators.exec( soFar ) ) ) {\\n\\t\\t\\tmatched = match.shift();\\n\\t\\t\\ttokens.push( {\\n\\t\\t\\t\\tvalue: matched,\\n\\n\\t\\t\\t\\t// Cast descendant combinators to space\\n\\t\\t\\t\\ttype: match[ 0 ].replace( rtrim, \\" \\" )\\n\\t\\t\\t} );\\n\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t}\\n\\n\\t\\t// Filters\\n\\t\\tfor ( type in Expr.filter ) {\\n\\t\\t\\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\\n\\t\\t\\t\\t( match = preFilters[ type ]( match ) ) ) ) {\\n\\t\\t\\t\\tmatched = match.shift();\\n\\t\\t\\t\\ttokens.push( {\\n\\t\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\t\\tmatches: match\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( !matched ) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the length of the invalid excess\\n\\t// if we\'re just parsing\\n\\t// Otherwise, throw an error or return tokens\\n\\treturn parseOnly ?\\n\\t\\tsoFar.length :\\n\\t\\tsoFar ?\\n\\t\\t\\tSizzle.error( selector ) :\\n\\n\\t\\t\\t// Cache the tokens\\n\\t\\t\\ttokenCache( selector, groups ).slice( 0 );\\n};\\n\\nfunction toSelector( tokens ) {\\n\\tvar i = 0,\\n\\t\\tlen = tokens.length,\\n\\t\\tselector = \\"\\";\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tselector += tokens[ i ].value;\\n\\t}\\n\\treturn selector;\\n}\\n\\nfunction addCombinator( matcher, combinator, base ) {\\n\\tvar dir = combinator.dir,\\n\\t\\tskip = combinator.next,\\n\\t\\tkey = skip || dir,\\n\\t\\tcheckNonElements = base && key === \\"parentNode\\",\\n\\t\\tdoneName = done++;\\n\\n\\treturn combinator.first ?\\n\\n\\t\\t// Check against closest ancestor/preceding element\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\twhile ( ( elem = elem[ dir ] ) ) {\\n\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\treturn matcher( elem, context, xml );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t} :\\n\\n\\t\\t// Check against all ancestor/preceding elements\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar oldCache, uniqueCache, outerCache,\\n\\t\\t\\t\\tnewCache = [ dirruns, doneName ];\\n\\n\\t\\t\\t// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from combinator caching\\n\\t\\t\\tif ( xml ) {\\n\\t\\t\\t\\twhile ( ( elem = elem[ dir ] ) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile ( ( elem = elem[ dir ] ) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ elem.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t( outerCache[ elem.uniqueID ] = {} );\\n\\n\\t\\t\\t\\t\\t\\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\\n\\t\\t\\t\\t\\t\\t\\telem = elem[ dir ] || elem;\\n\\t\\t\\t\\t\\t\\t} else if ( ( oldCache = uniqueCache[ key ] ) &&\\n\\t\\t\\t\\t\\t\\t\\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Assign to newCache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Reuse newcache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache[ key ] = newCache;\\n\\n\\t\\t\\t\\t\\t\\t\\t// A match means we\'re done; a fail means we have to keep checking\\n\\t\\t\\t\\t\\t\\t\\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n}\\n\\nfunction elementMatcher( matchers ) {\\n\\treturn matchers.length > 1 ?\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar i = matchers.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( !matchers[ i ]( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} :\\n\\t\\tmatchers[ 0 ];\\n}\\n\\nfunction multipleContexts( selector, contexts, results ) {\\n\\tvar i = 0,\\n\\t\\tlen = contexts.length;\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tSizzle( selector, contexts[ i ], results );\\n\\t}\\n\\treturn results;\\n}\\n\\nfunction condense( unmatched, map, filter, context, xml ) {\\n\\tvar elem,\\n\\t\\tnewUnmatched = [],\\n\\t\\ti = 0,\\n\\t\\tlen = unmatched.length,\\n\\t\\tmapped = map != null;\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( ( elem = unmatched[ i ] ) ) {\\n\\t\\t\\tif ( !filter || filter( elem, context, xml ) ) {\\n\\t\\t\\t\\tnewUnmatched.push( elem );\\n\\t\\t\\t\\tif ( mapped ) {\\n\\t\\t\\t\\t\\tmap.push( i );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn newUnmatched;\\n}\\n\\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\\n\\tif ( postFilter && !postFilter[ expando ] ) {\\n\\t\\tpostFilter = setMatcher( postFilter );\\n\\t}\\n\\tif ( postFinder && !postFinder[ expando ] ) {\\n\\t\\tpostFinder = setMatcher( postFinder, postSelector );\\n\\t}\\n\\treturn markFunction( function( seed, results, context, xml ) {\\n\\t\\tvar temp, i, elem,\\n\\t\\t\\tpreMap = [],\\n\\t\\t\\tpostMap = [],\\n\\t\\t\\tpreexisting = results.length,\\n\\n\\t\\t\\t// Get initial elements from seed or context\\n\\t\\t\\telems = seed || multipleContexts(\\n\\t\\t\\t\\tselector || \\"*\\",\\n\\t\\t\\t\\tcontext.nodeType ? [ context ] : context,\\n\\t\\t\\t\\t[]\\n\\t\\t\\t),\\n\\n\\t\\t\\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\\n\\t\\t\\tmatcherIn = preFilter && ( seed || !selector ) ?\\n\\t\\t\\t\\tcondense( elems, preMap, preFilter, context, xml ) :\\n\\t\\t\\t\\telems,\\n\\n\\t\\t\\tmatcherOut = matcher ?\\n\\n\\t\\t\\t\\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\\n\\t\\t\\t\\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\\n\\n\\t\\t\\t\\t\\t// ...intermediate processing is necessary\\n\\t\\t\\t\\t\\t[] :\\n\\n\\t\\t\\t\\t\\t// ...otherwise use results directly\\n\\t\\t\\t\\t\\tresults :\\n\\t\\t\\t\\tmatcherIn;\\n\\n\\t\\t// Find primary matches\\n\\t\\tif ( matcher ) {\\n\\t\\t\\tmatcher( matcherIn, matcherOut, context, xml );\\n\\t\\t}\\n\\n\\t\\t// Apply postFilter\\n\\t\\tif ( postFilter ) {\\n\\t\\t\\ttemp = condense( matcherOut, postMap );\\n\\t\\t\\tpostFilter( temp, [], context, xml );\\n\\n\\t\\t\\t// Un-match failing elements by moving them back to matcherIn\\n\\t\\t\\ti = temp.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( ( elem = temp[ i ] ) ) {\\n\\t\\t\\t\\t\\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( seed ) {\\n\\t\\t\\tif ( postFinder || preFilter ) {\\n\\t\\t\\t\\tif ( postFinder ) {\\n\\n\\t\\t\\t\\t\\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\\n\\t\\t\\t\\t\\ttemp = [];\\n\\t\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( ( elem = matcherOut[ i ] ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Restore matcherIn since elem is not yet a final match\\n\\t\\t\\t\\t\\t\\t\\ttemp.push( ( matcherIn[ i ] = elem ) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpostFinder( null, ( matcherOut = [] ), temp, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Move matched elements from seed to results to keep them synchronized\\n\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\tif ( ( elem = matcherOut[ i ] ) &&\\n\\t\\t\\t\\t\\t\\t( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {\\n\\n\\t\\t\\t\\t\\t\\tseed[ temp ] = !( results[ temp ] = elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Add elements to results, through postFinder if defined\\n\\t\\t} else {\\n\\t\\t\\tmatcherOut = condense(\\n\\t\\t\\t\\tmatcherOut === results ?\\n\\t\\t\\t\\t\\tmatcherOut.splice( preexisting, matcherOut.length ) :\\n\\t\\t\\t\\t\\tmatcherOut\\n\\t\\t\\t);\\n\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\tpostFinder( null, results, matcherOut, xml );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.apply( results, matcherOut );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} );\\n}\\n\\nfunction matcherFromTokens( tokens ) {\\n\\tvar checkContext, matcher, j,\\n\\t\\tlen = tokens.length,\\n\\t\\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\\n\\t\\timplicitRelative = leadingRelative || Expr.relative[ \\" \\" ],\\n\\t\\ti = leadingRelative ? 1 : 0,\\n\\n\\t\\t// The foundational matcher ensures that elements are reachable from top-level context(s)\\n\\t\\tmatchContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn elem === checkContext;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchAnyContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn indexOf( checkContext, elem ) > -1;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchers = [ function( elem, context, xml ) {\\n\\t\\t\\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\\n\\t\\t\\t\\t( checkContext = context ).nodeType ?\\n\\t\\t\\t\\t\\tmatchContext( elem, context, xml ) :\\n\\t\\t\\t\\t\\tmatchAnyContext( elem, context, xml ) );\\n\\n\\t\\t\\t// Avoid hanging onto element (issue #299)\\n\\t\\t\\tcheckContext = null;\\n\\t\\t\\treturn ret;\\n\\t\\t} ];\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\\n\\t\\t\\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\\n\\t\\t} else {\\n\\t\\t\\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\\n\\n\\t\\t\\t// Return special upon seeing a positional matcher\\n\\t\\t\\tif ( matcher[ expando ] ) {\\n\\n\\t\\t\\t\\t// Find the next relative operator (if any) for proper handling\\n\\t\\t\\t\\tj = ++i;\\n\\t\\t\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\t\\t\\tif ( Expr.relative[ tokens[ j ].type ] ) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn setMatcher(\\n\\t\\t\\t\\t\\ti > 1 && elementMatcher( matchers ),\\n\\t\\t\\t\\t\\ti > 1 && toSelector(\\n\\n\\t\\t\\t\\t\\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\\n\\t\\t\\t\\t\\ttokens\\n\\t\\t\\t\\t\\t\\t.slice( 0, i - 1 )\\n\\t\\t\\t\\t\\t\\t.concat( { value: tokens[ i - 2 ].type === \\" \\" ? \\"*\\" : \\"\\" } )\\n\\t\\t\\t\\t\\t).replace( rtrim, \\"$1\\" ),\\n\\t\\t\\t\\t\\tmatcher,\\n\\t\\t\\t\\t\\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\\n\\t\\t\\t\\t\\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\\n\\t\\t\\t\\t\\tj < len && toSelector( tokens )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tmatchers.push( matcher );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elementMatcher( matchers );\\n}\\n\\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\\n\\tvar bySet = setMatchers.length > 0,\\n\\t\\tbyElement = elementMatchers.length > 0,\\n\\t\\tsuperMatcher = function( seed, context, xml, results, outermost ) {\\n\\t\\t\\tvar elem, j, matcher,\\n\\t\\t\\t\\tmatchedCount = 0,\\n\\t\\t\\t\\ti = \\"0\\",\\n\\t\\t\\t\\tunmatched = seed && [],\\n\\t\\t\\t\\tsetMatched = [],\\n\\t\\t\\t\\tcontextBackup = outermostContext,\\n\\n\\t\\t\\t\\t// We must always have either seed elements or outermost context\\n\\t\\t\\t\\telems = seed || byElement && Expr.find[ \\"TAG\\" ]( \\"*\\", outermost ),\\n\\n\\t\\t\\t\\t// Use integer dirruns iff this is the outermost matcher\\n\\t\\t\\t\\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\\n\\t\\t\\t\\tlen = elems.length;\\n\\n\\t\\t\\tif ( outermost ) {\\n\\n\\t\\t\\t\\t// Support: IE 11+, Edge 17 - 18+\\n\\t\\t\\t\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t\\t\\t\\t// two documents; shallow comparisons work.\\n\\t\\t\\t\\t// eslint-disable-next-line eqeqeq\\n\\t\\t\\t\\toutermostContext = context == document || context || outermost;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add elements passing elementMatchers directly to results\\n\\t\\t\\t// Support: IE<9, Safari\\n\\t\\t\\t// Tolerate NodeList properties (IE: \\"length\\"; Safari: <number>) matching elements by id\\n\\t\\t\\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\\n\\t\\t\\t\\tif ( byElement && elem ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\n\\t\\t\\t\\t\\t// Support: IE 11+, Edge 17 - 18+\\n\\t\\t\\t\\t\\t// IE/Edge sometimes throw a \\"Permission denied\\" error when strict-comparing\\n\\t\\t\\t\\t\\t// two documents; shallow comparisons work.\\n\\t\\t\\t\\t\\t// eslint-disable-next-line eqeqeq\\n\\t\\t\\t\\t\\tif ( !context && elem.ownerDocument != document ) {\\n\\t\\t\\t\\t\\t\\tsetDocument( elem );\\n\\t\\t\\t\\t\\t\\txml = !documentIsHTML;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context || document, xml ) ) {\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Track unmatched elements for set filters\\n\\t\\t\\t\\tif ( bySet ) {\\n\\n\\t\\t\\t\\t\\t// They will have gone through all possible matchers\\n\\t\\t\\t\\t\\tif ( ( elem = !matcher && elem ) ) {\\n\\t\\t\\t\\t\\t\\tmatchedCount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Lengthen the array for every element, matched or not\\n\\t\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t\\tunmatched.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\\n\\t\\t\\t// makes the latter nonnegative.\\n\\t\\t\\tmatchedCount += i;\\n\\n\\t\\t\\t// Apply set filters to unmatched elements\\n\\t\\t\\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\\n\\t\\t\\t// equals `i`), unless we didn\'t visit _any_ elements in the above loop because we have\\n\\t\\t\\t// no element matchers and no seed.\\n\\t\\t\\t// Incrementing an initially-string \\"0\\" `i` allows `i` to remain a string only in that\\n\\t\\t\\t// case, which will result in a \\"00\\" `matchedCount` that differs from `i` but is also\\n\\t\\t\\t// numerically zero.\\n\\t\\t\\tif ( bySet && i !== matchedCount ) {\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\\n\\t\\t\\t\\t\\tmatcher( unmatched, setMatched, context, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( seed ) {\\n\\n\\t\\t\\t\\t\\t// Reintegrate element matches to eliminate the need for sorting\\n\\t\\t\\t\\t\\tif ( matchedCount > 0 ) {\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tsetMatched[ i ] = pop.call( results );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Discard index placeholder values to get only actual matches\\n\\t\\t\\t\\t\\tsetMatched = condense( setMatched );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Add matches to results\\n\\t\\t\\t\\tpush.apply( results, setMatched );\\n\\n\\t\\t\\t\\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\\n\\t\\t\\t\\tif ( outermost && !seed && setMatched.length > 0 &&\\n\\t\\t\\t\\t\\t( matchedCount + setMatchers.length ) > 1 ) {\\n\\n\\t\\t\\t\\t\\tSizzle.uniqueSort( results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Override manipulation of globals by nested matchers\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\toutermostContext = contextBackup;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unmatched;\\n\\t\\t};\\n\\n\\treturn bySet ?\\n\\t\\tmarkFunction( superMatcher ) :\\n\\t\\tsuperMatcher;\\n}\\n\\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\\n\\tvar i,\\n\\t\\tsetMatchers = [],\\n\\t\\telementMatchers = [],\\n\\t\\tcached = compilerCache[ selector + \\" \\" ];\\n\\n\\tif ( !cached ) {\\n\\n\\t\\t// Generate a function of recursive functions that can be used to check each element\\n\\t\\tif ( !match ) {\\n\\t\\t\\tmatch = tokenize( selector );\\n\\t\\t}\\n\\t\\ti = match.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tcached = matcherFromTokens( match[ i ] );\\n\\t\\t\\tif ( cached[ expando ] ) {\\n\\t\\t\\t\\tsetMatchers.push( cached );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telementMatchers.push( cached );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Cache the compiled function\\n\\t\\tcached = compilerCache(\\n\\t\\t\\tselector,\\n\\t\\t\\tmatcherFromGroupMatchers( elementMatchers, setMatchers )\\n\\t\\t);\\n\\n\\t\\t// Save selector and tokenization\\n\\t\\tcached.selector = selector;\\n\\t}\\n\\treturn cached;\\n};\\n\\n/**\\n * A low-level selection function that works with Sizzle\'s compiled\\n *  selector functions\\n * @param {String|Function} selector A selector or a pre-compiled\\n *  selector function built with Sizzle.compile\\n * @param {Element} context\\n * @param {Array} [results]\\n * @param {Array} [seed] A set of elements to match against\\n */\\nselect = Sizzle.select = function( selector, context, results, seed ) {\\n\\tvar i, tokens, token, type, find,\\n\\t\\tcompiled = typeof selector === \\"function\\" && selector,\\n\\t\\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\\n\\n\\tresults = results || [];\\n\\n\\t// Try to minimize operations if there is only one selector in the list and no seed\\n\\t// (the latter of which guarantees us context)\\n\\tif ( match.length === 1 ) {\\n\\n\\t\\t// Reduce context if the leading compound selector is an ID\\n\\t\\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\\n\\t\\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \\"ID\\" &&\\n\\t\\t\\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\\n\\n\\t\\t\\tcontext = ( Expr.find[ \\"ID\\" ]( token.matches[ 0 ]\\n\\t\\t\\t\\t.replace( runescape, funescape ), context ) || [] )[ 0 ];\\n\\t\\t\\tif ( !context ) {\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t// Precompiled matchers will still verify ancestry, so step up a level\\n\\t\\t\\t} else if ( compiled ) {\\n\\t\\t\\t\\tcontext = context.parentNode;\\n\\t\\t\\t}\\n\\n\\t\\t\\tselector = selector.slice( tokens.shift().value.length );\\n\\t\\t}\\n\\n\\t\\t// Fetch a seed set for right-to-left matching\\n\\t\\ti = matchExpr[ \\"needsContext\\" ].test( selector ) ? 0 : tokens.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttoken = tokens[ i ];\\n\\n\\t\\t\\t// Abort if we hit a combinator\\n\\t\\t\\tif ( Expr.relative[ ( type = token.type ) ] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( ( find = Expr.find[ type ] ) ) {\\n\\n\\t\\t\\t\\t// Search, expanding context for leading sibling combinators\\n\\t\\t\\t\\tif ( ( seed = find(\\n\\t\\t\\t\\t\\ttoken.matches[ 0 ].replace( runescape, funescape ),\\n\\t\\t\\t\\t\\trsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||\\n\\t\\t\\t\\t\\t\\tcontext\\n\\t\\t\\t\\t) ) ) {\\n\\n\\t\\t\\t\\t\\t// If seed is empty or no tokens remain, we can return early\\n\\t\\t\\t\\t\\ttokens.splice( i, 1 );\\n\\t\\t\\t\\t\\tselector = seed.length && toSelector( tokens );\\n\\t\\t\\t\\t\\tif ( !selector ) {\\n\\t\\t\\t\\t\\t\\tpush.apply( results, seed );\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Compile and execute a filtering function if one is not provided\\n\\t// Provide `match` to avoid retokenization if we modified the selector above\\n\\t( compiled || compile( selector, match ) )(\\n\\t\\tseed,\\n\\t\\tcontext,\\n\\t\\t!documentIsHTML,\\n\\t\\tresults,\\n\\t\\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\\n\\t);\\n\\treturn results;\\n};\\n\\n// One-time assignments\\n\\n// Sort stability\\nsupport.sortStable = expando.split( \\"\\" ).sort( sortOrder ).join( \\"\\" ) === expando;\\n\\n// Support: Chrome 14-35+\\n// Always assume duplicates if they aren\'t passed to the comparison function\\nsupport.detectDuplicates = !!hasDuplicate;\\n\\n// Initialize against the default document\\nsetDocument();\\n\\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\\n// Detached nodes confoundingly follow *each other*\\nsupport.sortDetached = assert( function( el ) {\\n\\n\\t// Should return 1, but returns 4 (following)\\n\\treturn el.compareDocumentPosition( document.createElement( \\"fieldset\\" ) ) & 1;\\n} );\\n\\n// Support: IE<8\\n// Prevent attribute/property \\"interpolation\\"\\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\\nif ( !assert( function( el ) {\\n\\tel.innerHTML = \\"<a href=\'#\'></a>\\";\\n\\treturn el.firstChild.getAttribute( \\"href\\" ) === \\"#\\";\\n} ) ) {\\n\\taddHandle( \\"type|href|height|width\\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem.getAttribute( name, name.toLowerCase() === \\"type\\" ? 1 : 2 );\\n\\t\\t}\\n\\t} );\\n}\\n\\n// Support: IE<9\\n// Use defaultValue in place of getAttribute(\\"value\\")\\nif ( !support.attributes || !assert( function( el ) {\\n\\tel.innerHTML = \\"<input/>\\";\\n\\tel.firstChild.setAttribute( \\"value\\", \\"\\" );\\n\\treturn el.firstChild.getAttribute( \\"value\\" ) === \\"\\";\\n} ) ) {\\n\\taddHandle( \\"value\\", function( elem, _name, isXML ) {\\n\\t\\tif ( !isXML && elem.nodeName.toLowerCase() === \\"input\\" ) {\\n\\t\\t\\treturn elem.defaultValue;\\n\\t\\t}\\n\\t} );\\n}\\n\\n// Support: IE<9\\n// Use getAttributeNode to fetch booleans when getAttribute lies\\nif ( !assert( function( el ) {\\n\\treturn el.getAttribute( \\"disabled\\" ) == null;\\n} ) ) {\\n\\taddHandle( booleans, function( elem, name, isXML ) {\\n\\t\\tvar val;\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem[ name ] === true ? name.toLowerCase() :\\n\\t\\t\\t\\t( val = elem.getAttributeNode( name ) ) && val.specified ?\\n\\t\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\t\\tnull;\\n\\t\\t}\\n\\t} );\\n}\\n\\nreturn Sizzle;\\n\\n} )( window );\\n\\n\\n\\njQuery.find = Sizzle;\\njQuery.expr = Sizzle.selectors;\\n\\n// Deprecated\\njQuery.expr[ \\":\\" ] = jQuery.expr.pseudos;\\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\\njQuery.text = Sizzle.getText;\\njQuery.isXMLDoc = Sizzle.isXML;\\njQuery.contains = Sizzle.contains;\\njQuery.escapeSelector = Sizzle.escape;\\n\\n\\n\\n\\nvar dir = function( elem, dir, until ) {\\n\\tvar matched = [],\\n\\t\\ttruncate = until !== undefined;\\n\\n\\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\\n\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\tif ( truncate && jQuery( elem ).is( until ) ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tmatched.push( elem );\\n\\t\\t}\\n\\t}\\n\\treturn matched;\\n};\\n\\n\\nvar siblings = function( n, elem ) {\\n\\tvar matched = [];\\n\\n\\tfor ( ; n; n = n.nextSibling ) {\\n\\t\\tif ( n.nodeType === 1 && n !== elem ) {\\n\\t\\t\\tmatched.push( n );\\n\\t\\t}\\n\\t}\\n\\n\\treturn matched;\\n};\\n\\n\\nvar rneedsContext = jQuery.expr.match.needsContext;\\n\\n\\n\\nfunction nodeName( elem, name ) {\\n\\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\\n\\n};\\nvar rsingleTag = ( /^<([a-z][^\\\\/\\\\0>:\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[\\\\x20\\\\t\\\\r\\\\n\\\\f]*\\\\/?>(?:<\\\\/\\\\1>|)$/i );\\n\\n\\n\\n// Implement the identical functionality for filter and not\\nfunction winnow( elements, qualifier, not ) {\\n\\tif ( isFunction( qualifier ) ) {\\n\\t\\treturn jQuery.grep( elements, function( elem, i ) {\\n\\t\\t\\treturn !!qualifier.call( elem, i, elem ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Single element\\n\\tif ( qualifier.nodeType ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( elem === qualifier ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Arraylike of elements (jQuery, arguments, Array)\\n\\tif ( typeof qualifier !== \\"string\\" ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Filtered directly for both simple and complex selectors\\n\\treturn jQuery.filter( qualifier, elements, not );\\n}\\n\\njQuery.filter = function( expr, elems, not ) {\\n\\tvar elem = elems[ 0 ];\\n\\n\\tif ( not ) {\\n\\t\\texpr = \\":not(\\" + expr + \\")\\";\\n\\t}\\n\\n\\tif ( elems.length === 1 && elem.nodeType === 1 ) {\\n\\t\\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\\n\\t}\\n\\n\\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\\n\\t\\treturn elem.nodeType === 1;\\n\\t} ) );\\n};\\n\\njQuery.fn.extend( {\\n\\tfind: function( selector ) {\\n\\t\\tvar i, ret,\\n\\t\\t\\tlen = this.length,\\n\\t\\t\\tself = this;\\n\\n\\t\\tif ( typeof selector !== \\"string\\" ) {\\n\\t\\t\\treturn this.pushStack( jQuery( selector ).filter( function() {\\n\\t\\t\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\t\\t\\tif ( jQuery.contains( self[ i ], this ) ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} ) );\\n\\t\\t}\\n\\n\\t\\tret = this.pushStack( [] );\\n\\n\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\tjQuery.find( selector, self[ i ], ret );\\n\\t\\t}\\n\\n\\t\\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\\n\\t},\\n\\tfilter: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], false ) );\\n\\t},\\n\\tnot: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], true ) );\\n\\t},\\n\\tis: function( selector ) {\\n\\t\\treturn !!winnow(\\n\\t\\t\\tthis,\\n\\n\\t\\t\\t// If this is a positional/relative selector, check membership in the returned set\\n\\t\\t\\t// so $(\\"p:first\\").is(\\"p:last\\") won\'t return true for a doc with two \\"p\\".\\n\\t\\t\\ttypeof selector === \\"string\\" && rneedsContext.test( selector ) ?\\n\\t\\t\\t\\tjQuery( selector ) :\\n\\t\\t\\t\\tselector || [],\\n\\t\\t\\tfalse\\n\\t\\t).length;\\n\\t}\\n} );\\n\\n\\n// Initialize a jQuery object\\n\\n\\n// A central reference to the root jQuery(document)\\nvar rootjQuery,\\n\\n\\t// A simple way to check for HTML strings\\n\\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\\n\\t// Strict HTML recognition (#11290: must start with <)\\n\\t// Shortcut simple #id case for speed\\n\\trquickExpr = /^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]+))$/,\\n\\n\\tinit = jQuery.fn.init = function( selector, context, root ) {\\n\\t\\tvar match, elem;\\n\\n\\t\\t// HANDLE: $(\\"\\"), $(null), $(undefined), $(false)\\n\\t\\tif ( !selector ) {\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\t// Method init() accepts an alternate rootjQuery\\n\\t\\t// so migrate can support jQuery.sub (gh-2101)\\n\\t\\troot = root || rootjQuery;\\n\\n\\t\\t// Handle HTML strings\\n\\t\\tif ( typeof selector === \\"string\\" ) {\\n\\t\\t\\tif ( selector[ 0 ] === \\"<\\" &&\\n\\t\\t\\t\\tselector[ selector.length - 1 ] === \\">\\" &&\\n\\t\\t\\t\\tselector.length >= 3 ) {\\n\\n\\t\\t\\t\\t// Assume that strings that start and end with <> are HTML and skip the regex check\\n\\t\\t\\t\\tmatch = [ null, selector, null ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmatch = rquickExpr.exec( selector );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Match html or make sure no context is specified for #id\\n\\t\\t\\tif ( match && ( match[ 1 ] || !context ) ) {\\n\\n\\t\\t\\t\\t// HANDLE: $(html) -> $(array)\\n\\t\\t\\t\\tif ( match[ 1 ] ) {\\n\\t\\t\\t\\t\\tcontext = context instanceof jQuery ? context[ 0 ] : context;\\n\\n\\t\\t\\t\\t\\t// Option to run scripts is true for back-compat\\n\\t\\t\\t\\t\\t// Intentionally let the error be thrown if parseHTML is not present\\n\\t\\t\\t\\t\\tjQuery.merge( this, jQuery.parseHTML(\\n\\t\\t\\t\\t\\t\\tmatch[ 1 ],\\n\\t\\t\\t\\t\\t\\tcontext && context.nodeType ? context.ownerDocument || context : document,\\n\\t\\t\\t\\t\\t\\ttrue\\n\\t\\t\\t\\t\\t) );\\n\\n\\t\\t\\t\\t\\t// HANDLE: $(html, props)\\n\\t\\t\\t\\t\\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\\n\\t\\t\\t\\t\\t\\tfor ( match in context ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Properties of context are called as methods if possible\\n\\t\\t\\t\\t\\t\\t\\tif ( isFunction( this[ match ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis[ match ]( context[ match ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...and otherwise set as attributes\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.attr( match, context[ match ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t// HANDLE: $(#id)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\telem = document.getElementById( match[ 2 ] );\\n\\n\\t\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t\\t// Inject the element directly into the jQuery object\\n\\t\\t\\t\\t\\t\\tthis[ 0 ] = elem;\\n\\t\\t\\t\\t\\t\\tthis.length = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// HANDLE: $(expr, $(...))\\n\\t\\t\\t} else if ( !context || context.jquery ) {\\n\\t\\t\\t\\treturn ( context || root ).find( selector );\\n\\n\\t\\t\\t// HANDLE: $(expr, context)\\n\\t\\t\\t// (which is just equivalent to: $(context).find(expr)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this.constructor( context ).find( selector );\\n\\t\\t\\t}\\n\\n\\t\\t// HANDLE: $(DOMElement)\\n\\t\\t} else if ( selector.nodeType ) {\\n\\t\\t\\tthis[ 0 ] = selector;\\n\\t\\t\\tthis.length = 1;\\n\\t\\t\\treturn this;\\n\\n\\t\\t// HANDLE: $(function)\\n\\t\\t// Shortcut for document ready\\n\\t\\t} else if ( isFunction( selector ) ) {\\n\\t\\t\\treturn root.ready !== undefined ?\\n\\t\\t\\t\\troot.ready( selector ) :\\n\\n\\t\\t\\t\\t// Execute immediately if ready is not present\\n\\t\\t\\t\\tselector( jQuery );\\n\\t\\t}\\n\\n\\t\\treturn jQuery.makeArray( selector, this );\\n\\t};\\n\\n// Give the init function the jQuery prototype for later instantiation\\ninit.prototype = jQuery.fn;\\n\\n// Initialize central reference\\nrootjQuery = jQuery( document );\\n\\n\\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\\n\\n\\t// Methods guaranteed to produce a unique set when starting from a unique set\\n\\tguaranteedUnique = {\\n\\t\\tchildren: true,\\n\\t\\tcontents: true,\\n\\t\\tnext: true,\\n\\t\\tprev: true\\n\\t};\\n\\njQuery.fn.extend( {\\n\\thas: function( target ) {\\n\\t\\tvar targets = jQuery( target, this ),\\n\\t\\t\\tl = targets.length;\\n\\n\\t\\treturn this.filter( function() {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tif ( jQuery.contains( this, targets[ i ] ) ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tclosest: function( selectors, context ) {\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tl = this.length,\\n\\t\\t\\tmatched = [],\\n\\t\\t\\ttargets = typeof selectors !== \\"string\\" && jQuery( selectors );\\n\\n\\t\\t// Positional selectors never match, since there\'s no _selection_ context\\n\\t\\tif ( !rneedsContext.test( selectors ) ) {\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\\n\\n\\t\\t\\t\\t\\t// Always skip document fragments\\n\\t\\t\\t\\t\\tif ( cur.nodeType < 11 && ( targets ?\\n\\t\\t\\t\\t\\t\\ttargets.index( cur ) > -1 :\\n\\n\\t\\t\\t\\t\\t\\t// Don\'t pass non-elements to Sizzle\\n\\t\\t\\t\\t\\t\\tcur.nodeType === 1 &&\\n\\t\\t\\t\\t\\t\\t\\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tmatched.push( cur );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\\n\\t},\\n\\n\\t// Determine the position of an element within the set\\n\\tindex: function( elem ) {\\n\\n\\t\\t// No argument, return index in parent\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\\n\\t\\t}\\n\\n\\t\\t// Index in selector\\n\\t\\tif ( typeof elem === \\"string\\" ) {\\n\\t\\t\\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\\n\\t\\t}\\n\\n\\t\\t// Locate the position of the desired element\\n\\t\\treturn indexOf.call( this,\\n\\n\\t\\t\\t// If it receives a jQuery object, the first element is used\\n\\t\\t\\telem.jquery ? elem[ 0 ] : elem\\n\\t\\t);\\n\\t},\\n\\n\\tadd: function( selector, context ) {\\n\\t\\treturn this.pushStack(\\n\\t\\t\\tjQuery.uniqueSort(\\n\\t\\t\\t\\tjQuery.merge( this.get(), jQuery( selector, context ) )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t},\\n\\n\\taddBack: function( selector ) {\\n\\t\\treturn this.add( selector == null ?\\n\\t\\t\\tthis.prevObject : this.prevObject.filter( selector )\\n\\t\\t);\\n\\t}\\n} );\\n\\nfunction sibling( cur, dir ) {\\n\\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\\n\\treturn cur;\\n}\\n\\njQuery.each( {\\n\\tparent: function( elem ) {\\n\\t\\tvar parent = elem.parentNode;\\n\\t\\treturn parent && parent.nodeType !== 11 ? parent : null;\\n\\t},\\n\\tparents: function( elem ) {\\n\\t\\treturn dir( elem, \\"parentNode\\" );\\n\\t},\\n\\tparentsUntil: function( elem, _i, until ) {\\n\\t\\treturn dir( elem, \\"parentNode\\", until );\\n\\t},\\n\\tnext: function( elem ) {\\n\\t\\treturn sibling( elem, \\"nextSibling\\" );\\n\\t},\\n\\tprev: function( elem ) {\\n\\t\\treturn sibling( elem, \\"previousSibling\\" );\\n\\t},\\n\\tnextAll: function( elem ) {\\n\\t\\treturn dir( elem, \\"nextSibling\\" );\\n\\t},\\n\\tprevAll: function( elem ) {\\n\\t\\treturn dir( elem, \\"previousSibling\\" );\\n\\t},\\n\\tnextUntil: function( elem, _i, until ) {\\n\\t\\treturn dir( elem, \\"nextSibling\\", until );\\n\\t},\\n\\tprevUntil: function( elem, _i, until ) {\\n\\t\\treturn dir( elem, \\"previousSibling\\", until );\\n\\t},\\n\\tsiblings: function( elem ) {\\n\\t\\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\\n\\t},\\n\\tchildren: function( elem ) {\\n\\t\\treturn siblings( elem.firstChild );\\n\\t},\\n\\tcontents: function( elem ) {\\n\\t\\tif ( elem.contentDocument != null &&\\n\\n\\t\\t\\t// Support: IE 11+\\n\\t\\t\\t// <object> elements with no `data` attribute has an object\\n\\t\\t\\t// `contentDocument` with a `null` prototype.\\n\\t\\t\\tgetProto( elem.contentDocument ) ) {\\n\\n\\t\\t\\treturn elem.contentDocument;\\n\\t\\t}\\n\\n\\t\\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\\n\\t\\t// Treat the template element as a regular one in browsers that\\n\\t\\t// don\'t support it.\\n\\t\\tif ( nodeName( elem, \\"template\\" ) ) {\\n\\t\\t\\telem = elem.content || elem;\\n\\t\\t}\\n\\n\\t\\treturn jQuery.merge( [], elem.childNodes );\\n\\t}\\n}, function( name, fn ) {\\n\\tjQuery.fn[ name ] = function( until, selector ) {\\n\\t\\tvar matched = jQuery.map( this, fn, until );\\n\\n\\t\\tif ( name.slice( -5 ) !== \\"Until\\" ) {\\n\\t\\t\\tselector = until;\\n\\t\\t}\\n\\n\\t\\tif ( selector && typeof selector === \\"string\\" ) {\\n\\t\\t\\tmatched = jQuery.filter( selector, matched );\\n\\t\\t}\\n\\n\\t\\tif ( this.length > 1 ) {\\n\\n\\t\\t\\t// Remove duplicates\\n\\t\\t\\tif ( !guaranteedUnique[ name ] ) {\\n\\t\\t\\t\\tjQuery.uniqueSort( matched );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reverse order for parents* and prev-derivatives\\n\\t\\t\\tif ( rparentsprev.test( name ) ) {\\n\\t\\t\\t\\tmatched.reverse();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched );\\n\\t};\\n} );\\nvar rnothtmlwhite = ( /[^\\\\x20\\\\t\\\\r\\\\n\\\\f]+/g );\\n\\n\\n\\n// Convert String-formatted options into Object-formatted ones\\nfunction createOptions( options ) {\\n\\tvar object = {};\\n\\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\\n\\t\\tobject[ flag ] = true;\\n\\t} );\\n\\treturn object;\\n}\\n\\n/*\\n * Create a callback list using the following parameters:\\n *\\n *\\toptions: an optional list of space-separated options that will change how\\n *\\t\\t\\tthe callback list behaves or a more traditional option object\\n *\\n * By default a callback list will act like an event callback list and can be\\n * \\"fired\\" multiple times.\\n *\\n * Possible options:\\n *\\n *\\tonce:\\t\\t\\twill ensure the callback list can only be fired once (like a Deferred)\\n *\\n *\\tmemory:\\t\\t\\twill keep track of previous values and will call any callback added\\n *\\t\\t\\t\\t\\tafter the list has been fired right away with the latest \\"memorized\\"\\n *\\t\\t\\t\\t\\tvalues (like a Deferred)\\n *\\n *\\tunique:\\t\\t\\twill ensure a callback can only be added once (no duplicate in the list)\\n *\\n *\\tstopOnFalse:\\tinterrupt callings when a callback returns false\\n *\\n */\\njQuery.Callbacks = function( options ) {\\n\\n\\t// Convert options from String-formatted to Object-formatted if needed\\n\\t// (we check in cache first)\\n\\toptions = typeof options === \\"string\\" ?\\n\\t\\tcreateOptions( options ) :\\n\\t\\tjQuery.extend( {}, options );\\n\\n\\tvar // Flag to know if list is currently firing\\n\\t\\tfiring,\\n\\n\\t\\t// Last fire value for non-forgettable lists\\n\\t\\tmemory,\\n\\n\\t\\t// Flag to know if list was already fired\\n\\t\\tfired,\\n\\n\\t\\t// Flag to prevent firing\\n\\t\\tlocked,\\n\\n\\t\\t// Actual callback list\\n\\t\\tlist = [],\\n\\n\\t\\t// Queue of execution data for repeatable lists\\n\\t\\tqueue = [],\\n\\n\\t\\t// Index of currently firing callback (modified by add/remove as needed)\\n\\t\\tfiringIndex = -1,\\n\\n\\t\\t// Fire callbacks\\n\\t\\tfire = function() {\\n\\n\\t\\t\\t// Enforce single-firing\\n\\t\\t\\tlocked = locked || options.once;\\n\\n\\t\\t\\t// Execute callbacks for all pending executions,\\n\\t\\t\\t// respecting firingIndex overrides and runtime changes\\n\\t\\t\\tfired = firing = true;\\n\\t\\t\\tfor ( ; queue.length; firingIndex = -1 ) {\\n\\t\\t\\t\\tmemory = queue.shift();\\n\\t\\t\\t\\twhile ( ++firingIndex < list.length ) {\\n\\n\\t\\t\\t\\t\\t// Run callback and check for early termination\\n\\t\\t\\t\\t\\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\\n\\t\\t\\t\\t\\t\\toptions.stopOnFalse ) {\\n\\n\\t\\t\\t\\t\\t\\t// Jump to end and forget the data so .add doesn\'t re-fire\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length;\\n\\t\\t\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Forget the data if we\'re done with it\\n\\t\\t\\tif ( !options.memory ) {\\n\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfiring = false;\\n\\n\\t\\t\\t// Clean up if we\'re done firing for good\\n\\t\\t\\tif ( locked ) {\\n\\n\\t\\t\\t\\t// Keep an empty list if we have data for future add calls\\n\\t\\t\\t\\tif ( memory ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\n\\t\\t\\t\\t// Otherwise, this object is spent\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlist = \\"\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Actual Callbacks object\\n\\t\\tself = {\\n\\n\\t\\t\\t// Add a callback or a collection of callbacks to the list\\n\\t\\t\\tadd: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\n\\t\\t\\t\\t\\t// If we have memory from a past run, we should fire after adding\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length - 1;\\n\\t\\t\\t\\t\\t\\tqueue.push( memory );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t( function add( args ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( args, function( _, arg ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( isFunction( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( !options.unique || !self.has( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlist.push( arg );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else if ( arg && arg.length && toType( arg ) !== \\"string\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Inspect recursively\\n\\t\\t\\t\\t\\t\\t\\t\\tadd( arg );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t} )( arguments );\\n\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove a callback from the list\\n\\t\\t\\tremove: function() {\\n\\t\\t\\t\\tjQuery.each( arguments, function( _, arg ) {\\n\\t\\t\\t\\t\\tvar index;\\n\\t\\t\\t\\t\\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\\n\\t\\t\\t\\t\\t\\tlist.splice( index, 1 );\\n\\n\\t\\t\\t\\t\\t\\t// Handle firing indexes\\n\\t\\t\\t\\t\\t\\tif ( index <= firingIndex ) {\\n\\t\\t\\t\\t\\t\\t\\tfiringIndex--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Check if a given callback is in the list.\\n\\t\\t\\t// If no argument is given, return whether or not list has callbacks attached.\\n\\t\\t\\thas: function( fn ) {\\n\\t\\t\\t\\treturn fn ?\\n\\t\\t\\t\\t\\tjQuery.inArray( fn, list ) > -1 :\\n\\t\\t\\t\\t\\tlist.length > 0;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove all callbacks from the list\\n\\t\\t\\tempty: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire and .add\\n\\t\\t\\t// Abort any current/pending executions\\n\\t\\t\\t// Clear all callbacks and values\\n\\t\\t\\tdisable: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tlist = memory = \\"\\";\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tdisabled: function() {\\n\\t\\t\\t\\treturn !list;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire\\n\\t\\t\\t// Also disable .add unless we have memory (since it would have no effect)\\n\\t\\t\\t// Abort any pending executions\\n\\t\\t\\tlock: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tif ( !memory && !firing ) {\\n\\t\\t\\t\\t\\tlist = memory = \\"\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tlocked: function() {\\n\\t\\t\\t\\treturn !!locked;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all callbacks with the given context and arguments\\n\\t\\t\\tfireWith: function( context, args ) {\\n\\t\\t\\t\\tif ( !locked ) {\\n\\t\\t\\t\\t\\targs = args || [];\\n\\t\\t\\t\\t\\targs = [ context, args.slice ? args.slice() : args ];\\n\\t\\t\\t\\t\\tqueue.push( args );\\n\\t\\t\\t\\t\\tif ( !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all the callbacks with the given arguments\\n\\t\\t\\tfire: function() {\\n\\t\\t\\t\\tself.fireWith( this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// To know if the callbacks have already been called at least once\\n\\t\\t\\tfired: function() {\\n\\t\\t\\t\\treturn !!fired;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\treturn self;\\n};\\n\\n\\nfunction Identity( v ) {\\n\\treturn v;\\n}\\nfunction Thrower( ex ) {\\n\\tthrow ex;\\n}\\n\\nfunction adoptValue( value, resolve, reject, noValue ) {\\n\\tvar method;\\n\\n\\ttry {\\n\\n\\t\\t// Check for promise aspect first to privilege synchronous behavior\\n\\t\\tif ( value && isFunction( ( method = value.promise ) ) ) {\\n\\t\\t\\tmethod.call( value ).done( resolve ).fail( reject );\\n\\n\\t\\t// Other thenables\\n\\t\\t} else if ( value && isFunction( ( method = value.then ) ) ) {\\n\\t\\t\\tmethod.call( value, resolve, reject );\\n\\n\\t\\t// Other non-thenables\\n\\t\\t} else {\\n\\n\\t\\t\\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\\n\\t\\t\\t// * false: [ value ].slice( 0 ) => resolve( value )\\n\\t\\t\\t// * true: [ value ].slice( 1 ) => resolve()\\n\\t\\t\\tresolve.apply( undefined, [ value ].slice( noValue ) );\\n\\t\\t}\\n\\n\\t// For Promises/A+, convert exceptions into rejections\\n\\t// Since jQuery.when doesn\'t unwrap thenables, we can skip the extra checks appearing in\\n\\t// Deferred#then to conditionally suppress rejection.\\n\\t} catch ( value ) {\\n\\n\\t\\t// Support: Android 4.0 only\\n\\t\\t// Strict mode functions invoked without .call/.apply get global-object context\\n\\t\\treject.apply( undefined, [ value ] );\\n\\t}\\n}\\n\\njQuery.extend( {\\n\\n\\tDeferred: function( func ) {\\n\\t\\tvar tuples = [\\n\\n\\t\\t\\t\\t// action, add listener, callbacks,\\n\\t\\t\\t\\t// ... .then handlers, argument index, [final state]\\n\\t\\t\\t\\t[ \\"notify\\", \\"progress\\", jQuery.Callbacks( \\"memory\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\"memory\\" ), 2 ],\\n\\t\\t\\t\\t[ \\"resolve\\", \\"done\\", jQuery.Callbacks( \\"once memory\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\"once memory\\" ), 0, \\"resolved\\" ],\\n\\t\\t\\t\\t[ \\"reject\\", \\"fail\\", jQuery.Callbacks( \\"once memory\\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \\"once memory\\" ), 1, \\"rejected\\" ]\\n\\t\\t\\t],\\n\\t\\t\\tstate = \\"pending\\",\\n\\t\\t\\tpromise = {\\n\\t\\t\\t\\tstate: function() {\\n\\t\\t\\t\\t\\treturn state;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\talways: function() {\\n\\t\\t\\t\\t\\tdeferred.done( arguments ).fail( arguments );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\"catch\\": function( fn ) {\\n\\t\\t\\t\\t\\treturn promise.then( null, fn );\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Keep pipe for back-compat\\n\\t\\t\\t\\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\\n\\t\\t\\t\\t\\tvar fns = arguments;\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( tuples, function( _i, tuple ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\\n\\t\\t\\t\\t\\t\\t\\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\\n\\t\\t\\t\\t\\t\\t\\tdeferred[ tuple[ 1 ] ]( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar returned = fn && fn.apply( this, arguments );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( returned && isFunction( returned.promise ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.promise()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.progress( newDefer.notify )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.done( newDefer.resolve )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.fail( newDefer.reject );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnewDefer[ tuple[ 0 ] + \\"With\\" ](\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfn ? [ returned ] : arguments\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\tfns = null;\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tthen: function( onFulfilled, onRejected, onProgress ) {\\n\\t\\t\\t\\t\\tvar maxDepth = 0;\\n\\t\\t\\t\\t\\tfunction resolve( depth, deferred, handler, special ) {\\n\\t\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\t\\tvar that = this,\\n\\t\\t\\t\\t\\t\\t\\t\\targs = arguments,\\n\\t\\t\\t\\t\\t\\t\\t\\tmightThrow = function() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar returned, then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-59\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore double-resolution attempts\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth < maxDepth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned = handler.apply( that, args );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-48\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( returned === deferred.promise() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthrow new TypeError( \\"Thenable self-resolution\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ sections 2.3.3.1, 3.5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-54\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-75\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Retrieve `then` only once\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthen = returned &&\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-64\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only check objects and functions for thenability\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( typeof returned === \\"object\\" ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof returned === \\"function\\" ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle a returned thenable\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( isFunction( then ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Special processors (notify) just wait for resolution\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( special ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Normal processors (resolve) also hook into progress\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// ...and disregard older resolution values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmaxDepth++;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.notifyWith )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle all other returned values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Identity ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ returned ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Process the value(s)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Default process is resolve\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( special || deferred.resolveWith )( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Only normal processors (resolve) catch and reject exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess = special ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.exceptionHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tjQuery.Deferred.exceptionHook( e,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.4.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-61\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore post-resolution exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth + 1 >= maxDepth ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Thrower ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ e ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.rejectWith( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.1\\n\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-57\\n\\t\\t\\t\\t\\t\\t\\t// Re-resolve promises immediately to dodge false rejection from\\n\\t\\t\\t\\t\\t\\t\\t// subsequent errors\\n\\t\\t\\t\\t\\t\\t\\tif ( depth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess();\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Call an optional hook to record the stack, in case of exception\\n\\t\\t\\t\\t\\t\\t\\t\\t// since it\'s otherwise lost when execution goes async\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.getStackHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace = jQuery.Deferred.getStackHook();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( process );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\n\\t\\t\\t\\t\\t\\t// progress_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onProgress ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonProgress :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer.notifyWith\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// fulfilled_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 1 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onFulfilled ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonFulfilled :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// rejected_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 2 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onRejected ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonRejected :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tThrower\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Get a promise for this deferred\\n\\t\\t\\t\\t// If obj is provided, the promise aspect is added to the object\\n\\t\\t\\t\\tpromise: function( obj ) {\\n\\t\\t\\t\\t\\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdeferred = {};\\n\\n\\t\\t// Add list-specific methods\\n\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\t\\t\\tvar list = tuple[ 2 ],\\n\\t\\t\\t\\tstateString = tuple[ 5 ];\\n\\n\\t\\t\\t// promise.progress = list.add\\n\\t\\t\\t// promise.done = list.add\\n\\t\\t\\t// promise.fail = list.add\\n\\t\\t\\tpromise[ tuple[ 1 ] ] = list.add;\\n\\n\\t\\t\\t// Handle state\\n\\t\\t\\tif ( stateString ) {\\n\\t\\t\\t\\tlist.add(\\n\\t\\t\\t\\t\\tfunction() {\\n\\n\\t\\t\\t\\t\\t\\t// state = \\"resolved\\" (i.e., fulfilled)\\n\\t\\t\\t\\t\\t\\t// state = \\"rejected\\"\\n\\t\\t\\t\\t\\t\\tstate = stateString;\\n\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t// rejected_callbacks.disable\\n\\t\\t\\t\\t\\t// fulfilled_callbacks.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 2 ].disable,\\n\\n\\t\\t\\t\\t\\t// rejected_handlers.disable\\n\\t\\t\\t\\t\\t// fulfilled_handlers.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 3 ].disable,\\n\\n\\t\\t\\t\\t\\t// progress_callbacks.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 2 ].lock,\\n\\n\\t\\t\\t\\t\\t// progress_handlers.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].lock\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// progress_handlers.fire\\n\\t\\t\\t// fulfilled_handlers.fire\\n\\t\\t\\t// rejected_handlers.fire\\n\\t\\t\\tlist.add( tuple[ 3 ].fire );\\n\\n\\t\\t\\t// deferred.notify = function() { deferred.notifyWith(...) }\\n\\t\\t\\t// deferred.resolve = function() { deferred.resolveWith(...) }\\n\\t\\t\\t// deferred.reject = function() { deferred.rejectWith(...) }\\n\\t\\t\\tdeferred[ tuple[ 0 ] ] = function() {\\n\\t\\t\\t\\tdeferred[ tuple[ 0 ] + \\"With\\" ]( this === deferred ? undefined : this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t};\\n\\n\\t\\t\\t// deferred.notifyWith = list.fireWith\\n\\t\\t\\t// deferred.resolveWith = list.fireWith\\n\\t\\t\\t// deferred.rejectWith = list.fireWith\\n\\t\\t\\tdeferred[ tuple[ 0 ] + \\"With\\" ] = list.fireWith;\\n\\t\\t} );\\n\\n\\t\\t// Make the deferred a promise\\n\\t\\tpromise.promise( deferred );\\n\\n\\t\\t// Call given func if any\\n\\t\\tif ( func ) {\\n\\t\\t\\tfunc.call( deferred, deferred );\\n\\t\\t}\\n\\n\\t\\t// All done!\\n\\t\\treturn deferred;\\n\\t},\\n\\n\\t// Deferred helper\\n\\twhen: function( singleValue ) {\\n\\t\\tvar\\n\\n\\t\\t\\t// count of uncompleted subordinates\\n\\t\\t\\tremaining = arguments.length,\\n\\n\\t\\t\\t// count of unprocessed arguments\\n\\t\\t\\ti = remaining,\\n\\n\\t\\t\\t// subordinate fulfillment data\\n\\t\\t\\tresolveContexts = Array( i ),\\n\\t\\t\\tresolveValues = slice.call( arguments ),\\n\\n\\t\\t\\t// the master Deferred\\n\\t\\t\\tmaster = jQuery.Deferred(),\\n\\n\\t\\t\\t// subordinate callback factory\\n\\t\\t\\tupdateFunc = function( i ) {\\n\\t\\t\\t\\treturn function( value ) {\\n\\t\\t\\t\\t\\tresolveContexts[ i ] = this;\\n\\t\\t\\t\\t\\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\\n\\t\\t\\t\\t\\tif ( !( --remaining ) ) {\\n\\t\\t\\t\\t\\t\\tmaster.resolveWith( resolveContexts, resolveValues );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\t};\\n\\n\\t\\t// Single- and empty arguments are adopted like Promise.resolve\\n\\t\\tif ( remaining <= 1 ) {\\n\\t\\t\\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\\n\\t\\t\\t\\t!remaining );\\n\\n\\t\\t\\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\\n\\t\\t\\tif ( master.state() === \\"pending\\" ||\\n\\t\\t\\t\\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\\n\\n\\t\\t\\t\\treturn master.then();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Multiple arguments are aggregated like Promise.all array elements\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\\n\\t\\t}\\n\\n\\t\\treturn master.promise();\\n\\t}\\n} );\\n\\n\\n// These usually indicate a programmer mistake during development,\\n// warn about them ASAP rather than swallowing them by default.\\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\\n\\njQuery.Deferred.exceptionHook = function( error, stack ) {\\n\\n\\t// Support: IE 8 - 9 only\\n\\t// Console exists when dev tools are open, which can happen at any time\\n\\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\\n\\t\\twindow.console.warn( \\"jQuery.Deferred exception: \\" + error.message, error.stack, stack );\\n\\t}\\n};\\n\\n\\n\\n\\njQuery.readyException = function( error ) {\\n\\twindow.setTimeout( function() {\\n\\t\\tthrow error;\\n\\t} );\\n};\\n\\n\\n\\n\\n// The deferred used on DOM ready\\nvar readyList = jQuery.Deferred();\\n\\njQuery.fn.ready = function( fn ) {\\n\\n\\treadyList\\n\\t\\t.then( fn )\\n\\n\\t\\t// Wrap jQuery.readyException in a function so that the lookup\\n\\t\\t// happens at the time of error handling instead of callback\\n\\t\\t// registration.\\n\\t\\t.catch( function( error ) {\\n\\t\\t\\tjQuery.readyException( error );\\n\\t\\t} );\\n\\n\\treturn this;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Is the DOM ready to be used? Set to true once it occurs.\\n\\tisReady: false,\\n\\n\\t// A counter to track how many items to wait for before\\n\\t// the ready event fires. See #6781\\n\\treadyWait: 1,\\n\\n\\t// Handle when the DOM is ready\\n\\tready: function( wait ) {\\n\\n\\t\\t// Abort if there are pending holds or we\'re already ready\\n\\t\\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Remember that the DOM is ready\\n\\t\\tjQuery.isReady = true;\\n\\n\\t\\t// If a normal DOM Ready event fired, decrement, and wait if need be\\n\\t\\tif ( wait !== true && --jQuery.readyWait > 0 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// If there are functions bound, to execute\\n\\t\\treadyList.resolveWith( document, [ jQuery ] );\\n\\t}\\n} );\\n\\njQuery.ready.then = readyList.then;\\n\\n// The ready event handler and self cleanup method\\nfunction completed() {\\n\\tdocument.removeEventListener( \\"DOMContentLoaded\\", completed );\\n\\twindow.removeEventListener( \\"load\\", completed );\\n\\tjQuery.ready();\\n}\\n\\n// Catch cases where $(document).ready() is called\\n// after the browser event has already occurred.\\n// Support: IE <=9 - 10 only\\n// Older IE sometimes signals \\"interactive\\" too soon\\nif ( document.readyState === \\"complete\\" ||\\n\\t( document.readyState !== \\"loading\\" && !document.documentElement.doScroll ) ) {\\n\\n\\t// Handle it asynchronously to allow scripts the opportunity to delay ready\\n\\twindow.setTimeout( jQuery.ready );\\n\\n} else {\\n\\n\\t// Use the handy event callback\\n\\tdocument.addEventListener( \\"DOMContentLoaded\\", completed );\\n\\n\\t// A fallback to window.onload, that will always work\\n\\twindow.addEventListener( \\"load\\", completed );\\n}\\n\\n\\n\\n\\n// Multifunctional method to get and set values of a collection\\n// The value/s can optionally be executed if it\'s a function\\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\\n\\tvar i = 0,\\n\\t\\tlen = elems.length,\\n\\t\\tbulk = key == null;\\n\\n\\t// Sets many values\\n\\tif ( toType( key ) === \\"object\\" ) {\\n\\t\\tchainable = true;\\n\\t\\tfor ( i in key ) {\\n\\t\\t\\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\\n\\t\\t}\\n\\n\\t// Sets one value\\n\\t} else if ( value !== undefined ) {\\n\\t\\tchainable = true;\\n\\n\\t\\tif ( !isFunction( value ) ) {\\n\\t\\t\\traw = true;\\n\\t\\t}\\n\\n\\t\\tif ( bulk ) {\\n\\n\\t\\t\\t// Bulk operations run against the entire set\\n\\t\\t\\tif ( raw ) {\\n\\t\\t\\t\\tfn.call( elems, value );\\n\\t\\t\\t\\tfn = null;\\n\\n\\t\\t\\t// ...except when executing function values\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbulk = fn;\\n\\t\\t\\t\\tfn = function( elem, _key, value ) {\\n\\t\\t\\t\\t\\treturn bulk.call( jQuery( elem ), value );\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\tfn(\\n\\t\\t\\t\\t\\telems[ i ], key, raw ?\\n\\t\\t\\t\\t\\tvalue :\\n\\t\\t\\t\\t\\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( chainable ) {\\n\\t\\treturn elems;\\n\\t}\\n\\n\\t// Gets\\n\\tif ( bulk ) {\\n\\t\\treturn fn.call( elems );\\n\\t}\\n\\n\\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\\n};\\n\\n\\n// Matches dashed string for camelizing\\nvar rmsPrefix = /^-ms-/,\\n\\trdashAlpha = /-([a-z])/g;\\n\\n// Used by camelCase as callback to replace()\\nfunction fcamelCase( _all, letter ) {\\n\\treturn letter.toUpperCase();\\n}\\n\\n// Convert dashed to camelCase; used by the css and data modules\\n// Support: IE <=9 - 11, Edge 12 - 15\\n// Microsoft forgot to hump their vendor prefix (#9572)\\nfunction camelCase( string ) {\\n\\treturn string.replace( rmsPrefix, \\"ms-\\" ).replace( rdashAlpha, fcamelCase );\\n}\\nvar acceptData = function( owner ) {\\n\\n\\t// Accepts only:\\n\\t//  - Node\\n\\t//    - Node.ELEMENT_NODE\\n\\t//    - Node.DOCUMENT_NODE\\n\\t//  - Object\\n\\t//    - Any\\n\\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\\n};\\n\\n\\n\\n\\nfunction Data() {\\n\\tthis.expando = jQuery.expando + Data.uid++;\\n}\\n\\nData.uid = 1;\\n\\nData.prototype = {\\n\\n\\tcache: function( owner ) {\\n\\n\\t\\t// Check if the owner object already has a cache\\n\\t\\tvar value = owner[ this.expando ];\\n\\n\\t\\t// If not, create one\\n\\t\\tif ( !value ) {\\n\\t\\t\\tvalue = {};\\n\\n\\t\\t\\t// We can accept data for non-element nodes in modern browsers,\\n\\t\\t\\t// but we should not, see #8335.\\n\\t\\t\\t// Always return an empty object.\\n\\t\\t\\tif ( acceptData( owner ) ) {\\n\\n\\t\\t\\t\\t// If it is a node unlikely to be stringify-ed or looped over\\n\\t\\t\\t\\t// use plain assignment\\n\\t\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\t\\towner[ this.expando ] = value;\\n\\n\\t\\t\\t\\t// Otherwise secure it in a non-enumerable property\\n\\t\\t\\t\\t// configurable must be true to allow the property to be\\n\\t\\t\\t\\t// deleted when data is removed\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty( owner, this.expando, {\\n\\t\\t\\t\\t\\t\\tvalue: value,\\n\\t\\t\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t},\\n\\tset: function( owner, data, value ) {\\n\\t\\tvar prop,\\n\\t\\t\\tcache = this.cache( owner );\\n\\n\\t\\t// Handle: [ owner, key, value ] args\\n\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\tif ( typeof data === \\"string\\" ) {\\n\\t\\t\\tcache[ camelCase( data ) ] = value;\\n\\n\\t\\t// Handle: [ owner, { properties } ] args\\n\\t\\t} else {\\n\\n\\t\\t\\t// Copy the properties one-by-one to the cache object\\n\\t\\t\\tfor ( prop in data ) {\\n\\t\\t\\t\\tcache[ camelCase( prop ) ] = data[ prop ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cache;\\n\\t},\\n\\tget: function( owner, key ) {\\n\\t\\treturn key === undefined ?\\n\\t\\t\\tthis.cache( owner ) :\\n\\n\\t\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\t\\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\\n\\t},\\n\\taccess: function( owner, key, value ) {\\n\\n\\t\\t// In cases where either:\\n\\t\\t//\\n\\t\\t//   1. No key was specified\\n\\t\\t//   2. A string key was specified, but no value provided\\n\\t\\t//\\n\\t\\t// Take the \\"read\\" path and allow the get method to determine\\n\\t\\t// which value to return, respectively either:\\n\\t\\t//\\n\\t\\t//   1. The entire cache object\\n\\t\\t//   2. The data stored at the key\\n\\t\\t//\\n\\t\\tif ( key === undefined ||\\n\\t\\t\\t\\t( ( key && typeof key === \\"string\\" ) && value === undefined ) ) {\\n\\n\\t\\t\\treturn this.get( owner, key );\\n\\t\\t}\\n\\n\\t\\t// When the key is not a string, or both a key and value\\n\\t\\t// are specified, set or extend (existing objects) with either:\\n\\t\\t//\\n\\t\\t//   1. An object of properties\\n\\t\\t//   2. A key and value\\n\\t\\t//\\n\\t\\tthis.set( owner, key, value );\\n\\n\\t\\t// Since the \\"set\\" path can have two possible entry points\\n\\t\\t// return the expected data based on which path was taken[*]\\n\\t\\treturn value !== undefined ? value : key;\\n\\t},\\n\\tremove: function( owner, key ) {\\n\\t\\tvar i,\\n\\t\\t\\tcache = owner[ this.expando ];\\n\\n\\t\\tif ( cache === undefined ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key !== undefined ) {\\n\\n\\t\\t\\t// Support array or space separated string of keys\\n\\t\\t\\tif ( Array.isArray( key ) ) {\\n\\n\\t\\t\\t\\t// If key is an array of keys...\\n\\t\\t\\t\\t// We always set camelCase keys, so remove that.\\n\\t\\t\\t\\tkey = key.map( camelCase );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tkey = camelCase( key );\\n\\n\\t\\t\\t\\t// If a key with the spaces exists, use it.\\n\\t\\t\\t\\t// Otherwise, create an array by matching non-whitespace\\n\\t\\t\\t\\tkey = key in cache ?\\n\\t\\t\\t\\t\\t[ key ] :\\n\\t\\t\\t\\t\\t( key.match( rnothtmlwhite ) || [] );\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = key.length;\\n\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tdelete cache[ key[ i ] ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove the expando if there\'s no more data\\n\\t\\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\\n\\n\\t\\t\\t// Support: Chrome <=35 - 45\\n\\t\\t\\t// Webkit & Blink performance suffers when deleting properties\\n\\t\\t\\t// from DOM nodes, so set to undefined instead\\n\\t\\t\\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\\n\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\towner[ this.expando ] = undefined;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete owner[ this.expando ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\thasData: function( owner ) {\\n\\t\\tvar cache = owner[ this.expando ];\\n\\t\\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\\n\\t}\\n};\\nvar dataPriv = new Data();\\n\\nvar dataUser = new Data();\\n\\n\\n\\n//\\tImplementation Summary\\n//\\n//\\t1. Enforce API surface and semantic compatibility with 1.9.x branch\\n//\\t2. Improve the module\'s maintainability by reducing the storage\\n//\\t\\tpaths to a single mechanism.\\n//\\t3. Use the same single mechanism to support \\"private\\" and \\"user\\" data.\\n//\\t4. _Never_ expose \\"private\\" data to user code (TODO: Drop _data, _removeData)\\n//\\t5. Avoid exposing implementation details on user objects (eg. expando properties)\\n//\\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\\n\\nvar rbrace = /^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,\\n\\trmultiDash = /[A-Z]/g;\\n\\nfunction getData( data ) {\\n\\tif ( data === \\"true\\" ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif ( data === \\"false\\" ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif ( data === \\"null\\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Only convert to a number if it doesn\'t change the string\\n\\tif ( data === +data + \\"\\" ) {\\n\\t\\treturn +data;\\n\\t}\\n\\n\\tif ( rbrace.test( data ) ) {\\n\\t\\treturn JSON.parse( data );\\n\\t}\\n\\n\\treturn data;\\n}\\n\\nfunction dataAttr( elem, key, data ) {\\n\\tvar name;\\n\\n\\t// If nothing was found internally, try to fetch any\\n\\t// data from the HTML5 data-* attribute\\n\\tif ( data === undefined && elem.nodeType === 1 ) {\\n\\t\\tname = \\"data-\\" + key.replace( rmultiDash, \\"-$&\\" ).toLowerCase();\\n\\t\\tdata = elem.getAttribute( name );\\n\\n\\t\\tif ( typeof data === \\"string\\" ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = getData( data );\\n\\t\\t\\t} catch ( e ) {}\\n\\n\\t\\t\\t// Make sure we set the data so it isn\'t changed later\\n\\t\\t\\tdataUser.set( elem, key, data );\\n\\t\\t} else {\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\t}\\n\\treturn data;\\n}\\n\\njQuery.extend( {\\n\\thasData: function( elem ) {\\n\\t\\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\\n\\t},\\n\\n\\tdata: function( elem, name, data ) {\\n\\t\\treturn dataUser.access( elem, name, data );\\n\\t},\\n\\n\\tremoveData: function( elem, name ) {\\n\\t\\tdataUser.remove( elem, name );\\n\\t},\\n\\n\\t// TODO: Now that all calls to _data and _removeData have been replaced\\n\\t// with direct calls to dataPriv methods, these can be deprecated.\\n\\t_data: function( elem, name, data ) {\\n\\t\\treturn dataPriv.access( elem, name, data );\\n\\t},\\n\\n\\t_removeData: function( elem, name ) {\\n\\t\\tdataPriv.remove( elem, name );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdata: function( key, value ) {\\n\\t\\tvar i, name, data,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tattrs = elem && elem.attributes;\\n\\n\\t\\t// Gets all values\\n\\t\\tif ( key === undefined ) {\\n\\t\\t\\tif ( this.length ) {\\n\\t\\t\\t\\tdata = dataUser.get( elem );\\n\\n\\t\\t\\t\\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \\"hasDataAttrs\\" ) ) {\\n\\t\\t\\t\\t\\ti = attrs.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t\\t\\t\\t// The attrs elements can be null (#14894)\\n\\t\\t\\t\\t\\t\\tif ( attrs[ i ] ) {\\n\\t\\t\\t\\t\\t\\t\\tname = attrs[ i ].name;\\n\\t\\t\\t\\t\\t\\t\\tif ( name.indexOf( \\"data-\\" ) === 0 ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tname = camelCase( name.slice( 5 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tdataAttr( elem, name, data[ name ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdataPriv.set( elem, \\"hasDataAttrs\\", true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\t\\t}\\n\\n\\t\\t// Sets multiple values\\n\\t\\tif ( typeof key === \\"object\\" ) {\\n\\t\\t\\treturn this.each( function() {\\n\\t\\t\\t\\tdataUser.set( this, key );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar data;\\n\\n\\t\\t\\t// The calling jQuery object (element matches) is not empty\\n\\t\\t\\t// (and therefore has an element appears at this[ 0 ]) and the\\n\\t\\t\\t// `value` parameter was not undefined. An empty jQuery object\\n\\t\\t\\t// will result in `undefined` for elem = this[ 0 ] which will\\n\\t\\t\\t// throw an exception if an attempt to read a data cache is made.\\n\\t\\t\\tif ( elem && value === undefined ) {\\n\\n\\t\\t\\t\\t// Attempt to get data from the cache\\n\\t\\t\\t\\t// The key will always be camelCased in Data\\n\\t\\t\\t\\tdata = dataUser.get( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Attempt to \\"discover\\" the data in\\n\\t\\t\\t\\t// HTML5 custom data-* attrs\\n\\t\\t\\t\\tdata = dataAttr( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// We tried really hard, but the data doesn\'t exist.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the data...\\n\\t\\t\\tthis.each( function() {\\n\\n\\t\\t\\t\\t// We always store the camelCased key\\n\\t\\t\\t\\tdataUser.set( this, key, value );\\n\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length > 1, null, true );\\n\\t},\\n\\n\\tremoveData: function( key ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdataUser.remove( this, key );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\njQuery.extend( {\\n\\tqueue: function( elem, type, data ) {\\n\\t\\tvar queue;\\n\\n\\t\\tif ( elem ) {\\n\\t\\t\\ttype = ( type || \\"fx\\" ) + \\"queue\\";\\n\\t\\t\\tqueue = dataPriv.get( elem, type );\\n\\n\\t\\t\\t// Speed up dequeue by getting out quickly if this is just a lookup\\n\\t\\t\\tif ( data ) {\\n\\t\\t\\t\\tif ( !queue || Array.isArray( data ) ) {\\n\\t\\t\\t\\t\\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tqueue.push( data );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn queue || [];\\n\\t\\t}\\n\\t},\\n\\n\\tdequeue: function( elem, type ) {\\n\\t\\ttype = type || \\"fx\\";\\n\\n\\t\\tvar queue = jQuery.queue( elem, type ),\\n\\t\\t\\tstartLength = queue.length,\\n\\t\\t\\tfn = queue.shift(),\\n\\t\\t\\thooks = jQuery._queueHooks( elem, type ),\\n\\t\\t\\tnext = function() {\\n\\t\\t\\t\\tjQuery.dequeue( elem, type );\\n\\t\\t\\t};\\n\\n\\t\\t// If the fx queue is dequeued, always remove the progress sentinel\\n\\t\\tif ( fn === \\"inprogress\\" ) {\\n\\t\\t\\tfn = queue.shift();\\n\\t\\t\\tstartLength--;\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\n\\t\\t\\t// Add a progress sentinel to prevent the fx queue from being\\n\\t\\t\\t// automatically dequeued\\n\\t\\t\\tif ( type === \\"fx\\" ) {\\n\\t\\t\\t\\tqueue.unshift( \\"inprogress\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Clear up the last queue stop function\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tfn.call( elem, next, hooks );\\n\\t\\t}\\n\\n\\t\\tif ( !startLength && hooks ) {\\n\\t\\t\\thooks.empty.fire();\\n\\t\\t}\\n\\t},\\n\\n\\t// Not public - generate a queueHooks object, or return the current one\\n\\t_queueHooks: function( elem, type ) {\\n\\t\\tvar key = type + \\"queueHooks\\";\\n\\t\\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\\n\\t\\t\\tempty: jQuery.Callbacks( \\"once memory\\" ).add( function() {\\n\\t\\t\\t\\tdataPriv.remove( elem, [ type + \\"queue\\", key ] );\\n\\t\\t\\t} )\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tqueue: function( type, data ) {\\n\\t\\tvar setter = 2;\\n\\n\\t\\tif ( typeof type !== \\"string\\" ) {\\n\\t\\t\\tdata = type;\\n\\t\\t\\ttype = \\"fx\\";\\n\\t\\t\\tsetter--;\\n\\t\\t}\\n\\n\\t\\tif ( arguments.length < setter ) {\\n\\t\\t\\treturn jQuery.queue( this[ 0 ], type );\\n\\t\\t}\\n\\n\\t\\treturn data === undefined ?\\n\\t\\t\\tthis :\\n\\t\\t\\tthis.each( function() {\\n\\t\\t\\t\\tvar queue = jQuery.queue( this, type, data );\\n\\n\\t\\t\\t\\t// Ensure a hooks for this queue\\n\\t\\t\\t\\tjQuery._queueHooks( this, type );\\n\\n\\t\\t\\t\\tif ( type === \\"fx\\" && queue[ 0 ] !== \\"inprogress\\" ) {\\n\\t\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t},\\n\\tdequeue: function( type ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t} );\\n\\t},\\n\\tclearQueue: function( type ) {\\n\\t\\treturn this.queue( type || \\"fx\\", [] );\\n\\t},\\n\\n\\t// Get a promise resolved when queues of a certain type\\n\\t// are emptied (fx is the type by default)\\n\\tpromise: function( type, obj ) {\\n\\t\\tvar tmp,\\n\\t\\t\\tcount = 1,\\n\\t\\t\\tdefer = jQuery.Deferred(),\\n\\t\\t\\telements = this,\\n\\t\\t\\ti = this.length,\\n\\t\\t\\tresolve = function() {\\n\\t\\t\\t\\tif ( !( --count ) ) {\\n\\t\\t\\t\\t\\tdefer.resolveWith( elements, [ elements ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\tif ( typeof type !== \\"string\\" ) {\\n\\t\\t\\tobj = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\ttype = type || \\"fx\\";\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttmp = dataPriv.get( elements[ i ], type + \\"queueHooks\\" );\\n\\t\\t\\tif ( tmp && tmp.empty ) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\ttmp.empty.add( resolve );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresolve();\\n\\t\\treturn defer.promise( obj );\\n\\t}\\n} );\\nvar pnum = ( /[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/ ).source;\\n\\nvar rcssNum = new RegExp( \\"^(?:([+-])=|)(\\" + pnum + \\")([a-z%]*)$\\", \\"i\\" );\\n\\n\\nvar cssExpand = [ \\"Top\\", \\"Right\\", \\"Bottom\\", \\"Left\\" ];\\n\\nvar documentElement = document.documentElement;\\n\\n\\n\\n\\tvar isAttached = function( elem ) {\\n\\t\\t\\treturn jQuery.contains( elem.ownerDocument, elem );\\n\\t\\t},\\n\\t\\tcomposed = { composed: true };\\n\\n\\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\\n\\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\\n\\t// Support: iOS 10.0-10.2 only\\n\\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\\n\\t// leading to errors. We need to check for `getRootNode`.\\n\\tif ( documentElement.getRootNode ) {\\n\\t\\tisAttached = function( elem ) {\\n\\t\\t\\treturn jQuery.contains( elem.ownerDocument, elem ) ||\\n\\t\\t\\t\\telem.getRootNode( composed ) === elem.ownerDocument;\\n\\t\\t};\\n\\t}\\nvar isHiddenWithinTree = function( elem, el ) {\\n\\n\\t\\t// isHiddenWithinTree might be called from jQuery#filter function;\\n\\t\\t// in that case, element will be second argument\\n\\t\\telem = el || elem;\\n\\n\\t\\t// Inline style trumps all\\n\\t\\treturn elem.style.display === \\"none\\" ||\\n\\t\\t\\telem.style.display === \\"\\" &&\\n\\n\\t\\t\\t// Otherwise, check computed style\\n\\t\\t\\t// Support: Firefox <=43 - 45\\n\\t\\t\\t// Disconnected elements can have computed display: none, so first confirm that elem is\\n\\t\\t\\t// in the document.\\n\\t\\t\\tisAttached( elem ) &&\\n\\n\\t\\t\\tjQuery.css( elem, \\"display\\" ) === \\"none\\";\\n\\t};\\n\\n\\n\\nfunction adjustCSS( elem, prop, valueParts, tween ) {\\n\\tvar adjusted, scale,\\n\\t\\tmaxIterations = 20,\\n\\t\\tcurrentValue = tween ?\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn tween.cur();\\n\\t\\t\\t} :\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn jQuery.css( elem, prop, \\"\\" );\\n\\t\\t\\t},\\n\\t\\tinitial = currentValue(),\\n\\t\\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \\"\\" : \\"px\\" ),\\n\\n\\t\\t// Starting value computation is required for potential unit mismatches\\n\\t\\tinitialInUnit = elem.nodeType &&\\n\\t\\t\\t( jQuery.cssNumber[ prop ] || unit !== \\"px\\" && +initial ) &&\\n\\t\\t\\trcssNum.exec( jQuery.css( elem, prop ) );\\n\\n\\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\\n\\n\\t\\t// Support: Firefox <=54\\n\\t\\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\\n\\t\\tinitial = initial / 2;\\n\\n\\t\\t// Trust units reported by jQuery.css\\n\\t\\tunit = unit || initialInUnit[ 3 ];\\n\\n\\t\\t// Iteratively approximate from a nonzero starting point\\n\\t\\tinitialInUnit = +initial || 1;\\n\\n\\t\\twhile ( maxIterations-- ) {\\n\\n\\t\\t\\t// Evaluate and update our best guess (doubling guesses that zero out).\\n\\t\\t\\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\\n\\t\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\t\\t\\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\\n\\t\\t\\t\\tmaxIterations = 0;\\n\\t\\t\\t}\\n\\t\\t\\tinitialInUnit = initialInUnit / scale;\\n\\n\\t\\t}\\n\\n\\t\\tinitialInUnit = initialInUnit * 2;\\n\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\n\\t\\t// Make sure we update the tween properties later on\\n\\t\\tvalueParts = valueParts || [];\\n\\t}\\n\\n\\tif ( valueParts ) {\\n\\t\\tinitialInUnit = +initialInUnit || +initial || 0;\\n\\n\\t\\t// Apply relative offset (+=/-=) if specified\\n\\t\\tadjusted = valueParts[ 1 ] ?\\n\\t\\t\\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\\n\\t\\t\\t+valueParts[ 2 ];\\n\\t\\tif ( tween ) {\\n\\t\\t\\ttween.unit = unit;\\n\\t\\t\\ttween.start = initialInUnit;\\n\\t\\t\\ttween.end = adjusted;\\n\\t\\t}\\n\\t}\\n\\treturn adjusted;\\n}\\n\\n\\nvar defaultDisplayMap = {};\\n\\nfunction getDefaultDisplay( elem ) {\\n\\tvar temp,\\n\\t\\tdoc = elem.ownerDocument,\\n\\t\\tnodeName = elem.nodeName,\\n\\t\\tdisplay = defaultDisplayMap[ nodeName ];\\n\\n\\tif ( display ) {\\n\\t\\treturn display;\\n\\t}\\n\\n\\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\\n\\tdisplay = jQuery.css( temp, \\"display\\" );\\n\\n\\ttemp.parentNode.removeChild( temp );\\n\\n\\tif ( display === \\"none\\" ) {\\n\\t\\tdisplay = \\"block\\";\\n\\t}\\n\\tdefaultDisplayMap[ nodeName ] = display;\\n\\n\\treturn display;\\n}\\n\\nfunction showHide( elements, show ) {\\n\\tvar display, elem,\\n\\t\\tvalues = [],\\n\\t\\tindex = 0,\\n\\t\\tlength = elements.length;\\n\\n\\t// Determine new display value for elements that need to change\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\telem = elements[ index ];\\n\\t\\tif ( !elem.style ) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tdisplay = elem.style.display;\\n\\t\\tif ( show ) {\\n\\n\\t\\t\\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\\n\\t\\t\\t// check is required in this first loop unless we have a nonempty display value (either\\n\\t\\t\\t// inline or about-to-be-restored)\\n\\t\\t\\tif ( display === \\"none\\" ) {\\n\\t\\t\\t\\tvalues[ index ] = dataPriv.get( elem, \\"display\\" ) || null;\\n\\t\\t\\t\\tif ( !values[ index ] ) {\\n\\t\\t\\t\\t\\telem.style.display = \\"\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( elem.style.display === \\"\\" && isHiddenWithinTree( elem ) ) {\\n\\t\\t\\t\\tvalues[ index ] = getDefaultDisplay( elem );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif ( display !== \\"none\\" ) {\\n\\t\\t\\t\\tvalues[ index ] = \\"none\\";\\n\\n\\t\\t\\t\\t// Remember what we\'re overwriting\\n\\t\\t\\t\\tdataPriv.set( elem, \\"display\\", display );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Set the display of the elements in a second loop to avoid constant reflow\\n\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\tif ( values[ index ] != null ) {\\n\\t\\t\\telements[ index ].style.display = values[ index ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn elements;\\n}\\n\\njQuery.fn.extend( {\\n\\tshow: function() {\\n\\t\\treturn showHide( this, true );\\n\\t},\\n\\thide: function() {\\n\\t\\treturn showHide( this );\\n\\t},\\n\\ttoggle: function( state ) {\\n\\t\\tif ( typeof state === \\"boolean\\" ) {\\n\\t\\t\\treturn state ? this.show() : this.hide();\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tif ( isHiddenWithinTree( this ) ) {\\n\\t\\t\\t\\tjQuery( this ).show();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tjQuery( this ).hide();\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\\n\\nvar rtagName = ( /<([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]*)/i );\\n\\nvar rscriptType = ( /^$|^module$|\\\\/(?:java|ecma)script/i );\\n\\n\\n\\n( function() {\\n\\tvar fragment = document.createDocumentFragment(),\\n\\t\\tdiv = fragment.appendChild( document.createElement( \\"div\\" ) ),\\n\\t\\tinput = document.createElement( \\"input\\" );\\n\\n\\t// Support: Android 4.0 - 4.3 only\\n\\t// Check state lost if the name is set (#11217)\\n\\t// Support: Windows Web Apps (WWA)\\n\\t// `name` and `type` must use .setAttribute for WWA (#14901)\\n\\tinput.setAttribute( \\"type\\", \\"radio\\" );\\n\\tinput.setAttribute( \\"checked\\", \\"checked\\" );\\n\\tinput.setAttribute( \\"name\\", \\"t\\" );\\n\\n\\tdiv.appendChild( input );\\n\\n\\t// Support: Android <=4.1 only\\n\\t// Older WebKit doesn\'t clone checked state correctly in fragments\\n\\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\\n\\n\\t// Support: IE <=11 only\\n\\t// Make sure textarea (and checkbox) defaultValue is properly cloned\\n\\tdiv.innerHTML = \\"<textarea>x</textarea>\\";\\n\\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\\n\\n\\t// Support: IE <=9 only\\n\\t// IE <=9 replaces <option> tags with their contents when inserted outside of\\n\\t// the select element.\\n\\tdiv.innerHTML = \\"<option></option>\\";\\n\\tsupport.option = !!div.lastChild;\\n} )();\\n\\n\\n// We have to close these tags to support XHTML (#13200)\\nvar wrapMap = {\\n\\n\\t// XHTML parsers do not magically insert elements in the\\n\\t// same way that tag soup parsers do. So we cannot shorten\\n\\t// this by omitting <tbody> or other required elements.\\n\\tthead: [ 1, \\"<table>\\", \\"</table>\\" ],\\n\\tcol: [ 2, \\"<table><colgroup>\\", \\"</colgroup></table>\\" ],\\n\\ttr: [ 2, \\"<table><tbody>\\", \\"</tbody></table>\\" ],\\n\\ttd: [ 3, \\"<table><tbody><tr>\\", \\"</tr></tbody></table>\\" ],\\n\\n\\t_default: [ 0, \\"\\", \\"\\" ]\\n};\\n\\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\\nwrapMap.th = wrapMap.td;\\n\\n// Support: IE <=9 only\\nif ( !support.option ) {\\n\\twrapMap.optgroup = wrapMap.option = [ 1, \\"<select multiple=\'multiple\'>\\", \\"</select>\\" ];\\n}\\n\\n\\nfunction getAll( context, tag ) {\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\\n\\tvar ret;\\n\\n\\tif ( typeof context.getElementsByTagName !== \\"undefined\\" ) {\\n\\t\\tret = context.getElementsByTagName( tag || \\"*\\" );\\n\\n\\t} else if ( typeof context.querySelectorAll !== \\"undefined\\" ) {\\n\\t\\tret = context.querySelectorAll( tag || \\"*\\" );\\n\\n\\t} else {\\n\\t\\tret = [];\\n\\t}\\n\\n\\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\\n\\t\\treturn jQuery.merge( [ context ], ret );\\n\\t}\\n\\n\\treturn ret;\\n}\\n\\n\\n// Mark scripts as having already been evaluated\\nfunction setGlobalEval( elems, refElements ) {\\n\\tvar i = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\tdataPriv.set(\\n\\t\\t\\telems[ i ],\\n\\t\\t\\t\\"globalEval\\",\\n\\t\\t\\t!refElements || dataPriv.get( refElements[ i ], \\"globalEval\\" )\\n\\t\\t);\\n\\t}\\n}\\n\\n\\nvar rhtml = /<|&#?\\\\w+;/;\\n\\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\\n\\tvar elem, tmp, tag, wrap, attached, j,\\n\\t\\tfragment = context.createDocumentFragment(),\\n\\t\\tnodes = [],\\n\\t\\ti = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\telem = elems[ i ];\\n\\n\\t\\tif ( elem || elem === 0 ) {\\n\\n\\t\\t\\t// Add nodes directly\\n\\t\\t\\tif ( toType( elem ) === \\"object\\" ) {\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\\n\\n\\t\\t\\t// Convert non-html into a text node\\n\\t\\t\\t} else if ( !rhtml.test( elem ) ) {\\n\\t\\t\\t\\tnodes.push( context.createTextNode( elem ) );\\n\\n\\t\\t\\t// Convert html into DOM nodes\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttmp = tmp || fragment.appendChild( context.createElement( \\"div\\" ) );\\n\\n\\t\\t\\t\\t// Deserialize a standard representation\\n\\t\\t\\t\\ttag = ( rtagName.exec( elem ) || [ \\"\\", \\"\\" ] )[ 1 ].toLowerCase();\\n\\t\\t\\t\\twrap = wrapMap[ tag ] || wrapMap._default;\\n\\t\\t\\t\\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\\n\\n\\t\\t\\t\\t// Descend through wrappers to the right content\\n\\t\\t\\t\\tj = wrap[ 0 ];\\n\\t\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\t\\ttmp = tmp.lastChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, tmp.childNodes );\\n\\n\\t\\t\\t\\t// Remember the top-level container\\n\\t\\t\\t\\ttmp = fragment.firstChild;\\n\\n\\t\\t\\t\\t// Ensure the created nodes are orphaned (#12392)\\n\\t\\t\\t\\ttmp.textContent = \\"\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Remove wrapper from fragment\\n\\tfragment.textContent = \\"\\";\\n\\n\\ti = 0;\\n\\twhile ( ( elem = nodes[ i++ ] ) ) {\\n\\n\\t\\t// Skip elements already in the context collection (trac-4087)\\n\\t\\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\\n\\t\\t\\tif ( ignored ) {\\n\\t\\t\\t\\tignored.push( elem );\\n\\t\\t\\t}\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tattached = isAttached( elem );\\n\\n\\t\\t// Append to fragment\\n\\t\\ttmp = getAll( fragment.appendChild( elem ), \\"script\\" );\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tif ( attached ) {\\n\\t\\t\\tsetGlobalEval( tmp );\\n\\t\\t}\\n\\n\\t\\t// Capture executables\\n\\t\\tif ( scripts ) {\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( elem = tmp[ j++ ] ) ) {\\n\\t\\t\\t\\tif ( rscriptType.test( elem.type || \\"\\" ) ) {\\n\\t\\t\\t\\t\\tscripts.push( elem );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn fragment;\\n}\\n\\n\\nvar\\n\\trkeyEvent = /^key/,\\n\\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\\n\\trtypenamespace = /^([^.]*)(?:\\\\.(.+)|)/;\\n\\nfunction returnTrue() {\\n\\treturn true;\\n}\\n\\nfunction returnFalse() {\\n\\treturn false;\\n}\\n\\n// Support: IE <=9 - 11+\\n// focus() and blur() are asynchronous, except when they are no-op.\\n// So expect focus to be synchronous when the element is already active,\\n// and blur to be synchronous when the element is not already active.\\n// (focus and blur are always synchronous in other supported browsers,\\n// this just defines when we can count on it).\\nfunction expectSync( elem, type ) {\\n\\treturn ( elem === safeActiveElement() ) === ( type === \\"focus\\" );\\n}\\n\\n// Support: IE <=9 only\\n// Accessing document.activeElement can throw unexpectedly\\n// https://bugs.jquery.com/ticket/13393\\nfunction safeActiveElement() {\\n\\ttry {\\n\\t\\treturn document.activeElement;\\n\\t} catch ( err ) { }\\n}\\n\\nfunction on( elem, types, selector, data, fn, one ) {\\n\\tvar origFn, type;\\n\\n\\t// Types can be a map of types/handlers\\n\\tif ( typeof types === \\"object\\" ) {\\n\\n\\t\\t// ( types-Object, selector, data )\\n\\t\\tif ( typeof selector !== \\"string\\" ) {\\n\\n\\t\\t\\t// ( types-Object, data )\\n\\t\\t\\tdata = data || selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tfor ( type in types ) {\\n\\t\\t\\ton( elem, type, selector, data, types[ type ], one );\\n\\t\\t}\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( data == null && fn == null ) {\\n\\n\\t\\t// ( types, fn )\\n\\t\\tfn = selector;\\n\\t\\tdata = selector = undefined;\\n\\t} else if ( fn == null ) {\\n\\t\\tif ( typeof selector === \\"string\\" ) {\\n\\n\\t\\t\\t// ( types, selector, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t} else {\\n\\n\\t\\t\\t// ( types, data, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t}\\n\\tif ( fn === false ) {\\n\\t\\tfn = returnFalse;\\n\\t} else if ( !fn ) {\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( one === 1 ) {\\n\\t\\torigFn = fn;\\n\\t\\tfn = function( event ) {\\n\\n\\t\\t\\t// Can use an empty set, since event contains the info\\n\\t\\t\\tjQuery().off( event );\\n\\t\\t\\treturn origFn.apply( this, arguments );\\n\\t\\t};\\n\\n\\t\\t// Use same guid so caller can remove using origFn\\n\\t\\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\\n\\t}\\n\\treturn elem.each( function() {\\n\\t\\tjQuery.event.add( this, types, fn, data, selector );\\n\\t} );\\n}\\n\\n/*\\n * Helper functions for managing events -- not part of the public interface.\\n * Props to Dean Edwards\' addEvent library for many of the ideas.\\n */\\njQuery.event = {\\n\\n\\tglobal: {},\\n\\n\\tadd: function( elem, types, handler, data, selector ) {\\n\\n\\t\\tvar handleObjIn, eventHandle, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.get( elem );\\n\\n\\t\\t// Only attach events to objects that accept data\\n\\t\\tif ( !acceptData( elem ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Caller can pass in an object of custom data in lieu of the handler\\n\\t\\tif ( handler.handler ) {\\n\\t\\t\\thandleObjIn = handler;\\n\\t\\t\\thandler = handleObjIn.handler;\\n\\t\\t\\tselector = handleObjIn.selector;\\n\\t\\t}\\n\\n\\t\\t// Ensure that invalid selectors throw exceptions at attach time\\n\\t\\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\\n\\t\\tif ( selector ) {\\n\\t\\t\\tjQuery.find.matchesSelector( documentElement, selector );\\n\\t\\t}\\n\\n\\t\\t// Make sure that the handler has a unique ID, used to find/remove it later\\n\\t\\tif ( !handler.guid ) {\\n\\t\\t\\thandler.guid = jQuery.guid++;\\n\\t\\t}\\n\\n\\t\\t// Init the element\'s event structure and main handler, if this is the first\\n\\t\\tif ( !( events = elemData.events ) ) {\\n\\t\\t\\tevents = elemData.events = Object.create( null );\\n\\t\\t}\\n\\t\\tif ( !( eventHandle = elemData.handle ) ) {\\n\\t\\t\\teventHandle = elemData.handle = function( e ) {\\n\\n\\t\\t\\t\\t// Discard the second event of a jQuery.event.trigger() and\\n\\t\\t\\t\\t// when an event is called after a page has unloaded\\n\\t\\t\\t\\treturn typeof jQuery !== \\"undefined\\" && jQuery.event.triggered !== e.type ?\\n\\t\\t\\t\\t\\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Handle multiple events separated by a space\\n\\t\\ttypes = ( types || \\"\\" ).match( rnothtmlwhite ) || [ \\"\\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \\"\\" ).split( \\".\\" ).sort();\\n\\n\\t\\t\\t// There *must* be a type, no attaching namespace-only handlers\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If event changes its type, use the special event handlers for the changed type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// If selector defined, determine special event api type, otherwise given type\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\n\\t\\t\\t// Update special based on newly reset type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// handleObj is passed to all event handlers\\n\\t\\t\\thandleObj = jQuery.extend( {\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\torigType: origType,\\n\\t\\t\\t\\tdata: data,\\n\\t\\t\\t\\thandler: handler,\\n\\t\\t\\t\\tguid: handler.guid,\\n\\t\\t\\t\\tselector: selector,\\n\\t\\t\\t\\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\\n\\t\\t\\t\\tnamespace: namespaces.join( \\".\\" )\\n\\t\\t\\t}, handleObjIn );\\n\\n\\t\\t\\t// Init the event handler queue if we\'re the first\\n\\t\\t\\tif ( !( handlers = events[ type ] ) ) {\\n\\t\\t\\t\\thandlers = events[ type ] = [];\\n\\t\\t\\t\\thandlers.delegateCount = 0;\\n\\n\\t\\t\\t\\t// Only use addEventListener if the special events handler returns false\\n\\t\\t\\t\\tif ( !special.setup ||\\n\\t\\t\\t\\t\\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\\n\\n\\t\\t\\t\\t\\tif ( elem.addEventListener ) {\\n\\t\\t\\t\\t\\t\\telem.addEventListener( type, eventHandle );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( special.add ) {\\n\\t\\t\\t\\tspecial.add.call( elem, handleObj );\\n\\n\\t\\t\\t\\tif ( !handleObj.handler.guid ) {\\n\\t\\t\\t\\t\\thandleObj.handler.guid = handler.guid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add to the element\'s handler list, delegates in front\\n\\t\\t\\tif ( selector ) {\\n\\t\\t\\t\\thandlers.splice( handlers.delegateCount++, 0, handleObj );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thandlers.push( handleObj );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Keep track of which events have ever been used, for event optimization\\n\\t\\t\\tjQuery.event.global[ type ] = true;\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// Detach an event or set of events from an element\\n\\tremove: function( elem, types, handler, selector, mappedTypes ) {\\n\\n\\t\\tvar j, origCount, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\\n\\n\\t\\tif ( !elemData || !( events = elemData.events ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Once for each type.namespace in types; type may be omitted\\n\\t\\ttypes = ( types || \\"\\" ).match( rnothtmlwhite ) || [ \\"\\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \\"\\" ).split( \\".\\" ).sort();\\n\\n\\t\\t\\t// Unbind all events (on this namespace, if provided) for the element\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\t\\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\t\\t\\thandlers = events[ type ] || [];\\n\\t\\t\\ttmp = tmp[ 2 ] &&\\n\\t\\t\\t\\tnew RegExp( \\"(^|\\\\\\\\.)\\" + namespaces.join( \\"\\\\\\\\.(?:.*\\\\\\\\.|)\\" ) + \\"(\\\\\\\\.|$)\\" );\\n\\n\\t\\t\\t// Remove matching events\\n\\t\\t\\torigCount = j = handlers.length;\\n\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\thandleObj = handlers[ j ];\\n\\n\\t\\t\\t\\tif ( ( mappedTypes || origType === handleObj.origType ) &&\\n\\t\\t\\t\\t\\t( !handler || handler.guid === handleObj.guid ) &&\\n\\t\\t\\t\\t\\t( !tmp || tmp.test( handleObj.namespace ) ) &&\\n\\t\\t\\t\\t\\t( !selector || selector === handleObj.selector ||\\n\\t\\t\\t\\t\\t\\tselector === \\"**\\" && handleObj.selector ) ) {\\n\\t\\t\\t\\t\\thandlers.splice( j, 1 );\\n\\n\\t\\t\\t\\t\\tif ( handleObj.selector ) {\\n\\t\\t\\t\\t\\t\\thandlers.delegateCount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( special.remove ) {\\n\\t\\t\\t\\t\\t\\tspecial.remove.call( elem, handleObj );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove generic event handler if we removed something and no more handlers exist\\n\\t\\t\\t// (avoids potential for endless recursion during removal of special event handlers)\\n\\t\\t\\tif ( origCount && !handlers.length ) {\\n\\t\\t\\t\\tif ( !special.teardown ||\\n\\t\\t\\t\\t\\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\\n\\n\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, elemData.handle );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete events[ type ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove data and the expando if it\'s no longer used\\n\\t\\tif ( jQuery.isEmptyObject( events ) ) {\\n\\t\\t\\tdataPriv.remove( elem, \\"handle events\\" );\\n\\t\\t}\\n\\t},\\n\\n\\tdispatch: function( nativeEvent ) {\\n\\n\\t\\tvar i, j, ret, matched, handleObj, handlerQueue,\\n\\t\\t\\targs = new Array( arguments.length ),\\n\\n\\t\\t\\t// Make a writable jQuery.Event from the native event object\\n\\t\\t\\tevent = jQuery.event.fix( nativeEvent ),\\n\\n\\t\\t\\thandlers = (\\n\\t\\t\\t\\t\\tdataPriv.get( this, \\"events\\" ) || Object.create( null )\\n\\t\\t\\t\\t)[ event.type ] || [],\\n\\t\\t\\tspecial = jQuery.event.special[ event.type ] || {};\\n\\n\\t\\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\\n\\t\\targs[ 0 ] = event;\\n\\n\\t\\tfor ( i = 1; i < arguments.length; i++ ) {\\n\\t\\t\\targs[ i ] = arguments[ i ];\\n\\t\\t}\\n\\n\\t\\tevent.delegateTarget = this;\\n\\n\\t\\t// Call the preDispatch hook for the mapped type, and let it bail if desired\\n\\t\\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine handlers\\n\\t\\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\\n\\n\\t\\t// Run delegates first; they may want to stop propagation beneath us\\n\\t\\ti = 0;\\n\\t\\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tevent.currentTarget = matched.elem;\\n\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\\n\\t\\t\\t\\t!event.isImmediatePropagationStopped() ) {\\n\\n\\t\\t\\t\\t// If the event is namespaced, then each handler is only invoked if it is\\n\\t\\t\\t\\t// specially universal or its namespaces are a superset of the event\'s.\\n\\t\\t\\t\\tif ( !event.rnamespace || handleObj.namespace === false ||\\n\\t\\t\\t\\t\\tevent.rnamespace.test( handleObj.namespace ) ) {\\n\\n\\t\\t\\t\\t\\tevent.handleObj = handleObj;\\n\\t\\t\\t\\t\\tevent.data = handleObj.data;\\n\\n\\t\\t\\t\\t\\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\\n\\t\\t\\t\\t\\t\\thandleObj.handler ).apply( matched.elem, args );\\n\\n\\t\\t\\t\\t\\tif ( ret !== undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ( event.result = ret ) === false ) {\\n\\t\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\t\\tevent.stopPropagation();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Call the postDispatch hook for the mapped type\\n\\t\\tif ( special.postDispatch ) {\\n\\t\\t\\tspecial.postDispatch.call( this, event );\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\thandlers: function( event, handlers ) {\\n\\t\\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\\n\\t\\t\\thandlerQueue = [],\\n\\t\\t\\tdelegateCount = handlers.delegateCount,\\n\\t\\t\\tcur = event.target;\\n\\n\\t\\t// Find delegate handlers\\n\\t\\tif ( delegateCount &&\\n\\n\\t\\t\\t// Support: IE <=9\\n\\t\\t\\t// Black-hole SVG <use> instance trees (trac-13180)\\n\\t\\t\\tcur.nodeType &&\\n\\n\\t\\t\\t// Support: Firefox <=42\\n\\t\\t\\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\\n\\t\\t\\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\\n\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t// ...but not arrow key \\"clicks\\" of radio inputs, which can have `button` -1 (gh-2343)\\n\\t\\t\\t!( event.type === \\"click\\" && event.button >= 1 ) ) {\\n\\n\\t\\t\\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\\n\\n\\t\\t\\t\\t// Don\'t check non-elements (#13208)\\n\\t\\t\\t\\t// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\\n\\t\\t\\t\\tif ( cur.nodeType === 1 && !( event.type === \\"click\\" && cur.disabled === true ) ) {\\n\\t\\t\\t\\t\\tmatchedHandlers = [];\\n\\t\\t\\t\\t\\tmatchedSelectors = {};\\n\\t\\t\\t\\t\\tfor ( i = 0; i < delegateCount; i++ ) {\\n\\t\\t\\t\\t\\t\\thandleObj = handlers[ i ];\\n\\n\\t\\t\\t\\t\\t\\t// Don\'t conflict with Object.prototype properties (#13203)\\n\\t\\t\\t\\t\\t\\tsel = handleObj.selector + \\" \\";\\n\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] === undefined ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedSelectors[ sel ] = handleObj.needsContext ?\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery( sel, this ).index( cur ) > -1 :\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.find( sel, this, null, [ cur ] ).length;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedHandlers.push( handleObj );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( matchedHandlers.length ) {\\n\\t\\t\\t\\t\\t\\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Add the remaining (directly-bound) handlers\\n\\t\\tcur = this;\\n\\t\\tif ( delegateCount < handlers.length ) {\\n\\t\\t\\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\\n\\t\\t}\\n\\n\\t\\treturn handlerQueue;\\n\\t},\\n\\n\\taddProp: function( name, hook ) {\\n\\t\\tObject.defineProperty( jQuery.Event.prototype, name, {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tconfigurable: true,\\n\\n\\t\\t\\tget: isFunction( hook ) ?\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn hook( this.originalEvent );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} :\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn this.originalEvent[ name ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\tset: function( value ) {\\n\\t\\t\\t\\tObject.defineProperty( this, name, {\\n\\t\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\t\\tconfigurable: true,\\n\\t\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\t\\tvalue: value\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tfix: function( originalEvent ) {\\n\\t\\treturn originalEvent[ jQuery.expando ] ?\\n\\t\\t\\toriginalEvent :\\n\\t\\t\\tnew jQuery.Event( originalEvent );\\n\\t},\\n\\n\\tspecial: {\\n\\t\\tload: {\\n\\n\\t\\t\\t// Prevent triggered image.load events from bubbling to window.load\\n\\t\\t\\tnoBubble: true\\n\\t\\t},\\n\\t\\tclick: {\\n\\n\\t\\t\\t// Utilize native event to ensure correct state for checkable inputs\\n\\t\\t\\tsetup: function( data ) {\\n\\n\\t\\t\\t\\t// For mutual compressibility with _default, replace `this` access with a local var.\\n\\t\\t\\t\\t// `|| data` is dead code meant only to preserve the variable through minification.\\n\\t\\t\\t\\tvar el = this || data;\\n\\n\\t\\t\\t\\t// Claim the first handler\\n\\t\\t\\t\\tif ( rcheckableType.test( el.type ) &&\\n\\t\\t\\t\\t\\tel.click && nodeName( el, \\"input\\" ) ) {\\n\\n\\t\\t\\t\\t\\t// dataPriv.set( el, \\"click\\", ... )\\n\\t\\t\\t\\t\\tleverageNative( el, \\"click\\", returnTrue );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Return false to allow normal processing in the caller\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t},\\n\\t\\t\\ttrigger: function( data ) {\\n\\n\\t\\t\\t\\t// For mutual compressibility with _default, replace `this` access with a local var.\\n\\t\\t\\t\\t// `|| data` is dead code meant only to preserve the variable through minification.\\n\\t\\t\\t\\tvar el = this || data;\\n\\n\\t\\t\\t\\t// Force setup before triggering a click\\n\\t\\t\\t\\tif ( rcheckableType.test( el.type ) &&\\n\\t\\t\\t\\t\\tel.click && nodeName( el, \\"input\\" ) ) {\\n\\n\\t\\t\\t\\t\\tleverageNative( el, \\"click\\" );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Return non-false to allow normal event-path propagation\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// For cross-browser consistency, suppress native .click() on links\\n\\t\\t\\t// Also prevent it if we\'re currently inside a leveraged native-event stack\\n\\t\\t\\t_default: function( event ) {\\n\\t\\t\\t\\tvar target = event.target;\\n\\t\\t\\t\\treturn rcheckableType.test( target.type ) &&\\n\\t\\t\\t\\t\\ttarget.click && nodeName( target, \\"input\\" ) &&\\n\\t\\t\\t\\t\\tdataPriv.get( target, \\"click\\" ) ||\\n\\t\\t\\t\\t\\tnodeName( target, \\"a\\" );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tbeforeunload: {\\n\\t\\t\\tpostDispatch: function( event ) {\\n\\n\\t\\t\\t\\t// Support: Firefox 20+\\n\\t\\t\\t\\t// Firefox doesn\'t alert if the returnValue field is not set.\\n\\t\\t\\t\\tif ( event.result !== undefined && event.originalEvent ) {\\n\\t\\t\\t\\t\\tevent.originalEvent.returnValue = event.result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n// Ensure the presence of an event listener that handles manually-triggered\\n// synthetic events by interrupting progress until reinvoked in response to\\n// *native* events that it fires directly, ensuring that state changes have\\n// already occurred before other listeners are invoked.\\nfunction leverageNative( el, type, expectSync ) {\\n\\n\\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\\n\\tif ( !expectSync ) {\\n\\t\\tif ( dataPriv.get( el, type ) === undefined ) {\\n\\t\\t\\tjQuery.event.add( el, type, returnTrue );\\n\\t\\t}\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Register the controller as a special universal handler for all event namespaces\\n\\tdataPriv.set( el, type, false );\\n\\tjQuery.event.add( el, type, {\\n\\t\\tnamespace: false,\\n\\t\\thandler: function( event ) {\\n\\t\\t\\tvar notAsync, result,\\n\\t\\t\\t\\tsaved = dataPriv.get( this, type );\\n\\n\\t\\t\\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\\n\\n\\t\\t\\t\\t// Interrupt processing of the outer synthetic .trigger()ed event\\n\\t\\t\\t\\t// Saved data should be false in such cases, but might be a leftover capture object\\n\\t\\t\\t\\t// from an async native handler (gh-4350)\\n\\t\\t\\t\\tif ( !saved.length ) {\\n\\n\\t\\t\\t\\t\\t// Store arguments for use when handling the inner native event\\n\\t\\t\\t\\t\\t// There will always be at least one argument (an event object), so this array\\n\\t\\t\\t\\t\\t// will not be confused with a leftover capture object.\\n\\t\\t\\t\\t\\tsaved = slice.call( arguments );\\n\\t\\t\\t\\t\\tdataPriv.set( this, type, saved );\\n\\n\\t\\t\\t\\t\\t// Trigger the native event and capture its result\\n\\t\\t\\t\\t\\t// Support: IE <=9 - 11+\\n\\t\\t\\t\\t\\t// focus() and blur() are asynchronous\\n\\t\\t\\t\\t\\tnotAsync = expectSync( this, type );\\n\\t\\t\\t\\t\\tthis[ type ]();\\n\\t\\t\\t\\t\\tresult = dataPriv.get( this, type );\\n\\t\\t\\t\\t\\tif ( saved !== result || notAsync ) {\\n\\t\\t\\t\\t\\t\\tdataPriv.set( this, type, false );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresult = {};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( saved !== result ) {\\n\\n\\t\\t\\t\\t\\t\\t// Cancel the outer synthetic event\\n\\t\\t\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\treturn result.value;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If this is an inner synthetic event for an event with a bubbling surrogate\\n\\t\\t\\t\\t// (focus or blur), assume that the surrogate already propagated from triggering the\\n\\t\\t\\t\\t// native event and prevent that from happening again here.\\n\\t\\t\\t\\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\\n\\t\\t\\t\\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\\n\\t\\t\\t\\t// less bad than duplication.\\n\\t\\t\\t\\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\\n\\t\\t\\t\\t\\tevent.stopPropagation();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// If this is a native event triggered above, everything is now in order\\n\\t\\t\\t// Fire an inner synthetic event with the original arguments\\n\\t\\t\\t} else if ( saved.length ) {\\n\\n\\t\\t\\t\\t// ...and capture the result\\n\\t\\t\\t\\tdataPriv.set( this, type, {\\n\\t\\t\\t\\t\\tvalue: jQuery.event.trigger(\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE <=9 - 11+\\n\\t\\t\\t\\t\\t\\t// Extend with the prototype to reset the above stopImmediatePropagation()\\n\\t\\t\\t\\t\\t\\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\\n\\t\\t\\t\\t\\t\\tsaved.slice( 1 ),\\n\\t\\t\\t\\t\\t\\tthis\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t// Abort handling of the native event\\n\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} );\\n}\\n\\njQuery.removeEvent = function( elem, type, handle ) {\\n\\n\\t// This \\"if\\" is needed for plain objects\\n\\tif ( elem.removeEventListener ) {\\n\\t\\telem.removeEventListener( type, handle );\\n\\t}\\n};\\n\\njQuery.Event = function( src, props ) {\\n\\n\\t// Allow instantiation without the \'new\' keyword\\n\\tif ( !( this instanceof jQuery.Event ) ) {\\n\\t\\treturn new jQuery.Event( src, props );\\n\\t}\\n\\n\\t// Event object\\n\\tif ( src && src.type ) {\\n\\t\\tthis.originalEvent = src;\\n\\t\\tthis.type = src.type;\\n\\n\\t\\t// Events bubbling up the document may have been marked as prevented\\n\\t\\t// by a handler lower down the tree; reflect the correct value.\\n\\t\\tthis.isDefaultPrevented = src.defaultPrevented ||\\n\\t\\t\\t\\tsrc.defaultPrevented === undefined &&\\n\\n\\t\\t\\t\\t// Support: Android <=2.3 only\\n\\t\\t\\t\\tsrc.returnValue === false ?\\n\\t\\t\\treturnTrue :\\n\\t\\t\\treturnFalse;\\n\\n\\t\\t// Create target properties\\n\\t\\t// Support: Safari <=6 - 7 only\\n\\t\\t// Target should not be a text node (#504, #13143)\\n\\t\\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\\n\\t\\t\\tsrc.target.parentNode :\\n\\t\\t\\tsrc.target;\\n\\n\\t\\tthis.currentTarget = src.currentTarget;\\n\\t\\tthis.relatedTarget = src.relatedTarget;\\n\\n\\t// Event type\\n\\t} else {\\n\\t\\tthis.type = src;\\n\\t}\\n\\n\\t// Put explicitly provided properties onto the event object\\n\\tif ( props ) {\\n\\t\\tjQuery.extend( this, props );\\n\\t}\\n\\n\\t// Create a timestamp if incoming event doesn\'t have one\\n\\tthis.timeStamp = src && src.timeStamp || Date.now();\\n\\n\\t// Mark it as fixed\\n\\tthis[ jQuery.expando ] = true;\\n};\\n\\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\\njQuery.Event.prototype = {\\n\\tconstructor: jQuery.Event,\\n\\tisDefaultPrevented: returnFalse,\\n\\tisPropagationStopped: returnFalse,\\n\\tisImmediatePropagationStopped: returnFalse,\\n\\tisSimulated: false,\\n\\n\\tpreventDefault: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isDefaultPrevented = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.preventDefault();\\n\\t\\t}\\n\\t},\\n\\tstopPropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isPropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopPropagation();\\n\\t\\t}\\n\\t},\\n\\tstopImmediatePropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isImmediatePropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopImmediatePropagation();\\n\\t\\t}\\n\\n\\t\\tthis.stopPropagation();\\n\\t}\\n};\\n\\n// Includes all common event props including KeyEvent and MouseEvent specific props\\njQuery.each( {\\n\\taltKey: true,\\n\\tbubbles: true,\\n\\tcancelable: true,\\n\\tchangedTouches: true,\\n\\tctrlKey: true,\\n\\tdetail: true,\\n\\teventPhase: true,\\n\\tmetaKey: true,\\n\\tpageX: true,\\n\\tpageY: true,\\n\\tshiftKey: true,\\n\\tview: true,\\n\\t\\"char\\": true,\\n\\tcode: true,\\n\\tcharCode: true,\\n\\tkey: true,\\n\\tkeyCode: true,\\n\\tbutton: true,\\n\\tbuttons: true,\\n\\tclientX: true,\\n\\tclientY: true,\\n\\toffsetX: true,\\n\\toffsetY: true,\\n\\tpointerId: true,\\n\\tpointerType: true,\\n\\tscreenX: true,\\n\\tscreenY: true,\\n\\ttargetTouches: true,\\n\\ttoElement: true,\\n\\ttouches: true,\\n\\n\\twhich: function( event ) {\\n\\t\\tvar button = event.button;\\n\\n\\t\\t// Add which for key events\\n\\t\\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\\n\\t\\t\\treturn event.charCode != null ? event.charCode : event.keyCode;\\n\\t\\t}\\n\\n\\t\\t// Add which for click: 1 === left; 2 === middle; 3 === right\\n\\t\\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\\n\\t\\t\\tif ( button & 1 ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 2 ) {\\n\\t\\t\\t\\treturn 3;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 4 ) {\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn event.which;\\n\\t}\\n}, jQuery.event.addProp );\\n\\njQuery.each( { focus: \\"focusin\\", blur: \\"focusout\\" }, function( type, delegateType ) {\\n\\tjQuery.event.special[ type ] = {\\n\\n\\t\\t// Utilize native event if possible so blur/focus sequence is correct\\n\\t\\tsetup: function() {\\n\\n\\t\\t\\t// Claim the first handler\\n\\t\\t\\t// dataPriv.set( this, \\"focus\\", ... )\\n\\t\\t\\t// dataPriv.set( this, \\"blur\\", ... )\\n\\t\\t\\tleverageNative( this, type, expectSync );\\n\\n\\t\\t\\t// Return false to allow normal processing in the caller\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\ttrigger: function() {\\n\\n\\t\\t\\t// Force setup before trigger\\n\\t\\t\\tleverageNative( this, type );\\n\\n\\t\\t\\t// Return non-false to allow normal event-path propagation\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\tdelegateType: delegateType\\n\\t};\\n} );\\n\\n// Create mouseenter/leave events using mouseover/out and event-time checks\\n// so that event delegation works in jQuery.\\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\\n//\\n// Support: Safari 7 only\\n// Safari sends mouseenter too often; see:\\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\\n// for the description of the bug (it existed in older Chrome versions as well).\\njQuery.each( {\\n\\tmouseenter: \\"mouseover\\",\\n\\tmouseleave: \\"mouseout\\",\\n\\tpointerenter: \\"pointerover\\",\\n\\tpointerleave: \\"pointerout\\"\\n}, function( orig, fix ) {\\n\\tjQuery.event.special[ orig ] = {\\n\\t\\tdelegateType: fix,\\n\\t\\tbindType: fix,\\n\\n\\t\\thandle: function( event ) {\\n\\t\\t\\tvar ret,\\n\\t\\t\\t\\ttarget = this,\\n\\t\\t\\t\\trelated = event.relatedTarget,\\n\\t\\t\\t\\thandleObj = event.handleObj;\\n\\n\\t\\t\\t// For mouseenter/leave call the handler if related is outside the target.\\n\\t\\t\\t// NB: No relatedTarget if the mouse left/entered the browser window\\n\\t\\t\\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\\n\\t\\t\\t\\tevent.type = handleObj.origType;\\n\\t\\t\\t\\tret = handleObj.handler.apply( this, arguments );\\n\\t\\t\\t\\tevent.type = fix;\\n\\t\\t\\t}\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ton: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn );\\n\\t},\\n\\tone: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn, 1 );\\n\\t},\\n\\toff: function( types, selector, fn ) {\\n\\t\\tvar handleObj, type;\\n\\t\\tif ( types && types.preventDefault && types.handleObj ) {\\n\\n\\t\\t\\t// ( event )  dispatched jQuery.Event\\n\\t\\t\\thandleObj = types.handleObj;\\n\\t\\t\\tjQuery( types.delegateTarget ).off(\\n\\t\\t\\t\\thandleObj.namespace ?\\n\\t\\t\\t\\t\\thandleObj.origType + \\".\\" + handleObj.namespace :\\n\\t\\t\\t\\t\\thandleObj.origType,\\n\\t\\t\\t\\thandleObj.selector,\\n\\t\\t\\t\\thandleObj.handler\\n\\t\\t\\t);\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( typeof types === \\"object\\" ) {\\n\\n\\t\\t\\t// ( types-object [, selector] )\\n\\t\\t\\tfor ( type in types ) {\\n\\t\\t\\t\\tthis.off( type, selector, types[ type ] );\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( selector === false || typeof selector === \\"function\\" ) {\\n\\n\\t\\t\\t// ( types [, fn] )\\n\\t\\t\\tfn = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tif ( fn === false ) {\\n\\t\\t\\tfn = returnFalse;\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.remove( this, types, fn, selector );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\nvar\\n\\n\\t// Support: IE <=10 - 11, Edge 12 - 13 only\\n\\t// In IE/Edge using regex groups here causes severe slowdowns.\\n\\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\\n\\trnoInnerhtml = /<script|<style|<link/i,\\n\\n\\t// checked=\\"checked\\" or checked\\n\\trchecked = /checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,\\n\\trcleanScript = /^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g;\\n\\n// Prefer a tbody over its parent table for containing new rows\\nfunction manipulationTarget( elem, content ) {\\n\\tif ( nodeName( elem, \\"table\\" ) &&\\n\\t\\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \\"tr\\" ) ) {\\n\\n\\t\\treturn jQuery( elem ).children( \\"tbody\\" )[ 0 ] || elem;\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\n// Replace/restore the type attribute of script elements for safe DOM manipulation\\nfunction disableScript( elem ) {\\n\\telem.type = ( elem.getAttribute( \\"type\\" ) !== null ) + \\"/\\" + elem.type;\\n\\treturn elem;\\n}\\nfunction restoreScript( elem ) {\\n\\tif ( ( elem.type || \\"\\" ).slice( 0, 5 ) === \\"true/\\" ) {\\n\\t\\telem.type = elem.type.slice( 5 );\\n\\t} else {\\n\\t\\telem.removeAttribute( \\"type\\" );\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\nfunction cloneCopyEvent( src, dest ) {\\n\\tvar i, l, type, pdataOld, udataOld, udataCur, events;\\n\\n\\tif ( dest.nodeType !== 1 ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// 1. Copy private data: events, handlers, etc.\\n\\tif ( dataPriv.hasData( src ) ) {\\n\\t\\tpdataOld = dataPriv.get( src );\\n\\t\\tevents = pdataOld.events;\\n\\n\\t\\tif ( events ) {\\n\\t\\t\\tdataPriv.remove( dest, \\"handle events\\" );\\n\\n\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tjQuery.event.add( dest, type, events[ type ][ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// 2. Copy user data\\n\\tif ( dataUser.hasData( src ) ) {\\n\\t\\tudataOld = dataUser.access( src );\\n\\t\\tudataCur = jQuery.extend( {}, udataOld );\\n\\n\\t\\tdataUser.set( dest, udataCur );\\n\\t}\\n}\\n\\n// Fix IE bugs, see support tests\\nfunction fixInput( src, dest ) {\\n\\tvar nodeName = dest.nodeName.toLowerCase();\\n\\n\\t// Fails to persist the checked state of a cloned checkbox or radio button.\\n\\tif ( nodeName === \\"input\\" && rcheckableType.test( src.type ) ) {\\n\\t\\tdest.checked = src.checked;\\n\\n\\t// Fails to return the selected option to the default selected state when cloning options\\n\\t} else if ( nodeName === \\"input\\" || nodeName === \\"textarea\\" ) {\\n\\t\\tdest.defaultValue = src.defaultValue;\\n\\t}\\n}\\n\\nfunction domManip( collection, args, callback, ignored ) {\\n\\n\\t// Flatten any nested arrays\\n\\targs = flat( args );\\n\\n\\tvar fragment, first, scripts, hasScripts, node, doc,\\n\\t\\ti = 0,\\n\\t\\tl = collection.length,\\n\\t\\tiNoClone = l - 1,\\n\\t\\tvalue = args[ 0 ],\\n\\t\\tvalueIsFunction = isFunction( value );\\n\\n\\t// We can\'t cloneNode fragments that contain checked, in WebKit\\n\\tif ( valueIsFunction ||\\n\\t\\t\\t( l > 1 && typeof value === \\"string\\" &&\\n\\t\\t\\t\\t!support.checkClone && rchecked.test( value ) ) ) {\\n\\t\\treturn collection.each( function( index ) {\\n\\t\\t\\tvar self = collection.eq( index );\\n\\t\\t\\tif ( valueIsFunction ) {\\n\\t\\t\\t\\targs[ 0 ] = value.call( this, index, self.html() );\\n\\t\\t\\t}\\n\\t\\t\\tdomManip( self, args, callback, ignored );\\n\\t\\t} );\\n\\t}\\n\\n\\tif ( l ) {\\n\\t\\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\\n\\t\\tfirst = fragment.firstChild;\\n\\n\\t\\tif ( fragment.childNodes.length === 1 ) {\\n\\t\\t\\tfragment = first;\\n\\t\\t}\\n\\n\\t\\t// Require either new content or an interest in ignored elements to invoke the callback\\n\\t\\tif ( first || ignored ) {\\n\\t\\t\\tscripts = jQuery.map( getAll( fragment, \\"script\\" ), disableScript );\\n\\t\\t\\thasScripts = scripts.length;\\n\\n\\t\\t\\t// Use the original fragment for the last item\\n\\t\\t\\t// instead of the first because it can end up\\n\\t\\t\\t// being emptied incorrectly in certain situations (#8070).\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tnode = fragment;\\n\\n\\t\\t\\t\\tif ( i !== iNoClone ) {\\n\\t\\t\\t\\t\\tnode = jQuery.clone( node, true, true );\\n\\n\\t\\t\\t\\t\\t// Keep references to cloned scripts for later restoration\\n\\t\\t\\t\\t\\tif ( hasScripts ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\t\\t\\tjQuery.merge( scripts, getAll( node, \\"script\\" ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcallback.call( collection[ i ], node, i );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasScripts ) {\\n\\t\\t\\t\\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\\n\\n\\t\\t\\t\\t// Reenable scripts\\n\\t\\t\\t\\tjQuery.map( scripts, restoreScript );\\n\\n\\t\\t\\t\\t// Evaluate executable scripts on first document insertion\\n\\t\\t\\t\\tfor ( i = 0; i < hasScripts; i++ ) {\\n\\t\\t\\t\\t\\tnode = scripts[ i ];\\n\\t\\t\\t\\t\\tif ( rscriptType.test( node.type || \\"\\" ) &&\\n\\t\\t\\t\\t\\t\\t!dataPriv.access( node, \\"globalEval\\" ) &&\\n\\t\\t\\t\\t\\t\\tjQuery.contains( doc, node ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( node.src && ( node.type || \\"\\" ).toLowerCase()  !== \\"module\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Optional AJAX dependency, but won\'t run scripts if not present\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery._evalUrl && !node.noModule ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery._evalUrl( node.src, {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnonce: node.nonce || node.getAttribute( \\"nonce\\" )\\n\\t\\t\\t\\t\\t\\t\\t\\t}, doc );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tDOMEval( node.textContent.replace( rcleanScript, \\"\\" ), node, doc );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn collection;\\n}\\n\\nfunction remove( elem, selector, keepData ) {\\n\\tvar node,\\n\\t\\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\\n\\t\\ti = 0;\\n\\n\\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\\n\\t\\tif ( !keepData && node.nodeType === 1 ) {\\n\\t\\t\\tjQuery.cleanData( getAll( node ) );\\n\\t\\t}\\n\\n\\t\\tif ( node.parentNode ) {\\n\\t\\t\\tif ( keepData && isAttached( node ) ) {\\n\\t\\t\\t\\tsetGlobalEval( getAll( node, \\"script\\" ) );\\n\\t\\t\\t}\\n\\t\\t\\tnode.parentNode.removeChild( node );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\njQuery.extend( {\\n\\thtmlPrefilter: function( html ) {\\n\\t\\treturn html;\\n\\t},\\n\\n\\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\\n\\t\\tvar i, l, srcElements, destElements,\\n\\t\\t\\tclone = elem.cloneNode( true ),\\n\\t\\t\\tinPage = isAttached( elem );\\n\\n\\t\\t// Fix IE cloning issues\\n\\t\\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\\n\\t\\t\\t\\t!jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\\n\\t\\t\\tdestElements = getAll( clone );\\n\\t\\t\\tsrcElements = getAll( elem );\\n\\n\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\tfixInput( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Copy the events from the original to the clone\\n\\t\\tif ( dataAndEvents ) {\\n\\t\\t\\tif ( deepDataAndEvents ) {\\n\\t\\t\\t\\tsrcElements = srcElements || getAll( elem );\\n\\t\\t\\t\\tdestElements = destElements || getAll( clone );\\n\\n\\t\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcloneCopyEvent( elem, clone );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tdestElements = getAll( clone, \\"script\\" );\\n\\t\\tif ( destElements.length > 0 ) {\\n\\t\\t\\tsetGlobalEval( destElements, !inPage && getAll( elem, \\"script\\" ) );\\n\\t\\t}\\n\\n\\t\\t// Return the cloned set\\n\\t\\treturn clone;\\n\\t},\\n\\n\\tcleanData: function( elems ) {\\n\\t\\tvar data, elem, type,\\n\\t\\t\\tspecial = jQuery.event.special,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\\n\\t\\t\\tif ( acceptData( elem ) ) {\\n\\t\\t\\t\\tif ( ( data = elem[ dataPriv.expando ] ) ) {\\n\\t\\t\\t\\t\\tif ( data.events ) {\\n\\t\\t\\t\\t\\t\\tfor ( type in data.events ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( special[ type ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.event.remove( elem, type );\\n\\n\\t\\t\\t\\t\\t\\t\\t// This is a shortcut to avoid jQuery.event.remove\'s overhead\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, data.handle );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataPriv.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( elem[ dataUser.expando ] ) {\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataUser.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdetach: function( selector ) {\\n\\t\\treturn remove( this, selector, true );\\n\\t},\\n\\n\\tremove: function( selector ) {\\n\\t\\treturn remove( this, selector );\\n\\t},\\n\\n\\ttext: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\treturn value === undefined ?\\n\\t\\t\\t\\tjQuery.text( this ) :\\n\\t\\t\\t\\tthis.empty().each( function() {\\n\\t\\t\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tthis.textContent = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\tappend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.appendChild( elem );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tprepend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.insertBefore( elem, target.firstChild );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tbefore: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tafter: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this.nextSibling );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tempty: function() {\\n\\t\\tvar elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\\n\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Prevent memory leaks\\n\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\n\\t\\t\\t\\t// Remove any remaining nodes\\n\\t\\t\\t\\telem.textContent = \\"\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tclone: function( dataAndEvents, deepDataAndEvents ) {\\n\\t\\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\\n\\t\\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\\n\\n\\t\\treturn this.map( function() {\\n\\t\\t\\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\\n\\t\\t} );\\n\\t},\\n\\n\\thtml: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar elem = this[ 0 ] || {},\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\tl = this.length;\\n\\n\\t\\t\\tif ( value === undefined && elem.nodeType === 1 ) {\\n\\t\\t\\t\\treturn elem.innerHTML;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// See if we can take a shortcut and just use innerHTML\\n\\t\\t\\tif ( typeof value === \\"string\\" && !rnoInnerhtml.test( value ) &&\\n\\t\\t\\t\\t!wrapMap[ ( rtagName.exec( value ) || [ \\"\\", \\"\\" ] )[ 1 ].toLowerCase() ] ) {\\n\\n\\t\\t\\t\\tvalue = jQuery.htmlPrefilter( value );\\n\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\telem = this[ i ] || {};\\n\\n\\t\\t\\t\\t\\t\\t// Remove element nodes and prevent memory leaks\\n\\t\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\t\\t\\t\\t\\t\\t\\telem.innerHTML = value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem = 0;\\n\\n\\t\\t\\t\\t// If using innerHTML throws an exception, use the fallback method\\n\\t\\t\\t\\t} catch ( e ) {}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\tthis.empty().append( value );\\n\\t\\t\\t}\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\treplaceWith: function() {\\n\\t\\tvar ignored = [];\\n\\n\\t\\t// Make the changes, replacing each non-ignored context element with the new content\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tvar parent = this.parentNode;\\n\\n\\t\\t\\tif ( jQuery.inArray( this, ignored ) < 0 ) {\\n\\t\\t\\t\\tjQuery.cleanData( getAll( this ) );\\n\\t\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\t\\tparent.replaceChild( elem, this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Force callback invocation\\n\\t\\t}, ignored );\\n\\t}\\n} );\\n\\njQuery.each( {\\n\\tappendTo: \\"append\\",\\n\\tprependTo: \\"prepend\\",\\n\\tinsertBefore: \\"before\\",\\n\\tinsertAfter: \\"after\\",\\n\\treplaceAll: \\"replaceWith\\"\\n}, function( name, original ) {\\n\\tjQuery.fn[ name ] = function( selector ) {\\n\\t\\tvar elems,\\n\\t\\t\\tret = [],\\n\\t\\t\\tinsert = jQuery( selector ),\\n\\t\\t\\tlast = insert.length - 1,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; i <= last; i++ ) {\\n\\t\\t\\telems = i === last ? this : this.clone( true );\\n\\t\\t\\tjQuery( insert[ i ] )[ original ]( elems );\\n\\n\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\tpush.apply( ret, elems.get() );\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( ret );\\n\\t};\\n} );\\nvar rnumnonpx = new RegExp( \\"^(\\" + pnum + \\")(?!px)[a-z%]+$\\", \\"i\\" );\\n\\nvar getStyles = function( elem ) {\\n\\n\\t\\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\\n\\t\\t// IE throws on elements created in popups\\n\\t\\t// FF meanwhile throws on frame elements through \\"defaultView.getComputedStyle\\"\\n\\t\\tvar view = elem.ownerDocument.defaultView;\\n\\n\\t\\tif ( !view || !view.opener ) {\\n\\t\\t\\tview = window;\\n\\t\\t}\\n\\n\\t\\treturn view.getComputedStyle( elem );\\n\\t};\\n\\nvar swap = function( elem, options, callback ) {\\n\\tvar ret, name,\\n\\t\\told = {};\\n\\n\\t// Remember the old values, and insert the new ones\\n\\tfor ( name in options ) {\\n\\t\\told[ name ] = elem.style[ name ];\\n\\t\\telem.style[ name ] = options[ name ];\\n\\t}\\n\\n\\tret = callback.call( elem );\\n\\n\\t// Revert the old values\\n\\tfor ( name in options ) {\\n\\t\\telem.style[ name ] = old[ name ];\\n\\t}\\n\\n\\treturn ret;\\n};\\n\\n\\nvar rboxStyle = new RegExp( cssExpand.join( \\"|\\" ), \\"i\\" );\\n\\n\\n\\n( function() {\\n\\n\\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\\n\\t// so they\'re executed at the same time to save the second computation.\\n\\tfunction computeStyleTests() {\\n\\n\\t\\t// This is a singleton, we need to execute it only once\\n\\t\\tif ( !div ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tcontainer.style.cssText = \\"position:absolute;left:-11111px;width:60px;\\" +\\n\\t\\t\\t\\"margin-top:1px;padding:0;border:0\\";\\n\\t\\tdiv.style.cssText =\\n\\t\\t\\t\\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\\" +\\n\\t\\t\\t\\"margin:auto;border:1px;padding:1px;\\" +\\n\\t\\t\\t\\"width:60%;top:1%\\";\\n\\t\\tdocumentElement.appendChild( container ).appendChild( div );\\n\\n\\t\\tvar divStyle = window.getComputedStyle( div );\\n\\t\\tpixelPositionVal = divStyle.top !== \\"1%\\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\\n\\t\\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\\n\\t\\t// Some styles come back with percentage values, even though they shouldn\'t\\n\\t\\tdiv.style.right = \\"60%\\";\\n\\t\\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\\n\\n\\t\\t// Support: IE 9 - 11 only\\n\\t\\t// Detect misreporting of content dimensions for box-sizing:border-box elements\\n\\t\\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\\n\\n\\t\\t// Support: IE 9 only\\n\\t\\t// Detect overflow:scroll screwiness (gh-3699)\\n\\t\\t// Support: Chrome <=64\\n\\t\\t// Don\'t get tricked when zoom affects offsetWidth (gh-4029)\\n\\t\\tdiv.style.position = \\"absolute\\";\\n\\t\\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\\n\\n\\t\\tdocumentElement.removeChild( container );\\n\\n\\t\\t// Nullify the div so it wouldn\'t be stored in the memory and\\n\\t\\t// it will also be a sign that checks already performed\\n\\t\\tdiv = null;\\n\\t}\\n\\n\\tfunction roundPixelMeasures( measure ) {\\n\\t\\treturn Math.round( parseFloat( measure ) );\\n\\t}\\n\\n\\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\\n\\t\\treliableTrDimensionsVal, reliableMarginLeftVal,\\n\\t\\tcontainer = document.createElement( \\"div\\" ),\\n\\t\\tdiv = document.createElement( \\"div\\" );\\n\\n\\t// Finish early in limited (non-browser) environments\\n\\tif ( !div.style ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Style of cloned element affects source element cloned (#8908)\\n\\tdiv.style.backgroundClip = \\"content-box\\";\\n\\tdiv.cloneNode( true ).style.backgroundClip = \\"\\";\\n\\tsupport.clearCloneStyle = div.style.backgroundClip === \\"content-box\\";\\n\\n\\tjQuery.extend( support, {\\n\\t\\tboxSizingReliable: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn boxSizingReliableVal;\\n\\t\\t},\\n\\t\\tpixelBoxStyles: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelBoxStylesVal;\\n\\t\\t},\\n\\t\\tpixelPosition: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelPositionVal;\\n\\t\\t},\\n\\t\\treliableMarginLeft: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn reliableMarginLeftVal;\\n\\t\\t},\\n\\t\\tscrollboxSize: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn scrollboxSizeVal;\\n\\t\\t},\\n\\n\\t\\t// Support: IE 9 - 11+, Edge 15 - 18+\\n\\t\\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\\n\\t\\t// set in CSS while `offset*` properties report correct values.\\n\\t\\t// Behavior in IE 9 is more subtle than in newer versions & it passes\\n\\t\\t// some versions of this test; make sure not to make it pass there!\\n\\t\\treliableTrDimensions: function() {\\n\\t\\t\\tvar table, tr, trChild, trStyle;\\n\\t\\t\\tif ( reliableTrDimensionsVal == null ) {\\n\\t\\t\\t\\ttable = document.createElement( \\"table\\" );\\n\\t\\t\\t\\ttr = document.createElement( \\"tr\\" );\\n\\t\\t\\t\\ttrChild = document.createElement( \\"div\\" );\\n\\n\\t\\t\\t\\ttable.style.cssText = \\"position:absolute;left:-11111px\\";\\n\\t\\t\\t\\ttr.style.height = \\"1px\\";\\n\\t\\t\\t\\ttrChild.style.height = \\"9px\\";\\n\\n\\t\\t\\t\\tdocumentElement\\n\\t\\t\\t\\t\\t.appendChild( table )\\n\\t\\t\\t\\t\\t.appendChild( tr )\\n\\t\\t\\t\\t\\t.appendChild( trChild );\\n\\n\\t\\t\\t\\ttrStyle = window.getComputedStyle( tr );\\n\\t\\t\\t\\treliableTrDimensionsVal = parseInt( trStyle.height ) > 3;\\n\\n\\t\\t\\t\\tdocumentElement.removeChild( table );\\n\\t\\t\\t}\\n\\t\\t\\treturn reliableTrDimensionsVal;\\n\\t\\t}\\n\\t} );\\n} )();\\n\\n\\nfunction curCSS( elem, name, computed ) {\\n\\tvar width, minWidth, maxWidth, ret,\\n\\n\\t\\t// Support: Firefox 51+\\n\\t\\t// Retrieving style before computed somehow\\n\\t\\t// fixes an issue with getting wrong values\\n\\t\\t// on detached elements\\n\\t\\tstyle = elem.style;\\n\\n\\tcomputed = computed || getStyles( elem );\\n\\n\\t// getPropertyValue is needed for:\\n\\t//   .css(\'filter\') (IE 9 only, #12537)\\n\\t//   .css(\'--customProperty) (#3144)\\n\\tif ( computed ) {\\n\\t\\tret = computed.getPropertyValue( name ) || computed[ name ];\\n\\n\\t\\tif ( ret === \\"\\" && !isAttached( elem ) ) {\\n\\t\\t\\tret = jQuery.style( elem, name );\\n\\t\\t}\\n\\n\\t\\t// A tribute to the \\"awesome hack by Dean Edwards\\"\\n\\t\\t// Android Browser returns percentage for some values,\\n\\t\\t// but width seems to be reliably pixels.\\n\\t\\t// This is against the CSSOM draft spec:\\n\\t\\t// https://drafts.csswg.org/cssom/#resolved-values\\n\\t\\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\\n\\n\\t\\t\\t// Remember the original values\\n\\t\\t\\twidth = style.width;\\n\\t\\t\\tminWidth = style.minWidth;\\n\\t\\t\\tmaxWidth = style.maxWidth;\\n\\n\\t\\t\\t// Put in the new values to get a computed value out\\n\\t\\t\\tstyle.minWidth = style.maxWidth = style.width = ret;\\n\\t\\t\\tret = computed.width;\\n\\n\\t\\t\\t// Revert the changed values\\n\\t\\t\\tstyle.width = width;\\n\\t\\t\\tstyle.minWidth = minWidth;\\n\\t\\t\\tstyle.maxWidth = maxWidth;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret !== undefined ?\\n\\n\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t// IE returns zIndex value as an integer.\\n\\t\\tret + \\"\\" :\\n\\t\\tret;\\n}\\n\\n\\nfunction addGetHookIf( conditionFn, hookFn ) {\\n\\n\\t// Define the hook, we\'ll check on the first run if it\'s really needed.\\n\\treturn {\\n\\t\\tget: function() {\\n\\t\\t\\tif ( conditionFn() ) {\\n\\n\\t\\t\\t\\t// Hook not needed (or it\'s not possible to use it due\\n\\t\\t\\t\\t// to missing dependency), remove it.\\n\\t\\t\\t\\tdelete this.get;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Hook needed; redefine it so that the support test is not executed again.\\n\\t\\t\\treturn ( this.get = hookFn ).apply( this, arguments );\\n\\t\\t}\\n\\t};\\n}\\n\\n\\nvar cssPrefixes = [ \\"Webkit\\", \\"Moz\\", \\"ms\\" ],\\n\\temptyStyle = document.createElement( \\"div\\" ).style,\\n\\tvendorProps = {};\\n\\n// Return a vendor-prefixed property or undefined\\nfunction vendorPropName( name ) {\\n\\n\\t// Check for vendor prefixed names\\n\\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\\n\\t\\ti = cssPrefixes.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tname = cssPrefixes[ i ] + capName;\\n\\t\\tif ( name in emptyStyle ) {\\n\\t\\t\\treturn name;\\n\\t\\t}\\n\\t}\\n}\\n\\n// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\\nfunction finalPropName( name ) {\\n\\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\\n\\n\\tif ( final ) {\\n\\t\\treturn final;\\n\\t}\\n\\tif ( name in emptyStyle ) {\\n\\t\\treturn name;\\n\\t}\\n\\treturn vendorProps[ name ] = vendorPropName( name ) || name;\\n}\\n\\n\\nvar\\n\\n\\t// Swappable if display is none or starts with table\\n\\t// except \\"table\\", \\"table-cell\\", or \\"table-caption\\"\\n\\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\\n\\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\\n\\trcustomProp = /^--/,\\n\\tcssShow = { position: \\"absolute\\", visibility: \\"hidden\\", display: \\"block\\" },\\n\\tcssNormalTransform = {\\n\\t\\tletterSpacing: \\"0\\",\\n\\t\\tfontWeight: \\"400\\"\\n\\t};\\n\\nfunction setPositiveNumber( _elem, value, subtract ) {\\n\\n\\t// Any relative (+/-) values have already been\\n\\t// normalized at this point\\n\\tvar matches = rcssNum.exec( value );\\n\\treturn matches ?\\n\\n\\t\\t// Guard against undefined \\"subtract\\", e.g., when used as in cssHooks\\n\\t\\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \\"px\\" ) :\\n\\t\\tvalue;\\n}\\n\\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\\n\\tvar i = dimension === \\"width\\" ? 1 : 0,\\n\\t\\textra = 0,\\n\\t\\tdelta = 0;\\n\\n\\t// Adjustment may not be necessary\\n\\tif ( box === ( isBorderBox ? \\"border\\" : \\"content\\" ) ) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor ( ; i < 4; i += 2 ) {\\n\\n\\t\\t// Both box models exclude margin\\n\\t\\tif ( box === \\"margin\\" ) {\\n\\t\\t\\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\\n\\t\\t}\\n\\n\\t\\t// If we get here with a content-box, we\'re seeking \\"padding\\" or \\"border\\" or \\"margin\\"\\n\\t\\tif ( !isBorderBox ) {\\n\\n\\t\\t\\t// Add padding\\n\\t\\t\\tdelta += jQuery.css( elem, \\"padding\\" + cssExpand[ i ], true, styles );\\n\\n\\t\\t\\t// For \\"border\\" or \\"margin\\", add border\\n\\t\\t\\tif ( box !== \\"padding\\" ) {\\n\\t\\t\\t\\tdelta += jQuery.css( elem, \\"border\\" + cssExpand[ i ] + \\"Width\\", true, styles );\\n\\n\\t\\t\\t// But still keep track of it otherwise\\n\\t\\t\\t} else {\\n\\t\\t\\t\\textra += jQuery.css( elem, \\"border\\" + cssExpand[ i ] + \\"Width\\", true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t// If we get here with a border-box (content + padding + border), we\'re seeking \\"content\\" or\\n\\t\\t// \\"padding\\" or \\"margin\\"\\n\\t\\t} else {\\n\\n\\t\\t\\t// For \\"content\\", subtract padding\\n\\t\\t\\tif ( box === \\"content\\" ) {\\n\\t\\t\\t\\tdelta -= jQuery.css( elem, \\"padding\\" + cssExpand[ i ], true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// For \\"content\\" or \\"padding\\", subtract border\\n\\t\\t\\tif ( box !== \\"margin\\" ) {\\n\\t\\t\\t\\tdelta -= jQuery.css( elem, \\"border\\" + cssExpand[ i ] + \\"Width\\", true, styles );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Account for positive content-box scroll gutter when requested by providing computedVal\\n\\tif ( !isBorderBox && computedVal >= 0 ) {\\n\\n\\t\\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\\n\\t\\t// Assuming integer scroll gutter, subtract the rest and round down\\n\\t\\tdelta += Math.max( 0, Math.ceil(\\n\\t\\t\\telem[ \\"offset\\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\\n\\t\\t\\tcomputedVal -\\n\\t\\t\\tdelta -\\n\\t\\t\\textra -\\n\\t\\t\\t0.5\\n\\n\\t\\t// If offsetWidth/offsetHeight is unknown, then we can\'t determine content-box scroll gutter\\n\\t\\t// Use an explicit zero to avoid NaN (gh-3964)\\n\\t\\t) ) || 0;\\n\\t}\\n\\n\\treturn delta;\\n}\\n\\nfunction getWidthOrHeight( elem, dimension, extra ) {\\n\\n\\t// Start with computed style\\n\\tvar styles = getStyles( elem ),\\n\\n\\t\\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\\n\\t\\t// Fake content-box until we know it\'s needed to know the true value.\\n\\t\\tboxSizingNeeded = !support.boxSizingReliable() || extra,\\n\\t\\tisBorderBox = boxSizingNeeded &&\\n\\t\\t\\tjQuery.css( elem, \\"boxSizing\\", false, styles ) === \\"border-box\\",\\n\\t\\tvalueIsBorderBox = isBorderBox,\\n\\n\\t\\tval = curCSS( elem, dimension, styles ),\\n\\t\\toffsetProp = \\"offset\\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\\n\\n\\t// Support: Firefox <=54\\n\\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\\n\\tif ( rnumnonpx.test( val ) ) {\\n\\t\\tif ( !extra ) {\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\t\\tval = \\"auto\\";\\n\\t}\\n\\n\\n\\t// Support: IE 9 - 11 only\\n\\t// Use offsetWidth/offsetHeight for when box sizing is unreliable.\\n\\t// In those cases, the computed value can be trusted to be border-box.\\n\\tif ( ( !support.boxSizingReliable() && isBorderBox ||\\n\\n\\t\\t// Support: IE 10 - 11+, Edge 15 - 18+\\n\\t\\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\\n\\t\\t// set in CSS while `offset*` properties report correct values.\\n\\t\\t// Interestingly, in some cases IE 9 doesn\'t suffer from this issue.\\n\\t\\t!support.reliableTrDimensions() && nodeName( elem, \\"tr\\" ) ||\\n\\n\\t\\t// Fall back to offsetWidth/offsetHeight when value is \\"auto\\"\\n\\t\\t// This happens for inline elements with no explicit setting (gh-3571)\\n\\t\\tval === \\"auto\\" ||\\n\\n\\t\\t// Support: Android <=4.1 - 4.3 only\\n\\t\\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\\n\\t\\t!parseFloat( val ) && jQuery.css( elem, \\"display\\", false, styles ) === \\"inline\\" ) &&\\n\\n\\t\\t// Make sure the element is visible & connected\\n\\t\\telem.getClientRects().length ) {\\n\\n\\t\\tisBorderBox = jQuery.css( elem, \\"boxSizing\\", false, styles ) === \\"border-box\\";\\n\\n\\t\\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\\n\\t\\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\\n\\t\\t// retrieved value as a content box dimension.\\n\\t\\tvalueIsBorderBox = offsetProp in elem;\\n\\t\\tif ( valueIsBorderBox ) {\\n\\t\\t\\tval = elem[ offsetProp ];\\n\\t\\t}\\n\\t}\\n\\n\\t// Normalize \\"\\" and auto\\n\\tval = parseFloat( val ) || 0;\\n\\n\\t// Adjust for the element\'s box model\\n\\treturn ( val +\\n\\t\\tboxModelAdjustment(\\n\\t\\t\\telem,\\n\\t\\t\\tdimension,\\n\\t\\t\\textra || ( isBorderBox ? \\"border\\" : \\"content\\" ),\\n\\t\\t\\tvalueIsBorderBox,\\n\\t\\t\\tstyles,\\n\\n\\t\\t\\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\\n\\t\\t\\tval\\n\\t\\t)\\n\\t) + \\"px\\";\\n}\\n\\njQuery.extend( {\\n\\n\\t// Add in style property hooks for overriding the default\\n\\t// behavior of getting and setting a style property\\n\\tcssHooks: {\\n\\t\\topacity: {\\n\\t\\t\\tget: function( elem, computed ) {\\n\\t\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t\\t// We should always get a number back from opacity\\n\\t\\t\\t\\t\\tvar ret = curCSS( elem, \\"opacity\\" );\\n\\t\\t\\t\\t\\treturn ret === \\"\\" ? \\"1\\" : ret;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// Don\'t automatically add \\"px\\" to these possibly-unitless properties\\n\\tcssNumber: {\\n\\t\\t\\"animationIterationCount\\": true,\\n\\t\\t\\"columnCount\\": true,\\n\\t\\t\\"fillOpacity\\": true,\\n\\t\\t\\"flexGrow\\": true,\\n\\t\\t\\"flexShrink\\": true,\\n\\t\\t\\"fontWeight\\": true,\\n\\t\\t\\"gridArea\\": true,\\n\\t\\t\\"gridColumn\\": true,\\n\\t\\t\\"gridColumnEnd\\": true,\\n\\t\\t\\"gridColumnStart\\": true,\\n\\t\\t\\"gridRow\\": true,\\n\\t\\t\\"gridRowEnd\\": true,\\n\\t\\t\\"gridRowStart\\": true,\\n\\t\\t\\"lineHeight\\": true,\\n\\t\\t\\"opacity\\": true,\\n\\t\\t\\"order\\": true,\\n\\t\\t\\"orphans\\": true,\\n\\t\\t\\"widows\\": true,\\n\\t\\t\\"zIndex\\": true,\\n\\t\\t\\"zoom\\": true\\n\\t},\\n\\n\\t// Add in properties whose names you wish to fix before\\n\\t// setting or getting the value\\n\\tcssProps: {},\\n\\n\\t// Get and set the style property on a DOM Node\\n\\tstyle: function( elem, name, value, extra ) {\\n\\n\\t\\t// Don\'t set styles on text and comment nodes\\n\\t\\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Make sure that we\'re working with the right name\\n\\t\\tvar ret, type, hooks,\\n\\t\\t\\torigName = camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name ),\\n\\t\\t\\tstyle = elem.style;\\n\\n\\t\\t// Make sure that we\'re working with the right name. We don\'t\\n\\t\\t// want to query the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Gets hook for the prefixed version, then unprefixed version\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// Check if we\'re setting a value\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\ttype = typeof value;\\n\\n\\t\\t\\t// Convert \\"+=\\" or \\"-=\\" to relative numbers (#7345)\\n\\t\\t\\tif ( type === \\"string\\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\\n\\t\\t\\t\\tvalue = adjustCSS( elem, name, ret );\\n\\n\\t\\t\\t\\t// Fixes bug #9237\\n\\t\\t\\t\\ttype = \\"number\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make sure that null and NaN values aren\'t set (#7116)\\n\\t\\t\\tif ( value == null || value !== value ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a number was passed in, add the unit (except for certain CSS properties)\\n\\t\\t\\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\\n\\t\\t\\t// \\"px\\" to a few hardcoded values.\\n\\t\\t\\tif ( type === \\"number\\" && !isCustomProp ) {\\n\\t\\t\\t\\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \\"\\" : \\"px\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// background-* props affect original clone\'s values\\n\\t\\t\\tif ( !support.clearCloneStyle && value === \\"\\" && name.indexOf( \\"background\\" ) === 0 ) {\\n\\t\\t\\t\\tstyle[ name ] = \\"inherit\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a hook was provided, use that value, otherwise just set the specified value\\n\\t\\t\\tif ( !hooks || !( \\"set\\" in hooks ) ||\\n\\t\\t\\t\\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\tif ( isCustomProp ) {\\n\\t\\t\\t\\t\\tstyle.setProperty( name, value );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstyle[ name ] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// If a hook was provided get the non-computed value from there\\n\\t\\t\\tif ( hooks && \\"get\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Otherwise just get the value from the style object\\n\\t\\t\\treturn style[ name ];\\n\\t\\t}\\n\\t},\\n\\n\\tcss: function( elem, name, extra, styles ) {\\n\\t\\tvar val, num, hooks,\\n\\t\\t\\torigName = camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name );\\n\\n\\t\\t// Make sure that we\'re working with the right name. We don\'t\\n\\t\\t// want to modify the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Try prefixed name followed by the unprefixed name\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// If a hook was provided get the computed value from there\\n\\t\\tif ( hooks && \\"get\\" in hooks ) {\\n\\t\\t\\tval = hooks.get( elem, true, extra );\\n\\t\\t}\\n\\n\\t\\t// Otherwise, if a way to get the computed value exists, use that\\n\\t\\tif ( val === undefined ) {\\n\\t\\t\\tval = curCSS( elem, name, styles );\\n\\t\\t}\\n\\n\\t\\t// Convert \\"normal\\" to computed value\\n\\t\\tif ( val === \\"normal\\" && name in cssNormalTransform ) {\\n\\t\\t\\tval = cssNormalTransform[ name ];\\n\\t\\t}\\n\\n\\t\\t// Make numeric if forced or a qualifier was provided and val looks numeric\\n\\t\\tif ( extra === \\"\\" || extra ) {\\n\\t\\t\\tnum = parseFloat( val );\\n\\t\\t\\treturn extra === true || isFinite( num ) ? num || 0 : val;\\n\\t\\t}\\n\\n\\t\\treturn val;\\n\\t}\\n} );\\n\\njQuery.each( [ \\"height\\", \\"width\\" ], function( _i, dimension ) {\\n\\tjQuery.cssHooks[ dimension ] = {\\n\\t\\tget: function( elem, computed, extra ) {\\n\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t// Certain elements can have dimension info if we invisibly show them\\n\\t\\t\\t\\t// but it must have a current display style that would benefit\\n\\t\\t\\t\\treturn rdisplayswap.test( jQuery.css( elem, \\"display\\" ) ) &&\\n\\n\\t\\t\\t\\t\\t// Support: Safari 8+\\n\\t\\t\\t\\t\\t// Table columns in Safari have non-zero offsetWidth & zero\\n\\t\\t\\t\\t\\t// getBoundingClientRect().width unless display is changed.\\n\\t\\t\\t\\t\\t// Support: IE <=11 only\\n\\t\\t\\t\\t\\t// Running getBoundingClientRect on a disconnected node\\n\\t\\t\\t\\t\\t// in IE throws an error.\\n\\t\\t\\t\\t\\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\\n\\t\\t\\t\\t\\t\\tswap( elem, cssShow, function() {\\n\\t\\t\\t\\t\\t\\t\\treturn getWidthOrHeight( elem, dimension, extra );\\n\\t\\t\\t\\t\\t\\t} ) :\\n\\t\\t\\t\\t\\t\\tgetWidthOrHeight( elem, dimension, extra );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tset: function( elem, value, extra ) {\\n\\t\\t\\tvar matches,\\n\\t\\t\\t\\tstyles = getStyles( elem ),\\n\\n\\t\\t\\t\\t// Only read styles.position if the test has a chance to fail\\n\\t\\t\\t\\t// to avoid forcing a reflow.\\n\\t\\t\\t\\tscrollboxSizeBuggy = !support.scrollboxSize() &&\\n\\t\\t\\t\\t\\tstyles.position === \\"absolute\\",\\n\\n\\t\\t\\t\\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\\n\\t\\t\\t\\tboxSizingNeeded = scrollboxSizeBuggy || extra,\\n\\t\\t\\t\\tisBorderBox = boxSizingNeeded &&\\n\\t\\t\\t\\t\\tjQuery.css( elem, \\"boxSizing\\", false, styles ) === \\"border-box\\",\\n\\t\\t\\t\\tsubtract = extra ?\\n\\t\\t\\t\\t\\tboxModelAdjustment(\\n\\t\\t\\t\\t\\t\\telem,\\n\\t\\t\\t\\t\\t\\tdimension,\\n\\t\\t\\t\\t\\t\\textra,\\n\\t\\t\\t\\t\\t\\tisBorderBox,\\n\\t\\t\\t\\t\\t\\tstyles\\n\\t\\t\\t\\t\\t) :\\n\\t\\t\\t\\t\\t0;\\n\\n\\t\\t\\t// Account for unreliable border-box dimensions by comparing offset* to computed and\\n\\t\\t\\t// faking a content-box to get border and padding (gh-3699)\\n\\t\\t\\tif ( isBorderBox && scrollboxSizeBuggy ) {\\n\\t\\t\\t\\tsubtract -= Math.ceil(\\n\\t\\t\\t\\t\\telem[ \\"offset\\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\\n\\t\\t\\t\\t\\tparseFloat( styles[ dimension ] ) -\\n\\t\\t\\t\\t\\tboxModelAdjustment( elem, dimension, \\"border\\", false, styles ) -\\n\\t\\t\\t\\t\\t0.5\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert to pixels if value adjustment is needed\\n\\t\\t\\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\\n\\t\\t\\t\\t( matches[ 3 ] || \\"px\\" ) !== \\"px\\" ) {\\n\\n\\t\\t\\t\\telem.style[ dimension ] = value;\\n\\t\\t\\t\\tvalue = jQuery.css( elem, dimension );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn setPositiveNumber( elem, value, subtract );\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\\n\\tfunction( elem, computed ) {\\n\\t\\tif ( computed ) {\\n\\t\\t\\treturn ( parseFloat( curCSS( elem, \\"marginLeft\\" ) ) ||\\n\\t\\t\\t\\telem.getBoundingClientRect().left -\\n\\t\\t\\t\\t\\tswap( elem, { marginLeft: 0 }, function() {\\n\\t\\t\\t\\t\\t\\treturn elem.getBoundingClientRect().left;\\n\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t) + \\"px\\";\\n\\t\\t}\\n\\t}\\n);\\n\\n// These hooks are used by animate to expand properties\\njQuery.each( {\\n\\tmargin: \\"\\",\\n\\tpadding: \\"\\",\\n\\tborder: \\"Width\\"\\n}, function( prefix, suffix ) {\\n\\tjQuery.cssHooks[ prefix + suffix ] = {\\n\\t\\texpand: function( value ) {\\n\\t\\t\\tvar i = 0,\\n\\t\\t\\t\\texpanded = {},\\n\\n\\t\\t\\t\\t// Assumes a single number if not a string\\n\\t\\t\\t\\tparts = typeof value === \\"string\\" ? value.split( \\" \\" ) : [ value ];\\n\\n\\t\\t\\tfor ( ; i < 4; i++ ) {\\n\\t\\t\\t\\texpanded[ prefix + cssExpand[ i ] + suffix ] =\\n\\t\\t\\t\\t\\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn expanded;\\n\\t\\t}\\n\\t};\\n\\n\\tif ( prefix !== \\"margin\\" ) {\\n\\t\\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tcss: function( name, value ) {\\n\\t\\treturn access( this, function( elem, name, value ) {\\n\\t\\t\\tvar styles, len,\\n\\t\\t\\t\\tmap = {},\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tif ( Array.isArray( name ) ) {\\n\\t\\t\\t\\tstyles = getStyles( elem );\\n\\t\\t\\t\\tlen = name.length;\\n\\n\\t\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\t\\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn map;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value !== undefined ?\\n\\t\\t\\t\\tjQuery.style( elem, name, value ) :\\n\\t\\t\\t\\tjQuery.css( elem, name );\\n\\t\\t}, name, value, arguments.length > 1 );\\n\\t}\\n} );\\n\\n\\nfunction Tween( elem, options, prop, end, easing ) {\\n\\treturn new Tween.prototype.init( elem, options, prop, end, easing );\\n}\\njQuery.Tween = Tween;\\n\\nTween.prototype = {\\n\\tconstructor: Tween,\\n\\tinit: function( elem, options, prop, end, easing, unit ) {\\n\\t\\tthis.elem = elem;\\n\\t\\tthis.prop = prop;\\n\\t\\tthis.easing = easing || jQuery.easing._default;\\n\\t\\tthis.options = options;\\n\\t\\tthis.start = this.now = this.cur();\\n\\t\\tthis.end = end;\\n\\t\\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \\"\\" : \\"px\\" );\\n\\t},\\n\\tcur: function() {\\n\\t\\tvar hooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\treturn hooks && hooks.get ?\\n\\t\\t\\thooks.get( this ) :\\n\\t\\t\\tTween.propHooks._default.get( this );\\n\\t},\\n\\trun: function( percent ) {\\n\\t\\tvar eased,\\n\\t\\t\\thooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\tif ( this.options.duration ) {\\n\\t\\t\\tthis.pos = eased = jQuery.easing[ this.easing ](\\n\\t\\t\\t\\tpercent, this.options.duration * percent, 0, 1, this.options.duration\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tthis.pos = eased = percent;\\n\\t\\t}\\n\\t\\tthis.now = ( this.end - this.start ) * eased + this.start;\\n\\n\\t\\tif ( this.options.step ) {\\n\\t\\t\\tthis.options.step.call( this.elem, this.now, this );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && hooks.set ) {\\n\\t\\t\\thooks.set( this );\\n\\t\\t} else {\\n\\t\\t\\tTween.propHooks._default.set( this );\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n};\\n\\nTween.prototype.init.prototype = Tween.prototype;\\n\\nTween.propHooks = {\\n\\t_default: {\\n\\t\\tget: function( tween ) {\\n\\t\\t\\tvar result;\\n\\n\\t\\t\\t// Use a property on the element directly when it is not a DOM element,\\n\\t\\t\\t// or when there is no matching style property that exists.\\n\\t\\t\\tif ( tween.elem.nodeType !== 1 ||\\n\\t\\t\\t\\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\\n\\t\\t\\t\\treturn tween.elem[ tween.prop ];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Passing an empty string as a 3rd parameter to .css will automatically\\n\\t\\t\\t// attempt a parseFloat and fallback to a string if the parse fails.\\n\\t\\t\\t// Simple values such as \\"10px\\" are parsed to Float;\\n\\t\\t\\t// complex values such as \\"rotate(1rad)\\" are returned as-is.\\n\\t\\t\\tresult = jQuery.css( tween.elem, tween.prop, \\"\\" );\\n\\n\\t\\t\\t// Empty strings, null, undefined and \\"auto\\" are converted to 0.\\n\\t\\t\\treturn !result || result === \\"auto\\" ? 0 : result;\\n\\t\\t},\\n\\t\\tset: function( tween ) {\\n\\n\\t\\t\\t// Use step hook for back compat.\\n\\t\\t\\t// Use cssHook if its there.\\n\\t\\t\\t// Use .style if available and use plain properties where available.\\n\\t\\t\\tif ( jQuery.fx.step[ tween.prop ] ) {\\n\\t\\t\\t\\tjQuery.fx.step[ tween.prop ]( tween );\\n\\t\\t\\t} else if ( tween.elem.nodeType === 1 && (\\n\\t\\t\\t\\t\\tjQuery.cssHooks[ tween.prop ] ||\\n\\t\\t\\t\\t\\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\\n\\t\\t\\t\\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n// Support: IE <=9 only\\n// Panic based approach to setting things on disconnected nodes\\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\\n\\tset: function( tween ) {\\n\\t\\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\\n\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.easing = {\\n\\tlinear: function( p ) {\\n\\t\\treturn p;\\n\\t},\\n\\tswing: function( p ) {\\n\\t\\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\\n\\t},\\n\\t_default: \\"swing\\"\\n};\\n\\njQuery.fx = Tween.prototype.init;\\n\\n// Back compat <1.8 extension point\\njQuery.fx.step = {};\\n\\n\\n\\n\\nvar\\n\\tfxNow, inProgress,\\n\\trfxtypes = /^(?:toggle|show|hide)$/,\\n\\trrun = /queueHooks$/;\\n\\nfunction schedule() {\\n\\tif ( inProgress ) {\\n\\t\\tif ( document.hidden === false && window.requestAnimationFrame ) {\\n\\t\\t\\twindow.requestAnimationFrame( schedule );\\n\\t\\t} else {\\n\\t\\t\\twindow.setTimeout( schedule, jQuery.fx.interval );\\n\\t\\t}\\n\\n\\t\\tjQuery.fx.tick();\\n\\t}\\n}\\n\\n// Animations created synchronously will run synchronously\\nfunction createFxNow() {\\n\\twindow.setTimeout( function() {\\n\\t\\tfxNow = undefined;\\n\\t} );\\n\\treturn ( fxNow = Date.now() );\\n}\\n\\n// Generate parameters to create a standard animation\\nfunction genFx( type, includeWidth ) {\\n\\tvar which,\\n\\t\\ti = 0,\\n\\t\\tattrs = { height: type };\\n\\n\\t// If we include width, step value is 1 to do all cssExpand values,\\n\\t// otherwise step value is 2 to skip over Left and Right\\n\\tincludeWidth = includeWidth ? 1 : 0;\\n\\tfor ( ; i < 4; i += 2 - includeWidth ) {\\n\\t\\twhich = cssExpand[ i ];\\n\\t\\tattrs[ \\"margin\\" + which ] = attrs[ \\"padding\\" + which ] = type;\\n\\t}\\n\\n\\tif ( includeWidth ) {\\n\\t\\tattrs.opacity = attrs.width = type;\\n\\t}\\n\\n\\treturn attrs;\\n}\\n\\nfunction createTween( value, prop, animation ) {\\n\\tvar tween,\\n\\t\\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \\"*\\" ] ),\\n\\t\\tindex = 0,\\n\\t\\tlength = collection.length;\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\\n\\n\\t\\t\\t// We\'re done with this property\\n\\t\\t\\treturn tween;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction defaultPrefilter( elem, props, opts ) {\\n\\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\\n\\t\\tisBox = \\"width\\" in props || \\"height\\" in props,\\n\\t\\tanim = this,\\n\\t\\torig = {},\\n\\t\\tstyle = elem.style,\\n\\t\\thidden = elem.nodeType && isHiddenWithinTree( elem ),\\n\\t\\tdataShow = dataPriv.get( elem, \\"fxshow\\" );\\n\\n\\t// Queue-skipping animations hijack the fx hooks\\n\\tif ( !opts.queue ) {\\n\\t\\thooks = jQuery._queueHooks( elem, \\"fx\\" );\\n\\t\\tif ( hooks.unqueued == null ) {\\n\\t\\t\\thooks.unqueued = 0;\\n\\t\\t\\toldfire = hooks.empty.fire;\\n\\t\\t\\thooks.empty.fire = function() {\\n\\t\\t\\t\\tif ( !hooks.unqueued ) {\\n\\t\\t\\t\\t\\toldfire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\thooks.unqueued++;\\n\\n\\t\\tanim.always( function() {\\n\\n\\t\\t\\t// Ensure the complete handler is called before this completes\\n\\t\\t\\tanim.always( function() {\\n\\t\\t\\t\\thooks.unqueued--;\\n\\t\\t\\t\\tif ( !jQuery.queue( elem, \\"fx\\" ).length ) {\\n\\t\\t\\t\\t\\thooks.empty.fire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\t// Detect show/hide animations\\n\\tfor ( prop in props ) {\\n\\t\\tvalue = props[ prop ];\\n\\t\\tif ( rfxtypes.test( value ) ) {\\n\\t\\t\\tdelete props[ prop ];\\n\\t\\t\\ttoggle = toggle || value === \\"toggle\\";\\n\\t\\t\\tif ( value === ( hidden ? \\"hide\\" : \\"show\\" ) ) {\\n\\n\\t\\t\\t\\t// Pretend to be hidden if this is a \\"show\\" and\\n\\t\\t\\t\\t// there is still data from a stopped show/hide\\n\\t\\t\\t\\tif ( value === \\"show\\" && dataShow && dataShow[ prop ] !== undefined ) {\\n\\t\\t\\t\\t\\thidden = true;\\n\\n\\t\\t\\t\\t// Ignore all other no-op show/hide data\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\\n\\t\\t}\\n\\t}\\n\\n\\t// Bail out if this is a no-op like .hide().hide()\\n\\tpropTween = !jQuery.isEmptyObject( props );\\n\\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Restrict \\"overflow\\" and \\"display\\" styles during box animations\\n\\tif ( isBox && elem.nodeType === 1 ) {\\n\\n\\t\\t// Support: IE <=9 - 11, Edge 12 - 15\\n\\t\\t// Record all 3 overflow attributes because IE does not infer the shorthand\\n\\t\\t// from identically-valued overflowX and overflowY and Edge just mirrors\\n\\t\\t// the overflowX value there.\\n\\t\\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\\n\\n\\t\\t// Identify a display type, preferring old show/hide data over the CSS cascade\\n\\t\\trestoreDisplay = dataShow && dataShow.display;\\n\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\trestoreDisplay = dataPriv.get( elem, \\"display\\" );\\n\\t\\t}\\n\\t\\tdisplay = jQuery.css( elem, \\"display\\" );\\n\\t\\tif ( display === \\"none\\" ) {\\n\\t\\t\\tif ( restoreDisplay ) {\\n\\t\\t\\t\\tdisplay = restoreDisplay;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Get nonempty value(s) by temporarily forcing visibility\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t\\trestoreDisplay = elem.style.display || restoreDisplay;\\n\\t\\t\\t\\tdisplay = jQuery.css( elem, \\"display\\" );\\n\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Animate inline elements as inline-block\\n\\t\\tif ( display === \\"inline\\" || display === \\"inline-block\\" && restoreDisplay != null ) {\\n\\t\\t\\tif ( jQuery.css( elem, \\"float\\" ) === \\"none\\" ) {\\n\\n\\t\\t\\t\\t// Restore the original display value at the end of pure show/hide animations\\n\\t\\t\\t\\tif ( !propTween ) {\\n\\t\\t\\t\\t\\tanim.done( function() {\\n\\t\\t\\t\\t\\t\\tstyle.display = restoreDisplay;\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\t\\t\\t\\tdisplay = style.display;\\n\\t\\t\\t\\t\\t\\trestoreDisplay = display === \\"none\\" ? \\"\\" : display;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstyle.display = \\"inline-block\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( opts.overflow ) {\\n\\t\\tstyle.overflow = \\"hidden\\";\\n\\t\\tanim.always( function() {\\n\\t\\t\\tstyle.overflow = opts.overflow[ 0 ];\\n\\t\\t\\tstyle.overflowX = opts.overflow[ 1 ];\\n\\t\\t\\tstyle.overflowY = opts.overflow[ 2 ];\\n\\t\\t} );\\n\\t}\\n\\n\\t// Implement show/hide animations\\n\\tpropTween = false;\\n\\tfor ( prop in orig ) {\\n\\n\\t\\t// General show/hide setup for this element animation\\n\\t\\tif ( !propTween ) {\\n\\t\\t\\tif ( dataShow ) {\\n\\t\\t\\t\\tif ( \\"hidden\\" in dataShow ) {\\n\\t\\t\\t\\t\\thidden = dataShow.hidden;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdataShow = dataPriv.access( elem, \\"fxshow\\", { display: restoreDisplay } );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Store hidden/visible for toggle so `.stop().toggle()` \\"reverses\\"\\n\\t\\t\\tif ( toggle ) {\\n\\t\\t\\t\\tdataShow.hidden = !hidden;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Show elements before animating them\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* eslint-disable no-loop-func */\\n\\n\\t\\t\\tanim.done( function() {\\n\\n\\t\\t\\t/* eslint-enable no-loop-func */\\n\\n\\t\\t\\t\\t// The final step of a \\"hide\\" animation is actually hiding the element\\n\\t\\t\\t\\tif ( !hidden ) {\\n\\t\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.remove( elem, \\"fxshow\\" );\\n\\t\\t\\t\\tfor ( prop in orig ) {\\n\\t\\t\\t\\t\\tjQuery.style( elem, prop, orig[ prop ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\t// Per-property setup\\n\\t\\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\\n\\t\\tif ( !( prop in dataShow ) ) {\\n\\t\\t\\tdataShow[ prop ] = propTween.start;\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tpropTween.end = propTween.start;\\n\\t\\t\\t\\tpropTween.start = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction propFilter( props, specialEasing ) {\\n\\tvar index, name, easing, value, hooks;\\n\\n\\t// camelCase, specialEasing and expand cssHook pass\\n\\tfor ( index in props ) {\\n\\t\\tname = camelCase( index );\\n\\t\\teasing = specialEasing[ name ];\\n\\t\\tvalue = props[ index ];\\n\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\teasing = value[ 1 ];\\n\\t\\t\\tvalue = props[ index ] = value[ 0 ];\\n\\t\\t}\\n\\n\\t\\tif ( index !== name ) {\\n\\t\\t\\tprops[ name ] = value;\\n\\t\\t\\tdelete props[ index ];\\n\\t\\t}\\n\\n\\t\\thooks = jQuery.cssHooks[ name ];\\n\\t\\tif ( hooks && \\"expand\\" in hooks ) {\\n\\t\\t\\tvalue = hooks.expand( value );\\n\\t\\t\\tdelete props[ name ];\\n\\n\\t\\t\\t// Not quite $.extend, this won\'t overwrite existing keys.\\n\\t\\t\\t// Reusing \'index\' because we have the correct \\"name\\"\\n\\t\\t\\tfor ( index in value ) {\\n\\t\\t\\t\\tif ( !( index in props ) ) {\\n\\t\\t\\t\\t\\tprops[ index ] = value[ index ];\\n\\t\\t\\t\\t\\tspecialEasing[ index ] = easing;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tspecialEasing[ name ] = easing;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction Animation( elem, properties, options ) {\\n\\tvar result,\\n\\t\\tstopped,\\n\\t\\tindex = 0,\\n\\t\\tlength = Animation.prefilters.length,\\n\\t\\tdeferred = jQuery.Deferred().always( function() {\\n\\n\\t\\t\\t// Don\'t match elem in the :animated selector\\n\\t\\t\\tdelete tick.elem;\\n\\t\\t} ),\\n\\t\\ttick = function() {\\n\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tvar currentTime = fxNow || createFxNow(),\\n\\t\\t\\t\\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\\n\\n\\t\\t\\t\\t// Support: Android 2.3 only\\n\\t\\t\\t\\t// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\\n\\t\\t\\t\\ttemp = remaining / animation.duration || 0,\\n\\t\\t\\t\\tpercent = 1 - temp,\\n\\t\\t\\t\\tindex = 0,\\n\\t\\t\\t\\tlength = animation.tweens.length;\\n\\n\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\tanimation.tweens[ index ].run( percent );\\n\\t\\t\\t}\\n\\n\\t\\t\\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\\n\\n\\t\\t\\t// If there\'s more to do, yield\\n\\t\\t\\tif ( percent < 1 && length ) {\\n\\t\\t\\t\\treturn remaining;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If this was an empty animation, synthesize a final progress notification\\n\\t\\t\\tif ( !length ) {\\n\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Resolve the animation and report its conclusion\\n\\t\\t\\tdeferred.resolveWith( elem, [ animation ] );\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tanimation = deferred.promise( {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tprops: jQuery.extend( {}, properties ),\\n\\t\\t\\topts: jQuery.extend( true, {\\n\\t\\t\\t\\tspecialEasing: {},\\n\\t\\t\\t\\teasing: jQuery.easing._default\\n\\t\\t\\t}, options ),\\n\\t\\t\\toriginalProperties: properties,\\n\\t\\t\\toriginalOptions: options,\\n\\t\\t\\tstartTime: fxNow || createFxNow(),\\n\\t\\t\\tduration: options.duration,\\n\\t\\t\\ttweens: [],\\n\\t\\t\\tcreateTween: function( prop, end ) {\\n\\t\\t\\t\\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\\n\\t\\t\\t\\t\\t\\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\\n\\t\\t\\t\\tanimation.tweens.push( tween );\\n\\t\\t\\t\\treturn tween;\\n\\t\\t\\t},\\n\\t\\t\\tstop: function( gotoEnd ) {\\n\\t\\t\\t\\tvar index = 0,\\n\\n\\t\\t\\t\\t\\t// If we are going to the end, we want to run all the tweens\\n\\t\\t\\t\\t\\t// otherwise we skip this part\\n\\t\\t\\t\\t\\tlength = gotoEnd ? animation.tweens.length : 0;\\n\\t\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstopped = true;\\n\\t\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\t\\tanimation.tweens[ index ].run( 1 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Resolve when we played the last frame; otherwise, reject\\n\\t\\t\\t\\tif ( gotoEnd ) {\\n\\t\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t\\t\\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t} ),\\n\\t\\tprops = animation.props;\\n\\n\\tpropFilter( props, animation.opts.specialEasing );\\n\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\\n\\t\\tif ( result ) {\\n\\t\\t\\tif ( isFunction( result.stop ) ) {\\n\\t\\t\\t\\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\\n\\t\\t\\t\\t\\tresult.stop.bind( result );\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\n\\tjQuery.map( props, createTween, animation );\\n\\n\\tif ( isFunction( animation.opts.start ) ) {\\n\\t\\tanimation.opts.start.call( elem, animation );\\n\\t}\\n\\n\\t// Attach callbacks from options\\n\\tanimation\\n\\t\\t.progress( animation.opts.progress )\\n\\t\\t.done( animation.opts.done, animation.opts.complete )\\n\\t\\t.fail( animation.opts.fail )\\n\\t\\t.always( animation.opts.always );\\n\\n\\tjQuery.fx.timer(\\n\\t\\tjQuery.extend( tick, {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tanim: animation,\\n\\t\\t\\tqueue: animation.opts.queue\\n\\t\\t} )\\n\\t);\\n\\n\\treturn animation;\\n}\\n\\njQuery.Animation = jQuery.extend( Animation, {\\n\\n\\ttweeners: {\\n\\t\\t\\"*\\": [ function( prop, value ) {\\n\\t\\t\\tvar tween = this.createTween( prop, value );\\n\\t\\t\\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\\n\\t\\t\\treturn tween;\\n\\t\\t} ]\\n\\t},\\n\\n\\ttweener: function( props, callback ) {\\n\\t\\tif ( isFunction( props ) ) {\\n\\t\\t\\tcallback = props;\\n\\t\\t\\tprops = [ \\"*\\" ];\\n\\t\\t} else {\\n\\t\\t\\tprops = props.match( rnothtmlwhite );\\n\\t\\t}\\n\\n\\t\\tvar prop,\\n\\t\\t\\tindex = 0,\\n\\t\\t\\tlength = props.length;\\n\\n\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\tprop = props[ index ];\\n\\t\\t\\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\\n\\t\\t\\tAnimation.tweeners[ prop ].unshift( callback );\\n\\t\\t}\\n\\t},\\n\\n\\tprefilters: [ defaultPrefilter ],\\n\\n\\tprefilter: function( callback, prepend ) {\\n\\t\\tif ( prepend ) {\\n\\t\\t\\tAnimation.prefilters.unshift( callback );\\n\\t\\t} else {\\n\\t\\t\\tAnimation.prefilters.push( callback );\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.speed = function( speed, easing, fn ) {\\n\\tvar opt = speed && typeof speed === \\"object\\" ? jQuery.extend( {}, speed ) : {\\n\\t\\tcomplete: fn || !fn && easing ||\\n\\t\\t\\tisFunction( speed ) && speed,\\n\\t\\tduration: speed,\\n\\t\\teasing: fn && easing || easing && !isFunction( easing ) && easing\\n\\t};\\n\\n\\t// Go to the end state if fx are off\\n\\tif ( jQuery.fx.off ) {\\n\\t\\topt.duration = 0;\\n\\n\\t} else {\\n\\t\\tif ( typeof opt.duration !== \\"number\\" ) {\\n\\t\\t\\tif ( opt.duration in jQuery.fx.speeds ) {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds[ opt.duration ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds._default;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Normalize opt.queue - true/undefined/null -> \\"fx\\"\\n\\tif ( opt.queue == null || opt.queue === true ) {\\n\\t\\topt.queue = \\"fx\\";\\n\\t}\\n\\n\\t// Queueing\\n\\topt.old = opt.complete;\\n\\n\\topt.complete = function() {\\n\\t\\tif ( isFunction( opt.old ) ) {\\n\\t\\t\\topt.old.call( this );\\n\\t\\t}\\n\\n\\t\\tif ( opt.queue ) {\\n\\t\\t\\tjQuery.dequeue( this, opt.queue );\\n\\t\\t}\\n\\t};\\n\\n\\treturn opt;\\n};\\n\\njQuery.fn.extend( {\\n\\tfadeTo: function( speed, to, easing, callback ) {\\n\\n\\t\\t// Show any hidden elements after setting opacity to 0\\n\\t\\treturn this.filter( isHiddenWithinTree ).css( \\"opacity\\", 0 ).show()\\n\\n\\t\\t\\t// Animate to the value specified\\n\\t\\t\\t.end().animate( { opacity: to }, speed, easing, callback );\\n\\t},\\n\\tanimate: function( prop, speed, easing, callback ) {\\n\\t\\tvar empty = jQuery.isEmptyObject( prop ),\\n\\t\\t\\toptall = jQuery.speed( speed, easing, callback ),\\n\\t\\t\\tdoAnimation = function() {\\n\\n\\t\\t\\t\\t// Operate on a copy of prop so per-property easing won\'t be lost\\n\\t\\t\\t\\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\\n\\n\\t\\t\\t\\t// Empty animations, or finishing resolves immediately\\n\\t\\t\\t\\tif ( empty || dataPriv.get( this, \\"finish\\" ) ) {\\n\\t\\t\\t\\t\\tanim.stop( true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tdoAnimation.finish = doAnimation;\\n\\n\\t\\treturn empty || optall.queue === false ?\\n\\t\\t\\tthis.each( doAnimation ) :\\n\\t\\t\\tthis.queue( optall.queue, doAnimation );\\n\\t},\\n\\tstop: function( type, clearQueue, gotoEnd ) {\\n\\t\\tvar stopQueue = function( hooks ) {\\n\\t\\t\\tvar stop = hooks.stop;\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tstop( gotoEnd );\\n\\t\\t};\\n\\n\\t\\tif ( typeof type !== \\"string\\" ) {\\n\\t\\t\\tgotoEnd = clearQueue;\\n\\t\\t\\tclearQueue = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\tif ( clearQueue ) {\\n\\t\\t\\tthis.queue( type || \\"fx\\", [] );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar dequeue = true,\\n\\t\\t\\t\\tindex = type != null && type + \\"queueHooks\\",\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tdata = dataPriv.get( this );\\n\\n\\t\\t\\tif ( index ) {\\n\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop ) {\\n\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor ( index in data ) {\\n\\t\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\\n\\t\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this &&\\n\\t\\t\\t\\t\\t( type == null || timers[ index ].queue === type ) ) {\\n\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( gotoEnd );\\n\\t\\t\\t\\t\\tdequeue = false;\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Start the next in the queue if the last step wasn\'t forced.\\n\\t\\t\\t// Timers currently will call their complete callbacks, which\\n\\t\\t\\t// will dequeue but only if they were gotoEnd.\\n\\t\\t\\tif ( dequeue || !gotoEnd ) {\\n\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\tfinish: function( type ) {\\n\\t\\tif ( type !== false ) {\\n\\t\\t\\ttype = type || \\"fx\\";\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar index,\\n\\t\\t\\t\\tdata = dataPriv.get( this ),\\n\\t\\t\\t\\tqueue = data[ type + \\"queue\\" ],\\n\\t\\t\\t\\thooks = data[ type + \\"queueHooks\\" ],\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tlength = queue ? queue.length : 0;\\n\\n\\t\\t\\t// Enable finishing flag on private data\\n\\t\\t\\tdata.finish = true;\\n\\n\\t\\t\\t// Empty the queue first\\n\\t\\t\\tjQuery.queue( this, type, [] );\\n\\n\\t\\t\\tif ( hooks && hooks.stop ) {\\n\\t\\t\\t\\thooks.stop.call( this, true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any active animations, and finish them\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( true );\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any animations in the old queue and finish them\\n\\t\\t\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\t\\t\\tif ( queue[ index ] && queue[ index ].finish ) {\\n\\t\\t\\t\\t\\tqueue[ index ].finish.call( this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Turn off finishing flag\\n\\t\\t\\tdelete data.finish;\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.each( [ \\"toggle\\", \\"show\\", \\"hide\\" ], function( _i, name ) {\\n\\tvar cssFn = jQuery.fn[ name ];\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn speed == null || typeof speed === \\"boolean\\" ?\\n\\t\\t\\tcssFn.apply( this, arguments ) :\\n\\t\\t\\tthis.animate( genFx( name, true ), speed, easing, callback );\\n\\t};\\n} );\\n\\n// Generate shortcuts for custom animations\\njQuery.each( {\\n\\tslideDown: genFx( \\"show\\" ),\\n\\tslideUp: genFx( \\"hide\\" ),\\n\\tslideToggle: genFx( \\"toggle\\" ),\\n\\tfadeIn: { opacity: \\"show\\" },\\n\\tfadeOut: { opacity: \\"hide\\" },\\n\\tfadeToggle: { opacity: \\"toggle\\" }\\n}, function( name, props ) {\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn this.animate( props, speed, easing, callback );\\n\\t};\\n} );\\n\\njQuery.timers = [];\\njQuery.fx.tick = function() {\\n\\tvar timer,\\n\\t\\ti = 0,\\n\\t\\ttimers = jQuery.timers;\\n\\n\\tfxNow = Date.now();\\n\\n\\tfor ( ; i < timers.length; i++ ) {\\n\\t\\ttimer = timers[ i ];\\n\\n\\t\\t// Run the timer and safely remove it when done (allowing for external removal)\\n\\t\\tif ( !timer() && timers[ i ] === timer ) {\\n\\t\\t\\ttimers.splice( i--, 1 );\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !timers.length ) {\\n\\t\\tjQuery.fx.stop();\\n\\t}\\n\\tfxNow = undefined;\\n};\\n\\njQuery.fx.timer = function( timer ) {\\n\\tjQuery.timers.push( timer );\\n\\tjQuery.fx.start();\\n};\\n\\njQuery.fx.interval = 13;\\njQuery.fx.start = function() {\\n\\tif ( inProgress ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tinProgress = true;\\n\\tschedule();\\n};\\n\\njQuery.fx.stop = function() {\\n\\tinProgress = null;\\n};\\n\\njQuery.fx.speeds = {\\n\\tslow: 600,\\n\\tfast: 200,\\n\\n\\t// Default speed\\n\\t_default: 400\\n};\\n\\n\\n// Based off of the plugin by Clint Helfers, with permission.\\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\\njQuery.fn.delay = function( time, type ) {\\n\\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\\n\\ttype = type || \\"fx\\";\\n\\n\\treturn this.queue( type, function( next, hooks ) {\\n\\t\\tvar timeout = window.setTimeout( next, time );\\n\\t\\thooks.stop = function() {\\n\\t\\t\\twindow.clearTimeout( timeout );\\n\\t\\t};\\n\\t} );\\n};\\n\\n\\n( function() {\\n\\tvar input = document.createElement( \\"input\\" ),\\n\\t\\tselect = document.createElement( \\"select\\" ),\\n\\t\\topt = select.appendChild( document.createElement( \\"option\\" ) );\\n\\n\\tinput.type = \\"checkbox\\";\\n\\n\\t// Support: Android <=4.3 only\\n\\t// Default value for a checkbox should be \\"on\\"\\n\\tsupport.checkOn = input.value !== \\"\\";\\n\\n\\t// Support: IE <=11 only\\n\\t// Must access selectedIndex to make default options select\\n\\tsupport.optSelected = opt.selected;\\n\\n\\t// Support: IE <=11 only\\n\\t// An input loses its value after becoming a radio\\n\\tinput = document.createElement( \\"input\\" );\\n\\tinput.value = \\"t\\";\\n\\tinput.type = \\"radio\\";\\n\\tsupport.radioValue = input.value === \\"t\\";\\n} )();\\n\\n\\nvar boolHook,\\n\\tattrHandle = jQuery.expr.attrHandle;\\n\\njQuery.fn.extend( {\\n\\tattr: function( name, value ) {\\n\\t\\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveAttr: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.removeAttr( this, name );\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tattr: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don\'t get/set attributes on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Fallback to prop when attributes are not supported\\n\\t\\tif ( typeof elem.getAttribute === \\"undefined\\" ) {\\n\\t\\t\\treturn jQuery.prop( elem, name, value );\\n\\t\\t}\\n\\n\\t\\t// Attribute hooks are determined by the lowercase version\\n\\t\\t// Grab necessary hook if one is defined\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\t\\t\\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\\n\\t\\t\\t\\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( value === null ) {\\n\\t\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hooks && \\"set\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\telem.setAttribute( name, value + \\"\\" );\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \\"get\\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\tret = jQuery.find.attr( elem, name );\\n\\n\\t\\t// Non-existent attributes return null, we normalize to undefined\\n\\t\\treturn ret == null ? undefined : ret;\\n\\t},\\n\\n\\tattrHooks: {\\n\\t\\ttype: {\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tif ( !support.radioValue && value === \\"radio\\" &&\\n\\t\\t\\t\\t\\tnodeName( elem, \\"input\\" ) ) {\\n\\t\\t\\t\\t\\tvar val = elem.value;\\n\\t\\t\\t\\t\\telem.setAttribute( \\"type\\", value );\\n\\t\\t\\t\\t\\tif ( val ) {\\n\\t\\t\\t\\t\\t\\telem.value = val;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tremoveAttr: function( elem, value ) {\\n\\t\\tvar name,\\n\\t\\t\\ti = 0,\\n\\n\\t\\t\\t// Attribute names can contain non-HTML whitespace characters\\n\\t\\t\\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\\n\\t\\t\\tattrNames = value && value.match( rnothtmlwhite );\\n\\n\\t\\tif ( attrNames && elem.nodeType === 1 ) {\\n\\t\\t\\twhile ( ( name = attrNames[ i++ ] ) ) {\\n\\t\\t\\t\\telem.removeAttribute( name );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Hooks for boolean attributes\\nboolHook = {\\n\\tset: function( elem, value, name ) {\\n\\t\\tif ( value === false ) {\\n\\n\\t\\t\\t// Remove boolean attributes when set to false\\n\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t} else {\\n\\t\\t\\telem.setAttribute( name, name );\\n\\t\\t}\\n\\t\\treturn name;\\n\\t}\\n};\\n\\njQuery.each( jQuery.expr.match.bool.source.match( /\\\\w+/g ), function( _i, name ) {\\n\\tvar getter = attrHandle[ name ] || jQuery.find.attr;\\n\\n\\tattrHandle[ name ] = function( elem, name, isXML ) {\\n\\t\\tvar ret, handle,\\n\\t\\t\\tlowercaseName = name.toLowerCase();\\n\\n\\t\\tif ( !isXML ) {\\n\\n\\t\\t\\t// Avoid an infinite loop by temporarily removing this function from the getter\\n\\t\\t\\thandle = attrHandle[ lowercaseName ];\\n\\t\\t\\tattrHandle[ lowercaseName ] = ret;\\n\\t\\t\\tret = getter( elem, name, isXML ) != null ?\\n\\t\\t\\t\\tlowercaseName :\\n\\t\\t\\t\\tnull;\\n\\t\\t\\tattrHandle[ lowercaseName ] = handle;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t};\\n} );\\n\\n\\n\\n\\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\\n\\trclickable = /^(?:a|area)$/i;\\n\\njQuery.fn.extend( {\\n\\tprop: function( name, value ) {\\n\\t\\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveProp: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdelete this[ jQuery.propFix[ name ] || name ];\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tprop: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don\'t get/set properties on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// Fix name and attach hooks\\n\\t\\t\\tname = jQuery.propFix[ name ] || name;\\n\\t\\t\\thooks = jQuery.propHooks[ name ];\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( hooks && \\"set\\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( elem[ name ] = value );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \\"get\\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\treturn elem[ name ];\\n\\t},\\n\\n\\tpropHooks: {\\n\\t\\ttabIndex: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t\\t\\t// elem.tabIndex doesn\'t always return the\\n\\t\\t\\t\\t// correct value when it hasn\'t been explicitly set\\n\\t\\t\\t\\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\\n\\t\\t\\t\\t// Use proper attribute retrieval(#12072)\\n\\t\\t\\t\\tvar tabindex = jQuery.find.attr( elem, \\"tabindex\\" );\\n\\n\\t\\t\\t\\tif ( tabindex ) {\\n\\t\\t\\t\\t\\treturn parseInt( tabindex, 10 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\trfocusable.test( elem.nodeName ) ||\\n\\t\\t\\t\\t\\trclickable.test( elem.nodeName ) &&\\n\\t\\t\\t\\t\\telem.href\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tpropFix: {\\n\\t\\t\\"for\\": \\"htmlFor\\",\\n\\t\\t\\"class\\": \\"className\\"\\n\\t}\\n} );\\n\\n// Support: IE <=11 only\\n// Accessing the selectedIndex property\\n// forces the browser to respect setting selected\\n// on the option\\n// The getter ensures a default option is selected\\n// when in an optgroup\\n// eslint rule \\"no-unused-expressions\\" is disabled for this code\\n// since it considers such accessions noop\\nif ( !support.optSelected ) {\\n\\tjQuery.propHooks.selected = {\\n\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \\"off\\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent && parent.parentNode ) {\\n\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tset: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \\"off\\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\tparent.selectedIndex;\\n\\n\\t\\t\\t\\tif ( parent.parentNode ) {\\n\\t\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\njQuery.each( [\\n\\t\\"tabIndex\\",\\n\\t\\"readOnly\\",\\n\\t\\"maxLength\\",\\n\\t\\"cellSpacing\\",\\n\\t\\"cellPadding\\",\\n\\t\\"rowSpan\\",\\n\\t\\"colSpan\\",\\n\\t\\"useMap\\",\\n\\t\\"frameBorder\\",\\n\\t\\"contentEditable\\"\\n], function() {\\n\\tjQuery.propFix[ this.toLowerCase() ] = this;\\n} );\\n\\n\\n\\n\\n\\t// Strip and collapse whitespace according to HTML spec\\n\\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\\n\\tfunction stripAndCollapse( value ) {\\n\\t\\tvar tokens = value.match( rnothtmlwhite ) || [];\\n\\t\\treturn tokens.join( \\" \\" );\\n\\t}\\n\\n\\nfunction getClass( elem ) {\\n\\treturn elem.getAttribute && elem.getAttribute( \\"class\\" ) || \\"\\";\\n}\\n\\nfunction classesToArray( value ) {\\n\\tif ( Array.isArray( value ) ) {\\n\\t\\treturn value;\\n\\t}\\n\\tif ( typeof value === \\"string\\" ) {\\n\\t\\treturn value.match( rnothtmlwhite ) || [];\\n\\t}\\n\\treturn [];\\n}\\n\\njQuery.fn.extend( {\\n\\taddClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tclasses = classesToArray( value );\\n\\n\\t\\tif ( classes.length ) {\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \\" \\" + stripAndCollapse( curValue ) + \\" \\" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\t\\t\\t\\t\\t\\tif ( cur.indexOf( \\" \\" + clazz + \\" \\" ) < 0 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur += clazz + \\" \\";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \\"class\\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tremoveClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\treturn this.attr( \\"class\\", \\"\\" );\\n\\t\\t}\\n\\n\\t\\tclasses = classesToArray( value );\\n\\n\\t\\tif ( classes.length ) {\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\n\\t\\t\\t\\t// This expression is here for better compressibility (see addClass)\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \\" \\" + stripAndCollapse( curValue ) + \\" \\" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Remove *all* instances\\n\\t\\t\\t\\t\\t\\twhile ( cur.indexOf( \\" \\" + clazz + \\" \\" ) > -1 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur = cur.replace( \\" \\" + clazz + \\" \\", \\" \\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \\"class\\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\ttoggleClass: function( value, stateVal ) {\\n\\t\\tvar type = typeof value,\\n\\t\\t\\tisValidValue = type === \\"string\\" || Array.isArray( value );\\n\\n\\t\\tif ( typeof stateVal === \\"boolean\\" && isValidValue ) {\\n\\t\\t\\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\\n\\t\\t}\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).toggleClass(\\n\\t\\t\\t\\t\\tvalue.call( this, i, getClass( this ), stateVal ),\\n\\t\\t\\t\\t\\tstateVal\\n\\t\\t\\t\\t);\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar className, i, self, classNames;\\n\\n\\t\\t\\tif ( isValidValue ) {\\n\\n\\t\\t\\t\\t// Toggle individual class names\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\tself = jQuery( this );\\n\\t\\t\\t\\tclassNames = classesToArray( value );\\n\\n\\t\\t\\t\\twhile ( ( className = classNames[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t// Check each className given, space separated list\\n\\t\\t\\t\\t\\tif ( self.hasClass( className ) ) {\\n\\t\\t\\t\\t\\t\\tself.removeClass( className );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tself.addClass( className );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// Toggle whole class name\\n\\t\\t\\t} else if ( value === undefined || type === \\"boolean\\" ) {\\n\\t\\t\\t\\tclassName = getClass( this );\\n\\t\\t\\t\\tif ( className ) {\\n\\n\\t\\t\\t\\t\\t// Store className if set\\n\\t\\t\\t\\t\\tdataPriv.set( this, \\"__className__\\", className );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the element has a class name or if we\'re passed `false`,\\n\\t\\t\\t\\t// then remove the whole classname (if there was one, the above saved it).\\n\\t\\t\\t\\t// Otherwise bring back whatever was previously saved (if anything),\\n\\t\\t\\t\\t// falling back to the empty string if nothing was stored.\\n\\t\\t\\t\\tif ( this.setAttribute ) {\\n\\t\\t\\t\\t\\tthis.setAttribute( \\"class\\",\\n\\t\\t\\t\\t\\t\\tclassName || value === false ?\\n\\t\\t\\t\\t\\t\\t\\"\\" :\\n\\t\\t\\t\\t\\t\\tdataPriv.get( this, \\"__className__\\" ) || \\"\\"\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\thasClass: function( selector ) {\\n\\t\\tvar className, elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tclassName = \\" \\" + selector + \\" \\";\\n\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\tif ( elem.nodeType === 1 &&\\n\\t\\t\\t\\t( \\" \\" + stripAndCollapse( getClass( elem ) ) + \\" \\" ).indexOf( className ) > -1 ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n} );\\n\\n\\n\\n\\nvar rreturn = /\\\\r/g;\\n\\njQuery.fn.extend( {\\n\\tval: function( value ) {\\n\\t\\tvar hooks, ret, valueIsFunction,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\thooks = jQuery.valHooks[ elem.type ] ||\\n\\t\\t\\t\\t\\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t\\tif ( hooks &&\\n\\t\\t\\t\\t\\t\\"get\\" in hooks &&\\n\\t\\t\\t\\t\\t( ret = hooks.get( elem, \\"value\\" ) ) !== undefined\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tret = elem.value;\\n\\n\\t\\t\\t\\t// Handle most common string cases\\n\\t\\t\\t\\tif ( typeof ret === \\"string\\" ) {\\n\\t\\t\\t\\t\\treturn ret.replace( rreturn, \\"\\" );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Handle cases where value is null/undef or number\\n\\t\\t\\t\\treturn ret == null ? \\"\\" : ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvalueIsFunction = isFunction( value );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tvar val;\\n\\n\\t\\t\\tif ( this.nodeType !== 1 ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( valueIsFunction ) {\\n\\t\\t\\t\\tval = value.call( this, i, jQuery( this ).val() );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tval = value;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Treat null/undefined as \\"\\"; convert numbers to string\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\tval = \\"\\";\\n\\n\\t\\t\\t} else if ( typeof val === \\"number\\" ) {\\n\\t\\t\\t\\tval += \\"\\";\\n\\n\\t\\t\\t} else if ( Array.isArray( val ) ) {\\n\\t\\t\\t\\tval = jQuery.map( val, function( value ) {\\n\\t\\t\\t\\t\\treturn value == null ? \\"\\" : value + \\"\\";\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t// If set returns undefined, fall back to normal setting\\n\\t\\t\\tif ( !hooks || !( \\"set\\" in hooks ) || hooks.set( this, val, \\"value\\" ) === undefined ) {\\n\\t\\t\\t\\tthis.value = val;\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tvalHooks: {\\n\\t\\toption: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\tvar val = jQuery.find.attr( elem, \\"value\\" );\\n\\t\\t\\t\\treturn val != null ?\\n\\t\\t\\t\\t\\tval :\\n\\n\\t\\t\\t\\t\\t// Support: IE <=10 - 11 only\\n\\t\\t\\t\\t\\t// option.text throws exceptions (#14686, #14858)\\n\\t\\t\\t\\t\\t// Strip and collapse whitespace\\n\\t\\t\\t\\t\\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\\n\\t\\t\\t\\t\\tstripAndCollapse( jQuery.text( elem ) );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tselect: {\\n\\t\\t\\tget: function( elem ) {\\n\\t\\t\\t\\tvar value, option, i,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tindex = elem.selectedIndex,\\n\\t\\t\\t\\t\\tone = elem.type === \\"select-one\\",\\n\\t\\t\\t\\t\\tvalues = one ? null : [],\\n\\t\\t\\t\\t\\tmax = one ? index + 1 : options.length;\\n\\n\\t\\t\\t\\tif ( index < 0 ) {\\n\\t\\t\\t\\t\\ti = max;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ti = one ? index : 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Loop through all the selected options\\n\\t\\t\\t\\tfor ( ; i < max; i++ ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t// IE8-9 doesn\'t update selected after form reset (#2551)\\n\\t\\t\\t\\t\\tif ( ( option.selected || i === index ) &&\\n\\n\\t\\t\\t\\t\\t\\t\\t// Don\'t return options that are disabled or in a disabled optgroup\\n\\t\\t\\t\\t\\t\\t\\t!option.disabled &&\\n\\t\\t\\t\\t\\t\\t\\t( !option.parentNode.disabled ||\\n\\t\\t\\t\\t\\t\\t\\t\\t!nodeName( option.parentNode, \\"optgroup\\" ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Get the specific value for the option\\n\\t\\t\\t\\t\\t\\tvalue = jQuery( option ).val();\\n\\n\\t\\t\\t\\t\\t\\t// We don\'t need an array for one selects\\n\\t\\t\\t\\t\\t\\tif ( one ) {\\n\\t\\t\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Multi-Selects return an array\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tvar optionSet, option,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tvalues = jQuery.makeArray( value ),\\n\\t\\t\\t\\t\\ti = options.length;\\n\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t/* eslint-disable no-cond-assign */\\n\\n\\t\\t\\t\\t\\tif ( option.selected =\\n\\t\\t\\t\\t\\t\\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\toptionSet = true;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t/* eslint-enable no-cond-assign */\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Force browsers to behave consistently when non-matching value is set\\n\\t\\t\\t\\tif ( !optionSet ) {\\n\\t\\t\\t\\t\\telem.selectedIndex = -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Radios and checkboxes getter/setter\\njQuery.each( [ \\"radio\\", \\"checkbox\\" ], function() {\\n\\tjQuery.valHooks[ this ] = {\\n\\t\\tset: function( elem, value ) {\\n\\t\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\t\\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tif ( !support.checkOn ) {\\n\\t\\tjQuery.valHooks[ this ].get = function( elem ) {\\n\\t\\t\\treturn elem.getAttribute( \\"value\\" ) === null ? \\"on\\" : elem.value;\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Return jQuery for attributes-only inclusion\\n\\n\\nsupport.focusin = \\"onfocusin\\" in window;\\n\\n\\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\\n\\tstopPropagationCallback = function( e ) {\\n\\t\\te.stopPropagation();\\n\\t};\\n\\njQuery.extend( jQuery.event, {\\n\\n\\ttrigger: function( event, data, elem, onlyHandlers ) {\\n\\n\\t\\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\\n\\t\\t\\teventPath = [ elem || document ],\\n\\t\\t\\ttype = hasOwn.call( event, \\"type\\" ) ? event.type : event,\\n\\t\\t\\tnamespaces = hasOwn.call( event, \\"namespace\\" ) ? event.namespace.split( \\".\\" ) : [];\\n\\n\\t\\tcur = lastElement = tmp = elem = elem || document;\\n\\n\\t\\t// Don\'t do events on text and comment nodes\\n\\t\\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\\n\\t\\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( type.indexOf( \\".\\" ) > -1 ) {\\n\\n\\t\\t\\t// Namespaced trigger; create a regexp to match event type in handle()\\n\\t\\t\\tnamespaces = type.split( \\".\\" );\\n\\t\\t\\ttype = namespaces.shift();\\n\\t\\t\\tnamespaces.sort();\\n\\t\\t}\\n\\t\\tontype = type.indexOf( \\":\\" ) < 0 && \\"on\\" + type;\\n\\n\\t\\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\\n\\t\\tevent = event[ jQuery.expando ] ?\\n\\t\\t\\tevent :\\n\\t\\t\\tnew jQuery.Event( type, typeof event === \\"object\\" && event );\\n\\n\\t\\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\\n\\t\\tevent.isTrigger = onlyHandlers ? 2 : 3;\\n\\t\\tevent.namespace = namespaces.join( \\".\\" );\\n\\t\\tevent.rnamespace = event.namespace ?\\n\\t\\t\\tnew RegExp( \\"(^|\\\\\\\\.)\\" + namespaces.join( \\"\\\\\\\\.(?:.*\\\\\\\\.|)\\" ) + \\"(\\\\\\\\.|$)\\" ) :\\n\\t\\t\\tnull;\\n\\n\\t\\t// Clean up the event in case it is being reused\\n\\t\\tevent.result = undefined;\\n\\t\\tif ( !event.target ) {\\n\\t\\t\\tevent.target = elem;\\n\\t\\t}\\n\\n\\t\\t// Clone any incoming data and prepend the event, creating the handler arg list\\n\\t\\tdata = data == null ?\\n\\t\\t\\t[ event ] :\\n\\t\\t\\tjQuery.makeArray( data, [ event ] );\\n\\n\\t\\t// Allow special events to draw outside the lines\\n\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\t\\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\\n\\t\\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\\n\\n\\t\\t\\tbubbleType = special.delegateType || type;\\n\\t\\t\\tif ( !rfocusMorph.test( bubbleType + type ) ) {\\n\\t\\t\\t\\tcur = cur.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( ; cur; cur = cur.parentNode ) {\\n\\t\\t\\t\\teventPath.push( cur );\\n\\t\\t\\t\\ttmp = cur;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\\n\\t\\t\\tif ( tmp === ( elem.ownerDocument || document ) ) {\\n\\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Fire handlers on the event path\\n\\t\\ti = 0;\\n\\t\\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tlastElement = cur;\\n\\t\\t\\tevent.type = i > 1 ?\\n\\t\\t\\t\\tbubbleType :\\n\\t\\t\\t\\tspecial.bindType || type;\\n\\n\\t\\t\\t// jQuery handler\\n\\t\\t\\thandle = (\\n\\t\\t\\t\\t\\tdataPriv.get( cur, \\"events\\" ) || Object.create( null )\\n\\t\\t\\t\\t)[ event.type ] &&\\n\\t\\t\\t\\tdataPriv.get( cur, \\"handle\\" );\\n\\t\\t\\tif ( handle ) {\\n\\t\\t\\t\\thandle.apply( cur, data );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Native handler\\n\\t\\t\\thandle = ontype && cur[ ontype ];\\n\\t\\t\\tif ( handle && handle.apply && acceptData( cur ) ) {\\n\\t\\t\\t\\tevent.result = handle.apply( cur, data );\\n\\t\\t\\t\\tif ( event.result === false ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tevent.type = type;\\n\\n\\t\\t// If nobody prevented the default action, do it now\\n\\t\\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\\n\\n\\t\\t\\tif ( ( !special._default ||\\n\\t\\t\\t\\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\\n\\t\\t\\t\\tacceptData( elem ) ) {\\n\\n\\t\\t\\t\\t// Call a native DOM method on the target with the same name as the event.\\n\\t\\t\\t\\t// Don\'t do default actions on window, that\'s where global variables be (#6170)\\n\\t\\t\\t\\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// Don\'t re-trigger an onFOO event when we call its FOO() method\\n\\t\\t\\t\\t\\ttmp = elem[ ontype ];\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prevent re-triggering of the same event, since we already bubbled it above\\n\\t\\t\\t\\t\\tjQuery.event.triggered = type;\\n\\n\\t\\t\\t\\t\\tif ( event.isPropagationStopped() ) {\\n\\t\\t\\t\\t\\t\\tlastElement.addEventListener( type, stopPropagationCallback );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem[ type ]();\\n\\n\\t\\t\\t\\t\\tif ( event.isPropagationStopped() ) {\\n\\t\\t\\t\\t\\t\\tlastElement.removeEventListener( type, stopPropagationCallback );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tjQuery.event.triggered = undefined;\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = tmp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\t// Piggyback on a donor event to simulate a different one\\n\\t// Used only for `focus(in | out)` events\\n\\tsimulate: function( type, elem, event ) {\\n\\t\\tvar e = jQuery.extend(\\n\\t\\t\\tnew jQuery.Event(),\\n\\t\\t\\tevent,\\n\\t\\t\\t{\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tisSimulated: true\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\tjQuery.event.trigger( e, null, elem );\\n\\t}\\n\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ttrigger: function( type, data ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.trigger( type, data, this );\\n\\t\\t} );\\n\\t},\\n\\ttriggerHandler: function( type, data ) {\\n\\t\\tvar elem = this[ 0 ];\\n\\t\\tif ( elem ) {\\n\\t\\t\\treturn jQuery.event.trigger( type, data, elem, true );\\n\\t\\t}\\n\\t}\\n} );\\n\\n\\n// Support: Firefox <=44\\n// Firefox doesn\'t have focus(in | out) events\\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\\n//\\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\\n// focus(in | out) events fire after focus & blur events,\\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\\nif ( !support.focusin ) {\\n\\tjQuery.each( { focus: \\"focusin\\", blur: \\"focusout\\" }, function( orig, fix ) {\\n\\n\\t\\t// Attach a single capturing handler on the document while someone wants focusin/focusout\\n\\t\\tvar handler = function( event ) {\\n\\t\\t\\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\\n\\t\\t};\\n\\n\\t\\tjQuery.event.special[ fix ] = {\\n\\t\\t\\tsetup: function() {\\n\\n\\t\\t\\t\\t// Handle: regular nodes (via `this.ownerDocument`), window\\n\\t\\t\\t\\t// (via `this.document`) & document (via `this`).\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this.document || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix );\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.addEventListener( orig, handler, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\\n\\t\\t\\t},\\n\\t\\t\\tteardown: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this.document || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix ) - 1;\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.removeEventListener( orig, handler, true );\\n\\t\\t\\t\\t\\tdataPriv.remove( doc, fix );\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdataPriv.access( doc, fix, attaches );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} );\\n}\\nvar location = window.location;\\n\\nvar nonce = { guid: Date.now() };\\n\\nvar rquery = ( /\\\\?/ );\\n\\n\\n\\n// Cross-browser xml parsing\\njQuery.parseXML = function( data ) {\\n\\tvar xml;\\n\\tif ( !data || typeof data !== \\"string\\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Support: IE 9 - 11 only\\n\\t// IE throws on parseFromString with invalid input.\\n\\ttry {\\n\\t\\txml = ( new window.DOMParser() ).parseFromString( data, \\"text/xml\\" );\\n\\t} catch ( e ) {\\n\\t\\txml = undefined;\\n\\t}\\n\\n\\tif ( !xml || xml.getElementsByTagName( \\"parsererror\\" ).length ) {\\n\\t\\tjQuery.error( \\"Invalid XML: \\" + data );\\n\\t}\\n\\treturn xml;\\n};\\n\\n\\nvar\\n\\trbracket = /\\\\[\\\\]$/,\\n\\trCRLF = /\\\\r?\\\\n/g,\\n\\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\\n\\trsubmittable = /^(?:input|select|textarea|keygen)/i;\\n\\nfunction buildParams( prefix, obj, traditional, add ) {\\n\\tvar name;\\n\\n\\tif ( Array.isArray( obj ) ) {\\n\\n\\t\\t// Serialize array item.\\n\\t\\tjQuery.each( obj, function( i, v ) {\\n\\t\\t\\tif ( traditional || rbracket.test( prefix ) ) {\\n\\n\\t\\t\\t\\t// Treat each array item as a scalar.\\n\\t\\t\\t\\tadd( prefix, v );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Item is non-scalar (array or object), encode its numeric index.\\n\\t\\t\\t\\tbuildParams(\\n\\t\\t\\t\\t\\tprefix + \\"[\\" + ( typeof v === \\"object\\" && v != null ? i : \\"\\" ) + \\"]\\",\\n\\t\\t\\t\\t\\tv,\\n\\t\\t\\t\\t\\ttraditional,\\n\\t\\t\\t\\t\\tadd\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t} else if ( !traditional && toType( obj ) === \\"object\\" ) {\\n\\n\\t\\t// Serialize object item.\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\tbuildParams( prefix + \\"[\\" + name + \\"]\\", obj[ name ], traditional, add );\\n\\t\\t}\\n\\n\\t} else {\\n\\n\\t\\t// Serialize scalar item.\\n\\t\\tadd( prefix, obj );\\n\\t}\\n}\\n\\n// Serialize an array of form elements or a set of\\n// key/values into a query string\\njQuery.param = function( a, traditional ) {\\n\\tvar prefix,\\n\\t\\ts = [],\\n\\t\\tadd = function( key, valueOrFunction ) {\\n\\n\\t\\t\\t// If value is a function, invoke it and use its return value\\n\\t\\t\\tvar value = isFunction( valueOrFunction ) ?\\n\\t\\t\\t\\tvalueOrFunction() :\\n\\t\\t\\t\\tvalueOrFunction;\\n\\n\\t\\t\\ts[ s.length ] = encodeURIComponent( key ) + \\"=\\" +\\n\\t\\t\\t\\tencodeURIComponent( value == null ? \\"\\" : value );\\n\\t\\t};\\n\\n\\tif ( a == null ) {\\n\\t\\treturn \\"\\";\\n\\t}\\n\\n\\t// If an array was passed in, assume that it is an array of form elements.\\n\\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\\n\\n\\t\\t// Serialize the form elements\\n\\t\\tjQuery.each( a, function() {\\n\\t\\t\\tadd( this.name, this.value );\\n\\t\\t} );\\n\\n\\t} else {\\n\\n\\t\\t// If traditional, encode the \\"old\\" way (the way 1.3.2 or older\\n\\t\\t// did it), otherwise encode params recursively.\\n\\t\\tfor ( prefix in a ) {\\n\\t\\t\\tbuildParams( prefix, a[ prefix ], traditional, add );\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the resulting serialization\\n\\treturn s.join( \\"&\\" );\\n};\\n\\njQuery.fn.extend( {\\n\\tserialize: function() {\\n\\t\\treturn jQuery.param( this.serializeArray() );\\n\\t},\\n\\tserializeArray: function() {\\n\\t\\treturn this.map( function() {\\n\\n\\t\\t\\t// Can add propHook for \\"elements\\" to filter or add form elements\\n\\t\\t\\tvar elements = jQuery.prop( this, \\"elements\\" );\\n\\t\\t\\treturn elements ? jQuery.makeArray( elements ) : this;\\n\\t\\t} )\\n\\t\\t.filter( function() {\\n\\t\\t\\tvar type = this.type;\\n\\n\\t\\t\\t// Use .is( \\":disabled\\" ) so that fieldset[disabled] works\\n\\t\\t\\treturn this.name && !jQuery( this ).is( \\":disabled\\" ) &&\\n\\t\\t\\t\\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\\n\\t\\t\\t\\t( this.checked || !rcheckableType.test( type ) );\\n\\t\\t} )\\n\\t\\t.map( function( _i, elem ) {\\n\\t\\t\\tvar val = jQuery( this ).val();\\n\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( Array.isArray( val ) ) {\\n\\t\\t\\t\\treturn jQuery.map( val, function( val ) {\\n\\t\\t\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \\"\\\\r\\\\n\\" ) };\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \\"\\\\r\\\\n\\" ) };\\n\\t\\t} ).get();\\n\\t}\\n} );\\n\\n\\nvar\\n\\tr20 = /%20/g,\\n\\trhash = /#.*$/,\\n\\trantiCache = /([?&])_=[^&]*/,\\n\\trheaders = /^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)$/mg,\\n\\n\\t// #7653, #8125, #8152: local protocol detection\\n\\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\\n\\trnoContent = /^(?:GET|HEAD)$/,\\n\\trprotocol = /^\\\\/\\\\//,\\n\\n\\t/* Prefilters\\n\\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\\n\\t * 2) These are called:\\n\\t *    - BEFORE asking for a transport\\n\\t *    - AFTER param serialization (s.data is a string if s.processData is true)\\n\\t * 3) key is the dataType\\n\\t * 4) the catchall symbol \\"*\\" can be used\\n\\t * 5) execution will start with transport dataType and THEN continue down to \\"*\\" if needed\\n\\t */\\n\\tprefilters = {},\\n\\n\\t/* Transports bindings\\n\\t * 1) key is the dataType\\n\\t * 2) the catchall symbol \\"*\\" can be used\\n\\t * 3) selection will start with transport dataType and THEN go to \\"*\\" if needed\\n\\t */\\n\\ttransports = {},\\n\\n\\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\\n\\tallTypes = \\"*/\\".concat( \\"*\\" ),\\n\\n\\t// Anchor tag for parsing the document origin\\n\\toriginAnchor = document.createElement( \\"a\\" );\\n\\toriginAnchor.href = location.href;\\n\\n// Base \\"constructor\\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\\nfunction addToPrefiltersOrTransports( structure ) {\\n\\n\\t// dataTypeExpression is optional and defaults to \\"*\\"\\n\\treturn function( dataTypeExpression, func ) {\\n\\n\\t\\tif ( typeof dataTypeExpression !== \\"string\\" ) {\\n\\t\\t\\tfunc = dataTypeExpression;\\n\\t\\t\\tdataTypeExpression = \\"*\\";\\n\\t\\t}\\n\\n\\t\\tvar dataType,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\\n\\n\\t\\tif ( isFunction( func ) ) {\\n\\n\\t\\t\\t// For each dataType in the dataTypeExpression\\n\\t\\t\\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t// Prepend if requested\\n\\t\\t\\t\\tif ( dataType[ 0 ] === \\"+\\" ) {\\n\\t\\t\\t\\t\\tdataType = dataType.slice( 1 ) || \\"*\\";\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\\n\\n\\t\\t\\t\\t// Otherwise append\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\n// Base inspection function for prefilters and transports\\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\\n\\n\\tvar inspected = {},\\n\\t\\tseekingTransport = ( structure === transports );\\n\\n\\tfunction inspect( dataType ) {\\n\\t\\tvar selected;\\n\\t\\tinspected[ dataType ] = true;\\n\\t\\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\\n\\t\\t\\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\\n\\t\\t\\tif ( typeof dataTypeOrTransport === \\"string\\" &&\\n\\t\\t\\t\\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\\n\\n\\t\\t\\t\\toptions.dataTypes.unshift( dataTypeOrTransport );\\n\\t\\t\\t\\tinspect( dataTypeOrTransport );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if ( seekingTransport ) {\\n\\t\\t\\t\\treturn !( selected = dataTypeOrTransport );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\treturn selected;\\n\\t}\\n\\n\\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \\"*\\" ] && inspect( \\"*\\" );\\n}\\n\\n// A special extend for ajax options\\n// that takes \\"flat\\" options (not to be deep extended)\\n// Fixes #9887\\nfunction ajaxExtend( target, src ) {\\n\\tvar key, deep,\\n\\t\\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\\n\\n\\tfor ( key in src ) {\\n\\t\\tif ( src[ key ] !== undefined ) {\\n\\t\\t\\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\\n\\t\\t}\\n\\t}\\n\\tif ( deep ) {\\n\\t\\tjQuery.extend( true, target, deep );\\n\\t}\\n\\n\\treturn target;\\n}\\n\\n/* Handles responses to an ajax request:\\n * - finds the right dataType (mediates between content-type and expected dataType)\\n * - returns the corresponding response\\n */\\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\\n\\n\\tvar ct, type, finalDataType, firstDataType,\\n\\t\\tcontents = s.contents,\\n\\t\\tdataTypes = s.dataTypes;\\n\\n\\t// Remove auto dataType and get content-type in the process\\n\\twhile ( dataTypes[ 0 ] === \\"*\\" ) {\\n\\t\\tdataTypes.shift();\\n\\t\\tif ( ct === undefined ) {\\n\\t\\t\\tct = s.mimeType || jqXHR.getResponseHeader( \\"Content-Type\\" );\\n\\t\\t}\\n\\t}\\n\\n\\t// Check if we\'re dealing with a known content-type\\n\\tif ( ct ) {\\n\\t\\tfor ( type in contents ) {\\n\\t\\t\\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\\n\\t\\t\\t\\tdataTypes.unshift( type );\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Check to see if we have a response for the expected dataType\\n\\tif ( dataTypes[ 0 ] in responses ) {\\n\\t\\tfinalDataType = dataTypes[ 0 ];\\n\\t} else {\\n\\n\\t\\t// Try convertible dataTypes\\n\\t\\tfor ( type in responses ) {\\n\\t\\t\\tif ( !dataTypes[ 0 ] || s.converters[ type + \\" \\" + dataTypes[ 0 ] ] ) {\\n\\t\\t\\t\\tfinalDataType = type;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( !firstDataType ) {\\n\\t\\t\\t\\tfirstDataType = type;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Or just use first one\\n\\t\\tfinalDataType = finalDataType || firstDataType;\\n\\t}\\n\\n\\t// If we found a dataType\\n\\t// We add the dataType to the list if needed\\n\\t// and return the corresponding response\\n\\tif ( finalDataType ) {\\n\\t\\tif ( finalDataType !== dataTypes[ 0 ] ) {\\n\\t\\t\\tdataTypes.unshift( finalDataType );\\n\\t\\t}\\n\\t\\treturn responses[ finalDataType ];\\n\\t}\\n}\\n\\n/* Chain conversions given the request and the original response\\n * Also sets the responseXXX fields on the jqXHR instance\\n */\\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\\n\\tvar conv2, current, conv, tmp, prev,\\n\\t\\tconverters = {},\\n\\n\\t\\t// Work with a copy of dataTypes in case we need to modify it for conversion\\n\\t\\tdataTypes = s.dataTypes.slice();\\n\\n\\t// Create converters map with lowercased keys\\n\\tif ( dataTypes[ 1 ] ) {\\n\\t\\tfor ( conv in s.converters ) {\\n\\t\\t\\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\\n\\t\\t}\\n\\t}\\n\\n\\tcurrent = dataTypes.shift();\\n\\n\\t// Convert to each sequential dataType\\n\\twhile ( current ) {\\n\\n\\t\\tif ( s.responseFields[ current ] ) {\\n\\t\\t\\tjqXHR[ s.responseFields[ current ] ] = response;\\n\\t\\t}\\n\\n\\t\\t// Apply the dataFilter if provided\\n\\t\\tif ( !prev && isSuccess && s.dataFilter ) {\\n\\t\\t\\tresponse = s.dataFilter( response, s.dataType );\\n\\t\\t}\\n\\n\\t\\tprev = current;\\n\\t\\tcurrent = dataTypes.shift();\\n\\n\\t\\tif ( current ) {\\n\\n\\t\\t\\t// There\'s only work to do if current dataType is non-auto\\n\\t\\t\\tif ( current === \\"*\\" ) {\\n\\n\\t\\t\\t\\tcurrent = prev;\\n\\n\\t\\t\\t// Convert response if prev dataType is non-auto and differs from current\\n\\t\\t\\t} else if ( prev !== \\"*\\" && prev !== current ) {\\n\\n\\t\\t\\t\\t// Seek a direct converter\\n\\t\\t\\t\\tconv = converters[ prev + \\" \\" + current ] || converters[ \\"* \\" + current ];\\n\\n\\t\\t\\t\\t// If none found, seek a pair\\n\\t\\t\\t\\tif ( !conv ) {\\n\\t\\t\\t\\t\\tfor ( conv2 in converters ) {\\n\\n\\t\\t\\t\\t\\t\\t// If conv2 outputs current\\n\\t\\t\\t\\t\\t\\ttmp = conv2.split( \\" \\" );\\n\\t\\t\\t\\t\\t\\tif ( tmp[ 1 ] === current ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// If prev can be converted to accepted input\\n\\t\\t\\t\\t\\t\\t\\tconv = converters[ prev + \\" \\" + tmp[ 0 ] ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tconverters[ \\"* \\" + tmp[ 0 ] ];\\n\\t\\t\\t\\t\\t\\t\\tif ( conv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Condense equivalence converters\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( conv === true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tconv = converters[ conv2 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Otherwise, insert the intermediate dataType\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if ( converters[ conv2 ] !== true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrent = tmp[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdataTypes.unshift( tmp[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Apply converter (if not an equivalence)\\n\\t\\t\\t\\tif ( conv !== true ) {\\n\\n\\t\\t\\t\\t\\t// Unless errors are allowed to bubble, catch and return them\\n\\t\\t\\t\\t\\tif ( conv && s.throws ) {\\n\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\tstate: \\"parsererror\\",\\n\\t\\t\\t\\t\\t\\t\\t\\terror: conv ? e : \\"No conversion from \\" + prev + \\" to \\" + current\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn { state: \\"success\\", data: response };\\n}\\n\\njQuery.extend( {\\n\\n\\t// Counter for holding the number of active queries\\n\\tactive: 0,\\n\\n\\t// Last-Modified header cache for next request\\n\\tlastModified: {},\\n\\tetag: {},\\n\\n\\tajaxSettings: {\\n\\t\\turl: location.href,\\n\\t\\ttype: \\"GET\\",\\n\\t\\tisLocal: rlocalProtocol.test( location.protocol ),\\n\\t\\tglobal: true,\\n\\t\\tprocessData: true,\\n\\t\\tasync: true,\\n\\t\\tcontentType: \\"application/x-www-form-urlencoded; charset=UTF-8\\",\\n\\n\\t\\t/*\\n\\t\\ttimeout: 0,\\n\\t\\tdata: null,\\n\\t\\tdataType: null,\\n\\t\\tusername: null,\\n\\t\\tpassword: null,\\n\\t\\tcache: null,\\n\\t\\tthrows: false,\\n\\t\\ttraditional: false,\\n\\t\\theaders: {},\\n\\t\\t*/\\n\\n\\t\\taccepts: {\\n\\t\\t\\t\\"*\\": allTypes,\\n\\t\\t\\ttext: \\"text/plain\\",\\n\\t\\t\\thtml: \\"text/html\\",\\n\\t\\t\\txml: \\"application/xml, text/xml\\",\\n\\t\\t\\tjson: \\"application/json, text/javascript\\"\\n\\t\\t},\\n\\n\\t\\tcontents: {\\n\\t\\t\\txml: /\\\\bxml\\\\b/,\\n\\t\\t\\thtml: /\\\\bhtml/,\\n\\t\\t\\tjson: /\\\\bjson\\\\b/\\n\\t\\t},\\n\\n\\t\\tresponseFields: {\\n\\t\\t\\txml: \\"responseXML\\",\\n\\t\\t\\ttext: \\"responseText\\",\\n\\t\\t\\tjson: \\"responseJSON\\"\\n\\t\\t},\\n\\n\\t\\t// Data converters\\n\\t\\t// Keys separate source (or catchall \\"*\\") and destination types with a single space\\n\\t\\tconverters: {\\n\\n\\t\\t\\t// Convert anything to text\\n\\t\\t\\t\\"* text\\": String,\\n\\n\\t\\t\\t// Text to html (true = no transformation)\\n\\t\\t\\t\\"text html\\": true,\\n\\n\\t\\t\\t// Evaluate text as a json expression\\n\\t\\t\\t\\"text json\\": JSON.parse,\\n\\n\\t\\t\\t// Parse text as xml\\n\\t\\t\\t\\"text xml\\": jQuery.parseXML\\n\\t\\t},\\n\\n\\t\\t// For options that shouldn\'t be deep extended:\\n\\t\\t// you can add your own custom options here if\\n\\t\\t// and when you create one that shouldn\'t be\\n\\t\\t// deep extended (see ajaxExtend)\\n\\t\\tflatOptions: {\\n\\t\\t\\turl: true,\\n\\t\\t\\tcontext: true\\n\\t\\t}\\n\\t},\\n\\n\\t// Creates a full fledged settings object into target\\n\\t// with both ajaxSettings and settings fields.\\n\\t// If target is omitted, writes into ajaxSettings.\\n\\tajaxSetup: function( target, settings ) {\\n\\t\\treturn settings ?\\n\\n\\t\\t\\t// Building a settings object\\n\\t\\t\\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\\n\\n\\t\\t\\t// Extending ajaxSettings\\n\\t\\t\\tajaxExtend( jQuery.ajaxSettings, target );\\n\\t},\\n\\n\\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\\n\\tajaxTransport: addToPrefiltersOrTransports( transports ),\\n\\n\\t// Main method\\n\\tajax: function( url, options ) {\\n\\n\\t\\t// If url is an object, simulate pre-1.5 signature\\n\\t\\tif ( typeof url === \\"object\\" ) {\\n\\t\\t\\toptions = url;\\n\\t\\t\\turl = undefined;\\n\\t\\t}\\n\\n\\t\\t// Force options to be an object\\n\\t\\toptions = options || {};\\n\\n\\t\\tvar transport,\\n\\n\\t\\t\\t// URL without anti-cache param\\n\\t\\t\\tcacheURL,\\n\\n\\t\\t\\t// Response headers\\n\\t\\t\\tresponseHeadersString,\\n\\t\\t\\tresponseHeaders,\\n\\n\\t\\t\\t// timeout handle\\n\\t\\t\\ttimeoutTimer,\\n\\n\\t\\t\\t// Url cleanup var\\n\\t\\t\\turlAnchor,\\n\\n\\t\\t\\t// Request state (becomes false upon send and true upon completion)\\n\\t\\t\\tcompleted,\\n\\n\\t\\t\\t// To know if global events are to be dispatched\\n\\t\\t\\tfireGlobals,\\n\\n\\t\\t\\t// Loop variable\\n\\t\\t\\ti,\\n\\n\\t\\t\\t// uncached part of the url\\n\\t\\t\\tuncached,\\n\\n\\t\\t\\t// Create the final options object\\n\\t\\t\\ts = jQuery.ajaxSetup( {}, options ),\\n\\n\\t\\t\\t// Callbacks context\\n\\t\\t\\tcallbackContext = s.context || s,\\n\\n\\t\\t\\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\\n\\t\\t\\tglobalEventContext = s.context &&\\n\\t\\t\\t\\t( callbackContext.nodeType || callbackContext.jquery ) ?\\n\\t\\t\\t\\t\\tjQuery( callbackContext ) :\\n\\t\\t\\t\\t\\tjQuery.event,\\n\\n\\t\\t\\t// Deferreds\\n\\t\\t\\tdeferred = jQuery.Deferred(),\\n\\t\\t\\tcompleteDeferred = jQuery.Callbacks( \\"once memory\\" ),\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tstatusCode = s.statusCode || {},\\n\\n\\t\\t\\t// Headers (they are sent all at once)\\n\\t\\t\\trequestHeaders = {},\\n\\t\\t\\trequestHeadersNames = {},\\n\\n\\t\\t\\t// Default abort message\\n\\t\\t\\tstrAbort = \\"canceled\\",\\n\\n\\t\\t\\t// Fake xhr\\n\\t\\t\\tjqXHR = {\\n\\t\\t\\t\\treadyState: 0,\\n\\n\\t\\t\\t\\t// Builds headers hashtable if needed\\n\\t\\t\\t\\tgetResponseHeader: function( key ) {\\n\\t\\t\\t\\t\\tvar match;\\n\\t\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\t\\tif ( !responseHeaders ) {\\n\\t\\t\\t\\t\\t\\t\\tresponseHeaders = {};\\n\\t\\t\\t\\t\\t\\t\\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresponseHeaders[ match[ 1 ].toLowerCase() + \\" \\" ] =\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( responseHeaders[ match[ 1 ].toLowerCase() + \\" \\" ] || [] )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.concat( match[ 2 ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmatch = responseHeaders[ key.toLowerCase() + \\" \\" ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn match == null ? null : match.join( \\", \\" );\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Raw string\\n\\t\\t\\t\\tgetAllResponseHeaders: function() {\\n\\t\\t\\t\\t\\treturn completed ? responseHeadersString : null;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Caches the header\\n\\t\\t\\t\\tsetRequestHeader: function( name, value ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\tname = requestHeadersNames[ name.toLowerCase() ] =\\n\\t\\t\\t\\t\\t\\t\\trequestHeadersNames[ name.toLowerCase() ] || name;\\n\\t\\t\\t\\t\\t\\trequestHeaders[ name ] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Overrides response content-type header\\n\\t\\t\\t\\toverrideMimeType: function( type ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\ts.mimeType = type;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\t\\tstatusCode: function( map ) {\\n\\t\\t\\t\\t\\tvar code;\\n\\t\\t\\t\\t\\tif ( map ) {\\n\\t\\t\\t\\t\\t\\tif ( completed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Execute the appropriate callbacks\\n\\t\\t\\t\\t\\t\\t\\tjqXHR.always( map[ jqXHR.status ] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Lazy-add the new callbacks in a way that preserves old ones\\n\\t\\t\\t\\t\\t\\t\\tfor ( code in map ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Cancel the request\\n\\t\\t\\t\\tabort: function( statusText ) {\\n\\t\\t\\t\\t\\tvar finalText = statusText || strAbort;\\n\\t\\t\\t\\t\\tif ( transport ) {\\n\\t\\t\\t\\t\\t\\ttransport.abort( finalText );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdone( 0, finalText );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t// Attach deferreds\\n\\t\\tdeferred.promise( jqXHR );\\n\\n\\t\\t// Add protocol if not provided (prefilters might expect it)\\n\\t\\t// Handle falsy url in the settings object (#10093: consistency with old signature)\\n\\t\\t// We also use the url parameter if available\\n\\t\\ts.url = ( ( url || s.url || location.href ) + \\"\\" )\\n\\t\\t\\t.replace( rprotocol, location.protocol + \\"//\\" );\\n\\n\\t\\t// Alias method option to type as per ticket #12004\\n\\t\\ts.type = options.method || options.type || s.method || s.type;\\n\\n\\t\\t// Extract dataTypes list\\n\\t\\ts.dataTypes = ( s.dataType || \\"*\\" ).toLowerCase().match( rnothtmlwhite ) || [ \\"\\" ];\\n\\n\\t\\t// A cross-domain request is in order when the origin doesn\'t match the current origin.\\n\\t\\tif ( s.crossDomain == null ) {\\n\\t\\t\\turlAnchor = document.createElement( \\"a\\" );\\n\\n\\t\\t\\t// Support: IE <=8 - 11, Edge 12 - 15\\n\\t\\t\\t// IE throws exception on accessing the href property if url is malformed,\\n\\t\\t\\t// e.g. http://example.com:80x/\\n\\t\\t\\ttry {\\n\\t\\t\\t\\turlAnchor.href = s.url;\\n\\n\\t\\t\\t\\t// Support: IE <=8 - 11 only\\n\\t\\t\\t\\t// Anchor\'s host property isn\'t correctly set when s.url is relative\\n\\t\\t\\t\\turlAnchor.href = urlAnchor.href;\\n\\t\\t\\t\\ts.crossDomain = originAnchor.protocol + \\"//\\" + originAnchor.host !==\\n\\t\\t\\t\\t\\turlAnchor.protocol + \\"//\\" + urlAnchor.host;\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// If there is an error parsing the URL, assume it is crossDomain,\\n\\t\\t\\t\\t// it can be rejected by the transport if it is invalid\\n\\t\\t\\t\\ts.crossDomain = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Convert data if not already a string\\n\\t\\tif ( s.data && s.processData && typeof s.data !== \\"string\\" ) {\\n\\t\\t\\ts.data = jQuery.param( s.data, s.traditional );\\n\\t\\t}\\n\\n\\t\\t// Apply prefilters\\n\\t\\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\\n\\n\\t\\t// If request was aborted inside a prefilter, stop there\\n\\t\\tif ( completed ) {\\n\\t\\t\\treturn jqXHR;\\n\\t\\t}\\n\\n\\t\\t// We can fire global events as of now if asked to\\n\\t\\t// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\\n\\t\\tfireGlobals = jQuery.event && s.global;\\n\\n\\t\\t// Watch for a new set of requests\\n\\t\\tif ( fireGlobals && jQuery.active++ === 0 ) {\\n\\t\\t\\tjQuery.event.trigger( \\"ajaxStart\\" );\\n\\t\\t}\\n\\n\\t\\t// Uppercase the type\\n\\t\\ts.type = s.type.toUpperCase();\\n\\n\\t\\t// Determine if request has content\\n\\t\\ts.hasContent = !rnoContent.test( s.type );\\n\\n\\t\\t// Save the URL in case we\'re toying with the If-Modified-Since\\n\\t\\t// and/or If-None-Match header later on\\n\\t\\t// Remove hash to simplify url manipulation\\n\\t\\tcacheURL = s.url.replace( rhash, \\"\\" );\\n\\n\\t\\t// More options handling for requests with no content\\n\\t\\tif ( !s.hasContent ) {\\n\\n\\t\\t\\t// Remember the hash so we can put it back\\n\\t\\t\\tuncached = s.url.slice( cacheURL.length );\\n\\n\\t\\t\\t// If data is available and should be processed, append data to url\\n\\t\\t\\tif ( s.data && ( s.processData || typeof s.data === \\"string\\" ) ) {\\n\\t\\t\\t\\tcacheURL += ( rquery.test( cacheURL ) ? \\"&\\" : \\"?\\" ) + s.data;\\n\\n\\t\\t\\t\\t// #9682: remove data so that it\'s not used in an eventual retry\\n\\t\\t\\t\\tdelete s.data;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add or update anti-cache param if needed\\n\\t\\t\\tif ( s.cache === false ) {\\n\\t\\t\\t\\tcacheURL = cacheURL.replace( rantiCache, \\"$1\\" );\\n\\t\\t\\t\\tuncached = ( rquery.test( cacheURL ) ? \\"&\\" : \\"?\\" ) + \\"_=\\" + ( nonce.guid++ ) +\\n\\t\\t\\t\\t\\tuncached;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\\n\\t\\t\\ts.url = cacheURL + uncached;\\n\\n\\t\\t// Change \'%20\' to \'+\' if this is encoded form body content (gh-2658)\\n\\t\\t} else if ( s.data && s.processData &&\\n\\t\\t\\t( s.contentType || \\"\\" ).indexOf( \\"application/x-www-form-urlencoded\\" ) === 0 ) {\\n\\t\\t\\ts.data = s.data.replace( r20, \\"+\\" );\\n\\t\\t}\\n\\n\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\tif ( s.ifModified ) {\\n\\t\\t\\tif ( jQuery.lastModified[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \\"If-Modified-Since\\", jQuery.lastModified[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t\\tif ( jQuery.etag[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \\"If-None-Match\\", jQuery.etag[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Set the correct header, if data is being sent\\n\\t\\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\\n\\t\\t\\tjqXHR.setRequestHeader( \\"Content-Type\\", s.contentType );\\n\\t\\t}\\n\\n\\t\\t// Set the Accepts header for the server, depending on the dataType\\n\\t\\tjqXHR.setRequestHeader(\\n\\t\\t\\t\\"Accept\\",\\n\\t\\t\\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\\n\\t\\t\\t\\ts.accepts[ s.dataTypes[ 0 ] ] +\\n\\t\\t\\t\\t\\t( s.dataTypes[ 0 ] !== \\"*\\" ? \\", \\" + allTypes + \\"; q=0.01\\" : \\"\\" ) :\\n\\t\\t\\t\\ts.accepts[ \\"*\\" ]\\n\\t\\t);\\n\\n\\t\\t// Check for headers option\\n\\t\\tfor ( i in s.headers ) {\\n\\t\\t\\tjqXHR.setRequestHeader( i, s.headers[ i ] );\\n\\t\\t}\\n\\n\\t\\t// Allow custom headers/mimetypes and early abort\\n\\t\\tif ( s.beforeSend &&\\n\\t\\t\\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\\n\\n\\t\\t\\t// Abort if not done already and return\\n\\t\\t\\treturn jqXHR.abort();\\n\\t\\t}\\n\\n\\t\\t// Aborting is no longer a cancellation\\n\\t\\tstrAbort = \\"abort\\";\\n\\n\\t\\t// Install callbacks on deferreds\\n\\t\\tcompleteDeferred.add( s.complete );\\n\\t\\tjqXHR.done( s.success );\\n\\t\\tjqXHR.fail( s.error );\\n\\n\\t\\t// Get transport\\n\\t\\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\\n\\n\\t\\t// If no transport, we auto-abort\\n\\t\\tif ( !transport ) {\\n\\t\\t\\tdone( -1, \\"No Transport\\" );\\n\\t\\t} else {\\n\\t\\t\\tjqXHR.readyState = 1;\\n\\n\\t\\t\\t// Send global event\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \\"ajaxSend\\", [ jqXHR, s ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If request was aborted inside ajaxSend, stop there\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn jqXHR;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Timeout\\n\\t\\t\\tif ( s.async && s.timeout > 0 ) {\\n\\t\\t\\t\\ttimeoutTimer = window.setTimeout( function() {\\n\\t\\t\\t\\t\\tjqXHR.abort( \\"timeout\\" );\\n\\t\\t\\t\\t}, s.timeout );\\n\\t\\t\\t}\\n\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tcompleted = false;\\n\\t\\t\\t\\ttransport.send( requestHeaders, done );\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// Rethrow post-completion exceptions\\n\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Propagate others as results\\n\\t\\t\\t\\tdone( -1, e );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Callback for when everything is done\\n\\t\\tfunction done( status, nativeStatusText, responses, headers ) {\\n\\t\\t\\tvar isSuccess, success, error, response, modified,\\n\\t\\t\\t\\tstatusText = nativeStatusText;\\n\\n\\t\\t\\t// Ignore repeat invocations\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcompleted = true;\\n\\n\\t\\t\\t// Clear timeout if it exists\\n\\t\\t\\tif ( timeoutTimer ) {\\n\\t\\t\\t\\twindow.clearTimeout( timeoutTimer );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Dereference transport for early garbage collection\\n\\t\\t\\t// (no matter how long the jqXHR object will be used)\\n\\t\\t\\ttransport = undefined;\\n\\n\\t\\t\\t// Cache response headers\\n\\t\\t\\tresponseHeadersString = headers || \\"\\";\\n\\n\\t\\t\\t// Set readyState\\n\\t\\t\\tjqXHR.readyState = status > 0 ? 4 : 0;\\n\\n\\t\\t\\t// Determine if successful\\n\\t\\t\\tisSuccess = status >= 200 && status < 300 || status === 304;\\n\\n\\t\\t\\t// Get response data\\n\\t\\t\\tif ( responses ) {\\n\\t\\t\\t\\tresponse = ajaxHandleResponses( s, jqXHR, responses );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Use a noop converter for missing script\\n\\t\\t\\tif ( !isSuccess && jQuery.inArray( \\"script\\", s.dataTypes ) > -1 ) {\\n\\t\\t\\t\\ts.converters[ \\"text script\\" ] = function() {};\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert no matter what (that way responseXXX fields are always set)\\n\\t\\t\\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\\n\\n\\t\\t\\t// If successful, handle type chaining\\n\\t\\t\\tif ( isSuccess ) {\\n\\n\\t\\t\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\t\\t\\tif ( s.ifModified ) {\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \\"Last-Modified\\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.lastModified[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \\"etag\\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.etag[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if no content\\n\\t\\t\\t\\tif ( status === 204 || s.type === \\"HEAD\\" ) {\\n\\t\\t\\t\\t\\tstatusText = \\"nocontent\\";\\n\\n\\t\\t\\t\\t// if not modified\\n\\t\\t\\t\\t} else if ( status === 304 ) {\\n\\t\\t\\t\\t\\tstatusText = \\"notmodified\\";\\n\\n\\t\\t\\t\\t// If we have data, let\'s convert it\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstatusText = response.state;\\n\\t\\t\\t\\t\\tsuccess = response.data;\\n\\t\\t\\t\\t\\terror = response.error;\\n\\t\\t\\t\\t\\tisSuccess = !error;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Extract error from statusText and normalize for non-aborts\\n\\t\\t\\t\\terror = statusText;\\n\\t\\t\\t\\tif ( status || !statusText ) {\\n\\t\\t\\t\\t\\tstatusText = \\"error\\";\\n\\t\\t\\t\\t\\tif ( status < 0 ) {\\n\\t\\t\\t\\t\\t\\tstatus = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set data for the fake xhr object\\n\\t\\t\\tjqXHR.status = status;\\n\\t\\t\\tjqXHR.statusText = ( nativeStatusText || statusText ) + \\"\\";\\n\\n\\t\\t\\t// Success/Error\\n\\t\\t\\tif ( isSuccess ) {\\n\\t\\t\\t\\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tjqXHR.statusCode( statusCode );\\n\\t\\t\\tstatusCode = undefined;\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( isSuccess ? \\"ajaxSuccess\\" : \\"ajaxError\\",\\n\\t\\t\\t\\t\\t[ jqXHR, s, isSuccess ? success : error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Complete\\n\\t\\t\\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \\"ajaxComplete\\", [ jqXHR, s ] );\\n\\n\\t\\t\\t\\t// Handle the global AJAX counter\\n\\t\\t\\t\\tif ( !( --jQuery.active ) ) {\\n\\t\\t\\t\\t\\tjQuery.event.trigger( \\"ajaxStop\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn jqXHR;\\n\\t},\\n\\n\\tgetJSON: function( url, data, callback ) {\\n\\t\\treturn jQuery.get( url, data, callback, \\"json\\" );\\n\\t},\\n\\n\\tgetScript: function( url, callback ) {\\n\\t\\treturn jQuery.get( url, undefined, callback, \\"script\\" );\\n\\t}\\n} );\\n\\njQuery.each( [ \\"get\\", \\"post\\" ], function( _i, method ) {\\n\\tjQuery[ method ] = function( url, data, callback, type ) {\\n\\n\\t\\t// Shift arguments if data argument was omitted\\n\\t\\tif ( isFunction( data ) ) {\\n\\t\\t\\ttype = type || callback;\\n\\t\\t\\tcallback = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\n\\t\\t// The url can be an options object (which then must have .url)\\n\\t\\treturn jQuery.ajax( jQuery.extend( {\\n\\t\\t\\turl: url,\\n\\t\\t\\ttype: method,\\n\\t\\t\\tdataType: type,\\n\\t\\t\\tdata: data,\\n\\t\\t\\tsuccess: callback\\n\\t\\t}, jQuery.isPlainObject( url ) && url ) );\\n\\t};\\n} );\\n\\njQuery.ajaxPrefilter( function( s ) {\\n\\tvar i;\\n\\tfor ( i in s.headers ) {\\n\\t\\tif ( i.toLowerCase() === \\"content-type\\" ) {\\n\\t\\t\\ts.contentType = s.headers[ i ] || \\"\\";\\n\\t\\t}\\n\\t}\\n} );\\n\\n\\njQuery._evalUrl = function( url, options, doc ) {\\n\\treturn jQuery.ajax( {\\n\\t\\turl: url,\\n\\n\\t\\t// Make this explicit, since user can override this through ajaxSetup (#11264)\\n\\t\\ttype: \\"GET\\",\\n\\t\\tdataType: \\"script\\",\\n\\t\\tcache: true,\\n\\t\\tasync: false,\\n\\t\\tglobal: false,\\n\\n\\t\\t// Only evaluate the response if it is successful (gh-4126)\\n\\t\\t// dataFilter is not invoked for failure responses, so using it instead\\n\\t\\t// of the default converter is kludgy but it works.\\n\\t\\tconverters: {\\n\\t\\t\\t\\"text script\\": function() {}\\n\\t\\t},\\n\\t\\tdataFilter: function( response ) {\\n\\t\\t\\tjQuery.globalEval( response, options, doc );\\n\\t\\t}\\n\\t} );\\n};\\n\\n\\njQuery.fn.extend( {\\n\\twrapAll: function( html ) {\\n\\t\\tvar wrap;\\n\\n\\t\\tif ( this[ 0 ] ) {\\n\\t\\t\\tif ( isFunction( html ) ) {\\n\\t\\t\\t\\thtml = html.call( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// The elements to wrap the target around\\n\\t\\t\\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\\n\\n\\t\\t\\tif ( this[ 0 ].parentNode ) {\\n\\t\\t\\t\\twrap.insertBefore( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\twrap.map( function() {\\n\\t\\t\\t\\tvar elem = this;\\n\\n\\t\\t\\t\\twhile ( elem.firstElementChild ) {\\n\\t\\t\\t\\t\\telem = elem.firstElementChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn elem;\\n\\t\\t\\t} ).append( this );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\twrapInner: function( html ) {\\n\\t\\tif ( isFunction( html ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).wrapInner( html.call( this, i ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar self = jQuery( this ),\\n\\t\\t\\t\\tcontents = self.contents();\\n\\n\\t\\t\\tif ( contents.length ) {\\n\\t\\t\\t\\tcontents.wrapAll( html );\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tself.append( html );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\twrap: function( html ) {\\n\\t\\tvar htmlIsFunction = isFunction( html );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\\n\\t\\t} );\\n\\t},\\n\\n\\tunwrap: function( selector ) {\\n\\t\\tthis.parent( selector ).not( \\"body\\" ).each( function() {\\n\\t\\t\\tjQuery( this ).replaceWith( this.childNodes );\\n\\t\\t} );\\n\\t\\treturn this;\\n\\t}\\n} );\\n\\n\\njQuery.expr.pseudos.hidden = function( elem ) {\\n\\treturn !jQuery.expr.pseudos.visible( elem );\\n};\\njQuery.expr.pseudos.visible = function( elem ) {\\n\\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\\n};\\n\\n\\n\\n\\njQuery.ajaxSettings.xhr = function() {\\n\\ttry {\\n\\t\\treturn new window.XMLHttpRequest();\\n\\t} catch ( e ) {}\\n};\\n\\nvar xhrSuccessStatus = {\\n\\n\\t\\t// File protocol always yields status code 0, assume 200\\n\\t\\t0: 200,\\n\\n\\t\\t// Support: IE <=9 only\\n\\t\\t// #1450: sometimes IE returns 1223 when it should be 204\\n\\t\\t1223: 204\\n\\t},\\n\\txhrSupported = jQuery.ajaxSettings.xhr();\\n\\nsupport.cors = !!xhrSupported && ( \\"withCredentials\\" in xhrSupported );\\nsupport.ajax = xhrSupported = !!xhrSupported;\\n\\njQuery.ajaxTransport( function( options ) {\\n\\tvar callback, errorCallback;\\n\\n\\t// Cross domain only allowed if supported through XMLHttpRequest\\n\\tif ( support.cors || xhrSupported && !options.crossDomain ) {\\n\\t\\treturn {\\n\\t\\t\\tsend: function( headers, complete ) {\\n\\t\\t\\t\\tvar i,\\n\\t\\t\\t\\t\\txhr = options.xhr();\\n\\n\\t\\t\\t\\txhr.open(\\n\\t\\t\\t\\t\\toptions.type,\\n\\t\\t\\t\\t\\toptions.url,\\n\\t\\t\\t\\t\\toptions.async,\\n\\t\\t\\t\\t\\toptions.username,\\n\\t\\t\\t\\t\\toptions.password\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Apply custom fields if provided\\n\\t\\t\\t\\tif ( options.xhrFields ) {\\n\\t\\t\\t\\t\\tfor ( i in options.xhrFields ) {\\n\\t\\t\\t\\t\\t\\txhr[ i ] = options.xhrFields[ i ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Override mime type if needed\\n\\t\\t\\t\\tif ( options.mimeType && xhr.overrideMimeType ) {\\n\\t\\t\\t\\t\\txhr.overrideMimeType( options.mimeType );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// X-Requested-With header\\n\\t\\t\\t\\t// For cross-domain requests, seeing as conditions for a preflight are\\n\\t\\t\\t\\t// akin to a jigsaw puzzle, we simply never set it to be sure.\\n\\t\\t\\t\\t// (it can always be set on a per-request basis or even using ajaxSetup)\\n\\t\\t\\t\\t// For same-domain requests, won\'t change header if already provided.\\n\\t\\t\\t\\tif ( !options.crossDomain && !headers[ \\"X-Requested-With\\" ] ) {\\n\\t\\t\\t\\t\\theaders[ \\"X-Requested-With\\" ] = \\"XMLHttpRequest\\";\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Set headers\\n\\t\\t\\t\\tfor ( i in headers ) {\\n\\t\\t\\t\\t\\txhr.setRequestHeader( i, headers[ i ] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Callback\\n\\t\\t\\t\\tcallback = function( type ) {\\n\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\tcallback = errorCallback = xhr.onload =\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.onerror = xhr.onabort = xhr.ontimeout =\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.onreadystatechange = null;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( type === \\"abort\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.abort();\\n\\t\\t\\t\\t\\t\\t\\t} else if ( type === \\"error\\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// On a manual native abort, IE9 throws\\n\\t\\t\\t\\t\\t\\t\\t\\t// errors on any property access that is not readyState\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( typeof xhr.status !== \\"number\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete( 0, \\"error\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// File: protocol always yields status 0; see #8605, #14207\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhrSuccessStatus[ xhr.status ] || xhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// IE9 has no XHR2 but throws on binary (trac-11426)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// For XHR2 non-text, let the caller handle it (gh-2498)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( xhr.responseType || \\"text\\" ) !== \\"text\\"  ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof xhr.responseText !== \\"string\\" ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ binary: xhr.response } :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ text: xhr.responseText },\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.getAllResponseHeaders()\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// Listen to events\\n\\t\\t\\t\\txhr.onload = callback();\\n\\t\\t\\t\\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \\"error\\" );\\n\\n\\t\\t\\t\\t// Support: IE 9 only\\n\\t\\t\\t\\t// Use onreadystatechange to replace onabort\\n\\t\\t\\t\\t// to handle uncaught aborts\\n\\t\\t\\t\\tif ( xhr.onabort !== undefined ) {\\n\\t\\t\\t\\t\\txhr.onabort = errorCallback;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\txhr.onreadystatechange = function() {\\n\\n\\t\\t\\t\\t\\t\\t// Check readyState before timeout as it changes\\n\\t\\t\\t\\t\\t\\tif ( xhr.readyState === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Allow onerror to be called first,\\n\\t\\t\\t\\t\\t\\t\\t// but that will not handle a native abort\\n\\t\\t\\t\\t\\t\\t\\t// Also, save errorCallback to a variable\\n\\t\\t\\t\\t\\t\\t\\t// as xhr.onerror cannot be accessed\\n\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\terrorCallback();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Create the abort callback\\n\\t\\t\\t\\tcallback = callback( \\"abort\\" );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\t// Do send the request (this may raise an exception)\\n\\t\\t\\t\\t\\txhr.send( options.hasContent && options.data || null );\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t// #14683: Only rethrow if this hasn\'t been notified as an error yet\\n\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\\njQuery.ajaxPrefilter( function( s ) {\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.contents.script = false;\\n\\t}\\n} );\\n\\n// Install script dataType\\njQuery.ajaxSetup( {\\n\\taccepts: {\\n\\t\\tscript: \\"text/javascript, application/javascript, \\" +\\n\\t\\t\\t\\"application/ecmascript, application/x-ecmascript\\"\\n\\t},\\n\\tcontents: {\\n\\t\\tscript: /\\\\b(?:java|ecma)script\\\\b/\\n\\t},\\n\\tconverters: {\\n\\t\\t\\"text script\\": function( text ) {\\n\\t\\t\\tjQuery.globalEval( text );\\n\\t\\t\\treturn text;\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Handle cache\'s special case and crossDomain\\njQuery.ajaxPrefilter( \\"script\\", function( s ) {\\n\\tif ( s.cache === undefined ) {\\n\\t\\ts.cache = false;\\n\\t}\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.type = \\"GET\\";\\n\\t}\\n} );\\n\\n// Bind script tag hack transport\\njQuery.ajaxTransport( \\"script\\", function( s ) {\\n\\n\\t// This transport only deals with cross domain or forced-by-attrs requests\\n\\tif ( s.crossDomain || s.scriptAttrs ) {\\n\\t\\tvar script, callback;\\n\\t\\treturn {\\n\\t\\t\\tsend: function( _, complete ) {\\n\\t\\t\\t\\tscript = jQuery( \\"<script>\\" )\\n\\t\\t\\t\\t\\t.attr( s.scriptAttrs || {} )\\n\\t\\t\\t\\t\\t.prop( { charset: s.scriptCharset, src: s.url } )\\n\\t\\t\\t\\t\\t.on( \\"load error\\", callback = function( evt ) {\\n\\t\\t\\t\\t\\t\\tscript.remove();\\n\\t\\t\\t\\t\\t\\tcallback = null;\\n\\t\\t\\t\\t\\t\\tif ( evt ) {\\n\\t\\t\\t\\t\\t\\t\\tcomplete( evt.type === \\"error\\" ? 404 : 200, evt.type );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t// Use native DOM manipulation to avoid our domManip AJAX trickery\\n\\t\\t\\t\\tdocument.head.appendChild( script[ 0 ] );\\n\\t\\t\\t},\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\nvar oldCallbacks = [],\\n\\trjsonp = /(=)\\\\?(?=&|$)|\\\\?\\\\?/;\\n\\n// Default jsonp settings\\njQuery.ajaxSetup( {\\n\\tjsonp: \\"callback\\",\\n\\tjsonpCallback: function() {\\n\\t\\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \\"_\\" + ( nonce.guid++ ) );\\n\\t\\tthis[ callback ] = true;\\n\\t\\treturn callback;\\n\\t}\\n} );\\n\\n// Detect, normalize options and install callbacks for jsonp requests\\njQuery.ajaxPrefilter( \\"json jsonp\\", function( s, originalSettings, jqXHR ) {\\n\\n\\tvar callbackName, overwritten, responseContainer,\\n\\t\\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\\n\\t\\t\\t\\"url\\" :\\n\\t\\t\\ttypeof s.data === \\"string\\" &&\\n\\t\\t\\t\\t( s.contentType || \\"\\" )\\n\\t\\t\\t\\t\\t.indexOf( \\"application/x-www-form-urlencoded\\" ) === 0 &&\\n\\t\\t\\t\\trjsonp.test( s.data ) && \\"data\\"\\n\\t\\t);\\n\\n\\t// Handle iff the expected data type is \\"jsonp\\" or we have a parameter to set\\n\\tif ( jsonProp || s.dataTypes[ 0 ] === \\"jsonp\\" ) {\\n\\n\\t\\t// Get callback name, remembering preexisting value associated with it\\n\\t\\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\\n\\t\\t\\ts.jsonpCallback() :\\n\\t\\t\\ts.jsonpCallback;\\n\\n\\t\\t// Insert callback into url or form data\\n\\t\\tif ( jsonProp ) {\\n\\t\\t\\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \\"$1\\" + callbackName );\\n\\t\\t} else if ( s.jsonp !== false ) {\\n\\t\\t\\ts.url += ( rquery.test( s.url ) ? \\"&\\" : \\"?\\" ) + s.jsonp + \\"=\\" + callbackName;\\n\\t\\t}\\n\\n\\t\\t// Use data converter to retrieve json after script execution\\n\\t\\ts.converters[ \\"script json\\" ] = function() {\\n\\t\\t\\tif ( !responseContainer ) {\\n\\t\\t\\t\\tjQuery.error( callbackName + \\" was not called\\" );\\n\\t\\t\\t}\\n\\t\\t\\treturn responseContainer[ 0 ];\\n\\t\\t};\\n\\n\\t\\t// Force json dataType\\n\\t\\ts.dataTypes[ 0 ] = \\"json\\";\\n\\n\\t\\t// Install callback\\n\\t\\toverwritten = window[ callbackName ];\\n\\t\\twindow[ callbackName ] = function() {\\n\\t\\t\\tresponseContainer = arguments;\\n\\t\\t};\\n\\n\\t\\t// Clean-up function (fires after converters)\\n\\t\\tjqXHR.always( function() {\\n\\n\\t\\t\\t// If previous value didn\'t exist - remove it\\n\\t\\t\\tif ( overwritten === undefined ) {\\n\\t\\t\\t\\tjQuery( window ).removeProp( callbackName );\\n\\n\\t\\t\\t// Otherwise restore preexisting value\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twindow[ callbackName ] = overwritten;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save back as free\\n\\t\\t\\tif ( s[ callbackName ] ) {\\n\\n\\t\\t\\t\\t// Make sure that re-using the options doesn\'t screw things around\\n\\t\\t\\t\\ts.jsonpCallback = originalSettings.jsonpCallback;\\n\\n\\t\\t\\t\\t// Save the callback name for future use\\n\\t\\t\\t\\toldCallbacks.push( callbackName );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Call if it was a function and we have a response\\n\\t\\t\\tif ( responseContainer && isFunction( overwritten ) ) {\\n\\t\\t\\t\\toverwritten( responseContainer[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\tresponseContainer = overwritten = undefined;\\n\\t\\t} );\\n\\n\\t\\t// Delegate to script\\n\\t\\treturn \\"script\\";\\n\\t}\\n} );\\n\\n\\n\\n\\n// Support: Safari 8 only\\n// In Safari 8 documents created via document.implementation.createHTMLDocument\\n// collapse sibling forms: the second one becomes a child of the first one.\\n// Because of that, this security measure has to be disabled in Safari 8.\\n// https://bugs.webkit.org/show_bug.cgi?id=137337\\nsupport.createHTMLDocument = ( function() {\\n\\tvar body = document.implementation.createHTMLDocument( \\"\\" ).body;\\n\\tbody.innerHTML = \\"<form></form><form></form>\\";\\n\\treturn body.childNodes.length === 2;\\n} )();\\n\\n\\n// Argument \\"data\\" should be string of html\\n// context (optional): If specified, the fragment will be created in this context,\\n// defaults to document\\n// keepScripts (optional): If true, will include scripts passed in the html string\\njQuery.parseHTML = function( data, context, keepScripts ) {\\n\\tif ( typeof data !== \\"string\\" ) {\\n\\t\\treturn [];\\n\\t}\\n\\tif ( typeof context === \\"boolean\\" ) {\\n\\t\\tkeepScripts = context;\\n\\t\\tcontext = false;\\n\\t}\\n\\n\\tvar base, parsed, scripts;\\n\\n\\tif ( !context ) {\\n\\n\\t\\t// Stop scripts or inline event handlers from being executed immediately\\n\\t\\t// by using document.implementation\\n\\t\\tif ( support.createHTMLDocument ) {\\n\\t\\t\\tcontext = document.implementation.createHTMLDocument( \\"\\" );\\n\\n\\t\\t\\t// Set the base href for the created document\\n\\t\\t\\t// so any parsed elements with URLs\\n\\t\\t\\t// are based on the document\'s URL (gh-2965)\\n\\t\\t\\tbase = context.createElement( \\"base\\" );\\n\\t\\t\\tbase.href = document.location.href;\\n\\t\\t\\tcontext.head.appendChild( base );\\n\\t\\t} else {\\n\\t\\t\\tcontext = document;\\n\\t\\t}\\n\\t}\\n\\n\\tparsed = rsingleTag.exec( data );\\n\\tscripts = !keepScripts && [];\\n\\n\\t// Single tag\\n\\tif ( parsed ) {\\n\\t\\treturn [ context.createElement( parsed[ 1 ] ) ];\\n\\t}\\n\\n\\tparsed = buildFragment( [ data ], context, scripts );\\n\\n\\tif ( scripts && scripts.length ) {\\n\\t\\tjQuery( scripts ).remove();\\n\\t}\\n\\n\\treturn jQuery.merge( [], parsed.childNodes );\\n};\\n\\n\\n/**\\n * Load a url into a page\\n */\\njQuery.fn.load = function( url, params, callback ) {\\n\\tvar selector, type, response,\\n\\t\\tself = this,\\n\\t\\toff = url.indexOf( \\" \\" );\\n\\n\\tif ( off > -1 ) {\\n\\t\\tselector = stripAndCollapse( url.slice( off ) );\\n\\t\\turl = url.slice( 0, off );\\n\\t}\\n\\n\\t// If it\'s a function\\n\\tif ( isFunction( params ) ) {\\n\\n\\t\\t// We assume that it\'s the callback\\n\\t\\tcallback = params;\\n\\t\\tparams = undefined;\\n\\n\\t// Otherwise, build a param string\\n\\t} else if ( params && typeof params === \\"object\\" ) {\\n\\t\\ttype = \\"POST\\";\\n\\t}\\n\\n\\t// If we have elements to modify, make the request\\n\\tif ( self.length > 0 ) {\\n\\t\\tjQuery.ajax( {\\n\\t\\t\\turl: url,\\n\\n\\t\\t\\t// If \\"type\\" variable is undefined, then \\"GET\\" method will be used.\\n\\t\\t\\t// Make value of this field explicit since\\n\\t\\t\\t// user can override it through ajaxSetup method\\n\\t\\t\\ttype: type || \\"GET\\",\\n\\t\\t\\tdataType: \\"html\\",\\n\\t\\t\\tdata: params\\n\\t\\t} ).done( function( responseText ) {\\n\\n\\t\\t\\t// Save response for use in complete callback\\n\\t\\t\\tresponse = arguments;\\n\\n\\t\\t\\tself.html( selector ?\\n\\n\\t\\t\\t\\t// If a selector was specified, locate the right elements in a dummy div\\n\\t\\t\\t\\t// Exclude scripts to avoid IE \'Permission Denied\' errors\\n\\t\\t\\t\\tjQuery( \\"<div>\\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\\n\\n\\t\\t\\t\\t// Otherwise use the full result\\n\\t\\t\\t\\tresponseText );\\n\\n\\t\\t// If the request succeeds, this function gets \\"data\\", \\"status\\", \\"jqXHR\\"\\n\\t\\t// but they are ignored because response was set above.\\n\\t\\t// If it fails, this function gets \\"jqXHR\\", \\"status\\", \\"error\\"\\n\\t\\t} ).always( callback && function( jqXHR, status ) {\\n\\t\\t\\tself.each( function() {\\n\\t\\t\\t\\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\treturn this;\\n};\\n\\n\\n\\n\\njQuery.expr.pseudos.animated = function( elem ) {\\n\\treturn jQuery.grep( jQuery.timers, function( fn ) {\\n\\t\\treturn elem === fn.elem;\\n\\t} ).length;\\n};\\n\\n\\n\\n\\njQuery.offset = {\\n\\tsetOffset: function( elem, options, i ) {\\n\\t\\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\\n\\t\\t\\tposition = jQuery.css( elem, \\"position\\" ),\\n\\t\\t\\tcurElem = jQuery( elem ),\\n\\t\\t\\tprops = {};\\n\\n\\t\\t// Set position first, in-case top/left are set even on static elem\\n\\t\\tif ( position === \\"static\\" ) {\\n\\t\\t\\telem.style.position = \\"relative\\";\\n\\t\\t}\\n\\n\\t\\tcurOffset = curElem.offset();\\n\\t\\tcurCSSTop = jQuery.css( elem, \\"top\\" );\\n\\t\\tcurCSSLeft = jQuery.css( elem, \\"left\\" );\\n\\t\\tcalculatePosition = ( position === \\"absolute\\" || position === \\"fixed\\" ) &&\\n\\t\\t\\t( curCSSTop + curCSSLeft ).indexOf( \\"auto\\" ) > -1;\\n\\n\\t\\t// Need to be able to calculate position if either\\n\\t\\t// top or left is auto and position is either absolute or fixed\\n\\t\\tif ( calculatePosition ) {\\n\\t\\t\\tcurPosition = curElem.position();\\n\\t\\t\\tcurTop = curPosition.top;\\n\\t\\t\\tcurLeft = curPosition.left;\\n\\n\\t\\t} else {\\n\\t\\t\\tcurTop = parseFloat( curCSSTop ) || 0;\\n\\t\\t\\tcurLeft = parseFloat( curCSSLeft ) || 0;\\n\\t\\t}\\n\\n\\t\\tif ( isFunction( options ) ) {\\n\\n\\t\\t\\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\\n\\t\\t\\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\\n\\t\\t}\\n\\n\\t\\tif ( options.top != null ) {\\n\\t\\t\\tprops.top = ( options.top - curOffset.top ) + curTop;\\n\\t\\t}\\n\\t\\tif ( options.left != null ) {\\n\\t\\t\\tprops.left = ( options.left - curOffset.left ) + curLeft;\\n\\t\\t}\\n\\n\\t\\tif ( \\"using\\" in options ) {\\n\\t\\t\\toptions.using.call( elem, props );\\n\\n\\t\\t} else {\\n\\t\\t\\tif ( typeof props.top === \\"number\\" ) {\\n\\t\\t\\t\\tprops.top += \\"px\\";\\n\\t\\t\\t}\\n\\t\\t\\tif ( typeof props.left === \\"number\\" ) {\\n\\t\\t\\t\\tprops.left += \\"px\\";\\n\\t\\t\\t}\\n\\t\\t\\tcurElem.css( props );\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.fn.extend( {\\n\\n\\t// offset() relates an element\'s border box to the document origin\\n\\toffset: function( options ) {\\n\\n\\t\\t// Preserve chaining for setter\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\treturn options === undefined ?\\n\\t\\t\\t\\tthis :\\n\\t\\t\\t\\tthis.each( function( i ) {\\n\\t\\t\\t\\t\\tjQuery.offset.setOffset( this, options, i );\\n\\t\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tvar rect, win,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\\n\\t\\t// Support: IE <=11 only\\n\\t\\t// Running getBoundingClientRect on a\\n\\t\\t// disconnected node in IE throws an error\\n\\t\\tif ( !elem.getClientRects().length ) {\\n\\t\\t\\treturn { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t\\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\\n\\t\\trect = elem.getBoundingClientRect();\\n\\t\\twin = elem.ownerDocument.defaultView;\\n\\t\\treturn {\\n\\t\\t\\ttop: rect.top + win.pageYOffset,\\n\\t\\t\\tleft: rect.left + win.pageXOffset\\n\\t\\t};\\n\\t},\\n\\n\\t// position() relates an element\'s margin box to its offset parent\'s padding box\\n\\t// This corresponds to the behavior of CSS absolute positioning\\n\\tposition: function() {\\n\\t\\tif ( !this[ 0 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar offsetParent, offset, doc,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tparentOffset = { top: 0, left: 0 };\\n\\n\\t\\t// position:fixed elements are offset from the viewport, which itself always has zero offset\\n\\t\\tif ( jQuery.css( elem, \\"position\\" ) === \\"fixed\\" ) {\\n\\n\\t\\t\\t// Assume position:fixed implies availability of getBoundingClientRect\\n\\t\\t\\toffset = elem.getBoundingClientRect();\\n\\n\\t\\t} else {\\n\\t\\t\\toffset = this.offset();\\n\\n\\t\\t\\t// Account for the *real* offset parent, which can be the document or its root element\\n\\t\\t\\t// when a statically positioned element is identified\\n\\t\\t\\tdoc = elem.ownerDocument;\\n\\t\\t\\toffsetParent = elem.offsetParent || doc.documentElement;\\n\\t\\t\\twhile ( offsetParent &&\\n\\t\\t\\t\\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\\n\\t\\t\\t\\tjQuery.css( offsetParent, \\"position\\" ) === \\"static\\" ) {\\n\\n\\t\\t\\t\\toffsetParent = offsetParent.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Incorporate borders into its offset, since they are outside its content origin\\n\\t\\t\\t\\tparentOffset = jQuery( offsetParent ).offset();\\n\\t\\t\\t\\tparentOffset.top += jQuery.css( offsetParent, \\"borderTopWidth\\", true );\\n\\t\\t\\t\\tparentOffset.left += jQuery.css( offsetParent, \\"borderLeftWidth\\", true );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Subtract parent offsets and element margins\\n\\t\\treturn {\\n\\t\\t\\ttop: offset.top - parentOffset.top - jQuery.css( elem, \\"marginTop\\", true ),\\n\\t\\t\\tleft: offset.left - parentOffset.left - jQuery.css( elem, \\"marginLeft\\", true )\\n\\t\\t};\\n\\t},\\n\\n\\t// This method will return documentElement in the following cases:\\n\\t// 1) For the element inside the iframe without offsetParent, this method will return\\n\\t//    documentElement of the parent window\\n\\t// 2) For the hidden or detached element\\n\\t// 3) For body or html element, i.e. in case of the html node - it will return itself\\n\\t//\\n\\t// but those exceptions were never presented as a real life use-cases\\n\\t// and might be considered as more preferable results.\\n\\t//\\n\\t// This logic, however, is not guaranteed and can change at any point in the future\\n\\toffsetParent: function() {\\n\\t\\treturn this.map( function() {\\n\\t\\t\\tvar offsetParent = this.offsetParent;\\n\\n\\t\\t\\twhile ( offsetParent && jQuery.css( offsetParent, \\"position\\" ) === \\"static\\" ) {\\n\\t\\t\\t\\toffsetParent = offsetParent.offsetParent;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn offsetParent || documentElement;\\n\\t\\t} );\\n\\t}\\n} );\\n\\n// Create scrollLeft and scrollTop methods\\njQuery.each( { scrollLeft: \\"pageXOffset\\", scrollTop: \\"pageYOffset\\" }, function( method, prop ) {\\n\\tvar top = \\"pageYOffset\\" === prop;\\n\\n\\tjQuery.fn[ method ] = function( val ) {\\n\\t\\treturn access( this, function( elem, method, val ) {\\n\\n\\t\\t\\t// Coalesce documents and windows\\n\\t\\t\\tvar win;\\n\\t\\t\\tif ( isWindow( elem ) ) {\\n\\t\\t\\t\\twin = elem;\\n\\t\\t\\t} else if ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\twin = elem.defaultView;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( val === undefined ) {\\n\\t\\t\\t\\treturn win ? win[ prop ] : elem[ method ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( win ) {\\n\\t\\t\\t\\twin.scrollTo(\\n\\t\\t\\t\\t\\t!top ? val : win.pageXOffset,\\n\\t\\t\\t\\t\\ttop ? val : win.pageYOffset\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telem[ method ] = val;\\n\\t\\t\\t}\\n\\t\\t}, method, val, arguments.length );\\n\\t};\\n} );\\n\\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\\n// Add the top/left cssHooks using jQuery.fn.position\\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\\n// getComputedStyle returns percent when specified for top/left/bottom/right;\\n// rather than make the css module depend on the offset module, just check for it here\\njQuery.each( [ \\"top\\", \\"left\\" ], function( _i, prop ) {\\n\\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\\n\\t\\tfunction( elem, computed ) {\\n\\t\\t\\tif ( computed ) {\\n\\t\\t\\t\\tcomputed = curCSS( elem, prop );\\n\\n\\t\\t\\t\\t// If curCSS returns percentage, fallback to offset\\n\\t\\t\\t\\treturn rnumnonpx.test( computed ) ?\\n\\t\\t\\t\\t\\tjQuery( elem ).position()[ prop ] + \\"px\\" :\\n\\t\\t\\t\\t\\tcomputed;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t);\\n} );\\n\\n\\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\\njQuery.each( { Height: \\"height\\", Width: \\"width\\" }, function( name, type ) {\\n\\tjQuery.each( { padding: \\"inner\\" + name, content: type, \\"\\": \\"outer\\" + name },\\n\\t\\tfunction( defaultExtra, funcName ) {\\n\\n\\t\\t// Margin is only for outerHeight, outerWidth\\n\\t\\tjQuery.fn[ funcName ] = function( margin, value ) {\\n\\t\\t\\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \\"boolean\\" ),\\n\\t\\t\\t\\textra = defaultExtra || ( margin === true || value === true ? \\"margin\\" : \\"border\\" );\\n\\n\\t\\t\\treturn access( this, function( elem, type, value ) {\\n\\t\\t\\t\\tvar doc;\\n\\n\\t\\t\\t\\tif ( isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\\n\\t\\t\\t\\t\\treturn funcName.indexOf( \\"outer\\" ) === 0 ?\\n\\t\\t\\t\\t\\t\\telem[ \\"inner\\" + name ] :\\n\\t\\t\\t\\t\\t\\telem.document.documentElement[ \\"client\\" + name ];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Get document width or height\\n\\t\\t\\t\\tif ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\t\\tdoc = elem.documentElement;\\n\\n\\t\\t\\t\\t\\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\\n\\t\\t\\t\\t\\t// whichever is greatest\\n\\t\\t\\t\\t\\treturn Math.max(\\n\\t\\t\\t\\t\\t\\telem.body[ \\"scroll\\" + name ], doc[ \\"scroll\\" + name ],\\n\\t\\t\\t\\t\\t\\telem.body[ \\"offset\\" + name ], doc[ \\"offset\\" + name ],\\n\\t\\t\\t\\t\\t\\tdoc[ \\"client\\" + name ]\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn value === undefined ?\\n\\n\\t\\t\\t\\t\\t// Get width or height on the element, requesting but not forcing parseFloat\\n\\t\\t\\t\\t\\tjQuery.css( elem, type, extra ) :\\n\\n\\t\\t\\t\\t\\t// Set width or height on the element\\n\\t\\t\\t\\t\\tjQuery.style( elem, type, value, extra );\\n\\t\\t\\t}, type, chainable ? margin : undefined, chainable );\\n\\t\\t};\\n\\t} );\\n} );\\n\\n\\njQuery.each( [\\n\\t\\"ajaxStart\\",\\n\\t\\"ajaxStop\\",\\n\\t\\"ajaxComplete\\",\\n\\t\\"ajaxError\\",\\n\\t\\"ajaxSuccess\\",\\n\\t\\"ajaxSend\\"\\n], function( _i, type ) {\\n\\tjQuery.fn[ type ] = function( fn ) {\\n\\t\\treturn this.on( type, fn );\\n\\t};\\n} );\\n\\n\\n\\n\\njQuery.fn.extend( {\\n\\n\\tbind: function( types, data, fn ) {\\n\\t\\treturn this.on( types, null, data, fn );\\n\\t},\\n\\tunbind: function( types, fn ) {\\n\\t\\treturn this.off( types, null, fn );\\n\\t},\\n\\n\\tdelegate: function( selector, types, data, fn ) {\\n\\t\\treturn this.on( types, selector, data, fn );\\n\\t},\\n\\tundelegate: function( selector, types, fn ) {\\n\\n\\t\\t// ( namespace ) or ( selector, types [, fn] )\\n\\t\\treturn arguments.length === 1 ?\\n\\t\\t\\tthis.off( selector, \\"**\\" ) :\\n\\t\\t\\tthis.off( types, selector || \\"**\\", fn );\\n\\t},\\n\\n\\thover: function( fnOver, fnOut ) {\\n\\t\\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\\n\\t}\\n} );\\n\\njQuery.each( ( \\"blur focus focusin focusout resize scroll click dblclick \\" +\\n\\t\\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \\" +\\n\\t\\"change select submit keydown keypress keyup contextmenu\\" ).split( \\" \\" ),\\n\\tfunction( _i, name ) {\\n\\n\\t\\t// Handle event binding\\n\\t\\tjQuery.fn[ name ] = function( data, fn ) {\\n\\t\\t\\treturn arguments.length > 0 ?\\n\\t\\t\\t\\tthis.on( name, null, data, fn ) :\\n\\t\\t\\t\\tthis.trigger( name );\\n\\t\\t};\\n\\t} );\\n\\n\\n\\n\\n// Support: Android <=4.0 only\\n// Make sure we trim BOM and NBSP\\nvar rtrim = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g;\\n\\n// Bind a function to a context, optionally partially applying any\\n// arguments.\\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\\n// However, it is not slated for removal any time soon\\njQuery.proxy = function( fn, context ) {\\n\\tvar tmp, args, proxy;\\n\\n\\tif ( typeof context === \\"string\\" ) {\\n\\t\\ttmp = fn[ context ];\\n\\t\\tcontext = fn;\\n\\t\\tfn = tmp;\\n\\t}\\n\\n\\t// Quick check to determine if target is callable, in the spec\\n\\t// this throws a TypeError, but we will just return undefined.\\n\\tif ( !isFunction( fn ) ) {\\n\\t\\treturn undefined;\\n\\t}\\n\\n\\t// Simulated bind\\n\\targs = slice.call( arguments, 2 );\\n\\tproxy = function() {\\n\\t\\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\\n\\t};\\n\\n\\t// Set the guid of unique handler to the same of original handler, so it can be removed\\n\\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\\n\\n\\treturn proxy;\\n};\\n\\njQuery.holdReady = function( hold ) {\\n\\tif ( hold ) {\\n\\t\\tjQuery.readyWait++;\\n\\t} else {\\n\\t\\tjQuery.ready( true );\\n\\t}\\n};\\njQuery.isArray = Array.isArray;\\njQuery.parseJSON = JSON.parse;\\njQuery.nodeName = nodeName;\\njQuery.isFunction = isFunction;\\njQuery.isWindow = isWindow;\\njQuery.camelCase = camelCase;\\njQuery.type = toType;\\n\\njQuery.now = Date.now;\\n\\njQuery.isNumeric = function( obj ) {\\n\\n\\t// As of jQuery 3.0, isNumeric is limited to\\n\\t// strings and numbers (primitives or objects)\\n\\t// that can be coerced to finite numbers (gh-2662)\\n\\tvar type = jQuery.type( obj );\\n\\treturn ( type === \\"number\\" || type === \\"string\\" ) &&\\n\\n\\t\\t// parseFloat NaNs numeric-cast false positives (\\"\\")\\n\\t\\t// ...but misinterprets leading-number strings, particularly hex literals (\\"0x...\\")\\n\\t\\t// subtraction forces infinities to NaN\\n\\t\\t!isNaN( obj - parseFloat( obj ) );\\n};\\n\\njQuery.trim = function( text ) {\\n\\treturn text == null ?\\n\\t\\t\\"\\" :\\n\\t\\t( text + \\"\\" ).replace( rtrim, \\"\\" );\\n};\\n\\n\\n\\n// Register as a named AMD module, since jQuery can be concatenated with other\\n// files that may use define, but not via a proper concatenation script that\\n// understands anonymous AMD modules. A named AMD is safest and most robust\\n// way to register. Lowercase jquery is used because AMD module names are\\n// derived from file names, and jQuery is normally delivered in a lowercase\\n// file name. Do this after creating the global so that if an AMD module wants\\n// to call noConflict to hide this version of jQuery, it will work.\\n\\n// Note that for maximum portability, libraries that are not jQuery should\\n// declare themselves as anonymous modules, and avoid setting a global if an\\n// AMD loader is present. jQuery is a special case. For more information, see\\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\\n\\nif ( typeof define === \\"function\\" && define.amd ) {\\n\\tdefine( \\"jquery\\", [], function() {\\n\\t\\treturn jQuery;\\n\\t} );\\n}\\n\\n\\n\\n\\nvar\\n\\n\\t// Map over jQuery in case of overwrite\\n\\t_jQuery = window.jQuery,\\n\\n\\t// Map over the $ in case of overwrite\\n\\t_$ = window.$;\\n\\njQuery.noConflict = function( deep ) {\\n\\tif ( window.$ === jQuery ) {\\n\\t\\twindow.$ = _$;\\n\\t}\\n\\n\\tif ( deep && window.jQuery === jQuery ) {\\n\\t\\twindow.jQuery = _jQuery;\\n\\t}\\n\\n\\treturn jQuery;\\n};\\n\\n// Expose jQuery and $ identifiers, even in AMD\\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\\n// and CommonJS for browser emulators (#13566)\\nif ( typeof noGlobal === \\"undefined\\" ) {\\n\\twindow.jQuery = window.$ = jQuery;\\n}\\n\\n\\n\\n\\nreturn jQuery;\\n} );\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanM/MmVlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My41LjFcXG4gKiBodHRwczovL2pxdWVyeS5jb20vXFxuICpcXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cXG4gKlxcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAqXFxuICogRGF0ZTogMjAyMC0wNS0wNFQyMjo0OVpcXG4gKi9cXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XFxuXFxuXFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXFxuXFx0XFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cXG5cXHRcXHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxcblxcdFxcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxcblxcdFxcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXFxuXFx0XFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcXFwianF1ZXJ5XFxcIikod2luZG93KTtcXG5cXHRcXHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cXG5cXHRcXHRcXHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XFxuXFx0XFx0XFx0ZnVuY3Rpb24oIHcgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhdy5kb2N1bWVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoIFxcXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XFxcIiApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFjdG9yeSggdyApO1xcblxcdFxcdFxcdH07XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRmYWN0b3J5KCBnbG9iYWwgKTtcXG5cXHR9XFxuXFxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcXG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XFxuXFxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXFxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXFxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cXG5cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxudmFyIGFyciA9IFtdO1xcblxcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcXG5cXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XFxuXFxudmFyIGZsYXQgPSBhcnIuZmxhdCA/IGZ1bmN0aW9uKCBhcnJheSApIHtcXG5cXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcXG59IDogZnVuY3Rpb24oIGFycmF5ICkge1xcblxcdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcXG59O1xcblxcblxcbnZhciBwdXNoID0gYXJyLnB1c2g7XFxuXFxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcXG5cXG52YXIgY2xhc3MydHlwZSA9IHt9O1xcblxcbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XFxuXFxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XFxuXFxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XFxuXFxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcXG5cXG52YXIgc3VwcG9ydCA9IHt9O1xcblxcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xcblxcbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcXFwiZnVuY3Rpb25cXFwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXFxuICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcIm9iamVjdFxcXCIgKSA9PT0gXFxcImZ1bmN0aW9uXFxcImApLlxcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcXFwibnVtYmVyXFxcIjtcXG4gIH07XFxuXFxuXFxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcXG5cXHRcXHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xcblxcdH07XFxuXFxuXFxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xcblxcblxcblxcblxcdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xcblxcdFxcdHR5cGU6IHRydWUsXFxuXFx0XFx0c3JjOiB0cnVlLFxcblxcdFxcdG5vbmNlOiB0cnVlLFxcblxcdFxcdG5vTW9kdWxlOiB0cnVlXFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XFxuXFx0XFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xcblxcblxcdFxcdHZhciBpLCB2YWwsXFxuXFx0XFx0XFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFxcXCJzY3JpcHRcXFwiICk7XFxuXFxuXFx0XFx0c2NyaXB0LnRleHQgPSBjb2RlO1xcblxcdFxcdGlmICggbm9kZSApIHtcXG5cXHRcXHRcXHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogRmlyZWZveCA2NCssIEVkZ2UgMTgrXFxuXFx0XFx0XFx0XFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcXFwibm9uY2VcXFwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXFxuXFx0XFx0XFx0XFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xcblxcdFxcdFxcdFxcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcXG5cXHRcXHRcXHRcXHQvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxcblxcdFxcdFxcdFxcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcXG5cXHRcXHRcXHRcXHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xcblxcdFxcdFxcdFxcdC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2ZcXG5cXHRcXHRcXHRcXHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcXG5cXHRcXHRcXHRcXHQvLyB2aWEgYW4gb2JqZWN0LlxcblxcdFxcdFxcdFxcdHZhbCA9IG5vZGVbIGkgXSB8fCBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSggaSApO1xcblxcdFxcdFxcdFxcdGlmICggdmFsICkge1xcblxcdFxcdFxcdFxcdFxcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcXG5cXHR9XFxuXFxuXFxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XFxuXFx0aWYgKCBvYmogPT0gbnVsbCApIHtcXG5cXHRcXHRyZXR1cm4gb2JqICsgXFxcIlxcXCI7XFxuXFx0fVxcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxcblxcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2Ygb2JqID09PSBcXFwiZnVuY3Rpb25cXFwiID9cXG5cXHRcXHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFxcXCJvYmplY3RcXFwiIDpcXG5cXHRcXHR0eXBlb2Ygb2JqO1xcbn1cXG4vKiBnbG9iYWwgU3ltYm9sICovXFxuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxcblxcblxcblxcbnZhclxcblxcdHZlcnNpb24gPSBcXFwiMy41LjFcXFwiLFxcblxcblxcdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XFxuXFx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xcblxcblxcdFxcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xcblxcdFxcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXFxuXFx0XFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcXG5cXHR9O1xcblxcbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XFxuXFxuXFx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxcblxcdGpxdWVyeTogdmVyc2lvbixcXG5cXG5cXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxcblxcblxcdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxcblxcdGxlbmd0aDogMCxcXG5cXG5cXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xcblxcdH0sXFxuXFxuXFx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxcblxcdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XFxuXFx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xcblxcblxcdFxcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcXG5cXHRcXHRpZiAoIG51bSA9PSBudWxsICkge1xcblxcdFxcdFxcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcXG5cXHRcXHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcXG5cXHR9LFxcblxcblxcdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcXG5cXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcXG5cXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcXG5cXG5cXHRcXHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxcblxcdFxcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcXG5cXG5cXHRcXHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxcblxcdFxcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcXG5cXG5cXHRcXHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxcblxcdFxcdHJldHVybiByZXQ7XFxuXFx0fSxcXG5cXG5cXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxcblxcdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XFxuXFx0fSxcXG5cXG5cXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xcblxcdFxcdFxcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XFxuXFx0XFx0fSApICk7XFxuXFx0fSxcXG5cXG5cXHRzbGljZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcXG5cXHR9LFxcblxcblxcdGZpcnN0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lcSggMCApO1xcblxcdH0sXFxuXFxuXFx0bGFzdDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XFxuXFx0fSxcXG5cXG5cXHRldmVuOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuICggaSArIDEgKSAlIDI7XFxuXFx0XFx0fSApICk7XFxuXFx0fSxcXG5cXG5cXHRvZGQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gaSAlIDI7XFxuXFx0XFx0fSApICk7XFxuXFx0fSxcXG5cXG5cXHRlcTogZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxcblxcdFxcdFxcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xcblxcdH0sXFxuXFxuXFx0ZW5kOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcXG5cXHR9LFxcblxcblxcdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cXG5cXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cXG5cXHRwdXNoOiBwdXNoLFxcblxcdHNvcnQ6IGFyci5zb3J0LFxcblxcdHNwbGljZTogYXJyLnNwbGljZVxcbn07XFxuXFxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcXG5cXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXFxuXFx0XFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXFxuXFx0XFx0aSA9IDEsXFxuXFx0XFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcXG5cXHRcXHRkZWVwID0gZmFsc2U7XFxuXFxuXFx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxcblxcdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXFxcImJvb2xlYW5cXFwiICkge1xcblxcdFxcdGRlZXAgPSB0YXJnZXQ7XFxuXFxuXFx0XFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxcblxcdFxcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xcblxcdFxcdGkrKztcXG5cXHR9XFxuXFxuXFx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXFxuXFx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcXFwib2JqZWN0XFxcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XFxuXFx0XFx0dGFyZ2V0ID0ge307XFxuXFx0fVxcblxcblxcdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxcblxcdGlmICggaSA9PT0gbGVuZ3RoICkge1xcblxcdFxcdHRhcmdldCA9IHRoaXM7XFxuXFx0XFx0aS0tO1xcblxcdH1cXG5cXG5cXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcXG5cXG5cXHRcXHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXFxuXFx0XFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxcblxcdFxcdFxcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcXG5cXHRcXHRcXHRcXHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cXG5cXHRcXHRcXHRcXHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXFxuXFx0XFx0XFx0XFx0aWYgKCBuYW1lID09PSBcXFwiX19wcm90b19fXFxcIiB8fCB0YXJnZXQgPT09IGNvcHkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xcblxcdFxcdFxcdFxcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxcblxcdFxcdFxcdFxcdFxcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xcblxcdFxcdFxcdFxcdFxcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxcblxcdFxcdFxcdFxcdFxcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNsb25lID0gW107XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xvbmUgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNsb25lID0gc3JjO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRjb3B5SXNBcnJheSA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxcblxcdFxcdFxcdFxcdFxcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdHRhcmdldFsgbmFtZSBdID0gY29weTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcXG5cXHRyZXR1cm4gdGFyZ2V0O1xcbn07XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxcblxcdGV4cGFuZG86IFxcXCJqUXVlcnlcXFwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXFxcRC9nLCBcXFwiXFxcIiApLFxcblxcblxcdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXFxuXFx0aXNSZWFkeTogdHJ1ZSxcXG5cXG5cXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcXG5cXHRcXHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xcblxcdH0sXFxuXFxuXFx0bm9vcDogZnVuY3Rpb24oKSB7fSxcXG5cXG5cXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xcblxcdFxcdHZhciBwcm90bywgQ3RvcjtcXG5cXG5cXHRcXHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcXG5cXHRcXHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcXG5cXHRcXHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFxcXCJbb2JqZWN0IE9iamVjdF1cXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XFxuXFxuXFx0XFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxcblxcdFxcdGlmICggIXByb3RvICkge1xcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxcblxcdFxcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFxcXCJjb25zdHJ1Y3RvclxcXCIgKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcXG5cXHRcXHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xcblxcdH0sXFxuXFxuXFx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcXG5cXHRcXHR2YXIgbmFtZTtcXG5cXG5cXHRcXHRmb3IgKCBuYW1lIGluIG9iaiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0cnVlO1xcblxcdH0sXFxuXFxuXFx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgcHJvdmlkZWQgY29udGV4dDsgZmFsbHMgYmFjayB0byB0aGUgZ2xvYmFsIG9uZVxcblxcdC8vIGlmIG5vdCBzcGVjaWZpZWQuXFxuXFx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcXG5cXHRcXHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XFxuXFx0fSxcXG5cXG5cXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcXG5cXHRcXHR2YXIgbGVuZ3RoLCBpID0gMDtcXG5cXG5cXHRcXHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcXG5cXHRcXHRcXHRsZW5ndGggPSBvYmoubGVuZ3RoO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRmb3IgKCBpIGluIG9iaiApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gb2JqO1xcblxcdH0sXFxuXFxuXFx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxcblxcdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcXG5cXHRcXHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcXG5cXG5cXHRcXHRpZiAoIGFyciAhPSBudWxsICkge1xcblxcdFxcdFxcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIHJldCxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlb2YgYXJyID09PSBcXFwic3RyaW5nXFxcIiA/XFxuXFx0XFx0XFx0XFx0XFx0WyBhcnIgXSA6IGFyclxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcmV0O1xcblxcdH0sXFxuXFxuXFx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcXG5cXHRcXHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcXG5cXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XFxuXFx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xcblxcdFxcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcXG5cXHRcXHRcXHRqID0gMCxcXG5cXHRcXHRcXHRpID0gZmlyc3QubGVuZ3RoO1xcblxcblxcdFxcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xcblxcdFxcdFxcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmaXJzdC5sZW5ndGggPSBpO1xcblxcblxcdFxcdHJldHVybiBmaXJzdDtcXG5cXHR9LFxcblxcblxcdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcXG5cXHRcXHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxcblxcdFxcdFxcdG1hdGNoZXMgPSBbXSxcXG5cXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xcblxcblxcdFxcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcXG5cXHRcXHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxcblxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xcblxcdFxcdFxcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xcblxcdFxcdFxcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBtYXRjaGVzO1xcblxcdH0sXFxuXFxuXFx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XFxuXFx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XFxuXFx0XFx0dmFyIGxlbmd0aCwgdmFsdWUsXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0cmV0ID0gW107XFxuXFxuXFx0XFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcXG5cXHRcXHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xcblxcdFxcdFxcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcXG5cXHRcXHRcXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0LnB1c2goIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Zm9yICggaSBpbiBlbGVtcyApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0LnB1c2goIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xcblxcdFxcdHJldHVybiBmbGF0KCByZXQgKTtcXG5cXHR9LFxcblxcblxcdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xcblxcdGd1aWQ6IDEsXFxuXFxuXFx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXFxuXFx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cXG5cXHRzdXBwb3J0OiBzdXBwb3J0XFxufSApO1xcblxcbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiApIHtcXG5cXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcXG59XFxuXFxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXFxualF1ZXJ5LmVhY2goIFxcXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFxcXCIuc3BsaXQoIFxcXCIgXFxcIiApLFxcbmZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcXG5cXHRjbGFzczJ0eXBlWyBcXFwiW29iamVjdCBcXFwiICsgbmFtZSArIFxcXCJdXFxcIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xcbn0gKTtcXG5cXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xcblxcblxcdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcXG5cXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXFxuXFx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXFxuXFx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxcblxcdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcXFwibGVuZ3RoXFxcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcXG5cXHRcXHR0eXBlID0gdG9UeXBlKCBvYmogKTtcXG5cXG5cXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fVxcblxcblxcdHJldHVybiB0eXBlID09PSBcXFwiYXJyYXlcXFwiIHx8IGxlbmd0aCA9PT0gMCB8fFxcblxcdFxcdHR5cGVvZiBsZW5ndGggPT09IFxcXCJudW1iZXJcXFwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xcbn1cXG52YXIgU2l6emxlID1cXG4vKiFcXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjVcXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cXG4gKlxcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwczovL2pzLmZvdW5kYXRpb24vXFxuICpcXG4gKiBEYXRlOiAyMDIwLTAzLTE0XFxuICovXFxuKCBmdW5jdGlvbiggd2luZG93ICkge1xcbnZhciBpLFxcblxcdHN1cHBvcnQsXFxuXFx0RXhwcixcXG5cXHRnZXRUZXh0LFxcblxcdGlzWE1MLFxcblxcdHRva2VuaXplLFxcblxcdGNvbXBpbGUsXFxuXFx0c2VsZWN0LFxcblxcdG91dGVybW9zdENvbnRleHQsXFxuXFx0c29ydElucHV0LFxcblxcdGhhc0R1cGxpY2F0ZSxcXG5cXG5cXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXFxuXFx0c2V0RG9jdW1lbnQsXFxuXFx0ZG9jdW1lbnQsXFxuXFx0ZG9jRWxlbSxcXG5cXHRkb2N1bWVudElzSFRNTCxcXG5cXHRyYnVnZ3lRU0EsXFxuXFx0cmJ1Z2d5TWF0Y2hlcyxcXG5cXHRtYXRjaGVzLFxcblxcdGNvbnRhaW5zLFxcblxcblxcdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcXG5cXHRleHBhbmRvID0gXFxcInNpenpsZVxcXCIgKyAxICogbmV3IERhdGUoKSxcXG5cXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXFxuXFx0ZGlycnVucyA9IDAsXFxuXFx0ZG9uZSA9IDAsXFxuXFx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXFxuXFx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXFxuXFx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXFxuXFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXFxuXFx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFx0XFx0aWYgKCBhID09PSBiICkge1xcblxcdFxcdFxcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAwO1xcblxcdH0sXFxuXFxuXFx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xcblxcdGhhc093biA9ICgge30gKS5oYXNPd25Qcm9wZXJ0eSxcXG5cXHRhcnIgPSBbXSxcXG5cXHRwb3AgPSBhcnIucG9wLFxcblxcdHB1c2hOYXRpdmUgPSBhcnIucHVzaCxcXG5cXHRwdXNoID0gYXJyLnB1c2gsXFxuXFx0c2xpY2UgPSBhcnIuc2xpY2UsXFxuXFxuXFx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXFxuXFx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxcblxcdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcXG5cXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0XFx0bGVuID0gbGlzdC5sZW5ndGg7XFxuXFx0XFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0XFx0aWYgKCBsaXN0WyBpIF0gPT09IGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gLTE7XFxuXFx0fSxcXG5cXG5cXHRib29sZWFucyA9IFxcXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58XFxcIiArXFxuXFx0XFx0XFxcImlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcXFwiLFxcblxcblxcdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcXG5cXG5cXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxcblxcdHdoaXRlc3BhY2UgPSBcXFwiW1xcXFxcXFxceDIwXFxcXFxcXFx0XFxcXFxcXFxyXFxcXFxcXFxuXFxcXFxcXFxmXVxcXCIsXFxuXFxuXFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaWRlbnQtdG9rZW4tZGlhZ3JhbVxcblxcdGlkZW50aWZpZXIgPSBcXFwiKD86XFxcXFxcXFxcXFxcXFxcXFtcXFxcXFxcXGRhLWZBLUZdezEsNn1cXFwiICsgd2hpdGVzcGFjZSArXFxuXFx0XFx0XFxcIj98XFxcXFxcXFxcXFxcXFxcXFteXFxcXFxcXFxyXFxcXFxcXFxuXFxcXFxcXFxmXXxbXFxcXFxcXFx3LV18W15cXFxcMC1cXFxcXFxcXHg3Zl0pK1xcXCIsXFxuXFxuXFx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXFxuXFx0YXR0cmlidXRlcyA9IFxcXCJcXFxcXFxcXFtcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIikoPzpcXFwiICsgd2hpdGVzcGFjZSArXFxuXFxuXFx0XFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcXG5cXHRcXHRcXFwiKihbKl4kfCF+XT89KVxcXCIgKyB3aGl0ZXNwYWNlICtcXG5cXG5cXHRcXHQvLyBcXFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XVxcblxcdFxcdC8vIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXFxcIlxcblxcdFxcdFxcXCIqKD86JygoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwnXSkqKSd8XFxcXFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCJdKSopXFxcXFxcXCJ8KFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIikpfClcXFwiICtcXG5cXHRcXHR3aGl0ZXNwYWNlICsgXFxcIipcXFxcXFxcXF1cXFwiLFxcblxcblxcdHBzZXVkb3MgPSBcXFwiOihcXFwiICsgaWRlbnRpZmllciArIFxcXCIpKD86XFxcXFxcXFwoKFxcXCIgK1xcblxcblxcdFxcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XFxuXFx0XFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXFxuXFx0XFx0XFxcIignKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCddKSopJ3xcXFxcXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIl0pKilcXFxcXFxcIil8XFxcIiArXFxuXFxuXFx0XFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXFxuXFx0XFx0XFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwoKVtcXFxcXFxcXF1dfFxcXCIgKyBhdHRyaWJ1dGVzICsgXFxcIikqKXxcXFwiICtcXG5cXG5cXHRcXHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXFxuXFx0XFx0XFxcIi4qXFxcIiArXFxuXFx0XFx0XFxcIilcXFxcXFxcXCl8KVxcXCIsXFxuXFxuXFx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxcblxcdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFxcXCIrXFxcIiwgXFxcImdcXFwiICksXFxuXFx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIit8KCg/Ol58W15cXFxcXFxcXFxcXFxcXFxcXSkoPzpcXFxcXFxcXFxcXFxcXFxcLikqKVxcXCIgK1xcblxcdFxcdHdoaXRlc3BhY2UgKyBcXFwiKyRcXFwiLCBcXFwiZ1xcXCIgKSxcXG5cXG5cXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiosXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXCIgKSxcXG5cXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooWz4rfl18XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKVxcXCIgKyB3aGl0ZXNwYWNlICtcXG5cXHRcXHRcXFwiKlxcXCIgKSxcXG5cXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcXFwifD5cXFwiICksXFxuXFxuXFx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcXG5cXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiJFxcXCIgKSxcXG5cXG5cXHRtYXRjaEV4cHIgPSB7XFxuXFx0XFx0XFxcIklEXFxcIjogbmV3IFJlZ0V4cCggXFxcIl4jKFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIilcXFwiICksXFxuXFx0XFx0XFxcIkNMQVNTXFxcIjogbmV3IFJlZ0V4cCggXFxcIl5cXFxcXFxcXC4oXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiKVxcXCIgKSxcXG5cXHRcXHRcXFwiVEFHXFxcIjogbmV3IFJlZ0V4cCggXFxcIl4oXFxcIiArIGlkZW50aWZpZXIgKyBcXFwifFsqXSlcXFwiICksXFxuXFx0XFx0XFxcIkFUVFJcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyBhdHRyaWJ1dGVzICksXFxuXFx0XFx0XFxcIlBTRVVET1xcXCI6IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHBzZXVkb3MgKSxcXG5cXHRcXHRcXFwiQ0hJTERcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXFxcXFwoXFxcIiArXFxuXFx0XFx0XFx0d2hpdGVzcGFjZSArIFxcXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxcXFxcZCopbnwpXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKig/OihbKy1dfClcXFwiICtcXG5cXHRcXHRcXHR3aGl0ZXNwYWNlICsgXFxcIiooXFxcXFxcXFxkKyl8KSlcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcXFxcXFwpfClcXFwiLCBcXFwiaVxcXCIgKSxcXG5cXHRcXHRcXFwiYm9vbFxcXCI6IG5ldyBSZWdFeHAoIFxcXCJeKD86XFxcIiArIGJvb2xlYW5zICsgXFxcIikkXFxcIiwgXFxcImlcXFwiICksXFxuXFxuXFx0XFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXFxuXFx0XFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxcblxcdFxcdFxcXCJuZWVkc0NvbnRleHRcXFwiOiBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICtcXG5cXHRcXHRcXHRcXFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXFxcXFwoXFxcIiArIHdoaXRlc3BhY2UgK1xcblxcdFxcdFxcdFxcXCIqKCg/Oi1cXFxcXFxcXGQpP1xcXFxcXFxcZCopXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXFxcXFxcKXwpKD89W14tXXwkKVxcXCIsIFxcXCJpXFxcIiApXFxuXFx0fSxcXG5cXG5cXHRyaHRtbCA9IC9IVE1MJC9pLFxcblxcdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxcblxcdHJoZWFkZXIgPSAvXmhcXFxcZCQvaSxcXG5cXG5cXHRybmF0aXZlID0gL15bXntdK1xcXFx7XFxcXHMqXFxcXFtuYXRpdmUgXFxcXHcvLFxcblxcblxcdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xcblxcdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcXFx3LV0rKXwoXFxcXHcrKXxcXFxcLihbXFxcXHctXSspKSQvLFxcblxcblxcdHJzaWJsaW5nID0gL1srfl0vLFxcblxcblxcdC8vIENTUyBlc2NhcGVzXFxuXFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xcblxcdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFxcXCJcXFxcXFxcXFxcXFxcXFxcW1xcXFxcXFxcZGEtZkEtRl17MSw2fVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIj98XFxcXFxcXFxcXFxcXFxcXChbXlxcXFxcXFxcclxcXFxcXFxcblxcXFxcXFxcZl0pXFxcIiwgXFxcImdcXFwiICksXFxuXFx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIGVzY2FwZSwgbm9uSGV4ICkge1xcblxcdFxcdHZhciBoaWdoID0gXFxcIjB4XFxcIiArIGVzY2FwZS5zbGljZSggMSApIC0gMHgxMDAwMDtcXG5cXG5cXHRcXHRyZXR1cm4gbm9uSGV4ID9cXG5cXG5cXHRcXHRcXHQvLyBTdHJpcCB0aGUgYmFja3NsYXNoIHByZWZpeCBmcm9tIGEgbm9uLWhleCBlc2NhcGUgc2VxdWVuY2VcXG5cXHRcXHRcXHRub25IZXggOlxcblxcblxcdFxcdFxcdC8vIFJlcGxhY2UgYSBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2Ugd2l0aCB0aGUgZW5jb2RlZCBVbmljb2RlIGNvZGUgcG9pbnRcXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTExK1xcblxcdFxcdFxcdC8vIEZvciB2YWx1ZXMgb3V0c2lkZSB0aGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lIChCTVApLCBtYW51YWxseSBjb25zdHJ1Y3QgYVxcblxcdFxcdFxcdC8vIHN1cnJvZ2F0ZSBwYWlyXFxuXFx0XFx0XFx0aGlnaCA8IDAgP1xcblxcdFxcdFxcdFxcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxcblxcdFxcdFxcdFxcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xcblxcdH0sXFxuXFxuXFx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cXG5cXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcXG5cXHRyY3NzZXNjYXBlID0gLyhbXFxcXDAtXFxcXHgxZlxcXFx4N2ZdfF4tP1xcXFxkKXxeLSR8W15cXFxcMC1cXFxceDFmXFxcXHg3Zi1cXFxcdUZGRkZcXFxcdy1dL2csXFxuXFx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XFxuXFx0XFx0aWYgKCBhc0NvZGVQb2ludCApIHtcXG5cXG5cXHRcXHRcXHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcXG5cXHRcXHRcXHRpZiAoIGNoID09PSBcXFwiXFxcXDBcXFwiICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBcXFwiXFxcXHVGRkZEXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcXG5cXHRcXHRcXHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcXFwiXFxcXFxcXFxcXFwiICtcXG5cXHRcXHRcXHRcXHRjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcXFwiIFxcXCI7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcXG5cXHRcXHRyZXR1cm4gXFxcIlxcXFxcXFxcXFxcIiArIGNoO1xcblxcdH0sXFxuXFxuXFx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xcblxcdC8vIFNlZSBzZXREb2N1bWVudCgpXFxuXFx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXFxcIlBlcm1pc3Npb24gRGVuaWVkXFxcIlxcblxcdC8vIGVycm9yIGluIElFXFxuXFx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHNldERvY3VtZW50KCk7XFxuXFx0fSxcXG5cXG5cXHRpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKFxcblxcdFxcdGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImZpZWxkc2V0XFxcIjtcXG5cXHRcXHR9LFxcblxcdFxcdHsgZGlyOiBcXFwicGFyZW50Tm9kZVxcXCIsIG5leHQ6IFxcXCJsZWdlbmRcXFwiIH1cXG5cXHQpO1xcblxcbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXFxudHJ5IHtcXG5cXHRwdXNoLmFwcGx5KFxcblxcdFxcdCggYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSApLFxcblxcdFxcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXFxuXFx0KTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxcblxcdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcXG5cXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXFxuXFx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcXG59IGNhdGNoICggZSApIHtcXG5cXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XFxuXFxuXFx0XFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcXG5cXHRcXHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XFxuXFx0XFx0XFx0cHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBlbHMgKSApO1xcblxcdFxcdH0gOlxcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFPDlcXG5cXHRcXHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XFxuXFx0XFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xcblxcdFxcdFxcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRcXHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcXG5cXHRcXHRcXHR3aGlsZSAoICggdGFyZ2V0WyBqKysgXSA9IGVsc1sgaSsrIF0gKSApIHt9XFxuXFx0XFx0XFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xcblxcdFxcdH1cXG5cXHR9O1xcbn1cXG5cXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xcblxcdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxcblxcdFxcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcXG5cXG5cXHRcXHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XFxuXFx0XFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XFxuXFxuXFx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XFxuXFxuXFx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcXG5cXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXFxcInN0cmluZ1xcXCIgfHwgIXNlbGVjdG9yIHx8XFxuXFx0XFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xcblxcblxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdH1cXG5cXG5cXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXFxuXFx0aWYgKCAhc2VlZCApIHtcXG5cXHRcXHRzZXREb2N1bWVudCggY29udGV4dCApO1xcblxcdFxcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xcblxcblxcdFxcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFxcXCJnZXQqQnkqXFxcIiBET00gbWV0aG9kXFxuXFx0XFx0XFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxcblxcdFxcdFxcdGlmICggbm9kZVR5cGUgIT09IDExICYmICggbWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJRCBzZWxlY3RvclxcblxcdFxcdFxcdFxcdGlmICggKCBtID0gbWF0Y2hbIDEgXSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIERvY3VtZW50IGNvbnRleHRcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggKCBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEVsZW1lbnQgY29udGV4dFxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5ld0NvbnRleHQgJiYgKCBlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5pZCA9PT0gbSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFR5cGUgc2VsZWN0b3JcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRjaFsgMiBdICkge1xcblxcdFxcdFxcdFxcdFxcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXG5cXHRcXHRcXHRcXHQvLyBDbGFzcyBzZWxlY3RvclxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoICggbSA9IG1hdGNoWyAzIF0gKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcXG5cXHRcXHRcXHRpZiAoIHN1cHBvcnQucXNhICYmXFxuXFx0XFx0XFx0XFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIHNlbGVjdG9yICsgXFxcIiBcXFwiIF0gJiZcXG5cXHRcXHRcXHRcXHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApICkgJiZcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA4IG9ubHlcXG5cXHRcXHRcXHRcXHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xcblxcdFxcdFxcdFxcdCggbm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcXFwib2JqZWN0XFxcIiApICkge1xcblxcblxcdFxcdFxcdFxcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XFxuXFx0XFx0XFx0XFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxcblxcdFxcdFxcdFxcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXFxuXFx0XFx0XFx0XFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcXG5cXHRcXHRcXHRcXHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXFxuXFx0XFx0XFx0XFx0Ly8gVGhlIHRlY2huaXF1ZSBoYXMgdG8gYmUgdXNlZCBhcyB3ZWxsIHdoZW4gYSBsZWFkaW5nIGNvbWJpbmF0b3IgaXMgdXNlZFxcblxcdFxcdFxcdFxcdC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxcblxcdFxcdFxcdFxcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cXG5cXHRcXHRcXHRcXHRpZiAoIG5vZGVUeXBlID09PSAxICYmXFxuXFx0XFx0XFx0XFx0XFx0KCByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApIHx8IHJjb21iaW5hdG9ycy50ZXN0KCBzZWxlY3RvciApICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXFxuXFx0XFx0XFx0XFx0XFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBXZSBjYW4gdXNlIDpzY29wZSBpbnN0ZWFkIG9mIHRoZSBJRCBoYWNrIGlmIHRoZSBicm93c2VyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3VwcG9ydHMgaXQgJiBpZiB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIGNvbnRleHQuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBuZXdDb250ZXh0ICE9PSBjb250ZXh0IHx8ICFzdXBwb3J0LnNjb3BlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoIG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcXFwiaWRcXFwiICkgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFxcXCJpZFxcXCIsICggbmlkID0gZXhwYW5kbyApICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3RcXG5cXHRcXHRcXHRcXHRcXHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcXG5cXHRcXHRcXHRcXHRcXHRpID0gZ3JvdXBzLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRncm91cHNbIGkgXSA9ICggbmlkID8gXFxcIiNcXFwiICsgbmlkIDogXFxcIjpzY29wZVxcXCIgKSArIFxcXCIgXFxcIiArXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG9TZWxlY3RvciggZ3JvdXBzWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXFxcIixcXFwiICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcXG5cXHRcXHRcXHRcXHRcXHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdH0gZmluYWxseSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFxcXCJpZFxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIEFsbCBvdGhlcnNcXG5cXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXFxcIiQxXFxcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcXG4gKlxcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXFxuICpcXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XFxuICovXFxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XFxuXFx0dmFyIGtleXMgPSBbXTtcXG5cXG5cXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcXG5cXG5cXHRcXHQvLyBVc2UgKGtleSArIFxcXCIgXFxcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcXG5cXHRcXHRpZiAoIGtleXMucHVzaCgga2V5ICsgXFxcIiBcXFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xcblxcblxcdFxcdFxcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xcblxcdFxcdFxcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiAoIGNhY2hlWyBrZXkgKyBcXFwiIFxcXCIgXSA9IHZhbHVlICk7XFxuXFx0fVxcblxcdHJldHVybiBjYWNoZTtcXG59XFxuXFxuLyoqXFxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xcbiAqL1xcbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XFxuXFx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XFxuXFx0cmV0dXJuIGZuO1xcbn1cXG5cXG4vKipcXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcXG4gKi9cXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xcblxcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJmaWVsZHNldFxcXCIgKTtcXG5cXG5cXHR0cnkge1xcblxcdFxcdHJldHVybiAhIWZuKCBlbCApO1xcblxcdH0gY2F0Y2ggKCBlICkge1xcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9IGZpbmFsbHkge1xcblxcblxcdFxcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxcblxcdFxcdGlmICggZWwucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxcblxcdFxcdGVsID0gbnVsbDtcXG5cXHR9XFxufVxcblxcbi8qKlxcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXFxuICovXFxuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcXG5cXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoIFxcXCJ8XFxcIiApLFxcblxcdFxcdGkgPSBhcnIubGVuZ3RoO1xcblxcblxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdEV4cHIuYXR0ckhhbmRsZVsgYXJyWyBpIF0gXSA9IGhhbmRsZXI7XFxuXFx0fVxcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXFxuICogQHBhcmFtIHtFbGVtZW50fSBhXFxuICogQHBhcmFtIHtFbGVtZW50fSBiXFxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXFxuICovXFxuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xcblxcdHZhciBjdXIgPSBiICYmIGEsXFxuXFx0XFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcXG5cXHRcXHRcXHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcXG5cXG5cXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcXG5cXHRpZiAoIGRpZmYgKSB7XFxuXFx0XFx0cmV0dXJuIGRpZmY7XFxuXFx0fVxcblxcblxcdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXFxuXFx0aWYgKCBjdXIgKSB7XFxuXFx0XFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5uZXh0U2libGluZyApICkge1xcblxcdFxcdFxcdGlmICggY3VyID09PSBiICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAtMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gYSA/IDEgOiAtMTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXFxuICovXFxuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XFxuXFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdHJldHVybiBuYW1lID09PSBcXFwiaW5wdXRcXFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcXG5cXHR9O1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxcbiAqL1xcbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcXG5cXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0cmV0dXJuICggbmFtZSA9PT0gXFxcImlucHV0XFxcIiB8fCBuYW1lID09PSBcXFwiYnV0dG9uXFxcIiApICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcXG5cXHR9O1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XFxuXFxuXFx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXFxuXFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXFxuXFx0XFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxcblxcdFxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXFxuXFx0XFx0aWYgKCBcXFwiZm9ybVxcXCIgaW4gZWxlbSApIHtcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XFxuXFx0XFx0XFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcXG5cXHRcXHRcXHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXFxuXFx0XFx0XFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcXG5cXHRcXHRcXHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXFxuXFx0XFx0XFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXFxuXFx0XFx0XFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFxcXCJmb3JtXFxcIiBwcm9wZXJ0eS5cXG5cXHRcXHRcXHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxcblxcdFxcdFxcdFxcdGlmICggXFxcImxhYmVsXFxcIiBpbiBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggXFxcImxhYmVsXFxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcXG5cXHRcXHRcXHRcXHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcXG5cXHRcXHRcXHRcXHRcXHQvKiBqc2hpbnQgLVcwMTggKi9cXG5cXHRcXHRcXHRcXHRcXHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxcblxcdFxcdFxcdFxcdFxcdGluRGlzYWJsZWRGaWVsZHNldCggZWxlbSApID09PSBkaXNhYmxlZDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xcblxcblxcdFxcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cXG5cXHRcXHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3RcXG5cXHRcXHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cXG5cXHRcXHR9IGVsc2UgaWYgKCBcXFwibGFiZWxcXFwiIGluIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHR9O1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcXG5cXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggYXJndW1lbnQgKSB7XFxuXFx0XFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XFxuXFx0XFx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XFxuXFx0XFx0XFx0dmFyIGosXFxuXFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcXG5cXHRcXHRcXHRcXHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcXG5cXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHNlZWRbICggaiA9IG1hdGNoSW5kZXhlc1sgaSBdICkgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRzZWVkWyBqIF0gPSAhKCBtYXRjaGVzWyBqIF0gPSBzZWVkWyBqIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9ICk7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxcbiAqL1xcbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xcblxcdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBjb250ZXh0O1xcbn1cXG5cXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xcblxcbi8qKlxcbiAqIERldGVjdHMgWE1MIG5vZGVzXFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXFxuICovXFxuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHR2YXIgbmFtZXNwYWNlID0gZWxlbS5uYW1lc3BhY2VVUkksXFxuXFx0XFx0ZG9jRWxlbSA9ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKS5kb2N1bWVudEVsZW1lbnQ7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD04XFxuXFx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlIGxvYWRpbmcgaWZyYW1lc1xcblxcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXFxuXFx0cmV0dXJuICFyaHRtbC50ZXN0KCBuYW1lc3BhY2UgfHwgZG9jRWxlbSAmJiBkb2NFbGVtLm5vZGVOYW1lIHx8IFxcXCJIVE1MXFxcIiApO1xcbn07XFxuXFxuLyoqXFxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XFxuICovXFxuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcXG5cXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxcblxcdFxcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcXG5cXG5cXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxcblxcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xcblxcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXFxcIlBlcm1pc3Npb24gZGVuaWVkXFxcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcXG5cXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXFxuXFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxcblxcdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcXG5cXHRcXHRyZXR1cm4gZG9jdW1lbnQ7XFxuXFx0fVxcblxcblxcdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXFxuXFx0ZG9jdW1lbnQgPSBkb2M7XFxuXFx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG5cXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXFxuXFx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcXFwicGVybWlzc2lvbiBkZW5pZWRcXFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcXG5cXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcXG5cXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFxcXCJQZXJtaXNzaW9uIGRlbmllZFxcXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXFxuXFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxcblxcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcXG5cXHRpZiAoIHByZWZlcnJlZERvYyAhPSBkb2N1bWVudCAmJlxcblxcdFxcdCggc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgKSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2VcXG5cXHRcXHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xcblxcdFxcdFxcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcXFwidW5sb2FkXFxcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxcblxcdFxcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcXG5cXHRcXHRcXHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFxcXCJvbnVubG9hZFxcXCIsIHVubG9hZEhhbmRsZXIgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIFN1cHBvcnQ6IElFIDggLSAxMSssIEVkZ2UgMTIgLSAxOCssIENocm9tZSA8PTE2IC0gMjUgb25seSwgRmlyZWZveCA8PTMuNiAtIDMxIG9ubHksXFxuXFx0Ly8gU2FmYXJpIDQgLSA1IG9ubHksIE9wZXJhIDw9MTEuNiAtIDEyLnggb25seVxcblxcdC8vIElFL0VkZ2UgJiBvbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSA6c2NvcGUgcHNldWRvLWNsYXNzLlxcblxcdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjAgb25seVxcblxcdC8vIFNhZmFyaSA2LjAgc3VwcG9ydHMgOnNjb3BlIGJ1dCBpdCdzIGFuIGFsaWFzIG9mIDpyb290IHRoZXJlLlxcblxcdHN1cHBvcnQuc2NvcGUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiZGl2XFxcIiApICk7XFxuXFx0XFx0cmV0dXJuIHR5cGVvZiBlbC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJlxcblxcdFxcdFxcdCFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcXFwiOnNjb3BlIGZpZWxkc2V0IGRpdlxcXCIgKS5sZW5ndGg7XFxuXFx0fSApO1xcblxcblxcdC8qIEF0dHJpYnV0ZXNcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0Ly8gU3VwcG9ydDogSUU8OFxcblxcdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xcblxcdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxcblxcdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xcblxcdFxcdGVsLmNsYXNzTmFtZSA9IFxcXCJpXFxcIjtcXG5cXHRcXHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZSggXFxcImNsYXNzTmFtZVxcXCIgKTtcXG5cXHR9ICk7XFxuXFxuXFx0LyogZ2V0RWxlbWVudChzKUJ5KlxcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXG5cXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiKlxcXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xcblxcdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggXFxcIlxcXCIgKSApO1xcblxcdFxcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFxcXCIqXFxcIiApLmxlbmd0aDtcXG5cXHR9ICk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUU8OVxcblxcdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xcblxcblxcdC8vIFN1cHBvcnQ6IElFPDEwXFxuXFx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXFxuXFx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXFxuXFx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XFxuXFx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XFxuXFx0XFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XFxuXFx0XFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XFxuXFx0fSApO1xcblxcblxcdC8vIElEIGZpbHRlciBhbmQgZmluZFxcblxcdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xcblxcdFxcdEV4cHIuZmlsdGVyWyBcXFwiSURcXFwiIF0gPSBmdW5jdGlvbiggaWQgKSB7XFxuXFx0XFx0XFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXFxcImlkXFxcIiApID09PSBhdHRySWQ7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9O1xcblxcdFxcdEV4cHIuZmluZFsgXFxcIklEXFxcIiBdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xcblxcdFxcdFxcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xcblxcdFxcdFxcdFxcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRFeHByLmZpbHRlclsgXFxcIklEXFxcIiBdID0gIGZ1bmN0aW9uKCBpZCApIHtcXG5cXHRcXHRcXHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJlxcblxcdFxcdFxcdFxcdFxcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXFxcImlkXFxcIiApO1xcblxcdFxcdFxcdFxcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxcblxcdFxcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcXG5cXHRcXHRFeHByLmZpbmRbIFxcXCJJRFxcXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcXG5cXHRcXHRcXHRcXHR2YXIgbm9kZSwgaSwgZWxlbXMsXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBlbGVtICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXFxuXFx0XFx0XFx0XFx0XFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXFxcImlkXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gWyBlbGVtIF07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxcblxcdFxcdFxcdFxcdFxcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcXG5cXHRcXHRcXHRcXHRcXHRpID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggZWxlbSA9IGVsZW1zWyBpKysgXSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFxcXCJpZFxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIFsgZWxlbSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0Ly8gVGFnXFxuXFx0RXhwci5maW5kWyBcXFwiVEFHXFxcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XFxuXFx0XFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcXFwidW5kZWZpbmVkXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XFxuXFxuXFx0XFx0XFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gOlxcblxcblxcdFxcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XFxuXFx0XFx0XFx0dmFyIGVsZW0sXFxuXFx0XFx0XFx0XFx0dG1wID0gW10sXFxuXFx0XFx0XFx0XFx0aSA9IDAsXFxuXFxuXFx0XFx0XFx0XFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xcblxcdFxcdFxcdFxcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcXG5cXG5cXHRcXHRcXHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXFxuXFx0XFx0XFx0aWYgKCB0YWcgPT09IFxcXCIqXFxcIiApIHtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdG1wO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHR9O1xcblxcblxcdC8vIENsYXNzXFxuXFx0RXhwci5maW5kWyBcXFwiQ0xBU1NcXFwiIF0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcXG5cXHRcXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xcblxcdFxcdFxcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3JcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxcblxcblxcdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXFxuXFx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xcblxcblxcdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXFxuXFx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXFxuXFx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxcblxcdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXFxuXFx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxcblxcdHJidWdneVFTQSA9IFtdO1xcblxcblxcdGlmICggKCBzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApICkgKSB7XFxuXFxuXFx0XFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XFxuXFx0XFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxcblxcdFxcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xcblxcblxcdFxcdFxcdHZhciBpbnB1dDtcXG5cXG5cXHRcXHRcXHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXFxuXFx0XFx0XFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XFxuXFx0XFx0XFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXFxuXFx0XFx0XFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcXG5cXHRcXHRcXHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcXG5cXHRcXHRcXHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFxcXCI8YSBpZD0nXFxcIiArIGV4cGFuZG8gKyBcXFwiJz48L2E+XFxcIiArXFxuXFx0XFx0XFx0XFx0XFxcIjxzZWxlY3QgaWQ9J1xcXCIgKyBleHBhbmRvICsgXFxcIi1cXFxcclxcXFxcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cXFwiICtcXG5cXHRcXHRcXHRcXHRcXFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cXFwiO1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcXG5cXHRcXHRcXHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XFxuXFx0XFx0XFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXFxcInNhZmVcXFwiIGZvciBXaW5SVFxcblxcdFxcdFxcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxcblxcdFxcdFxcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXFxcIlttc2FsbG93Y2FwdHVyZV49JyddXFxcIiApLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIlsqXiRdPVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooPzonJ3xcXFxcXFxcIlxcXFxcXFwiKVxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU4XFxuXFx0XFx0XFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcXFwidmFsdWVcXFwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcXG5cXHRcXHRcXHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcXFwiW3NlbGVjdGVkXVxcXCIgKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCJcXFxcXFxcXFtcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKD86dmFsdWV8XFxcIiArIGJvb2xlYW5zICsgXFxcIilcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xcblxcdFxcdFxcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFxcXCJbaWR+PVxcXCIgKyBleHBhbmRvICsgXFxcIi1dXFxcIiApLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIn49XFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcXG5cXHRcXHRcXHQvLyBJRSAxMS9FZGdlIGRvbid0IGZpbmQgZWxlbWVudHMgb24gYSBgW25hbWU9JyddYCBxdWVyeSBpbiBzb21lIGNhc2VzLlxcblxcdFxcdFxcdC8vIEFkZGluZyBhIHRlbXBvcmFyeSBhdHRyaWJ1dGUgdG8gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgc2VsZWN0aW9uIHdvcmtzXFxuXFx0XFx0XFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cXG5cXHRcXHRcXHQvLyBJbnRlcmVzdGluZ2x5LCBJRSAxMCAmIG9sZGVyIGRvbid0IHNlZW0gdG8gaGF2ZSB0aGUgaXNzdWUuXFxuXFx0XFx0XFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiaW5wdXRcXFwiICk7XFxuXFx0XFx0XFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcXFwibmFtZVxcXCIsIFxcXCJcXFwiICk7XFxuXFx0XFx0XFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XFxuXFx0XFx0XFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXFxcIltuYW1lPScnXVxcXCIgKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCJcXFxcXFxcXFtcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqbmFtZVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIio9XFxcIiArXFxuXFx0XFx0XFx0XFx0XFx0d2hpdGVzcGFjZSArIFxcXCIqKD86Jyd8XFxcXFxcXCJcXFxcXFxcIilcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcXG5cXHRcXHRcXHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xcblxcdFxcdFxcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFxcXCI6Y2hlY2tlZFxcXCIgKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCI6Y2hlY2tlZFxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcXG5cXHRcXHRcXHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXFxuXFx0XFx0XFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xcblxcdFxcdFxcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFxcXCJhI1xcXCIgKyBleHBhbmRvICsgXFxcIisqXFxcIiApLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIi4jLitbK35dXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9My42IC0gNSBvbmx5XFxuXFx0XFx0XFx0Ly8gT2xkIEZpcmVmb3ggZG9lc24ndCB0aHJvdyBvbiBhIGJhZGx5LWVzY2FwZWQgaWRlbnRpZmllci5cXG5cXHRcXHRcXHRlbC5xdWVyeVNlbGVjdG9yQWxsKCBcXFwiXFxcXFxcXFxcXFxcZlxcXCIgKTtcXG5cXHRcXHRcXHRyYnVnZ3lRU0EucHVzaCggXFxcIltcXFxcXFxcXHJcXFxcXFxcXG5cXFxcXFxcXGZdXFxcIiApO1xcblxcdFxcdH0gKTtcXG5cXG5cXHRcXHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcXG5cXHRcXHRcXHRlbC5pbm5lckhUTUwgPSBcXFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cXFwiICtcXG5cXHRcXHRcXHRcXHRcXFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXFxuXFx0XFx0XFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XFxuXFx0XFx0XFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImlucHV0XFxcIiApO1xcblxcdFxcdFxcdGlucHV0LnNldEF0dHJpYnV0ZSggXFxcInR5cGVcXFwiLCBcXFwiaGlkZGVuXFxcIiApO1xcblxcdFxcdFxcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXFxcIm5hbWVcXFwiLCBcXFwiRFxcXCIgKTtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRThcXG5cXHRcXHRcXHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcXG5cXHRcXHRcXHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFxcXCJbbmFtZT1kXVxcXCIgKS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCJuYW1lXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlsqXiR8IX5dPz1cXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXFxuXFx0XFx0XFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcXG5cXHRcXHRcXHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFxcXCI6ZW5hYmxlZFxcXCIgKS5sZW5ndGggIT09IDIgKSB7XFxuXFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goIFxcXCI6ZW5hYmxlZFxcXCIsIFxcXCI6ZGlzYWJsZWRcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOS0xMStcXG5cXHRcXHRcXHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcXG5cXHRcXHRcXHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFxcXCI6ZGlzYWJsZWRcXFwiICkubGVuZ3RoICE9PSAyICkge1xcblxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKCBcXFwiOmVuYWJsZWRcXFwiLCBcXFwiOmRpc2FibGVkXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBPcGVyYSAxMCAtIDExIG9ubHlcXG5cXHRcXHRcXHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xcblxcdFxcdFxcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFxcXCIqLDp4XFxcIiApO1xcblxcdFxcdFxcdHJidWdneVFTQS5wdXNoKCBcXFwiLC4qOlxcXCIgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdGlmICggKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKCBtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XFxuXFx0XFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcXG5cXHRcXHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxcblxcdFxcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxcblxcdFxcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IgKSApICkgKSB7XFxuXFxuXFx0XFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXFxuXFx0XFx0XFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcXG5cXHRcXHRcXHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXFxcIipcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxcblxcdFxcdFxcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcXG5cXHRcXHRcXHRtYXRjaGVzLmNhbGwoIGVsLCBcXFwiW3MhPScnXTp4XFxcIiApO1xcblxcdFxcdFxcdHJidWdneU1hdGNoZXMucHVzaCggXFxcIiE9XFxcIiwgcHNldWRvcyApO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxuXFxuXFx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbiggXFxcInxcXFwiICkgKTtcXG5cXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKCBcXFwifFxcXCIgKSApO1xcblxcblxcdC8qIENvbnRhaW5zXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcXG5cXG5cXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcXG5cXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcXG5cXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxcblxcdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XFxuXFx0XFx0ZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFx0XFx0XFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcXG5cXHRcXHRcXHRcXHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcXG5cXHRcXHRcXHRcXHRhZG93bi5jb250YWlucyA/XFxuXFx0XFx0XFx0XFx0XFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcXG5cXHRcXHRcXHRcXHRcXHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcXG5cXHRcXHRcXHQpICk7XFxuXFx0XFx0fSA6XFxuXFx0XFx0ZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFx0XFx0XFx0aWYgKCBiICkge1xcblxcdFxcdFxcdFxcdHdoaWxlICggKCBiID0gYi5wYXJlbnROb2RlICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBiID09PSBhICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9O1xcblxcblxcdC8qIFNvcnRpbmdcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xcblxcdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xcblxcdGZ1bmN0aW9uKCBhLCBiICkge1xcblxcblxcdFxcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXFxuXFx0XFx0aWYgKCBhID09PSBiICkge1xcblxcdFxcdFxcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XFxuXFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cXG5cXHRcXHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XFxuXFx0XFx0aWYgKCBjb21wYXJlICkge1xcblxcdFxcdFxcdHJldHVybiBjb21wYXJlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXFxuXFx0XFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcXFwiUGVybWlzc2lvbiBkZW5pZWRcXFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xcblxcdFxcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cXG5cXHRcXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXFxuXFx0XFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xcblxcdFxcdFxcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXFxuXFx0XFx0XFx0MTtcXG5cXG5cXHRcXHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcXG5cXHRcXHRpZiAoIGNvbXBhcmUgJiAxIHx8XFxuXFx0XFx0XFx0KCAhc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXFxuXFx0XFx0XFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcXFwiUGVybWlzc2lvbiBkZW5pZWRcXFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xcblxcdFxcdFxcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cXG5cXHRcXHRcXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXFxuXFx0XFx0XFx0aWYgKCBhID09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcXG5cXHRcXHRcXHRcXHRjb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIC0xO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcXG5cXHRcXHRcXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFxcXCJQZXJtaXNzaW9uIGRlbmllZFxcXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXFxuXFx0XFx0XFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxcblxcdFxcdFxcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcXG5cXHRcXHRcXHRpZiAoIGIgPT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxcblxcdFxcdFxcdFxcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGIgKSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcXG5cXHRcXHRcXHRyZXR1cm4gc29ydElucHV0ID9cXG5cXHRcXHRcXHRcXHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XFxuXFx0XFx0XFx0XFx0MDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xcblxcdH0gOlxcblxcdGZ1bmN0aW9uKCBhLCBiICkge1xcblxcblxcdFxcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcXG5cXHRcXHRpZiAoIGEgPT09IGIgKSB7XFxuXFx0XFx0XFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGN1cixcXG5cXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRhdXAgPSBhLnBhcmVudE5vZGUsXFxuXFx0XFx0XFx0YnVwID0gYi5wYXJlbnROb2RlLFxcblxcdFxcdFxcdGFwID0gWyBhIF0sXFxuXFx0XFx0XFx0YnAgPSBbIGIgXTtcXG5cXG5cXHRcXHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxcblxcdFxcdGlmICggIWF1cCB8fCAhYnVwICkge1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xcblxcdFxcdFxcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXFxcIlBlcm1pc3Npb24gZGVuaWVkXFxcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcXG5cXHRcXHRcXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXFxuXFx0XFx0XFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXFxuXFx0XFx0XFx0cmV0dXJuIGEgPT0gZG9jdW1lbnQgPyAtMSA6XFxuXFx0XFx0XFx0XFx0YiA9PSBkb2N1bWVudCA/IDEgOlxcblxcdFxcdFxcdFxcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXFxuXFx0XFx0XFx0XFx0YXVwID8gLTEgOlxcblxcdFxcdFxcdFxcdGJ1cCA/IDEgOlxcblxcdFxcdFxcdFxcdHNvcnRJbnB1dCA/XFxuXFx0XFx0XFx0XFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxcblxcdFxcdFxcdFxcdDA7XFxuXFxuXFx0XFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcXG5cXHRcXHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXFxuXFx0XFx0Y3VyID0gYTtcXG5cXHRcXHR3aGlsZSAoICggY3VyID0gY3VyLnBhcmVudE5vZGUgKSApIHtcXG5cXHRcXHRcXHRhcC51bnNoaWZ0KCBjdXIgKTtcXG5cXHRcXHR9XFxuXFx0XFx0Y3VyID0gYjtcXG5cXHRcXHR3aGlsZSAoICggY3VyID0gY3VyLnBhcmVudE5vZGUgKSApIHtcXG5cXHRcXHRcXHRicC51bnNoaWZ0KCBjdXIgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcXG5cXHRcXHR3aGlsZSAoIGFwWyBpIF0gPT09IGJwWyBpIF0gKSB7XFxuXFx0XFx0XFx0aSsrO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gaSA/XFxuXFxuXFx0XFx0XFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXFxuXFx0XFx0XFx0c2libGluZ0NoZWNrKCBhcFsgaSBdLCBicFsgaSBdICkgOlxcblxcblxcdFxcdFxcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xcblxcdFxcdFxcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXFxcIlBlcm1pc3Npb24gZGVuaWVkXFxcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcXG5cXHRcXHRcXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXFxuXFx0XFx0XFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXFxuXFx0XFx0XFx0YXBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAtMSA6XFxuXFx0XFx0XFx0YnBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAxIDpcXG5cXHRcXHRcXHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xcblxcdFxcdFxcdDA7XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gZG9jdW1lbnQ7XFxufTtcXG5cXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcXG5cXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xcbn07XFxuXFxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xcblxcdHNldERvY3VtZW50KCBlbGVtICk7XFxuXFxuXFx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxcblxcdFxcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBleHByICsgXFxcIiBcXFwiIF0gJiZcXG5cXHRcXHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXFxuXFx0XFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xcblxcblxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xcblxcblxcdFxcdFxcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcXG5cXHRcXHRcXHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcXG5cXHRcXHRcXHRcXHQvLyBmcmFnbWVudCBpbiBJRSA5XFxuXFx0XFx0XFx0XFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGNhdGNoICggZSApIHtcXG5cXHRcXHRcXHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xcbn07XFxuXFxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XFxuXFxuXFx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXFxuXFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXFxuXFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcXFwiUGVybWlzc2lvbiBkZW5pZWRcXFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xcblxcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cXG5cXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXFxuXFx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT0gZG9jdW1lbnQgKSB7XFxuXFx0XFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcXG5cXHR9XFxuXFx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XFxufTtcXG5cXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xcblxcblxcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxcblxcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xcblxcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXFxcIlBlcm1pc3Npb24gZGVuaWVkXFxcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcXG5cXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXFxuXFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxcblxcdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9IGRvY3VtZW50ICkge1xcblxcdFxcdHNldERvY3VtZW50KCBlbGVtICk7XFxuXFx0fVxcblxcblxcdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXFxuXFxuXFx0XFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXFxuXFx0XFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xcblxcdFxcdFxcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XFxuXFx0XFx0XFx0dW5kZWZpbmVkO1xcblxcblxcdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0dmFsIDpcXG5cXHRcXHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cXG5cXHRcXHRcXHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcXG5cXHRcXHRcXHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XFxuXFx0XFx0XFx0XFx0dmFsLnZhbHVlIDpcXG5cXHRcXHRcXHRcXHRudWxsO1xcbn07XFxuXFxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XFxuXFx0cmV0dXJuICggc2VsICsgXFxcIlxcXCIgKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XFxufTtcXG5cXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xcblxcdHRocm93IG5ldyBFcnJvciggXFxcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFxcXCIgKyBtc2cgKTtcXG59O1xcblxcbi8qKlxcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xcbiAqL1xcblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XFxuXFx0dmFyIGVsZW0sXFxuXFx0XFx0ZHVwbGljYXRlcyA9IFtdLFxcblxcdFxcdGogPSAwLFxcblxcdFxcdGkgPSAwO1xcblxcblxcdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2VcXG5cXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xcblxcdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xcblxcdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XFxuXFxuXFx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XFxuXFx0XFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xcblxcdFxcdFxcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xcblxcdFxcdFxcdFxcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHdoaWxlICggai0tICkge1xcblxcdFxcdFxcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXFxuXFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XFxuXFx0c29ydElucHV0ID0gbnVsbDtcXG5cXG5cXHRyZXR1cm4gcmVzdWx0cztcXG59O1xcblxcbi8qKlxcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXFxuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXFxuICovXFxuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0dmFyIG5vZGUsXFxuXFx0XFx0cmV0ID0gXFxcIlxcXCIsXFxuXFx0XFx0aSA9IDAsXFxuXFx0XFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xcblxcblxcdGlmICggIW5vZGVUeXBlICkge1xcblxcblxcdFxcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XFxuXFx0XFx0d2hpbGUgKCAoIG5vZGUgPSBlbGVtWyBpKysgXSApICkge1xcblxcblxcdFxcdFxcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXFxuXFx0XFx0XFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcXG5cXHRcXHR9XFxuXFx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xcblxcblxcdFxcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcXG5cXHRcXHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxcblxcdFxcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXFxuXFx0XFx0XFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XFxuXFx0XFx0XFx0XFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xcblxcdFxcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcXG5cXHR9XFxuXFxuXFx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXFxuXFxuXFx0cmV0dXJuIHJldDtcXG59O1xcblxcbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xcblxcblxcdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxcblxcdGNhY2hlTGVuZ3RoOiA1MCxcXG5cXG5cXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcXG5cXG5cXHRtYXRjaDogbWF0Y2hFeHByLFxcblxcblxcdGF0dHJIYW5kbGU6IHt9LFxcblxcblxcdGZpbmQ6IHt9LFxcblxcblxcdHJlbGF0aXZlOiB7XFxuXFx0XFx0XFxcIj5cXFwiOiB7IGRpcjogXFxcInBhcmVudE5vZGVcXFwiLCBmaXJzdDogdHJ1ZSB9LFxcblxcdFxcdFxcXCIgXFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiB9LFxcblxcdFxcdFxcXCIrXFxcIjogeyBkaXI6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLCBmaXJzdDogdHJ1ZSB9LFxcblxcdFxcdFxcXCJ+XFxcIjogeyBkaXI6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiIH1cXG5cXHR9LFxcblxcblxcdHByZUZpbHRlcjoge1xcblxcdFxcdFxcXCJBVFRSXFxcIjogZnVuY3Rpb24oIG1hdGNoICkge1xcblxcdFxcdFxcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XFxuXFxuXFx0XFx0XFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcXG5cXHRcXHRcXHRtYXRjaFsgMyBdID0gKCBtYXRjaFsgMyBdIHx8IG1hdGNoWyA0IF0gfHxcXG5cXHRcXHRcXHRcXHRtYXRjaFsgNSBdIHx8IFxcXCJcXFwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGNoWyAyIF0gPT09IFxcXCJ+PVxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hbIDMgXSA9IFxcXCIgXFxcIiArIG1hdGNoWyAzIF0gKyBcXFwiIFxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcIkNISUxEXFxcIjogZnVuY3Rpb24oIG1hdGNoICkge1xcblxcblxcdFxcdFxcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXFxcIkNISUxEXFxcIl1cXG5cXHRcXHRcXHRcXHQxIHR5cGUgKG9ubHl8bnRofC4uLilcXG5cXHRcXHRcXHRcXHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXFxuXFx0XFx0XFx0XFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxcXGQqfFxcXFxkKm4oWystXVxcXFxkKyk/fC4uLilcXG5cXHRcXHRcXHRcXHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcXFxkKm58KVxcblxcdFxcdFxcdFxcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcXG5cXHRcXHRcXHRcXHQ2IHggb2YgeG4tY29tcG9uZW50XFxuXFx0XFx0XFx0XFx0NyBzaWduIG9mIHktY29tcG9uZW50XFxuXFx0XFx0XFx0XFx0OCB5IG9mIHktY29tcG9uZW50XFxuXFx0XFx0XFx0Ki9cXG5cXHRcXHRcXHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xcblxcblxcdFxcdFxcdGlmICggbWF0Y2hbIDEgXS5zbGljZSggMCwgMyApID09PSBcXFwibnRoXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxcblxcdFxcdFxcdFxcdGlmICggIW1hdGNoWyAzIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0U2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxcblxcdFxcdFxcdFxcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcXG5cXHRcXHRcXHRcXHRtYXRjaFsgNCBdID0gKyggbWF0Y2hbIDQgXSA/XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hbIDUgXSArICggbWF0Y2hbIDYgXSB8fCAxICkgOlxcblxcdFxcdFxcdFxcdFxcdDIgKiAoIG1hdGNoWyAzIF0gPT09IFxcXCJldmVuXFxcIiB8fCBtYXRjaFsgMyBdID09PSBcXFwib2RkXFxcIiApICk7XFxuXFx0XFx0XFx0XFx0bWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcXFwib2RkXFxcIiApO1xcblxcblxcdFxcdFxcdFxcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGNoWyAzIF0gKSB7XFxuXFx0XFx0XFx0XFx0U2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBtYXRjaDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJQU0VVRE9cXFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XFxuXFx0XFx0XFx0dmFyIGV4Y2VzcyxcXG5cXHRcXHRcXHRcXHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRjaEV4cHJbIFxcXCJDSElMRFxcXCIgXS50ZXN0KCBtYXRjaFsgMCBdICkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXFxuXFx0XFx0XFx0aWYgKCBtYXRjaFsgMyBdICkge1xcblxcdFxcdFxcdFxcdG1hdGNoWyAyIF0gPSBtYXRjaFsgNCBdIHx8IG1hdGNoWyA1IF0gfHwgXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcXG5cXG5cXHRcXHRcXHRcXHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxcblxcdFxcdFxcdFxcdCggZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkgKSAmJlxcblxcblxcdFxcdFxcdFxcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xcblxcdFxcdFxcdFxcdCggZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXFxcIilcXFwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XFxuXFx0XFx0XFx0XFx0bWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xcblxcdFxcdFxcdFxcdG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxcblxcdFxcdFxcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdGZpbHRlcjoge1xcblxcblxcdFxcdFxcXCJUQUdcXFwiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcXG5cXHRcXHRcXHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXFxcIipcXFwiID9cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9IDpcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiQ0xBU1NcXFwiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xcblxcdFxcdFxcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXFxcIiBcXFwiIF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBhdHRlcm4gfHxcXG5cXHRcXHRcXHRcXHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcXFwiKF58XFxcIiArIHdoaXRlc3BhY2UgK1xcblxcdFxcdFxcdFxcdFxcdFxcXCIpXFxcIiArIGNsYXNzTmFtZSArIFxcXCIoXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwifCQpXFxcIiApICkgJiYgY2xhc3NDYWNoZShcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBwYXR0ZXJuLnRlc3QoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcXFwic3RyaW5nXFxcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmdldEF0dHJpYnV0ZSggXFxcImNsYXNzXFxcIiApIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcIlxcXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJBVFRSXFxcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gb3BlcmF0b3IgPT09IFxcXCIhPVxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICggIW9wZXJhdG9yICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXN1bHQgKz0gXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBvcGVyYXRvciA9PT0gXFxcIj1cXFwiID8gcmVzdWx0ID09PSBjaGVjayA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCIhPVxcXCIgPyByZXN1bHQgIT09IGNoZWNrIDpcXG5cXHRcXHRcXHRcXHRcXHRvcGVyYXRvciA9PT0gXFxcIl49XFxcIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcXG5cXHRcXHRcXHRcXHRcXHRvcGVyYXRvciA9PT0gXFxcIio9XFxcIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxcblxcdFxcdFxcdFxcdFxcdG9wZXJhdG9yID09PSBcXFwiJD1cXFwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcXG5cXHRcXHRcXHRcXHRcXHRvcGVyYXRvciA9PT0gXFxcIn49XFxcIiA/ICggXFxcIiBcXFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcXFwiIFxcXCIgKSArIFxcXCIgXFxcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XFxuXFx0XFx0XFx0XFx0XFx0b3BlcmF0b3IgPT09IFxcXCJ8PVxcXCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFxcXCItXFxcIiA6XFxuXFx0XFx0XFx0XFx0XFx0ZmFsc2U7XFxuXFx0XFx0XFx0XFx0LyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXFxuXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJDSElMRFxcXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBfYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xcblxcdFxcdFxcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFxcXCJudGhcXFwiLFxcblxcdFxcdFxcdFxcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcXFwibGFzdFxcXCIsXFxuXFx0XFx0XFx0XFx0b2ZUeXBlID0gd2hhdCA9PT0gXFxcIm9mLXR5cGVcXFwiO1xcblxcblxcdFxcdFxcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cXG5cXG5cXHRcXHRcXHRcXHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xcblxcdFxcdFxcdFxcdH0gOlxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXFxcIm5leHRTaWJsaW5nXFxcIiA6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaWZmID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwYXJlbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggc2ltcGxlICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggZGlyICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUgPSBlbGVtO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggKCBub2RlID0gbm9kZVsgZGlyIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG9mVHlwZSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlLm5vZGVUeXBlID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXFxcIm9ubHlcXFwiICYmICFzdGFydCAmJiBcXFwibmV4dFNpYmxpbmdcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IHBhcmVudDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB1c2VDYWNoZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZSA9IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlmZiA9IG5vZGVJbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoIG9mVHlwZSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQrK2RpZmYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdXNlQ2FjaGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxcblxcdFxcdFxcdFxcdFxcdFxcdGRpZmYgLT0gbGFzdDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJQU0VVRE9cXFwiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcXG5cXG5cXHRcXHRcXHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXFxuXFx0XFx0XFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcXG5cXHRcXHRcXHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXFxuXFx0XFx0XFx0dmFyIGFyZ3MsXFxuXFx0XFx0XFx0XFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxcblxcdFxcdFxcdFxcdFxcdFNpenpsZS5lcnJvciggXFxcInVuc3VwcG9ydGVkIHBzZXVkbzogXFxcIiArIHBzZXVkbyApO1xcblxcblxcdFxcdFxcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcXG5cXHRcXHRcXHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxcblxcdFxcdFxcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcXG5cXHRcXHRcXHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcXG5cXHRcXHRcXHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XFxuXFx0XFx0XFx0XFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFxcXCJcXFwiLCBhcmd1bWVudCBdO1xcblxcdFxcdFxcdFxcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xcblxcdFxcdFxcdFxcdFxcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGlkeCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbIGkgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSApIDpcXG5cXHRcXHRcXHRcXHRcXHRmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZm47XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0cHNldWRvczoge1xcblxcblxcdFxcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xcblxcdFxcdFxcXCJub3RcXFwiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXG5cXHRcXHRcXHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxcblxcdFxcdFxcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXFxuXFx0XFx0XFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXFxuXFx0XFx0XFx0dmFyIGlucHV0ID0gW10sXFxuXFx0XFx0XFx0XFx0cmVzdWx0cyA9IFtdLFxcblxcdFxcdFxcdFxcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXFxcIiQxXFxcIiApICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XFxuXFx0XFx0XFx0XFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZWxlbSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0aSA9IHNlZWQubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSApIDpcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRpbnB1dFsgMCBdID0gZWxlbTtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcXG5cXHRcXHRcXHRcXHRcXHRpbnB1dFsgMCBdID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHR9ICksXFxuXFxuXFx0XFx0XFxcImhhc1xcXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9ICksXFxuXFxuXFx0XFx0XFxcImNvbnRhaW5zXFxcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggdGV4dCApIHtcXG5cXHRcXHRcXHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSApLFxcblxcblxcdFxcdC8vIFxcXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXFxuXFx0XFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcXG5cXHRcXHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxcblxcdFxcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXFxcIi1cXFwiLlxcblxcdFxcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxcblxcdFxcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXFxcIlxcblxcdFxcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cXG5cXHRcXHRcXFwibGFuZ1xcXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxcblxcdFxcdFxcdGlmICggIXJpZGVudGlmaWVyLnRlc3QoIGxhbmcgfHwgXFxcIlxcXCIgKSApIHtcXG5cXHRcXHRcXHRcXHRTaXp6bGUuZXJyb3IoIFxcXCJ1bnN1cHBvcnRlZCBsYW5nOiBcXFwiICsgbGFuZyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdFxcdHZhciBlbGVtTGFuZztcXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0ubGFuZyA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFxcXCJ4bWw6bGFuZ1xcXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXFxcImxhbmdcXFwiICkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcXFwiLVxcXCIgKSA9PT0gMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAoICggZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9ICksXFxuXFxuXFx0XFx0Ly8gTWlzY2VsbGFuZW91c1xcblxcdFxcdFxcXCJ0YXJnZXRcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcXG5cXHRcXHRcXHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwicm9vdFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcImZvY3VzXFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiZcXG5cXHRcXHRcXHRcXHQoICFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpICkgJiZcXG5cXHRcXHRcXHRcXHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXFxuXFx0XFx0XFxcImVuYWJsZWRcXFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcXG5cXHRcXHRcXFwiZGlzYWJsZWRcXFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxcblxcblxcdFxcdFxcXCJjaGVja2VkXFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcXG5cXHRcXHRcXHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0cmV0dXJuICggbm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIgJiYgISFlbGVtLmNoZWNrZWQgKSB8fFxcblxcdFxcdFxcdFxcdCggbm9kZU5hbWUgPT09IFxcXCJvcHRpb25cXFwiICYmICEhZWxlbS5zZWxlY3RlZCApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcInNlbGVjdGVkXFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxcblxcdFxcdFxcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcXG5cXHRcXHRcXHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXFxuXFx0XFx0XFx0XFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gQ29udGVudHNcXG5cXHRcXHRcXFwiZW1wdHlcXFwiOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xcblxcdFxcdFxcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcXG5cXHRcXHRcXHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxcblxcdFxcdFxcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cXG5cXHRcXHRcXHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcInBhcmVudFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiAhRXhwci5wc2V1ZG9zWyBcXFwiZW1wdHlcXFwiIF0oIGVsZW0gKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcXG5cXHRcXHRcXFwiaGVhZGVyXFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcImlucHV0XFxcIjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0XFxcImJ1dHRvblxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdHJldHVybiBuYW1lID09PSBcXFwiaW5wdXRcXFwiICYmIGVsZW0udHlwZSA9PT0gXFxcImJ1dHRvblxcXCIgfHwgbmFtZSA9PT0gXFxcImJ1dHRvblxcXCI7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwidGV4dFxcXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHZhciBhdHRyO1xcblxcdFxcdFxcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIgJiZcXG5cXHRcXHRcXHRcXHRlbGVtLnR5cGUgPT09IFxcXCJ0ZXh0XFxcIiAmJlxcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFPDhcXG5cXHRcXHRcXHRcXHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXFxcInNlYXJjaFxcXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXFxcInRleHRcXFwiXFxuXFx0XFx0XFx0XFx0KCAoIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXFxcInR5cGVcXFwiICkgKSA9PSBudWxsIHx8XFxuXFx0XFx0XFx0XFx0XFx0YXR0ci50b0xvd2VyQ2FzZSgpID09PSBcXFwidGV4dFxcXCIgKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cXG5cXHRcXHRcXFwiZmlyc3RcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gWyAwIF07XFxuXFx0XFx0fSApLFxcblxcblxcdFxcdFxcXCJsYXN0XFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XFxuXFx0XFx0fSApLFxcblxcblxcdFxcdFxcXCJlcVxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xcblxcdFxcdFxcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcXG5cXHRcXHR9ICksXFxuXFxuXFx0XFx0XFxcImV2ZW5cXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSAwO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xcblxcdFxcdFxcdFxcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtYXRjaEluZGV4ZXM7XFxuXFx0XFx0fSApLFxcblxcblxcdFxcdFxcXCJvZGRcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSAxO1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xcblxcdFxcdFxcdFxcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtYXRjaEluZGV4ZXM7XFxuXFx0XFx0fSApLFxcblxcblxcdFxcdFxcXCJsdFxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgP1xcblxcdFxcdFxcdFxcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcXG5cXHRcXHRcXHRcXHRhcmd1bWVudCA+IGxlbmd0aCA/XFxuXFx0XFx0XFx0XFx0XFx0bGVuZ3RoIDpcXG5cXHRcXHRcXHRcXHRcXHRhcmd1bWVudDtcXG5cXHRcXHRcXHRmb3IgKCA7IC0taSA+PSAwOyApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xcblxcdFxcdH0gKSxcXG5cXG5cXHRcXHRcXFwiZ3RcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xcblxcdFxcdFxcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcXG5cXHRcXHRcXHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcXG5cXHRcXHR9IClcXG5cXHR9XFxufTtcXG5cXG5FeHByLnBzZXVkb3NbIFxcXCJudGhcXFwiIF0gPSBFeHByLnBzZXVkb3NbIFxcXCJlcVxcXCIgXTtcXG5cXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xcblxcdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcXG59XFxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcXG5cXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xcbn1cXG5cXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cXG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcXG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xcblxcbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XFxuXFx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXFxuXFx0XFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcXG5cXHRcXHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFxcXCIgXFxcIiBdO1xcblxcblxcdGlmICggY2FjaGVkICkge1xcblxcdFxcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XFxuXFx0fVxcblxcblxcdHNvRmFyID0gc2VsZWN0b3I7XFxuXFx0Z3JvdXBzID0gW107XFxuXFx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xcblxcblxcdHdoaWxlICggc29GYXIgKSB7XFxuXFxuXFx0XFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxcblxcdFxcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XFxuXFx0XFx0XFx0aWYgKCBtYXRjaCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxcblxcdFxcdFxcdFxcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGdyb3Vwcy5wdXNoKCAoIHRva2VucyA9IFtdICkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0bWF0Y2hlZCA9IGZhbHNlO1xcblxcblxcdFxcdC8vIENvbWJpbmF0b3JzXFxuXFx0XFx0aWYgKCAoIG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkgKSApIHtcXG5cXHRcXHRcXHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcXG5cXHRcXHRcXHR0b2tlbnMucHVzaCgge1xcblxcdFxcdFxcdFxcdHZhbHVlOiBtYXRjaGVkLFxcblxcblxcdFxcdFxcdFxcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxcblxcdFxcdFxcdFxcdHR5cGU6IG1hdGNoWyAwIF0ucmVwbGFjZSggcnRyaW0sIFxcXCIgXFxcIiApXFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZpbHRlcnNcXG5cXHRcXHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xcblxcdFxcdFxcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcXG5cXHRcXHRcXHRcXHQoIG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApICkgKSApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcXG5cXHRcXHRcXHRcXHR0b2tlbnMucHVzaCgge1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlOiBtYXRjaGVkLFxcblxcdFxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlczogbWF0Y2hcXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggIW1hdGNoZWQgKSB7XFxuXFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3NcXG5cXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcXG5cXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcXG5cXHRyZXR1cm4gcGFyc2VPbmx5ID9cXG5cXHRcXHRzb0Zhci5sZW5ndGggOlxcblxcdFxcdHNvRmFyID9cXG5cXHRcXHRcXHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxcblxcblxcdFxcdFxcdC8vIENhY2hlIHRoZSB0b2tlbnNcXG5cXHRcXHRcXHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcXG59O1xcblxcbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcXG5cXHR2YXIgaSA9IDAsXFxuXFx0XFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcXG5cXHRcXHRzZWxlY3RvciA9IFxcXCJcXFwiO1xcblxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xcblxcdH1cXG5cXHRyZXR1cm4gc2VsZWN0b3I7XFxufVxcblxcbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XFxuXFx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxcblxcdFxcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXFxuXFx0XFx0a2V5ID0gc2tpcCB8fCBkaXIsXFxuXFx0XFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcXFwicGFyZW50Tm9kZVxcXCIsXFxuXFx0XFx0ZG9uZU5hbWUgPSBkb25lKys7XFxuXFxuXFx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xcblxcblxcdFxcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxcblxcdFxcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xcblxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9IDpcXG5cXG5cXHRcXHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcXG5cXHRcXHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xcblxcdFxcdFxcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXFxuXFx0XFx0XFx0XFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XFxuXFxuXFx0XFx0XFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXFxuXFx0XFx0XFx0aWYgKCB4bWwgKSB7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KCBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggKCBvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAoIG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH07XFxufVxcblxcbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcXG5cXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XFxuXFx0XFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHRcXHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcXG5cXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICFtYXRjaGVyc1sgaSBdKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9IDpcXG5cXHRcXHRtYXRjaGVyc1sgMCBdO1xcbn1cXG5cXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XFxuXFx0dmFyIGkgPSAwLFxcblxcdFxcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcXG5cXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcXG5cXHRcXHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XFxuXFx0fVxcblxcdHJldHVybiByZXN1bHRzO1xcbn1cXG5cXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xcblxcdHZhciBlbGVtLFxcblxcdFxcdG5ld1VubWF0Y2hlZCA9IFtdLFxcblxcdFxcdGkgPSAwLFxcblxcdFxcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXFxuXFx0XFx0bWFwcGVkID0gbWFwICE9IG51bGw7XFxuXFxuXFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xcblxcdFxcdFxcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xcblxcdFxcdFxcdFxcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBtYXBwZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWFwLnB1c2goIGkgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcXG59XFxuXFxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xcblxcdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xcblxcdFxcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XFxuXFx0fVxcblxcdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xcblxcdFxcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcXG5cXHR9XFxuXFx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcXG5cXHRcXHR2YXIgdGVtcCwgaSwgZWxlbSxcXG5cXHRcXHRcXHRwcmVNYXAgPSBbXSxcXG5cXHRcXHRcXHRwb3N0TWFwID0gW10sXFxuXFx0XFx0XFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcXG5cXG5cXHRcXHRcXHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxcblxcdFxcdFxcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKFxcblxcdFxcdFxcdFxcdHNlbGVjdG9yIHx8IFxcXCIqXFxcIixcXG5cXHRcXHRcXHRcXHRjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LFxcblxcdFxcdFxcdFxcdFtdXFxuXFx0XFx0XFx0KSxcXG5cXG5cXHRcXHRcXHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cXG5cXHRcXHRcXHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cXG5cXHRcXHRcXHRcXHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XFxuXFx0XFx0XFx0XFx0ZWxlbXMsXFxuXFxuXFx0XFx0XFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xcblxcblxcdFxcdFxcdFxcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXFxuXFx0XFx0XFx0XFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxcblxcdFxcdFxcdFxcdFxcdFtdIDpcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHRzIDpcXG5cXHRcXHRcXHRcXHRtYXRjaGVySW47XFxuXFxuXFx0XFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcXG5cXHRcXHRpZiAoIG1hdGNoZXIgKSB7XFxuXFx0XFx0XFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxcblxcdFxcdGlmICggcG9zdEZpbHRlciApIHtcXG5cXHRcXHRcXHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcXG5cXHRcXHRcXHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XFxuXFxuXFx0XFx0XFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxcblxcdFxcdFxcdGkgPSB0ZW1wLmxlbmd0aDtcXG5cXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHNlZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHBvc3RGaW5kZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXFxuXFx0XFx0XFx0XFx0XFx0dGVtcCA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGVtcC5wdXNoKCAoIG1hdGNoZXJJblsgaSBdID0gZWxlbSApICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcXG5cXHRcXHRcXHRcXHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdCggdGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbIGkgXSApID4gLTEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VlZFsgdGVtcCBdID0gISggcmVzdWx0c1sgdGVtcCBdID0gZWxlbSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxcblxcdFxcdFxcdFxcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlck91dFxcblxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0aWYgKCBwb3N0RmluZGVyICkge1xcblxcdFxcdFxcdFxcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSApO1xcbn1cXG5cXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xcblxcdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXFxuXFx0XFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcXG5cXHRcXHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDAgXS50eXBlIF0sXFxuXFx0XFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlWyBcXFwiIFxcXCIgXSxcXG5cXHRcXHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXFxuXFxuXFx0XFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcXG5cXHRcXHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xcblxcdFxcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcXG5cXHRcXHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcXG5cXHRcXHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXFxuXFx0XFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XFxuXFx0XFx0XFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXFxuXFx0XFx0XFx0XFx0KCBjaGVja0NvbnRleHQgPSBjb250ZXh0ICkubm9kZVR5cGUgP1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxcblxcdFxcdFxcdFxcdFxcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcXG5cXG5cXHRcXHRcXHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcXG5cXHRcXHRcXHRjaGVja0NvbnRleHQgPSBudWxsO1xcblxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0fSBdO1xcblxcblxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdGlmICggKCBtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBpIF0udHlwZSBdICkgKSB7XFxuXFx0XFx0XFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyICkgXTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zWyBpIF0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbIGkgXS5tYXRjaGVzICk7XFxuXFxuXFx0XFx0XFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcXG5cXHRcXHRcXHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcXG5cXHRcXHRcXHRcXHRqID0gKytpO1xcblxcdFxcdFxcdFxcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBqIF0udHlwZSBdICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHNldE1hdGNoZXIoXFxuXFx0XFx0XFx0XFx0XFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXFxuXFx0XFx0XFx0XFx0XFx0aSA+IDEgJiYgdG9TZWxlY3RvcihcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxcblxcdFxcdFxcdFxcdFxcdHRva2Vuc1xcblxcdFxcdFxcdFxcdFxcdFxcdC5zbGljZSggMCwgaSAtIDEgKVxcblxcdFxcdFxcdFxcdFxcdFxcdC5jb25jYXQoIHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcXFwiIFxcXCIgPyBcXFwiKlxcXCIgOiBcXFwiXFxcIiB9IClcXG5cXHRcXHRcXHRcXHRcXHQpLnJlcGxhY2UoIHJ0cmltLCBcXFwiJDFcXFwiICksXFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlcixcXG5cXHRcXHRcXHRcXHRcXHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcXG5cXHRcXHRcXHRcXHRcXHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcXG5cXHRcXHRcXHRcXHRcXHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xcbn1cXG5cXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XFxuXFx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcXG5cXHRcXHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcXG5cXHRcXHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XFxuXFx0XFx0XFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXFxuXFx0XFx0XFx0XFx0bWF0Y2hlZENvdW50ID0gMCxcXG5cXHRcXHRcXHRcXHRpID0gXFxcIjBcXFwiLFxcblxcdFxcdFxcdFxcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXFxuXFx0XFx0XFx0XFx0c2V0TWF0Y2hlZCA9IFtdLFxcblxcdFxcdFxcdFxcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxcblxcblxcdFxcdFxcdFxcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcXG5cXHRcXHRcXHRcXHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFsgXFxcIlRBR1xcXCIgXSggXFxcIipcXFwiLCBvdXRlcm1vc3QgKSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxcblxcdFxcdFxcdFxcdGRpcnJ1bnNVbmlxdWUgPSAoIGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xICksXFxuXFx0XFx0XFx0XFx0bGVuID0gZWxlbXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdGlmICggb3V0ZXJtb3N0ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xcblxcdFxcdFxcdFxcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXFxcIlBlcm1pc3Npb24gZGVuaWVkXFxcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcXG5cXHRcXHRcXHRcXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXFxuXFx0XFx0XFx0XFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxcblxcdFxcdFxcdFxcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxcblxcdFxcdFxcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcXFwibGVuZ3RoXFxcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcXG5cXHRcXHRcXHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0aiA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcXFwiUGVybWlzc2lvbiBkZW5pZWRcXFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xcblxcdFxcdFxcdFxcdFxcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cXG5cXHRcXHRcXHRcXHRcXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT0gZG9jdW1lbnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggKCBtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzWyBqKysgXSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG91dGVybW9zdCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcXG5cXHRcXHRcXHRcXHRpZiAoIGJ5U2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICggZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVkQ291bnQtLTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxcblxcdFxcdFxcdFxcdFxcdGlmICggc2VlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcXG5cXHRcXHRcXHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxcblxcdFxcdFxcdG1hdGNoZWRDb3VudCArPSBpO1xcblxcblxcdFxcdFxcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xcblxcdFxcdFxcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcXG5cXHRcXHRcXHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcXG5cXHRcXHRcXHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxcblxcdFxcdFxcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFxcXCIwXFxcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XFxuXFx0XFx0XFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcXFwiMDBcXFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xcblxcdFxcdFxcdC8vIG51bWVyaWNhbGx5IHplcm8uXFxuXFx0XFx0XFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XFxuXFx0XFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBzZXRNYXRjaGVyc1sgaisrIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHNlZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xcblxcdFxcdFxcdFxcdFxcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEoIHVubWF0Y2hlZFsgaSBdIHx8IHNldE1hdGNoZWRbIGkgXSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHNldE1hdGNoZWRbIGkgXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcXG5cXHRcXHRcXHRcXHRcXHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xcblxcdFxcdFxcdFxcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcXG5cXHRcXHRcXHRcXHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcXG5cXHRcXHRcXHRcXHRcXHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXFxuXFx0XFx0XFx0aWYgKCBvdXRlcm1vc3QgKSB7XFxuXFx0XFx0XFx0XFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XFxuXFx0XFx0XFx0XFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB1bm1hdGNoZWQ7XFxuXFx0XFx0fTtcXG5cXG5cXHRyZXR1cm4gYnlTZXQgP1xcblxcdFxcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxcblxcdFxcdHN1cGVyTWF0Y2hlcjtcXG59XFxuXFxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcXG5cXHR2YXIgaSxcXG5cXHRcXHRzZXRNYXRjaGVycyA9IFtdLFxcblxcdFxcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxcblxcdFxcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXFxcIiBcXFwiIF07XFxuXFxuXFx0aWYgKCAhY2FjaGVkICkge1xcblxcblxcdFxcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxcblxcdFxcdGlmICggIW1hdGNoICkge1xcblxcdFxcdFxcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XFxuXFx0XFx0fVxcblxcdFxcdGkgPSBtYXRjaC5sZW5ndGg7XFxuXFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoWyBpIF0gKTtcXG5cXHRcXHRcXHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xcblxcdFxcdFxcdFxcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXFxuXFx0XFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZShcXG5cXHRcXHRcXHRzZWxlY3RvcixcXG5cXHRcXHRcXHRtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKVxcblxcdFxcdCk7XFxuXFxuXFx0XFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXFxuXFx0XFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XFxuXFx0fVxcblxcdHJldHVybiBjYWNoZWQ7XFxufTtcXG5cXG4vKipcXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxcbiAqL1xcbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XFxuXFx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXFxuXFx0XFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgc2VsZWN0b3IsXFxuXFx0XFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKCBzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yICkgKTtcXG5cXG5cXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcXG5cXG5cXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxcblxcdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcXG5cXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcXG5cXG5cXHRcXHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxcblxcdFxcdHRva2VucyA9IG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwICk7XFxuXFx0XFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAoIHRva2VuID0gdG9rZW5zWyAwIF0gKS50eXBlID09PSBcXFwiSURcXFwiICYmXFxuXFx0XFx0XFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XFxuXFxuXFx0XFx0XFx0Y29udGV4dCA9ICggRXhwci5maW5kWyBcXFwiSURcXFwiIF0oIHRva2VuLm1hdGNoZXNbIDAgXVxcblxcdFxcdFxcdFxcdC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLCBjb250ZXh0ICkgfHwgW10gKVsgMCBdO1xcblxcdFxcdFxcdGlmICggIWNvbnRleHQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFxuXFx0XFx0XFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xcblxcdFxcdFxcdFxcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXFxuXFx0XFx0aSA9IG1hdGNoRXhwclsgXFxcIm5lZWRzQ29udGV4dFxcXCIgXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XFxuXFx0XFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0XFx0dG9rZW4gPSB0b2tlbnNbIGkgXTtcXG5cXG5cXHRcXHRcXHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXFxuXFx0XFx0XFx0aWYgKCBFeHByLnJlbGF0aXZlWyAoIHR5cGUgPSB0b2tlbi50eXBlICkgXSApIHtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCAoIGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xcblxcdFxcdFxcdFxcdGlmICggKCBzZWVkID0gZmluZChcXG5cXHRcXHRcXHRcXHRcXHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcXG5cXHRcXHRcXHRcXHRcXHRyc2libGluZy50ZXN0KCB0b2tlbnNbIDAgXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dFxcblxcdFxcdFxcdFxcdCkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcXG5cXHRcXHRcXHRcXHRcXHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XFxuXFx0XFx0XFx0XFx0XFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICFzZWxlY3RvciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcXG5cXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXFxuXFx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxcblxcdFxcdHNlZWQsXFxuXFx0XFx0Y29udGV4dCxcXG5cXHRcXHQhZG9jdW1lbnRJc0hUTUwsXFxuXFx0XFx0cmVzdWx0cyxcXG5cXHRcXHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XFxuXFx0KTtcXG5cXHRyZXR1cm4gcmVzdWx0cztcXG59O1xcblxcbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXFxuXFxuLy8gU29ydCBzdGFiaWxpdHlcXG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcXFwiXFxcIiApLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oIFxcXCJcXFwiICkgPT09IGV4cGFuZG87XFxuXFxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcXG5cXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcXG5zZXREb2N1bWVudCgpO1xcblxcbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXFxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXFxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcXG5cXG5cXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcXG5cXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJmaWVsZHNldFxcXCIgKSApICYgMTtcXG59ICk7XFxuXFxuLy8gU3VwcG9ydDogSUU8OFxcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFxcXCJpbnRlcnBvbGF0aW9uXFxcIlxcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XFxuaWYgKCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XFxuXFx0ZWwuaW5uZXJIVE1MID0gXFxcIjxhIGhyZWY9JyMnPjwvYT5cXFwiO1xcblxcdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXFxcImhyZWZcXFwiICkgPT09IFxcXCIjXFxcIjtcXG59ICkgKSB7XFxuXFx0YWRkSGFuZGxlKCBcXFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFxcXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcXG5cXHRcXHRpZiAoICFpc1hNTCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcInR5cGVcXFwiID8gMSA6IDIgKTtcXG5cXHRcXHR9XFxuXFx0fSApO1xcbn1cXG5cXG4vLyBTdXBwb3J0OiBJRTw5XFxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIilcXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xcblxcdGVsLmlubmVySFRNTCA9IFxcXCI8aW5wdXQvPlxcXCI7XFxuXFx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFxcXCJ2YWx1ZVxcXCIsIFxcXCJcXFwiICk7XFxuXFx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcXFwidmFsdWVcXFwiICkgPT09IFxcXCJcXFwiO1xcbn0gKSApIHtcXG5cXHRhZGRIYW5kbGUoIFxcXCJ2YWx1ZVxcXCIsIGZ1bmN0aW9uKCBlbGVtLCBfbmFtZSwgaXNYTUwgKSB7XFxuXFx0XFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcXFwiaW5wdXRcXFwiICkge1xcblxcdFxcdFxcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcXG5cXHRcXHR9XFxuXFx0fSApO1xcbn1cXG5cXG4vLyBTdXBwb3J0OiBJRTw5XFxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xcblxcdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoIFxcXCJkaXNhYmxlZFxcXCIgKSA9PSBudWxsO1xcbn0gKSApIHtcXG5cXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XFxuXFx0XFx0dmFyIHZhbDtcXG5cXHRcXHRpZiAoICFpc1hNTCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcXG5cXHRcXHRcXHRcXHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XFxuXFx0XFx0XFx0XFx0XFx0dmFsLnZhbHVlIDpcXG5cXHRcXHRcXHRcXHRcXHRudWxsO1xcblxcdFxcdH1cXG5cXHR9ICk7XFxufVxcblxcbnJldHVybiBTaXp6bGU7XFxuXFxufSApKCB3aW5kb3cgKTtcXG5cXG5cXG5cXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcXG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XFxuXFxuLy8gRGVwcmVjYXRlZFxcbmpRdWVyeS5leHByWyBcXFwiOlxcXCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XFxualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XFxualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcXG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XFxualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XFxuXFxuXFxuXFxuXFxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xcblxcdHZhciBtYXRjaGVkID0gW10sXFxuXFx0XFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xcblxcblxcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xcblxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdHJldHVybiBtYXRjaGVkO1xcbn07XFxuXFxuXFxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XFxuXFx0dmFyIG1hdGNoZWQgPSBbXTtcXG5cXG5cXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xcblxcdFxcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xcblxcdFxcdFxcdG1hdGNoZWQucHVzaCggbiApO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIG1hdGNoZWQ7XFxufTtcXG5cXG5cXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcXG5cXG5cXG5cXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcXG5cXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcbn07XFxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFxcXC9cXFxcMD46XFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXSopW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0qXFxcXC8/Pig/OjxcXFxcL1xcXFwxPnwpJC9pICk7XFxuXFxuXFxuXFxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcXG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcXG5cXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xcblxcdFxcdFxcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdC8vIFNpbmdsZSBlbGVtZW50XFxuXFx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxcblxcdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcXG5cXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XFxufVxcblxcbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcXG5cXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XFxuXFxuXFx0aWYgKCBub3QgKSB7XFxuXFx0XFx0ZXhwciA9IFxcXCI6bm90KFxcXCIgKyBleHByICsgXFxcIilcXFwiO1xcblxcdH1cXG5cXG5cXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XFxuXFx0fVxcblxcblxcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xcblxcdH0gKSApO1xcbn07XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHR2YXIgaSwgcmV0LFxcblxcdFxcdFxcdGxlbiA9IHRoaXMubGVuZ3RoLFxcblxcdFxcdFxcdHNlbGYgPSB0aGlzO1xcblxcblxcdFxcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSApICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xcblxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcXG5cXHR9LFxcblxcdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xcblxcdH0sXFxuXFx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcXG5cXHR9LFxcblxcdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuICEhd2lubm93KFxcblxcdFxcdFxcdHRoaXMsXFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxcblxcdFxcdFxcdC8vIHNvICQoXFxcInA6Zmlyc3RcXFwiKS5pcyhcXFwicDpsYXN0XFxcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFxcXCJwXFxcIi5cXG5cXHRcXHRcXHR0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJzdHJpbmdcXFwiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcXG5cXHRcXHRcXHRcXHRzZWxlY3RvciB8fCBbXSxcXG5cXHRcXHRcXHRmYWxzZVxcblxcdFxcdCkubGVuZ3RoO1xcblxcdH1cXG59ICk7XFxuXFxuXFxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcXG5cXG5cXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcXG52YXIgcm9vdGpRdWVyeSxcXG5cXG5cXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xcblxcdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcXG5cXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcXG5cXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXFxuXFx0cnF1aWNrRXhwciA9IC9eKD86XFxcXHMqKDxbXFxcXHdcXFxcV10rPilbXj5dKnwjKFtcXFxcdy1dKykpJC8sXFxuXFxuXFx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xcblxcdFxcdHZhciBtYXRjaCwgZWxlbTtcXG5cXG5cXHRcXHQvLyBIQU5ETEU6ICQoXFxcIlxcXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXFxuXFx0XFx0aWYgKCAhc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxcblxcdFxcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcXG5cXHRcXHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xcblxcblxcdFxcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3NcXG5cXHRcXHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcXFwiPFxcXCIgJiZcXG5cXHRcXHRcXHRcXHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcXFwiPlxcXCIgJiZcXG5cXHRcXHRcXHRcXHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xcblxcdFxcdFxcdFxcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcXG5cXHRcXHRcXHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxcblxcdFxcdFxcdFxcdGlmICggbWF0Y2hbIDEgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hbIDEgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxcblxcdFxcdFxcdFxcdFxcdFxcdHRydWVcXG5cXHRcXHRcXHRcXHRcXHQpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxcblxcdFxcdFxcdFxcdFxcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdFxcdC8vIEhBTkRMRTogJCgjaWQpXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzWyAwIF0gPSBlbGVtO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubGVuZ3RoID0gMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcXG5cXHRcXHRcXHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXFxuXFx0XFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XFxuXFx0XFx0XFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XFxuXFx0XFx0XFx0dGhpcy5sZW5ndGggPSAxO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcXG5cXHRcXHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcXG5cXHRcXHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xcblxcdFxcdFxcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdFxcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxcblxcblxcdFxcdFxcdFxcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcXG5cXHRcXHRcXHRcXHRzZWxlY3RvciggalF1ZXJ5ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xcblxcdH07XFxuXFxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxcbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xcblxcbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xcblxcblxcbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcXG5cXG5cXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxcblxcdGd1YXJhbnRlZWRVbmlxdWUgPSB7XFxuXFx0XFx0Y2hpbGRyZW46IHRydWUsXFxuXFx0XFx0Y29udGVudHM6IHRydWUsXFxuXFx0XFx0bmV4dDogdHJ1ZSxcXG5cXHRcXHRwcmV2OiB0cnVlXFxuXFx0fTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xcblxcdFxcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcXG5cXHRcXHRcXHRsID0gdGFyZ2V0cy5sZW5ndGg7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDA7XFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XFxuXFx0XFx0dmFyIGN1cixcXG5cXHRcXHRcXHRpID0gMCxcXG5cXHRcXHRcXHRsID0gdGhpcy5sZW5ndGgsXFxuXFx0XFx0XFx0bWF0Y2hlZCA9IFtdLFxcblxcdFxcdFxcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcXFwic3RyaW5nXFxcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xcblxcblxcdFxcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcXG5cXHRcXHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xcblxcdFxcdFxcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcXG5cXHRcXHRcXHRcXHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xcblxcdFxcdFxcdFxcdFxcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXIubm9kZVR5cGUgPT09IDEgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVkLnB1c2goIGN1ciApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcXG5cXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcXG5cXHRcXHRpZiAoICFlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSW5kZXggaW4gc2VsZWN0b3JcXG5cXHRcXHRpZiAoIHR5cGVvZiBlbGVtID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxcblxcdFxcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXFxuXFxuXFx0XFx0XFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXFxuXFx0XFx0XFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXFxuXFx0XFx0KTtcXG5cXHR9LFxcblxcblxcdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcXG5cXHRcXHRcXHRqUXVlcnkudW5pcXVlU29ydChcXG5cXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXFxuXFx0XFx0XFx0KVxcblxcdFxcdCk7XFxuXFx0fSxcXG5cXG5cXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cXG5cXHRcXHRcXHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXFxuXFx0XFx0KTtcXG5cXHR9XFxufSApO1xcblxcbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xcblxcdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cXG5cXHRyZXR1cm4gY3VyO1xcbn1cXG5cXG5qUXVlcnkuZWFjaCgge1xcblxcdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcXG5cXHRcXHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xcblxcdH0sXFxuXFx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcInBhcmVudE5vZGVcXFwiICk7XFxuXFx0fSxcXG5cXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcInBhcmVudE5vZGVcXFwiLCB1bnRpbCApO1xcblxcdH0sXFxuXFx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFxcXCJuZXh0U2libGluZ1xcXCIgKTtcXG5cXHR9LFxcblxcdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiApO1xcblxcdH0sXFxuXFx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcIm5leHRTaWJsaW5nXFxcIiApO1xcblxcdH0sXFxuXFx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIGRpciggZWxlbSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIgKTtcXG5cXHR9LFxcblxcdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcXG5cXHRcXHRyZXR1cm4gZGlyKCBlbGVtLCBcXFwibmV4dFNpYmxpbmdcXFwiLCB1bnRpbCApO1xcblxcdH0sXFxuXFx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xcblxcdFxcdHJldHVybiBkaXIoIGVsZW0sIFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLCB1bnRpbCApO1xcblxcdH0sXFxuXFx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XFxuXFx0fSxcXG5cXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcXG5cXHR9LFxcblxcdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRpZiAoIGVsZW0uY29udGVudERvY3VtZW50ICE9IG51bGwgJiZcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSAxMStcXG5cXHRcXHRcXHQvLyA8b2JqZWN0PiBlbGVtZW50cyB3aXRoIG5vIGBkYXRhYCBhdHRyaWJ1dGUgaGFzIGFuIG9iamVjdFxcblxcdFxcdFxcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxcblxcdFxcdFxcdGdldFByb3RvKCBlbGVtLmNvbnRlbnREb2N1bWVudCApICkge1xcblxcblxcdFxcdFxcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XFxuXFx0XFx0Ly8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XFxuXFx0XFx0Ly8gZG9uJ3Qgc3VwcG9ydCBpdC5cXG5cXHRcXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcXFwidGVtcGxhdGVcXFwiICkgKSB7XFxuXFx0XFx0XFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XFxuXFx0fVxcbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcXG5cXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XFxuXFx0XFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcXG5cXG5cXHRcXHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFxcXCJVbnRpbFxcXCIgKSB7XFxuXFx0XFx0XFx0c2VsZWN0b3IgPSB1bnRpbDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgZHVwbGljYXRlc1xcblxcdFxcdFxcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xcblxcdFxcdFxcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcXG5cXHRcXHRcXHRcXHRtYXRjaGVkLnJldmVyc2UoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xcblxcdH07XFxufSApO1xcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdKy9nICk7XFxuXFxuXFxuXFxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xcblxcdHZhciBvYmplY3QgPSB7fTtcXG5cXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcXG5cXHRcXHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XFxuXFx0fSApO1xcblxcdHJldHVybiBvYmplY3Q7XFxufVxcblxcbi8qXFxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XFxuICpcXG4gKlxcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcXG4gKlxcdFxcdFxcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcXG4gKlxcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXFxuICogXFxcImZpcmVkXFxcIiBtdWx0aXBsZSB0aW1lcy5cXG4gKlxcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XFxuICpcXG4gKlxcdG9uY2U6XFx0XFx0XFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxcbiAqXFxuICpcXHRtZW1vcnk6XFx0XFx0XFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxcbiAqXFx0XFx0XFx0XFx0XFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXFxcIm1lbW9yaXplZFxcXCJcXG4gKlxcdFxcdFxcdFxcdFxcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxcbiAqXFxuICpcXHR1bmlxdWU6XFx0XFx0XFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXFxuICpcXG4gKlxcdHN0b3BPbkZhbHNlOlxcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxcbiAqXFxuICovXFxualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xcblxcblxcdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcXG5cXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXFxuXFx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcXFwic3RyaW5nXFxcIiA/XFxuXFx0XFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcXG5cXHRcXHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xcblxcblxcdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXFxuXFx0XFx0ZmlyaW5nLFxcblxcblxcdFxcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXFxuXFx0XFx0bWVtb3J5LFxcblxcblxcdFxcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXFxuXFx0XFx0ZmlyZWQsXFxuXFxuXFx0XFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xcblxcdFxcdGxvY2tlZCxcXG5cXG5cXHRcXHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxcblxcdFxcdGxpc3QgPSBbXSxcXG5cXG5cXHRcXHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xcblxcdFxcdHF1ZXVlID0gW10sXFxuXFxuXFx0XFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXFxuXFx0XFx0ZmlyaW5nSW5kZXggPSAtMSxcXG5cXG5cXHRcXHQvLyBGaXJlIGNhbGxiYWNrc1xcblxcdFxcdGZpcmUgPSBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcXG5cXHRcXHRcXHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xcblxcblxcdFxcdFxcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxcblxcdFxcdFxcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcXG5cXHRcXHRcXHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XFxuXFx0XFx0XFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XFxuXFx0XFx0XFx0XFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxcblxcdFxcdFxcdFxcdFxcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtZW1vcnkgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XFxuXFx0XFx0XFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XFxuXFx0XFx0XFx0XFx0bWVtb3J5ID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZpcmluZyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXFxuXFx0XFx0XFx0aWYgKCBsb2NrZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xcblxcdFxcdFxcdFxcdGlmICggbWVtb3J5ICkge1xcblxcdFxcdFxcdFxcdFxcdGxpc3QgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XFxuXFx0XFx0c2VsZiA9IHtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XFxuXFx0XFx0XFx0YWRkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGxpc3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGlzdC5wdXNoKCBhcmcgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFkZCggYXJnICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9ICkoIGFyZ3VtZW50cyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyZSgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XFxuXFx0XFx0XFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZpcmluZ0luZGV4LS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxcblxcdFxcdFxcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxcblxcdFxcdFxcdGhhczogZnVuY3Rpb24oIGZuICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmbiA/XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XFxuXFx0XFx0XFx0XFx0XFx0bGlzdC5sZW5ndGggPiAwO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxcblxcdFxcdFxcdGVtcHR5OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGxpc3QgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdCA9IFtdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcXG5cXHRcXHRcXHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcXG5cXHRcXHRcXHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcXG5cXHRcXHRcXHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xcblxcdFxcdFxcdFxcdGxpc3QgPSBtZW1vcnkgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gIWxpc3Q7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBEaXNhYmxlIC5maXJlXFxuXFx0XFx0XFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcXG5cXHRcXHRcXHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXFxuXFx0XFx0XFx0bG9jazogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0bG9ja2VkID0gcXVldWUgPSBbXTtcXG5cXHRcXHRcXHRcXHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ID0gbWVtb3J5ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gISFsb2NrZWQ7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXFxuXFx0XFx0XFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xcblxcdFxcdFxcdFxcdGlmICggIWxvY2tlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRhcmdzID0gYXJncyB8fCBbXTtcXG5cXHRcXHRcXHRcXHRcXHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xcblxcdFxcdFxcdFxcdFxcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICFmaXJpbmcgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyZSgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xcblxcdFxcdFxcdGZpcmU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXFxuXFx0XFx0XFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIWZpcmVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdHJldHVybiBzZWxmO1xcbn07XFxuXFxuXFxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XFxuXFx0cmV0dXJuIHY7XFxufVxcbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xcblxcdHRocm93IGV4O1xcbn1cXG5cXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xcblxcdHZhciBtZXRob2Q7XFxuXFxuXFx0dHJ5IHtcXG5cXG5cXHRcXHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXFxuXFx0XFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xcblxcdFxcdFxcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcXG5cXG5cXHRcXHQvLyBPdGhlciB0aGVuYWJsZXNcXG5cXHRcXHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xcblxcdFxcdFxcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XFxuXFxuXFx0XFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxcblxcdFxcdFxcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcXG5cXHRcXHRcXHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxcblxcdFxcdFxcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXFxuXFx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxcblxcdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXFxuXFx0fSBjYXRjaCAoIHZhbHVlICkge1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcXG5cXHRcXHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XFxuXFx0XFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xcblxcdH1cXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcXG5cXHRcXHR2YXIgdHVwbGVzID0gW1xcblxcblxcdFxcdFxcdFxcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXFxuXFx0XFx0XFx0XFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxcblxcdFxcdFxcdFxcdFsgXFxcIm5vdGlmeVxcXCIsIFxcXCJwcm9ncmVzc1xcXCIsIGpRdWVyeS5DYWxsYmFja3MoIFxcXCJtZW1vcnlcXFwiICksXFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LkNhbGxiYWNrcyggXFxcIm1lbW9yeVxcXCIgKSwgMiBdLFxcblxcdFxcdFxcdFxcdFsgXFxcInJlc29sdmVcXFwiLCBcXFwiZG9uZVxcXCIsIGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKSxcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICksIDAsIFxcXCJyZXNvbHZlZFxcXCIgXSxcXG5cXHRcXHRcXHRcXHRbIFxcXCJyZWplY3RcXFwiLCBcXFwiZmFpbFxcXCIsIGpRdWVyeS5DYWxsYmFja3MoIFxcXCJvbmNlIG1lbW9yeVxcXCIgKSxcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICksIDEsIFxcXCJyZWplY3RlZFxcXCIgXVxcblxcdFxcdFxcdF0sXFxuXFx0XFx0XFx0c3RhdGUgPSBcXFwicGVuZGluZ1xcXCIsXFxuXFx0XFx0XFx0cHJvbWlzZSA9IHtcXG5cXHRcXHRcXHRcXHRzdGF0ZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHN0YXRlO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJjYXRjaFxcXCI6IGZ1bmN0aW9uKCBmbiApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxcblxcdFxcdFxcdFxcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZm5zID0gYXJndW1lbnRzO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuZWQucHJvbWlzZSgpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFxcXCJXaXRoXFxcIiBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZucyA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0fSApLnByb21pc2UoKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWF4RGVwdGggPSAwO1xcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFyZ3MgPSBhcmd1bWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciByZXR1cm5lZCwgdGhlbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoIFxcXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhlbiA9IHJldHVybmVkICYmXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFxcXCJvYmplY3RcXFwiIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dHlwZW9mIHJldHVybmVkID09PSBcXFwiZnVuY3Rpb25cXFwiICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm5lZC50aGVuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggc3BlY2lhbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGVuLmNhbGwoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuZWQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3NcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXhEZXB0aCsrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoZW4uY2FsbChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm5lZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdCA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhcmdzID0gWyByZXR1cm5lZCBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9jZXNzID0gc3BlY2lhbCA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bWlnaHRUaHJvdyA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtaWdodFRocm93KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0ID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFyZ3MgPSBbIGUgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkZXB0aCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9jZXNzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxcblxcdFxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0MCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEZWZlcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9uUHJvZ3Jlc3MgOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdElkZW50aXR5LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0RlZmVyLm5vdGlmeVdpdGhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxcblxcdFxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0MCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdEZWZlcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvbkZ1bGZpbGxlZCA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0SWRlbnRpdHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzb2x2ZShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQwLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5ld0RlZmVyLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b25SZWplY3RlZCA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0VGhyb3dlclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdClcXG5cXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdH0gKS5wcm9taXNlKCk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXFxuXFx0XFx0XFx0XFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxcblxcdFxcdFxcdFxcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRlZmVycmVkID0ge307XFxuXFxuXFx0XFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xcblxcdFxcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcXG5cXHRcXHRcXHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXFxuXFx0XFx0XFx0XFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xcblxcblxcdFxcdFxcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxcblxcdFxcdFxcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXFxuXFx0XFx0XFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcXG5cXHRcXHRcXHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcXG5cXG5cXHRcXHRcXHQvLyBIYW5kbGUgc3RhdGVcXG5cXHRcXHRcXHRpZiAoIHN0YXRlU3RyaW5nICkge1xcblxcdFxcdFxcdFxcdGxpc3QuYWRkKFxcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHN0YXRlID0gXFxcInJlc29sdmVkXFxcIiAoaS5lLiwgZnVsZmlsbGVkKVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHN0YXRlID0gXFxcInJlamVjdGVkXFxcIlxcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlID0gc3RhdGVTdHJpbmc7XFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxcblxcdFxcdFxcdFxcdFxcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxcblxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxcblxcdFxcdFxcdFxcdFxcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXFxuXFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xcblxcdFxcdFxcdFxcdFxcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXFxuXFx0XFx0XFx0XFx0XFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxcblxcdFxcdFxcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXFxuXFx0XFx0XFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxcblxcdFxcdFxcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcXG5cXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxcblxcdFxcdFxcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxcblxcdFxcdFxcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFxcXCJXaXRoXFxcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcXG5cXHRcXHRcXHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxcblxcdFxcdFxcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXFxcIldpdGhcXFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xcblxcdFxcdH0gKTtcXG5cXG5cXHRcXHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2VcXG5cXHRcXHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XFxuXFxuXFx0XFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxcblxcdFxcdGlmICggZnVuYyApIHtcXG5cXHRcXHRcXHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBbGwgZG9uZSFcXG5cXHRcXHRyZXR1cm4gZGVmZXJyZWQ7XFxuXFx0fSxcXG5cXG5cXHQvLyBEZWZlcnJlZCBoZWxwZXJcXG5cXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XFxuXFx0XFx0dmFyXFxuXFxuXFx0XFx0XFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXFxuXFx0XFx0XFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcXG5cXG5cXHRcXHRcXHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcXG5cXHRcXHRcXHRpID0gcmVtYWluaW5nLFxcblxcblxcdFxcdFxcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcXG5cXHRcXHRcXHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxcblxcdFxcdFxcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcXG5cXG5cXHRcXHRcXHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXFxuXFx0XFx0XFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXFxuXFxuXFx0XFx0XFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxcblxcdFxcdFxcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdFxcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcXG5cXHRcXHRcXHRcXHRcXHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcXG5cXHRcXHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xcblxcdFxcdFxcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcXG5cXHRcXHRcXHRcXHQhcmVtYWluaW5nICk7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxcblxcdFxcdFxcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFxcXCJwZW5kaW5nXFxcIiB8fFxcblxcdFxcdFxcdFxcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBtYXN0ZXIudGhlbigpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcXG5cXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcXG5cXHR9XFxufSApO1xcblxcblxcbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxcbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xcblxcbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XFxuXFx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcXG5cXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xcblxcdFxcdHdpbmRvdy5jb25zb2xlLndhcm4oIFxcXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcXFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XFxuXFx0fVxcbn07XFxuXFxuXFxuXFxuXFxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xcblxcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcXG5cXHRcXHR0aHJvdyBlcnJvcjtcXG5cXHR9ICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcXG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XFxuXFxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xcblxcblxcdHJlYWR5TGlzdFxcblxcdFxcdC50aGVuKCBmbiApXFxuXFxuXFx0XFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcXG5cXHRcXHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcXG5cXHRcXHQvLyByZWdpc3RyYXRpb24uXFxuXFx0XFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xcblxcdFxcdH0gKTtcXG5cXG5cXHRyZXR1cm4gdGhpcztcXG59O1xcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXG5cXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxcblxcdGlzUmVhZHk6IGZhbHNlLFxcblxcblxcdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcXG5cXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxcblxcdHJlYWR5V2FpdDogMSxcXG5cXG5cXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XFxuXFx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xcblxcblxcdFxcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcXG5cXHRcXHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxcblxcdFxcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcXG5cXG5cXHRcXHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxcblxcdFxcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxcblxcdFxcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XFxuXFxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XFxuXFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBjb21wbGV0ZWQgKTtcXG5cXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXFxcImxvYWRcXFwiLCBjb21wbGV0ZWQgKTtcXG5cXHRqUXVlcnkucmVhZHkoKTtcXG59XFxuXFxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XFxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXFxcImludGVyYWN0aXZlXFxcIiB0b28gc29vblxcbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXFxcImNvbXBsZXRlXFxcIiB8fFxcblxcdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXFxcImxvYWRpbmdcXFwiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcXG5cXG5cXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcXG5cXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XFxuXFxufSBlbHNlIHtcXG5cXG5cXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXFxuXFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBjb21wbGV0ZWQgKTtcXG5cXG5cXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xcblxcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcXFwibG9hZFxcXCIsIGNvbXBsZXRlZCApO1xcbn1cXG5cXG5cXG5cXG5cXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xcblxcdHZhciBpID0gMCxcXG5cXHRcXHRsZW4gPSBlbGVtcy5sZW5ndGgsXFxuXFx0XFx0YnVsayA9IGtleSA9PSBudWxsO1xcblxcblxcdC8vIFNldHMgbWFueSB2YWx1ZXNcXG5cXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcdFxcdGNoYWluYWJsZSA9IHRydWU7XFxuXFx0XFx0Zm9yICggaSBpbiBrZXkgKSB7XFxuXFx0XFx0XFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XFxuXFx0XFx0fVxcblxcblxcdC8vIFNldHMgb25lIHZhbHVlXFxuXFx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRjaGFpbmFibGUgPSB0cnVlO1xcblxcblxcdFxcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0cmF3ID0gdHJ1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBidWxrICkge1xcblxcblxcdFxcdFxcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxcblxcdFxcdFxcdGlmICggcmF3ICkge1xcblxcdFxcdFxcdFxcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdGZuID0gbnVsbDtcXG5cXG5cXHRcXHRcXHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRidWxrID0gZm47XFxuXFx0XFx0XFx0XFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwgX2tleSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggZm4gKSB7XFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0Zm4oXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlIDpcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0aWYgKCBjaGFpbmFibGUgKSB7XFxuXFx0XFx0cmV0dXJuIGVsZW1zO1xcblxcdH1cXG5cXG5cXHQvLyBHZXRzXFxuXFx0aWYgKCBidWxrICkge1xcblxcdFxcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XFxufTtcXG5cXG5cXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcXG5cXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XFxuXFxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXFxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggX2FsbCwgbGV0dGVyICkge1xcblxcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcXG59XFxuXFxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcXG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXFxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XFxuXFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFxcXCJtcy1cXFwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xcbn1cXG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcXG5cXG5cXHQvLyBBY2NlcHRzIG9ubHk6XFxuXFx0Ly8gIC0gTm9kZVxcblxcdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcXG5cXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxcblxcdC8vICAtIE9iamVjdFxcblxcdC8vICAgIC0gQW55XFxuXFx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xcbn07XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gRGF0YSgpIHtcXG5cXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XFxufVxcblxcbkRhdGEudWlkID0gMTtcXG5cXG5EYXRhLnByb3RvdHlwZSA9IHtcXG5cXG5cXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xcblxcblxcdFxcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxcblxcdFxcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcXG5cXG5cXHRcXHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcXG5cXHRcXHRpZiAoICF2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YWx1ZSA9IHt9O1xcblxcblxcdFxcdFxcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxcblxcdFxcdFxcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXFxuXFx0XFx0XFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXFxuXFx0XFx0XFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcXG5cXHRcXHRcXHRcXHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxcblxcdFxcdFxcdFxcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XFxuXFx0XFx0XFx0XFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcXG5cXHRcXHRcXHRcXHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZTogdmFsdWUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uZmlndXJhYmxlOiB0cnVlXFxuXFx0XFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHR9LFxcblxcdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgcHJvcCxcXG5cXHRcXHRcXHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XFxuXFxuXFx0XFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xcblxcdFxcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1NylcXG5cXHRcXHRpZiAoIHR5cGVvZiBkYXRhID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xcblxcblxcdFxcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxcblxcdFxcdFxcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcXG5cXHRcXHRcXHRcXHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBjYWNoZTtcXG5cXHR9LFxcblxcdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XFxuXFx0XFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHR0aGlzLmNhY2hlKCBvd25lciApIDpcXG5cXG5cXHRcXHRcXHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXFxuXFx0XFx0XFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xcblxcdH0sXFxuXFx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XFxuXFxuXFx0XFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxcblxcdFxcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gVGFrZSB0aGUgXFxcInJlYWRcXFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxcblxcdFxcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcXG5cXHRcXHQvL1xcblxcdFxcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3RcXG5cXHRcXHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XFxuXFx0XFx0Ly9cXG5cXHRcXHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XFxuXFx0XFx0XFx0XFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcXFwic3RyaW5nXFxcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcXG5cXHRcXHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcXG5cXHRcXHQvL1xcblxcdFxcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcXG5cXHRcXHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxcblxcdFxcdC8vXFxuXFx0XFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XFxuXFxuXFx0XFx0Ly8gU2luY2UgdGhlIFxcXCJzZXRcXFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xcblxcdFxcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxcblxcdFxcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XFxuXFx0fSxcXG5cXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xcblxcdFxcdHZhciBpLFxcblxcdFxcdFxcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xcblxcblxcdFxcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXFxuXFx0XFx0XFx0XFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXFxuXFx0XFx0XFx0XFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xcblxcblxcdFxcdFxcdFxcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxcblxcdFxcdFxcdFxcdGtleSA9IGtleSBpbiBjYWNoZSA/XFxuXFx0XFx0XFx0XFx0XFx0WyBrZXkgXSA6XFxuXFx0XFx0XFx0XFx0XFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpID0ga2V5Lmxlbmd0aDtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcXG5cXHRcXHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcXG5cXHRcXHRcXHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xcblxcdFxcdFxcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcXG5cXHRcXHRcXHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxcblxcdFxcdFxcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0sXFxuXFx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xcblxcdFxcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcXG5cXHRcXHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XFxuXFx0fVxcbn07XFxudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcXG5cXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xcblxcblxcblxcbi8vXFx0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxcbi8vXFxuLy9cXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXFxuLy9cXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2VcXG4vL1xcdFxcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cXG4vL1xcdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXFxcInByaXZhdGVcXFwiIGFuZCBcXFwidXNlclxcXCIgZGF0YS5cXG4vL1xcdDQuIF9OZXZlcl8gZXhwb3NlIFxcXCJwcml2YXRlXFxcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXFxuLy9cXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcXG4vL1xcdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxcblxcbnZhciByYnJhY2UgPSAvXig/OlxcXFx7W1xcXFx3XFxcXFddKlxcXFx9fFxcXFxbW1xcXFx3XFxcXFddKlxcXFxdKSQvLFxcblxcdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcXG5cXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xcblxcdGlmICggZGF0YSA9PT0gXFxcInRydWVcXFwiICkge1xcblxcdFxcdHJldHVybiB0cnVlO1xcblxcdH1cXG5cXG5cXHRpZiAoIGRhdGEgPT09IFxcXCJmYWxzZVxcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdH1cXG5cXG5cXHRpZiAoIGRhdGEgPT09IFxcXCJudWxsXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHR9XFxuXFxuXFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcXG5cXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXFxcIlxcXCIgKSB7XFxuXFx0XFx0cmV0dXJuICtkYXRhO1xcblxcdH1cXG5cXG5cXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XFxuXFx0XFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGRhdGE7XFxufVxcblxcbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XFxuXFx0dmFyIG5hbWU7XFxuXFxuXFx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxcblxcdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxcblxcdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XFxuXFx0XFx0bmFtZSA9IFxcXCJkYXRhLVxcXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXFxcIi0kJlxcXCIgKS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xcblxcblxcdFxcdGlmICggdHlwZW9mIGRhdGEgPT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcXG5cXHRcXHRcXHR9IGNhdGNoICggZSApIHt9XFxuXFxuXFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXFxuXFx0XFx0XFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGRhdGEgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRyZXR1cm4gZGF0YTtcXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xcblxcdH0sXFxuXFxuXFx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XFxuXFx0XFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xcblxcdH0sXFxuXFxuXFx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XFxuXFx0XFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XFxuXFx0fSxcXG5cXG5cXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxcblxcdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxcblxcdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcXG5cXHRcXHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XFxuXFx0fSxcXG5cXG5cXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XFxuXFx0XFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XFxuXFx0XFx0dmFyIGksIG5hbWUsIGRhdGEsXFxuXFx0XFx0XFx0ZWxlbSA9IHRoaXNbIDAgXSxcXG5cXHRcXHRcXHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xcblxcblxcdFxcdC8vIEdldHMgYWxsIHZhbHVlc1xcblxcdFxcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFxcXCJoYXNEYXRhQXR0cnNcXFwiICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aSA9IGF0dHJzLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBhdHRyc1sgaSBdICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBuYW1lLmluZGV4T2YoIFxcXCJkYXRhLVxcXCIgKSA9PT0gMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcXFwiaGFzRGF0YUF0dHJzXFxcIiwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXFxuXFx0XFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciBkYXRhO1xcblxcblxcdFxcdFxcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XFxuXFx0XFx0XFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcXG5cXHRcXHRcXHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxcblxcdFxcdFxcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcXG5cXHRcXHRcXHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxcblxcdFxcdFxcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcXG5cXHRcXHRcXHRcXHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xcblxcdFxcdFxcdFxcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBdHRlbXB0IHRvIFxcXCJkaXNjb3ZlclxcXCIgdGhlIGRhdGEgaW5cXG5cXHRcXHRcXHRcXHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXFxuXFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IHRoZSBkYXRhLi4uXFxuXFx0XFx0XFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XFxuXFx0XFx0XFx0XFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xcblxcdH0sXFxuXFxuXFx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcblxcbmpRdWVyeS5leHRlbmQoIHtcXG5cXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XFxuXFx0XFx0dmFyIHF1ZXVlO1xcblxcblxcdFxcdGlmICggZWxlbSApIHtcXG5cXHRcXHRcXHR0eXBlID0gKCB0eXBlIHx8IFxcXCJmeFxcXCIgKSArIFxcXCJxdWV1ZVxcXCI7XFxuXFx0XFx0XFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcXG5cXG5cXHRcXHRcXHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXFxuXFx0XFx0XFx0aWYgKCBkYXRhICkge1xcblxcdFxcdFxcdFxcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRxdWV1ZS5wdXNoKCBkYXRhICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcXVldWUgfHwgW107XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XFxuXFx0XFx0dHlwZSA9IHR5cGUgfHwgXFxcImZ4XFxcIjtcXG5cXG5cXHRcXHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcXG5cXHRcXHRcXHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcXG5cXHRcXHRcXHRmbiA9IHF1ZXVlLnNoaWZ0KCksXFxuXFx0XFx0XFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcXG5cXHRcXHRcXHRuZXh0ID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcXG5cXHRcXHRpZiAoIGZuID09PSBcXFwiaW5wcm9ncmVzc1xcXCIgKSB7XFxuXFx0XFx0XFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xcblxcdFxcdFxcdHN0YXJ0TGVuZ3RoLS07XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggZm4gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xcblxcdFxcdFxcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcXG5cXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJmeFxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0cXVldWUudW5zaGlmdCggXFxcImlucHJvZ3Jlc3NcXFwiICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cXG5cXHRcXHRcXHRkZWxldGUgaG9va3Muc3RvcDtcXG5cXHRcXHRcXHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcXG5cXHRcXHRcXHRob29rcy5lbXB0eS5maXJlKCk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcXG5cXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XFxuXFx0XFx0dmFyIGtleSA9IHR5cGUgKyBcXFwicXVldWVIb29rc1xcXCI7XFxuXFx0XFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcXG5cXHRcXHRcXHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXFxcIm9uY2UgbWVtb3J5XFxcIiApLmFkZCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcXFwicXVldWVcXFwiLCBrZXkgXSApO1xcblxcdFxcdFxcdH0gKVxcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XFxuXFx0XFx0dmFyIHNldHRlciA9IDI7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0ZGF0YSA9IHR5cGU7XFxuXFx0XFx0XFx0dHlwZSA9IFxcXCJmeFxcXCI7XFxuXFx0XFx0XFx0c2V0dGVyLS07XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0XFx0dGhpcyA6XFxuXFx0XFx0XFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxcblxcdFxcdFxcdFxcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdHlwZSA9PT0gXFxcImZ4XFxcIiAmJiBxdWV1ZVsgMCBdICE9PSBcXFwiaW5wcm9ncmVzc1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSApO1xcblxcdH0sXFxuXFx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcXFwiZnhcXFwiLCBbXSApO1xcblxcdH0sXFxuXFxuXFx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxcblxcdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxcblxcdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XFxuXFx0XFx0dmFyIHRtcCxcXG5cXHRcXHRcXHRjb3VudCA9IDEsXFxuXFx0XFx0XFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcXG5cXHRcXHRcXHRlbGVtZW50cyA9IHRoaXMsXFxuXFx0XFx0XFx0aSA9IHRoaXMubGVuZ3RoLFxcblxcdFxcdFxcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoICEoIC0tY291bnQgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdGlmICggdHlwZW9mIHR5cGUgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdG9iaiA9IHR5cGU7XFxuXFx0XFx0XFx0dHlwZSA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFx0XFx0dHlwZSA9IHR5cGUgfHwgXFxcImZ4XFxcIjtcXG5cXG5cXHRcXHR3aGlsZSAoIGktLSApIHtcXG5cXHRcXHRcXHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcXFwicXVldWVIb29rc1xcXCIgKTtcXG5cXHRcXHRcXHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XFxuXFx0XFx0XFx0XFx0Y291bnQrKztcXG5cXHRcXHRcXHRcXHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXNvbHZlKCk7XFxuXFx0XFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xcblxcdH1cXG59ICk7XFxudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcXFxkKlxcXFwufClcXFxcZCsoPzpbZUVdWystXT9cXFxcZCt8KS8gKS5zb3VyY2U7XFxuXFxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcXFwiXig/OihbKy1dKT18KShcXFwiICsgcG51bSArIFxcXCIpKFthLXolXSopJFxcXCIsIFxcXCJpXFxcIiApO1xcblxcblxcbnZhciBjc3NFeHBhbmQgPSBbIFxcXCJUb3BcXFwiLCBcXFwiUmlnaHRcXFwiLCBcXFwiQm90dG9tXFxcIiwgXFxcIkxlZnRcXFwiIF07XFxuXFxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcXG5cXG5cXG5cXG5cXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xcblxcdFxcdH0sXFxuXFx0XFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcXG5cXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcXG5cXHQvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcXG5cXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXFxuXFx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXFxuXFx0aWYgKCBkb2N1bWVudEVsZW1lbnQuZ2V0Um9vdE5vZGUgKSB7XFxuXFx0XFx0aXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XFxuXFx0XFx0XFx0XFx0ZWxlbS5nZXRSb290Tm9kZSggY29tcG9zZWQgKSA9PT0gZWxlbS5vd25lckRvY3VtZW50O1xcblxcdFxcdH07XFxuXFx0fVxcbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XFxuXFxuXFx0XFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XFxuXFx0XFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XFxuXFx0XFx0ZWxlbSA9IGVsIHx8IGVsZW07XFxuXFxuXFx0XFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcXG5cXHRcXHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgfHxcXG5cXHRcXHRcXHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFxcXCJcXFwiICYmXFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XFxuXFx0XFx0XFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXFxuXFx0XFx0XFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxcblxcdFxcdFxcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxcblxcblxcdFxcdFxcdGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApID09PSBcXFwibm9uZVxcXCI7XFxuXFx0fTtcXG5cXG5cXG5cXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xcblxcdHZhciBhZGp1c3RlZCwgc2NhbGUsXFxuXFx0XFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxcblxcdFxcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cXG5cXHRcXHRcXHRmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHdlZW4uY3VyKCk7XFxuXFx0XFx0XFx0fSA6XFxuXFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFxcXCJcXFwiICk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXFxuXFx0XFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiICksXFxuXFxuXFx0XFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcXG5cXHRcXHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxcblxcdFxcdFxcdCggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFxcXCJweFxcXCIgJiYgK2luaXRpYWwgKSAmJlxcblxcdFxcdFxcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XFxuXFxuXFx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcXG5cXHRcXHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXFxuXFx0XFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xcblxcblxcdFxcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3NcXG5cXHRcXHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XFxuXFxuXFx0XFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcXG5cXHRcXHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcXG5cXG5cXHRcXHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcXG5cXG5cXHRcXHRcXHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxcblxcdFxcdFxcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cXG5cXHRcXHRcXHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XFxuXFx0XFx0XFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XFxuXFx0XFx0XFx0XFx0bWF4SXRlcmF0aW9ucyA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcXG5cXHRcXHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XFxuXFxuXFx0XFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxcblxcdFxcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xcblxcdH1cXG5cXG5cXHRpZiAoIHZhbHVlUGFydHMgKSB7XFxuXFx0XFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XFxuXFxuXFx0XFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXFxuXFx0XFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xcblxcdFxcdFxcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XFxuXFx0XFx0XFx0K3ZhbHVlUGFydHNbIDIgXTtcXG5cXHRcXHRpZiAoIHR3ZWVuICkge1xcblxcdFxcdFxcdHR3ZWVuLnVuaXQgPSB1bml0O1xcblxcdFxcdFxcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcXG5cXHRcXHRcXHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdHJldHVybiBhZGp1c3RlZDtcXG59XFxuXFxuXFxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XFxuXFxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XFxuXFx0dmFyIHRlbXAsXFxuXFx0XFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxcblxcdFxcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcXG5cXHRcXHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XFxuXFxuXFx0aWYgKCBkaXNwbGF5ICkge1xcblxcdFxcdHJldHVybiBkaXNwbGF5O1xcblxcdH1cXG5cXG5cXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XFxuXFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFxcXCJkaXNwbGF5XFxcIiApO1xcblxcblxcdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xcblxcblxcdGlmICggZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiICkge1xcblxcdFxcdGRpc3BsYXkgPSBcXFwiYmxvY2tcXFwiO1xcblxcdH1cXG5cXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XFxuXFxuXFx0cmV0dXJuIGRpc3BsYXk7XFxufVxcblxcbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcXG5cXHR2YXIgZGlzcGxheSwgZWxlbSxcXG5cXHRcXHR2YWx1ZXMgPSBbXSxcXG5cXHRcXHRpbmRleCA9IDAsXFxuXFx0XFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xcblxcblxcdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxcblxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xcblxcdFxcdGlmICggIWVsZW0uc3R5bGUgKSB7XFxuXFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XFxuXFx0XFx0aWYgKCBzaG93ICkge1xcblxcblxcdFxcdFxcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcXG5cXHRcXHRcXHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcXG5cXHRcXHRcXHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXFxuXFx0XFx0XFx0aWYgKCBkaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcXFwiZGlzcGxheVxcXCIgKSB8fCBudWxsO1xcblxcdFxcdFxcdFxcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcXFwiXFxcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGlmICggZGlzcGxheSAhPT0gXFxcIm5vbmVcXFwiICkge1xcblxcdFxcdFxcdFxcdHZhbHVlc1sgaW5kZXggXSA9IFxcXCJub25lXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXFxuXFx0XFx0XFx0XFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcXFwiZGlzcGxheVxcXCIsIGRpc3BsYXkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XFxuXFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xcblxcdFxcdFxcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gZWxlbWVudHM7XFxufVxcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRzaG93OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcXG5cXHR9LFxcblxcdGhpZGU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xcblxcdH0sXFxuXFx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XFxuXFx0XFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFxcXCJib29sZWFuXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLnNob3coKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xcblxcbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcXFwvXFxcXDA+XFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXSopL2kgKTtcXG5cXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xcblxcblxcblxcbiggZnVuY3Rpb24oKSB7XFxuXFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxcblxcdFxcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiZGl2XFxcIiApICksXFxuXFx0XFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiaW5wdXRcXFwiICk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxcblxcdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXFxuXFx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxcblxcdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxcblxcdGlucHV0LnNldEF0dHJpYnV0ZSggXFxcInR5cGVcXFwiLCBcXFwicmFkaW9cXFwiICk7XFxuXFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcXFwiY2hlY2tlZFxcXCIsIFxcXCJjaGVja2VkXFxcIiApO1xcblxcdGlucHV0LnNldEF0dHJpYnV0ZSggXFxcIm5hbWVcXFwiLCBcXFwidFxcXCIgKTtcXG5cXG5cXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XFxuXFx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXFxuXFx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xcblxcblxcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxcblxcdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXFxuXFx0ZGl2LmlubmVySFRNTCA9IFxcXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XFxcIjtcXG5cXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcblxcdC8vIElFIDw9OSByZXBsYWNlcyA8b3B0aW9uPiB0YWdzIHdpdGggdGhlaXIgY29udGVudHMgd2hlbiBpbnNlcnRlZCBvdXRzaWRlIG9mXFxuXFx0Ly8gdGhlIHNlbGVjdCBlbGVtZW50LlxcblxcdGRpdi5pbm5lckhUTUwgPSBcXFwiPG9wdGlvbj48L29wdGlvbj5cXFwiO1xcblxcdHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xcbn0gKSgpO1xcblxcblxcbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXFxudmFyIHdyYXBNYXAgPSB7XFxuXFxuXFx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcXG5cXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXFxuXFx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxcblxcdHRoZWFkOiBbIDEsIFxcXCI8dGFibGU+XFxcIiwgXFxcIjwvdGFibGU+XFxcIiBdLFxcblxcdGNvbDogWyAyLCBcXFwiPHRhYmxlPjxjb2xncm91cD5cXFwiLCBcXFwiPC9jb2xncm91cD48L3RhYmxlPlxcXCIgXSxcXG5cXHR0cjogWyAyLCBcXFwiPHRhYmxlPjx0Ym9keT5cXFwiLCBcXFwiPC90Ym9keT48L3RhYmxlPlxcXCIgXSxcXG5cXHR0ZDogWyAzLCBcXFwiPHRhYmxlPjx0Ym9keT48dHI+XFxcIiwgXFxcIjwvdHI+PC90Ym9keT48L3RhYmxlPlxcXCIgXSxcXG5cXG5cXHRfZGVmYXVsdDogWyAwLCBcXFwiXFxcIiwgXFxcIlxcXCIgXVxcbn07XFxuXFxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcXG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcXG5cXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcbmlmICggIXN1cHBvcnQub3B0aW9uICkge1xcblxcdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXFxcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cXFwiLCBcXFwiPC9zZWxlY3Q+XFxcIiBdO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XFxuXFx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxcblxcdHZhciByZXQ7XFxuXFxuXFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgKSB7XFxuXFx0XFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFxcXCIqXFxcIiApO1xcblxcblxcdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFxcXCJ1bmRlZmluZWRcXFwiICkge1xcblxcdFxcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFxcXCIqXFxcIiApO1xcblxcblxcdH0gZWxzZSB7XFxuXFx0XFx0cmV0ID0gW107XFxuXFx0fVxcblxcblxcdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XFxuXFx0fVxcblxcblxcdHJldHVybiByZXQ7XFxufVxcblxcblxcbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcXG5cXHR2YXIgaSA9IDAsXFxuXFx0XFx0bCA9IGVsZW1zLmxlbmd0aDtcXG5cXG5cXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0ZGF0YVByaXYuc2V0KFxcblxcdFxcdFxcdGVsZW1zWyBpIF0sXFxuXFx0XFx0XFx0XFxcImdsb2JhbEV2YWxcXFwiLFxcblxcdFxcdFxcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFxcXCJnbG9iYWxFdmFsXFxcIiApXFxuXFx0XFx0KTtcXG5cXHR9XFxufVxcblxcblxcbnZhciByaHRtbCA9IC88fCYjP1xcXFx3KzsvO1xcblxcbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XFxuXFx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcXG5cXHRcXHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxcblxcdFxcdG5vZGVzID0gW10sXFxuXFx0XFx0aSA9IDAsXFxuXFx0XFx0bCA9IGVsZW1zLmxlbmd0aDtcXG5cXG5cXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0ZWxlbSA9IGVsZW1zWyBpIF07XFxuXFxuXFx0XFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XFxuXFx0XFx0XFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxcblxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xcblxcdFxcdFxcdFxcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFxcXCJkaXZcXFwiICkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXFxuXFx0XFx0XFx0XFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcXFwiXFxcIiwgXFxcIlxcXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRcXHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcXG5cXHRcXHRcXHRcXHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcXG5cXHRcXHRcXHRcXHRqID0gd3JhcFsgMCBdO1xcblxcdFxcdFxcdFxcdHdoaWxlICggai0tICkge1xcblxcdFxcdFxcdFxcdFxcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxcblxcdFxcdFxcdFxcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG5cXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXFxuXFx0XFx0XFx0XFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXFxuXFx0XFx0XFx0XFx0dG1wLnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxcblxcdGZyYWdtZW50LnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuXFxuXFx0aSA9IDA7XFxuXFx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcXG5cXG5cXHRcXHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxcblxcdFxcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xcblxcdFxcdFxcdGlmICggaWdub3JlZCApIHtcXG5cXHRcXHRcXHRcXHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xcblxcblxcdFxcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxcblxcdFxcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXFxcInNjcmlwdFxcXCIgKTtcXG5cXG5cXHRcXHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XFxuXFx0XFx0aWYgKCBhdHRhY2hlZCApIHtcXG5cXHRcXHRcXHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xcblxcdFxcdGlmICggc2NyaXB0cyApIHtcXG5cXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcXFwiXFxcIiApICkge1xcblxcdFxcdFxcdFxcdFxcdHNjcmlwdHMucHVzaCggZWxlbSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gZnJhZ21lbnQ7XFxufVxcblxcblxcbnZhclxcblxcdHJrZXlFdmVudCA9IC9ea2V5LyxcXG5cXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcXG5cXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcXFwuKC4rKXwpLztcXG5cXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xcblxcdHJldHVybiB0cnVlO1xcbn1cXG5cXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcXG5cXHRyZXR1cm4gZmFsc2U7XFxufVxcblxcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xcbi8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzLCBleGNlcHQgd2hlbiB0aGV5IGFyZSBuby1vcC5cXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcXG4vLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cXG4vLyAoZm9jdXMgYW5kIGJsdXIgYXJlIGFsd2F5cyBzeW5jaHJvbm91cyBpbiBvdGhlciBzdXBwb3J0ZWQgYnJvd3NlcnMsXFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxcbmZ1bmN0aW9uIGV4cGVjdFN5bmMoIGVsZW0sIHR5cGUgKSB7XFxuXFx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFxcXCJmb2N1c1xcXCIgKTtcXG59XFxuXFxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG4vLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XFxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXFxuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XFxuXFx0dHJ5IHtcXG5cXHRcXHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcXG5cXHR9IGNhdGNoICggZXJyICkgeyB9XFxufVxcblxcbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XFxuXFx0dmFyIG9yaWdGbiwgdHlwZTtcXG5cXG5cXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcXG5cXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcXG5cXHRcXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxcblxcdFxcdFxcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xcblxcdFxcdFxcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xcblxcdFxcdFxcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBlbGVtO1xcblxcdH1cXG5cXG5cXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xcblxcblxcdFxcdC8vICggdHlwZXMsIGZuIClcXG5cXHRcXHRmbiA9IHNlbGVjdG9yO1xcblxcdFxcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcXG5cXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xcblxcdFxcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXG5cXHRcXHRcXHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxcblxcdFxcdFxcdGZuID0gZGF0YTtcXG5cXHRcXHRcXHRkYXRhID0gdW5kZWZpbmVkO1xcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxcblxcdFxcdFxcdGZuID0gZGF0YTtcXG5cXHRcXHRcXHRkYXRhID0gc2VsZWN0b3I7XFxuXFx0XFx0XFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXHRpZiAoIGZuID09PSBmYWxzZSApIHtcXG5cXHRcXHRmbiA9IHJldHVybkZhbHNlO1xcblxcdH0gZWxzZSBpZiAoICFmbiApIHtcXG5cXHRcXHRyZXR1cm4gZWxlbTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBvbmUgPT09IDEgKSB7XFxuXFx0XFx0b3JpZ0ZuID0gZm47XFxuXFx0XFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXFxuXFx0XFx0XFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xcblxcdFxcdFxcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cXG5cXHRcXHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcXG5cXHR9XFxuXFx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xcblxcdH0gKTtcXG59XFxuXFxuLypcXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXFxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cXG4gKi9cXG5qUXVlcnkuZXZlbnQgPSB7XFxuXFxuXFx0Z2xvYmFsOiB7fSxcXG5cXG5cXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XFxuXFxuXFx0XFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxcblxcdFxcdFxcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxcblxcdFxcdFxcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcXG5cXHRcXHRcXHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xcblxcblxcdFxcdC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcXG5cXHRcXHRpZiAoICFhY2NlcHREYXRhKCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcXG5cXHRcXHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcXG5cXHRcXHRcXHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XFxuXFx0XFx0XFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XFxuXFx0XFx0XFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3RvcjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxcblxcdFxcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxcblxcdFxcdGlmICggc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxcblxcdFxcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcXG5cXHRcXHRcXHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XFxuXFx0XFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcXG5cXHRcXHRcXHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKCBudWxsICk7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcXG5cXHRcXHRcXHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXFxuXFx0XFx0XFx0XFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxcblxcdFxcdFxcdFxcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxcblxcdFxcdHR5cGVzID0gKCB0eXBlcyB8fCBcXFwiXFxcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcXFwiXFxcIiBdO1xcblxcdFxcdHQgPSB0eXBlcy5sZW5ndGg7XFxuXFx0XFx0d2hpbGUgKCB0LS0gKSB7XFxuXFx0XFx0XFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xcblxcdFxcdFxcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xcblxcdFxcdFxcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFxcXCJcXFwiICkuc3BsaXQoIFxcXCIuXFxcIiApLnNvcnQoKTtcXG5cXG5cXHRcXHRcXHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcXG5cXHRcXHRcXHRpZiAoICF0eXBlICkge1xcblxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcXG5cXHRcXHRcXHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcXG5cXHRcXHRcXHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xcblxcblxcdFxcdFxcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0XFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xcblxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxcblxcdFxcdFxcdFxcdGRhdGE6IGRhdGEsXFxuXFx0XFx0XFx0XFx0aGFuZGxlcjogaGFuZGxlcixcXG5cXHRcXHRcXHRcXHRndWlkOiBoYW5kbGVyLmd1aWQsXFxuXFx0XFx0XFx0XFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxcblxcdFxcdFxcdFxcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXFxuXFx0XFx0XFx0XFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFxcXCIuXFxcIiApXFxuXFx0XFx0XFx0fSwgaGFuZGxlT2JqSW4gKTtcXG5cXG5cXHRcXHRcXHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxcblxcdFxcdFxcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xcblxcdFxcdFxcdFxcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcXG5cXHRcXHRcXHRcXHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2VcXG5cXHRcXHRcXHRcXHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XFxuXFx0XFx0XFx0XFx0XFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcXG5cXHRcXHRcXHRcXHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xcblxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxcblxcdFxcdFxcdGlmICggc2VsZWN0b3IgKSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cXG5cXHRcXHRcXHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xcblxcdFxcdH1cXG5cXG5cXHR9LFxcblxcblxcdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxcblxcdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XFxuXFxuXFx0XFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxcblxcdFxcdFxcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxcblxcdFxcdFxcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcXG5cXHRcXHRcXHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcXG5cXG5cXHRcXHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcXG5cXHRcXHR0eXBlcyA9ICggdHlwZXMgfHwgXFxcIlxcXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXFxcIlxcXCIgXTtcXG5cXHRcXHR0ID0gdHlwZXMubGVuZ3RoO1xcblxcdFxcdHdoaWxlICggdC0tICkge1xcblxcdFxcdFxcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcXG5cXHRcXHRcXHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcXG5cXHRcXHRcXHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcXFwiXFxcIiApLnNwbGl0KCBcXFwiLlxcXCIgKS5zb3J0KCk7XFxuXFxuXFx0XFx0XFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XFxuXFx0XFx0XFx0aWYgKCAhdHlwZSApIHtcXG5cXHRcXHRcXHRcXHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xcblxcdFxcdFxcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcXG5cXHRcXHRcXHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xcblxcdFxcdFxcdHRtcCA9IHRtcFsgMiBdICYmXFxuXFx0XFx0XFx0XFx0bmV3IFJlZ0V4cCggXFxcIihefFxcXFxcXFxcLilcXFwiICsgbmFtZXNwYWNlcy5qb2luKCBcXFwiXFxcXFxcXFwuKD86LipcXFxcXFxcXC58KVxcXCIgKSArIFxcXCIoXFxcXFxcXFwufCQpXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcXG5cXHRcXHRcXHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xcblxcdFxcdFxcdHdoaWxlICggai0tICkge1xcblxcdFxcdFxcdFxcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxcblxcdFxcdFxcdFxcdFxcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXFxuXFx0XFx0XFx0XFx0XFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxcblxcdFxcdFxcdFxcdFxcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RvciA9PT0gXFxcIioqXFxcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxcblxcdFxcdFxcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxcblxcdFxcdFxcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxcblxcdFxcdFxcdFxcdFxcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXFxuXFx0XFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XFxuXFx0XFx0XFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcXFwiaGFuZGxlIGV2ZW50c1xcXCIgKTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xcblxcblxcdFxcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxcblxcdFxcdFxcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcXG5cXG5cXHRcXHRcXHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcXG5cXHRcXHRcXHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICksXFxuXFxuXFx0XFx0XFx0aGFuZGxlcnMgPSAoXFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcXFwiZXZlbnRzXFxcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxcblxcdFxcdFxcdFxcdClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcXG5cXHRcXHRcXHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcXG5cXG5cXHRcXHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxcblxcdFxcdGFyZ3NbIDAgXSA9IGV2ZW50O1xcblxcblxcdFxcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xcblxcdFxcdFxcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XFxuXFxuXFx0XFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxcblxcdFxcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXFxuXFx0XFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xcblxcblxcdFxcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXFxuXFx0XFx0aSA9IDA7XFxuXFx0XFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XFxuXFx0XFx0XFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcXG5cXG5cXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxcblxcdFxcdFxcdFxcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xcblxcblxcdFxcdFxcdFxcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcXG5cXHRcXHRcXHRcXHQvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxcblxcdFxcdFxcdFxcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcXG5cXHRcXHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xcblxcdFxcdFxcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBldmVudC5yZXN1bHQ7XFxuXFx0fSxcXG5cXG5cXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcXG5cXHRcXHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcXG5cXHRcXHRcXHRoYW5kbGVyUXVldWUgPSBbXSxcXG5cXHRcXHRcXHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcXG5cXHRcXHRcXHRjdXIgPSBldmVudC50YXJnZXQ7XFxuXFxuXFx0XFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xcblxcdFxcdGlmICggZGVsZWdhdGVDb3VudCAmJlxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OVxcblxcdFxcdFxcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxcblxcdFxcdFxcdGN1ci5ub2RlVHlwZSAmJlxcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxcblxcdFxcdFxcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcXG5cXHRcXHRcXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxcblxcdFxcdFxcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFxcXCJjbGlja3NcXFwiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXFxuXFx0XFx0XFx0ISggZXZlbnQudHlwZSA9PT0gXFxcImNsaWNrXFxcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xcblxcblxcdFxcdFxcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xcblxcblxcdFxcdFxcdFxcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxcblxcdFxcdFxcdFxcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxcblxcdFxcdFxcdFxcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFxcXCJjbGlja1xcXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcXFwiIFxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xcblxcdFxcdGN1ciA9IHRoaXM7XFxuXFx0XFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xcblxcdFxcdFxcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xcblxcdH0sXFxuXFxuXFx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XFxuXFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXG5cXHRcXHRcXHRjb25maWd1cmFibGU6IHRydWUsXFxuXFxuXFx0XFx0XFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xcblxcdFxcdFxcdFxcdGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSA6XFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xcblxcdFxcdFxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxuXFx0XFx0XFx0XFx0XFx0Y29uZmlndXJhYmxlOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdHdyaXRhYmxlOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdHZhbHVlOiB2YWx1ZVxcblxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcXG5cXHRcXHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XFxuXFx0XFx0XFx0b3JpZ2luYWxFdmVudCA6XFxuXFx0XFx0XFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xcblxcdH0sXFxuXFxuXFx0c3BlY2lhbDoge1xcblxcdFxcdGxvYWQ6IHtcXG5cXG5cXHRcXHRcXHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXFxuXFx0XFx0XFx0bm9CdWJibGU6IHRydWVcXG5cXHRcXHR9LFxcblxcdFxcdGNsaWNrOiB7XFxuXFxuXFx0XFx0XFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcXG5cXHRcXHRcXHRzZXR1cDogZnVuY3Rpb24oIGRhdGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXFxuXFx0XFx0XFx0XFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cXG5cXHRcXHRcXHRcXHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcXG5cXHRcXHRcXHRcXHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxcblxcdFxcdFxcdFxcdFxcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXFxcImlucHV0XFxcIiApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGRhdGFQcml2LnNldCggZWwsIFxcXCJjbGlja1xcXCIsIC4uLiApXFxuXFx0XFx0XFx0XFx0XFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcXFwiY2xpY2tcXFwiLCByZXR1cm5UcnVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXFxuXFx0XFx0XFx0XFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cXG5cXHRcXHRcXHRcXHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xcblxcdFxcdFxcdFxcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXFxuXFx0XFx0XFx0XFx0XFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcXFwiaW5wdXRcXFwiICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcXFwiY2xpY2tcXFwiICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3NcXG5cXHRcXHRcXHQvLyBBbHNvIHByZXZlbnQgaXQgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcXG5cXHRcXHRcXHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcdFxcdFxcdFxcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXFxcImlucHV0XFxcIiApICYmXFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVByaXYuZ2V0KCB0YXJnZXQsIFxcXCJjbGlja1xcXCIgKSB8fFxcblxcdFxcdFxcdFxcdFxcdG5vZGVOYW1lKCB0YXJnZXQsIFxcXCJhXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdGJlZm9yZXVubG9hZDoge1xcblxcdFxcdFxcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXFxuXFx0XFx0XFx0XFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxcblxcdFxcdFxcdFxcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59O1xcblxcbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxcbi8vIHN5bnRoZXRpYyBldmVudHMgYnkgaW50ZXJydXB0aW5nIHByb2dyZXNzIHVudGlsIHJlaW52b2tlZCBpbiByZXNwb25zZSB0b1xcbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cXG5mdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZSggZWwsIHR5cGUsIGV4cGVjdFN5bmMgKSB7XFxuXFxuXFx0Ly8gTWlzc2luZyBleHBlY3RTeW5jIGluZGljYXRlcyBhIHRyaWdnZXIgY2FsbCwgd2hpY2ggbXVzdCBmb3JjZSBzZXR1cCB0aHJvdWdoIGpRdWVyeS5ldmVudC5hZGRcXG5cXHRpZiAoICFleHBlY3RTeW5jICkge1xcblxcdFxcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHJldHVyblRydWUgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuO1xcblxcdH1cXG5cXG5cXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXFxuXFx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcXG5cXHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwge1xcblxcdFxcdG5hbWVzcGFjZTogZmFsc2UsXFxuXFx0XFx0aGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcdFxcdFxcdHZhciBub3RBc3luYywgcmVzdWx0LFxcblxcdFxcdFxcdFxcdHNhdmVkID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XFxuXFxuXFx0XFx0XFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcXG5cXHRcXHRcXHRcXHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxcblxcdFxcdFxcdFxcdC8vIGZyb20gYW4gYXN5bmMgbmF0aXZlIGhhbmRsZXIgKGdoLTQzNTApXFxuXFx0XFx0XFx0XFx0aWYgKCAhc2F2ZWQubGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN0b3JlIGFyZ3VtZW50cyBmb3IgdXNlIHdoZW4gaGFuZGxpbmcgdGhlIGlubmVyIG5hdGl2ZSBldmVudFxcblxcdFxcdFxcdFxcdFxcdC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBhcmd1bWVudCAoYW4gZXZlbnQgb2JqZWN0KSwgc28gdGhpcyBhcnJheVxcblxcdFxcdFxcdFxcdFxcdC8vIHdpbGwgbm90IGJlIGNvbmZ1c2VkIHdpdGggYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdC5cXG5cXHRcXHRcXHRcXHRcXHRzYXZlZCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xcblxcdFxcdFxcdFxcdFxcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgc2F2ZWQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xcblxcdFxcdFxcdFxcdFxcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXFxuXFx0XFx0XFx0XFx0XFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpc1sgdHlwZSBdKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdCA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHNhdmVkICE9PSByZXN1bHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQudmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXFxuXFx0XFx0XFx0XFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cXG5cXHRcXHRcXHRcXHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxcblxcdFxcdFxcdFxcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcXG5cXHRcXHRcXHRcXHQvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXFxuXFx0XFx0XFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggc2F2ZWQubGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcXG5cXHRcXHRcXHRcXHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2F2ZWQuc2xpY2UoIDEgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzXFxuXFx0XFx0XFx0XFx0XFx0KVxcblxcdFxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50XFxuXFx0XFx0XFx0XFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9ICk7XFxufVxcblxcbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XFxuXFxuXFx0Ly8gVGhpcyBcXFwiaWZcXFwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xcblxcdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xcblxcdFxcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XFxuXFx0fVxcbn07XFxuXFxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XFxuXFxuXFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXFxuXFx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XFxuXFx0XFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcXG5cXHR9XFxuXFxuXFx0Ly8gRXZlbnQgb2JqZWN0XFxuXFx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XFxuXFx0XFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xcblxcdFxcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xcblxcblxcdFxcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXFxuXFx0XFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXFxuXFx0XFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxcblxcdFxcdFxcdFxcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcXG5cXHRcXHRcXHRcXHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cXG5cXHRcXHRcXHRyZXR1cm5UcnVlIDpcXG5cXHRcXHRcXHRyZXR1cm5GYWxzZTtcXG5cXG5cXHRcXHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcXG5cXHRcXHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XFxuXFx0XFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0MylcXG5cXHRcXHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xcblxcdFxcdFxcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XFxuXFx0XFx0XFx0c3JjLnRhcmdldDtcXG5cXG5cXHRcXHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcXG5cXHRcXHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcXG5cXG5cXHQvLyBFdmVudCB0eXBlXFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR0aGlzLnR5cGUgPSBzcmM7XFxuXFx0fVxcblxcblxcdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XFxuXFx0aWYgKCBwcm9wcyApIHtcXG5cXHRcXHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xcblxcdH1cXG5cXG5cXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxcblxcdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcXG5cXG5cXHQvLyBNYXJrIGl0IGFzIGZpeGVkXFxuXFx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XFxufTtcXG5cXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcXG5cXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxcblxcdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXFxuXFx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxcblxcdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcXG5cXHRpc1NpbXVsYXRlZDogZmFsc2UsXFxuXFxuXFx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xcblxcblxcdFxcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcXG5cXG5cXHRcXHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XFxuXFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XFxuXFxuXFx0XFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XFxuXFxuXFx0XFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xcblxcdFxcdFxcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0fVxcblxcdH0sXFxuXFx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcXG5cXG5cXHRcXHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcXG5cXG5cXHRcXHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XFxuXFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHR9XFxufTtcXG5cXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xcbmpRdWVyeS5lYWNoKCB7XFxuXFx0YWx0S2V5OiB0cnVlLFxcblxcdGJ1YmJsZXM6IHRydWUsXFxuXFx0Y2FuY2VsYWJsZTogdHJ1ZSxcXG5cXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcXG5cXHRjdHJsS2V5OiB0cnVlLFxcblxcdGRldGFpbDogdHJ1ZSxcXG5cXHRldmVudFBoYXNlOiB0cnVlLFxcblxcdG1ldGFLZXk6IHRydWUsXFxuXFx0cGFnZVg6IHRydWUsXFxuXFx0cGFnZVk6IHRydWUsXFxuXFx0c2hpZnRLZXk6IHRydWUsXFxuXFx0dmlldzogdHJ1ZSxcXG5cXHRcXFwiY2hhclxcXCI6IHRydWUsXFxuXFx0Y29kZTogdHJ1ZSxcXG5cXHRjaGFyQ29kZTogdHJ1ZSxcXG5cXHRrZXk6IHRydWUsXFxuXFx0a2V5Q29kZTogdHJ1ZSxcXG5cXHRidXR0b246IHRydWUsXFxuXFx0YnV0dG9uczogdHJ1ZSxcXG5cXHRjbGllbnRYOiB0cnVlLFxcblxcdGNsaWVudFk6IHRydWUsXFxuXFx0b2Zmc2V0WDogdHJ1ZSxcXG5cXHRvZmZzZXRZOiB0cnVlLFxcblxcdHBvaW50ZXJJZDogdHJ1ZSxcXG5cXHRwb2ludGVyVHlwZTogdHJ1ZSxcXG5cXHRzY3JlZW5YOiB0cnVlLFxcblxcdHNjcmVlblk6IHRydWUsXFxuXFx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcXG5cXHR0b0VsZW1lbnQ6IHRydWUsXFxuXFx0dG91Y2hlczogdHJ1ZSxcXG5cXG5cXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xcblxcdFxcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XFxuXFxuXFx0XFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXFxuXFx0XFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcXG5cXHRcXHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XFxuXFx0XFx0XFx0aWYgKCBidXR0b24gJiAxICkge1xcblxcdFxcdFxcdFxcdHJldHVybiAxO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGJ1dHRvbiAmIDIgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIDM7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggYnV0dG9uICYgNCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBldmVudC53aGljaDtcXG5cXHR9XFxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcXG5cXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXFxcImZvY3VzaW5cXFwiLCBibHVyOiBcXFwiZm9jdXNvdXRcXFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XFxuXFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSA9IHtcXG5cXG5cXHRcXHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3RcXG5cXHRcXHRzZXR1cDogZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcXG5cXHRcXHRcXHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFxcXCJmb2N1c1xcXCIsIC4uLiApXFxuXFx0XFx0XFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcXFwiYmx1clxcXCIsIC4uLiApXFxuXFx0XFx0XFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMgKTtcXG5cXG5cXHRcXHRcXHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9LFxcblxcdFxcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXFxuXFx0XFx0XFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcXG5cXG5cXHRcXHRcXHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxcblxcdH07XFxufSApO1xcblxcbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xcbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXFxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcXG4vL1xcbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcXG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcXG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxcbmpRdWVyeS5lYWNoKCB7XFxuXFx0bW91c2VlbnRlcjogXFxcIm1vdXNlb3ZlclxcXCIsXFxuXFx0bW91c2VsZWF2ZTogXFxcIm1vdXNlb3V0XFxcIixcXG5cXHRwb2ludGVyZW50ZXI6IFxcXCJwb2ludGVyb3ZlclxcXCIsXFxuXFx0cG9pbnRlcmxlYXZlOiBcXFwicG9pbnRlcm91dFxcXCJcXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xcblxcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XFxuXFx0XFx0ZGVsZWdhdGVUeXBlOiBmaXgsXFxuXFx0XFx0YmluZFR5cGU6IGZpeCxcXG5cXG5cXHRcXHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXHRcXHRcXHR2YXIgcmV0LFxcblxcdFxcdFxcdFxcdHRhcmdldCA9IHRoaXMsXFxuXFx0XFx0XFx0XFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXFxuXFx0XFx0XFx0XFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xcblxcblxcdFxcdFxcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXFxuXFx0XFx0XFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcXG5cXHRcXHRcXHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcXG5cXHRcXHRcXHRcXHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0XFx0XFx0ZXZlbnQudHlwZSA9IGZpeDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9XFxuXFx0fTtcXG59ICk7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcblxcdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcXG5cXHR9LFxcblxcdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XFxuXFx0XFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XFxuXFx0fSxcXG5cXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xcblxcdFxcdHZhciBoYW5kbGVPYmosIHR5cGU7XFxuXFx0XFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxcblxcdFxcdFxcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcXG5cXHRcXHRcXHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxcblxcdFxcdFxcdFxcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xcblxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iai5vcmlnVHlwZSArIFxcXCIuXFxcIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxcblxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iai5vcmlnVHlwZSxcXG5cXHRcXHRcXHRcXHRoYW5kbGVPYmouc2VsZWN0b3IsXFxuXFx0XFx0XFx0XFx0aGFuZGxlT2JqLmhhbmRsZXJcXG5cXHRcXHRcXHQpO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcXG5cXHRcXHRcXHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xcblxcdFxcdFxcdFxcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcXFwiZnVuY3Rpb25cXFwiICkge1xcblxcblxcdFxcdFxcdC8vICggdHlwZXMgWywgZm5dIClcXG5cXHRcXHRcXHRmbiA9IHNlbGVjdG9yO1xcblxcdFxcdFxcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoIGZuID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRmbiA9IHJldHVybkZhbHNlO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxuXFxudmFyXFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxcblxcdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXFxuXFx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cXG5cXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcXG5cXG5cXHQvLyBjaGVja2VkPVxcXCJjaGVja2VkXFxcIiBvciBjaGVja2VkXFxuXFx0cmNoZWNrZWQgPSAvY2hlY2tlZFxcXFxzKig/OltePV18PVxcXFxzKi5jaGVja2VkLikvaSxcXG5cXHRyY2xlYW5TY3JpcHQgPSAvXlxcXFxzKjwhKD86XFxcXFtDREFUQVxcXFxbfC0tKXwoPzpcXFxcXVxcXFxdfC0tKT5cXFxccyokL2c7XFxuXFxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXFxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xcblxcdGlmICggbm9kZU5hbWUoIGVsZW0sIFxcXCJ0YWJsZVxcXCIgKSAmJlxcblxcdFxcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFxcXCJ0clxcXCIgKSApIHtcXG5cXG5cXHRcXHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFxcXCJ0Ym9keVxcXCIgKVsgMCBdIHx8IGVsZW07XFxuXFx0fVxcblxcblxcdHJldHVybiBlbGVtO1xcbn1cXG5cXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXFxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcXG5cXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcXFwidHlwZVxcXCIgKSAhPT0gbnVsbCApICsgXFxcIi9cXFwiICsgZWxlbS50eXBlO1xcblxcdHJldHVybiBlbGVtO1xcbn1cXG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xcblxcdGlmICggKCBlbGVtLnR5cGUgfHwgXFxcIlxcXCIgKS5zbGljZSggMCwgNSApID09PSBcXFwidHJ1ZS9cXFwiICkge1xcblxcdFxcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gZWxlbTtcXG59XFxuXFxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcXG5cXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xcblxcblxcdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXFxuXFx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcXG5cXHRcXHRwZGF0YU9sZCA9IGRhdGFQcml2LmdldCggc3JjICk7XFxuXFx0XFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xcblxcblxcdFxcdGlmICggZXZlbnRzICkge1xcblxcdFxcdFxcdGRhdGFQcml2LnJlbW92ZSggZGVzdCwgXFxcImhhbmRsZSBldmVudHNcXFwiICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxcblxcdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XFxuXFx0XFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xcblxcdFxcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XFxuXFxuXFx0XFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xcblxcdH1cXG59XFxuXFxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXFxuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcXG5cXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuXFx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXFxuXFx0aWYgKCBub2RlTmFtZSA9PT0gXFxcImlucHV0XFxcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xcblxcdFxcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xcblxcblxcdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXFxuXFx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCJ0ZXh0YXJlYVxcXCIgKSB7XFxuXFx0XFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xcblxcblxcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcXG5cXHRhcmdzID0gZmxhdCggYXJncyApO1xcblxcblxcdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXFxuXFx0XFx0aU5vQ2xvbmUgPSBsIC0gMSxcXG5cXHRcXHR2YWx1ZSA9IGFyZ3NbIDAgXSxcXG5cXHRcXHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xcblxcblxcdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxcblxcdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XFxuXFx0XFx0XFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiICYmXFxuXFx0XFx0XFx0XFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XFxuXFx0XFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xcblxcdFxcdFxcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcXG5cXHRcXHRcXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcXG5cXHRcXHRcXHRcXHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG5cXG5cXHRpZiAoIGwgKSB7XFxuXFx0XFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcXG5cXHRcXHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XFxuXFxuXFx0XFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcXG5cXHRcXHRcXHRmcmFnbWVudCA9IGZpcnN0O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcXG5cXHRcXHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XFxuXFx0XFx0XFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFxcXCJzY3JpcHRcXFwiICksIGRpc2FibGVTY3JpcHQgKTtcXG5cXHRcXHRcXHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxcblxcdFxcdFxcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxcblxcdFxcdFxcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdG5vZGUgPSBmcmFnbWVudDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xcblxcdFxcdFxcdFxcdFxcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNTY3JpcHRzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXFxcInNjcmlwdFxcXCIgKSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggaGFzU2NyaXB0cyApIHtcXG5cXHRcXHRcXHRcXHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xcblxcblxcdFxcdFxcdFxcdC8vIFJlZW5hYmxlIHNjcmlwdHNcXG5cXHRcXHRcXHRcXHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdG5vZGUgPSBzY3JpcHRzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXFxcIlxcXCIgKSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFxcXCJnbG9iYWxFdmFsXFxcIiApICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFxcXCJcXFwiICkudG9Mb3dlckNhc2UoKSAgIT09IFxcXCJtb2R1bGVcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vbmNlOiBub2RlLm5vbmNlIHx8IG5vZGUuZ2V0QXR0cmlidXRlKCBcXFwibm9uY2VcXFwiIClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9LCBkb2MgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXFxcIlxcXCIgKSwgbm9kZSwgZG9jICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGNvbGxlY3Rpb247XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xcblxcdHZhciBub2RlLFxcblxcdFxcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcXG5cXHRcXHRpID0gMDtcXG5cXG5cXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XFxuXFx0XFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcXG5cXHRcXHRcXHRcXHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFxcXCJzY3JpcHRcXFwiICkgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gZWxlbTtcXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xcblxcdFxcdHJldHVybiBodG1sO1xcblxcdH0sXFxuXFxuXFx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcXG5cXHRcXHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcXG5cXHRcXHRcXHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXFxuXFx0XFx0XFx0aW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xcblxcblxcdFxcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xcblxcdFxcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcXG5cXHRcXHRcXHRcXHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXFxuXFx0XFx0XFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xcblxcdFxcdFxcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XFxuXFx0XFx0XFx0XFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXFxuXFx0XFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xcblxcdFxcdFxcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XFxuXFx0XFx0XFx0XFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxcblxcdFxcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFxcXCJzY3JpcHRcXFwiICk7XFxuXFx0XFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcXG5cXHRcXHRcXHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcXFwic2NyaXB0XFxcIiApICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxcblxcdFxcdHJldHVybiBjbG9uZTtcXG5cXHR9LFxcblxcblxcdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xcblxcdFxcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxcblxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcXG5cXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XFxuXFx0XFx0XFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuZXZlbnRzICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xcblxcdFxcdFxcdFxcdFxcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxcblxcdFxcdFxcdFxcdFxcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcXG5cXHRcXHRcXHRcXHRcXHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcXG5cXHRcXHRcXHRcXHRcXHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcXG5cXHR9LFxcblxcblxcdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XFxuXFx0fSxcXG5cXG5cXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRcXHRqUXVlcnkudGV4dCggdGhpcyApIDpcXG5cXHRcXHRcXHRcXHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcXG5cXHR9LFxcblxcblxcdGFwcGVuZDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xcblxcdFxcdFxcdFxcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcXG5cXHRcXHRcXHRcXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdGFmdGVyOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXG5cXHRlbXB0eTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGVsZW0sXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XFxuXFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcXG5cXHRcXHRcXHRcXHRlbGVtLnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9LFxcblxcblxcdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XFxuXFx0XFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcXG5cXHRcXHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXFxuXFx0XFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0XFx0bCA9IHRoaXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmlubmVySFRNTDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxcblxcdFxcdFxcdGlmICggdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcXG5cXHRcXHRcXHRcXHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXFxcIlxcXCIsIFxcXCJcXFwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xcblxcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gMDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2RcXG5cXHRcXHRcXHRcXHR9IGNhdGNoICggZSApIHt9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xcblxcdH0sXFxuXFxuXFx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBpZ25vcmVkID0gW107XFxuXFxuXFx0XFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XFxuXFx0XFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdFxcdFxcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XFxuXFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xcblxcdFxcdFxcdFxcdGlmICggcGFyZW50ICkge1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cXG5cXHRcXHR9LCBpZ25vcmVkICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZWFjaCgge1xcblxcdGFwcGVuZFRvOiBcXFwiYXBwZW5kXFxcIixcXG5cXHRwcmVwZW5kVG86IFxcXCJwcmVwZW5kXFxcIixcXG5cXHRpbnNlcnRCZWZvcmU6IFxcXCJiZWZvcmVcXFwiLFxcblxcdGluc2VydEFmdGVyOiBcXFwiYWZ0ZXJcXFwiLFxcblxcdHJlcGxhY2VBbGw6IFxcXCJyZXBsYWNlV2l0aFxcXCJcXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XFxuXFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XFxuXFx0XFx0dmFyIGVsZW1zLFxcblxcdFxcdFxcdHJldCA9IFtdLFxcblxcdFxcdFxcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcXG5cXHRcXHRcXHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcXG5cXHRcXHRcXHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xcblxcdFxcdFxcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcXG5cXHRcXHRcXHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XFxuXFx0XFx0XFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xcblxcdH07XFxufSApO1xcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcXFwiXihcXFwiICsgcG51bSArIFxcXCIpKD8hcHgpW2EteiVdKyRcXFwiLCBcXFwiaVxcXCIgKTtcXG5cXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxcblxcdFxcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xcblxcdFxcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcXFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVxcXCJcXG5cXHRcXHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcXG5cXG5cXHRcXHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcXG5cXHRcXHRcXHR2aWV3ID0gd2luZG93O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XFxuXFx0fTtcXG5cXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcXG5cXHR2YXIgcmV0LCBuYW1lLFxcblxcdFxcdG9sZCA9IHt9O1xcblxcblxcdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xcblxcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcXG5cXHRcXHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcXG5cXHRcXHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XFxuXFx0fVxcblxcblxcdHJldCA9IGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcXG5cXG5cXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcXG5cXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XFxuXFx0XFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XFxuXFx0fVxcblxcblxcdHJldHVybiByZXQ7XFxufTtcXG5cXG5cXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFxcXCJ8XFxcIiApLCBcXFwiaVxcXCIgKTtcXG5cXG5cXG5cXG4oIGZ1bmN0aW9uKCkge1xcblxcblxcdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxcblxcdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXFxuXFx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XFxuXFxuXFx0XFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxcblxcdFxcdGlmICggIWRpdiApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXFxcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcXFwiICtcXG5cXHRcXHRcXHRcXFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXFxcIjtcXG5cXHRcXHRkaXYuc3R5bGUuY3NzVGV4dCA9XFxuXFx0XFx0XFx0XFxcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcXFwiICtcXG5cXHRcXHRcXHRcXFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcXFwiICtcXG5cXHRcXHRcXHRcXFwid2lkdGg6NjAlO3RvcDoxJVxcXCI7XFxuXFx0XFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XFxuXFxuXFx0XFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xcblxcdFxcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFxcXCIxJVxcXCI7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxcblxcdFxcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcXG5cXHRcXHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3RcXG5cXHRcXHRkaXYuc3R5bGUucmlnaHQgPSBcXFwiNjAlXFxcIjtcXG5cXHRcXHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcXG5cXHRcXHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXFxuXFx0XFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxcblxcdFxcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcXG5cXHRcXHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxcblxcdFxcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxcblxcdFxcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFxcXCJhYnNvbHV0ZVxcXCI7XFxuXFx0XFx0c2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2Lm9mZnNldFdpZHRoIC8gMyApID09PSAxMjtcXG5cXG5cXHRcXHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xcblxcblxcdFxcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcXG5cXHRcXHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXFxuXFx0XFx0ZGl2ID0gbnVsbDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xcblxcdFxcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcXG5cXHR9XFxuXFxuXFx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcXG5cXHRcXHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxcblxcdFxcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJkaXZcXFwiICksXFxuXFx0XFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImRpdlxcXCIgKTtcXG5cXG5cXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xcblxcdGlmICggIWRpdi5zdHlsZSApIHtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcXG5cXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXFxuXFx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXFxcImNvbnRlbnQtYm94XFxcIjtcXG5cXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcXFwiXFxcIjtcXG5cXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXFxcImNvbnRlbnQtYm94XFxcIjtcXG5cXG5cXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XFxuXFx0XFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xcblxcdFxcdH0sXFxuXFx0XFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xcblxcdFxcdH0sXFxuXFx0XFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcXG5cXHRcXHR9LFxcblxcdFxcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xcblxcdFxcdH0sXFxuXFx0XFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTUgLSAxOCtcXG5cXHRcXHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxcblxcdFxcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxcblxcdFxcdC8vIEJlaGF2aW9yIGluIElFIDkgaXMgbW9yZSBzdWJ0bGUgdGhhbiBpbiBuZXdlciB2ZXJzaW9ucyAmIGl0IHBhc3Nlc1xcblxcdFxcdC8vIHNvbWUgdmVyc2lvbnMgb2YgdGhpcyB0ZXN0OyBtYWtlIHN1cmUgbm90IHRvIG1ha2UgaXQgcGFzcyB0aGVyZSFcXG5cXHRcXHRyZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcXG5cXHRcXHRcXHRpZiAoIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwidGFibGVcXFwiICk7XFxuXFx0XFx0XFx0XFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwidHJcXFwiICk7XFxuXFx0XFx0XFx0XFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJkaXZcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0dGFibGUuc3R5bGUuY3NzVGV4dCA9IFxcXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4XFxcIjtcXG5cXHRcXHRcXHRcXHR0ci5zdHlsZS5oZWlnaHQgPSBcXFwiMXB4XFxcIjtcXG5cXHRcXHRcXHRcXHR0ckNoaWxkLnN0eWxlLmhlaWdodCA9IFxcXCI5cHhcXFwiO1xcblxcblxcdFxcdFxcdFxcdGRvY3VtZW50RWxlbWVudFxcblxcdFxcdFxcdFxcdFxcdC5hcHBlbmRDaGlsZCggdGFibGUgKVxcblxcdFxcdFxcdFxcdFxcdC5hcHBlbmRDaGlsZCggdHIgKVxcblxcdFxcdFxcdFxcdFxcdC5hcHBlbmRDaGlsZCggdHJDaGlsZCApO1xcblxcblxcdFxcdFxcdFxcdHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggdHIgKTtcXG5cXHRcXHRcXHRcXHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9IHBhcnNlSW50KCB0clN0eWxlLmhlaWdodCApID4gMztcXG5cXG5cXHRcXHRcXHRcXHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRhYmxlICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcXG5cXHRcXHR9XFxuXFx0fSApO1xcbn0gKSgpO1xcblxcblxcbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XFxuXFx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xcblxcdFxcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcXG5cXHRcXHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXFxuXFx0XFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcXG5cXHRcXHRzdHlsZSA9IGVsZW0uc3R5bGU7XFxuXFxuXFx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcXG5cXG5cXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XFxuXFx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXFxuXFx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXFxuXFx0aWYgKCBjb21wdXRlZCApIHtcXG5cXHRcXHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcXG5cXG5cXHRcXHRpZiAoIHJldCA9PT0gXFxcIlxcXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcXG5cXHRcXHRcXHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcXFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1xcXCJcXG5cXHRcXHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcXG5cXHRcXHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxcblxcdFxcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcXG5cXHRcXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xcblxcdFxcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXFxuXFx0XFx0XFx0d2lkdGggPSBzdHlsZS53aWR0aDtcXG5cXHRcXHRcXHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xcblxcdFxcdFxcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XFxuXFxuXFx0XFx0XFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxcblxcdFxcdFxcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcXG5cXHRcXHRcXHRyZXQgPSBjb21wdXRlZC53aWR0aDtcXG5cXG5cXHRcXHRcXHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXFxuXFx0XFx0XFx0c3R5bGUud2lkdGggPSB3aWR0aDtcXG5cXHRcXHRcXHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xcblxcdFxcdFxcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcXG5cXHRcXHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxcblxcdFxcdHJldCArIFxcXCJcXFwiIDpcXG5cXHRcXHRyZXQ7XFxufVxcblxcblxcbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcXG5cXG5cXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxcblxcdHJldHVybiB7XFxuXFx0XFx0Z2V0OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXFxuXFx0XFx0XFx0XFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxcblxcdFxcdFxcdFxcdGRlbGV0ZSB0aGlzLmdldDtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxcblxcdFxcdFxcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xcblxcdFxcdH1cXG5cXHR9O1xcbn1cXG5cXG5cXG52YXIgY3NzUHJlZml4ZXMgPSBbIFxcXCJXZWJraXRcXFwiLCBcXFwiTW96XFxcIiwgXFxcIm1zXFxcIiBdLFxcblxcdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwiZGl2XFxcIiApLnN0eWxlLFxcblxcdHZlbmRvclByb3BzID0ge307XFxuXFxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xcblxcblxcdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcXG5cXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxcblxcdFxcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XFxuXFxuXFx0d2hpbGUgKCBpLS0gKSB7XFxuXFx0XFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xcblxcdFxcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xcblxcdFxcdFxcdHJldHVybiBuYW1lO1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XFxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcXG5cXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xcblxcblxcdGlmICggZmluYWwgKSB7XFxuXFx0XFx0cmV0dXJuIGZpbmFsO1xcblxcdH1cXG5cXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcXG5cXHRcXHRyZXR1cm4gbmFtZTtcXG5cXHR9XFxuXFx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XFxufVxcblxcblxcbnZhclxcblxcblxcdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcXG5cXHQvLyBleGNlcHQgXFxcInRhYmxlXFxcIiwgXFxcInRhYmxlLWNlbGxcXFwiLCBvciBcXFwidGFibGUtY2FwdGlvblxcXCJcXG5cXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcXG5cXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXFxuXFx0cmN1c3RvbVByb3AgPSAvXi0tLyxcXG5cXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXFxcImFic29sdXRlXFxcIiwgdmlzaWJpbGl0eTogXFxcImhpZGRlblxcXCIsIGRpc3BsYXk6IFxcXCJibG9ja1xcXCIgfSxcXG5cXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XFxuXFx0XFx0bGV0dGVyU3BhY2luZzogXFxcIjBcXFwiLFxcblxcdFxcdGZvbnRXZWlnaHQ6IFxcXCI0MDBcXFwiXFxuXFx0fTtcXG5cXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcXG5cXG5cXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXFxuXFx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XFxuXFx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XFxuXFx0cmV0dXJuIG1hdGNoZXMgP1xcblxcblxcdFxcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFxcXCJzdWJ0cmFjdFxcXCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xcblxcdFxcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXFxcInB4XFxcIiApIDpcXG5cXHRcXHR2YWx1ZTtcXG59XFxuXFxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XFxuXFx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFxcXCJ3aWR0aFxcXCIgPyAxIDogMCxcXG5cXHRcXHRleHRyYSA9IDAsXFxuXFx0XFx0ZGVsdGEgPSAwO1xcblxcblxcdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3NhcnlcXG5cXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFxcXCJib3JkZXJcXFwiIDogXFxcImNvbnRlbnRcXFwiICkgKSB7XFxuXFx0XFx0cmV0dXJuIDA7XFxuXFx0fVxcblxcblxcdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcXG5cXG5cXHRcXHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cXG5cXHRcXHRpZiAoIGJveCA9PT0gXFxcIm1hcmdpblxcXCIgKSB7XFxuXFx0XFx0XFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXFxcInBhZGRpbmdcXFwiIG9yIFxcXCJib3JkZXJcXFwiIG9yIFxcXCJtYXJnaW5cXFwiXFxuXFx0XFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIHBhZGRpbmdcXG5cXHRcXHRcXHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwicGFkZGluZ1xcXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XFxuXFxuXFx0XFx0XFx0Ly8gRm9yIFxcXCJib3JkZXJcXFwiIG9yIFxcXCJtYXJnaW5cXFwiLCBhZGQgYm9yZGVyXFxuXFx0XFx0XFx0aWYgKCBib3ggIT09IFxcXCJwYWRkaW5nXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm9yZGVyXFxcIiArIGNzc0V4cGFuZFsgaSBdICsgXFxcIldpZHRoXFxcIiwgdHJ1ZSwgc3R5bGVzICk7XFxuXFxuXFx0XFx0XFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm9yZGVyXFxcIiArIGNzc0V4cGFuZFsgaSBdICsgXFxcIldpZHRoXFxcIiwgdHJ1ZSwgc3R5bGVzICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXFxcImNvbnRlbnRcXFwiIG9yXFxuXFx0XFx0Ly8gXFxcInBhZGRpbmdcXFwiIG9yIFxcXCJtYXJnaW5cXFwiXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyBGb3IgXFxcImNvbnRlbnRcXFwiLCBzdWJ0cmFjdCBwYWRkaW5nXFxuXFx0XFx0XFx0aWYgKCBib3ggPT09IFxcXCJjb250ZW50XFxcIiApIHtcXG5cXHRcXHRcXHRcXHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwicGFkZGluZ1xcXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZvciBcXFwiY29udGVudFxcXCIgb3IgXFxcInBhZGRpbmdcXFwiLCBzdWJ0cmFjdCBib3JkZXJcXG5cXHRcXHRcXHRpZiAoIGJveCAhPT0gXFxcIm1hcmdpblxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImJvcmRlclxcXCIgKyBjc3NFeHBhbmRbIGkgXSArIFxcXCJXaWR0aFxcXCIsIHRydWUsIHN0eWxlcyApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXFxuXFx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcXG5cXG5cXHRcXHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXFxuXFx0XFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxcblxcdFxcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXFxuXFx0XFx0XFx0ZWxlbVsgXFxcIm9mZnNldFxcXCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXFxuXFx0XFx0XFx0Y29tcHV0ZWRWYWwgLVxcblxcdFxcdFxcdGRlbHRhIC1cXG5cXHRcXHRcXHRleHRyYSAtXFxuXFx0XFx0XFx0MC41XFxuXFxuXFx0XFx0Ly8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcXG5cXHRcXHQvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXFxuXFx0XFx0KSApIHx8IDA7XFxuXFx0fVxcblxcblxcdHJldHVybiBkZWx0YTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcXG5cXG5cXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXFxuXFx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxcblxcblxcdFxcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxcblxcdFxcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxcblxcdFxcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXFxuXFx0XFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcXG5cXHRcXHRcXHRqUXVlcnkuY3NzKCBlbGVtLCBcXFwiYm94U2l6aW5nXFxcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcXFwiYm9yZGVyLWJveFxcXCIsXFxuXFx0XFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxcblxcblxcdFxcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcXG5cXHRcXHRvZmZzZXRQcm9wID0gXFxcIm9mZnNldFxcXCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XFxuXFx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXFxuXFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XFxuXFx0XFx0aWYgKCAhZXh0cmEgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZhbDtcXG5cXHRcXHR9XFxuXFx0XFx0dmFsID0gXFxcImF1dG9cXFwiO1xcblxcdH1cXG5cXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxcblxcdC8vIFVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlLlxcblxcdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cXG5cXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXFxuXFx0XFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcXG5cXHRcXHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cXG5cXHRcXHQvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxcblxcdFxcdCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoIGVsZW0sIFxcXCJ0clxcXCIgKSB8fFxcblxcblxcdFxcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcXFwiYXV0b1xcXCJcXG5cXHRcXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXFxuXFx0XFx0dmFsID09PSBcXFwiYXV0b1xcXCIgfHxcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcXG5cXHRcXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxcblxcdFxcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcXFwiZGlzcGxheVxcXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXFxcImlubGluZVxcXCIgKSAmJlxcblxcblxcdFxcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXFxuXFx0XFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcXG5cXG5cXHRcXHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJib3hTaXppbmdcXFwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFxcXCJib3JkZXItYm94XFxcIjtcXG5cXG5cXHRcXHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXFxuXFx0XFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxcblxcdFxcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cXG5cXHRcXHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xcblxcdFxcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcXG5cXHRcXHRcXHR2YWwgPSBlbGVtWyBvZmZzZXRQcm9wIF07XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBOb3JtYWxpemUgXFxcIlxcXCIgYW5kIGF1dG9cXG5cXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xcblxcblxcdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcXG5cXHRyZXR1cm4gKCB2YWwgK1xcblxcdFxcdGJveE1vZGVsQWRqdXN0bWVudChcXG5cXHRcXHRcXHRlbGVtLFxcblxcdFxcdFxcdGRpbWVuc2lvbixcXG5cXHRcXHRcXHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIgKSxcXG5cXHRcXHRcXHR2YWx1ZUlzQm9yZGVyQm94LFxcblxcdFxcdFxcdHN0eWxlcyxcXG5cXG5cXHRcXHRcXHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxcblxcdFxcdFxcdHZhbFxcblxcdFxcdClcXG5cXHQpICsgXFxcInB4XFxcIjtcXG59XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcblxcdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxcblxcdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxcblxcdGNzc0hvb2tzOiB7XFxuXFx0XFx0b3BhY2l0eToge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xcblxcdFxcdFxcdFxcdGlmICggY29tcHV0ZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcXFwib3BhY2l0eVxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmV0ID09PSBcXFwiXFxcIiA/IFxcXCIxXFxcIiA6IHJldDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFxcXCJweFxcXCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xcblxcdGNzc051bWJlcjoge1xcblxcdFxcdFxcXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcImNvbHVtbkNvdW50XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiZmlsbE9wYWNpdHlcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJmbGV4R3Jvd1xcXCI6IHRydWUsXFxuXFx0XFx0XFxcImZsZXhTaHJpbmtcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJmb250V2VpZ2h0XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiZ3JpZEFyZWFcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJncmlkQ29sdW1uXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiZ3JpZENvbHVtbkVuZFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcImdyaWRDb2x1bW5TdGFydFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcImdyaWRSb3dcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJncmlkUm93RW5kXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwiZ3JpZFJvd1N0YXJ0XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXFwibGluZUhlaWdodFxcXCI6IHRydWUsXFxuXFx0XFx0XFxcIm9wYWNpdHlcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJvcmRlclxcXCI6IHRydWUsXFxuXFx0XFx0XFxcIm9ycGhhbnNcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJ3aWRvd3NcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJ6SW5kZXhcXFwiOiB0cnVlLFxcblxcdFxcdFxcXCJ6b29tXFxcIjogdHJ1ZVxcblxcdH0sXFxuXFxuXFx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxcblxcdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcXG5cXHRjc3NQcm9wczoge30sXFxuXFxuXFx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcXG5cXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcXG5cXG5cXHRcXHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcXG5cXHRcXHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxcblxcdFxcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxcblxcdFxcdFxcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXFxuXFx0XFx0XFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxcblxcdFxcdFxcdHN0eWxlID0gZWxlbS5zdHlsZTtcXG5cXG5cXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XFxuXFx0XFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XFxuXFx0XFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxcblxcdFxcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcXG5cXHRcXHRcXHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cXG5cXHRcXHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcXG5cXG5cXHRcXHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcXG5cXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IFxcXCIrPVxcXCIgb3IgXFxcIi09XFxcIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcXG5cXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xcblxcblxcdFxcdFxcdFxcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xcblxcdFxcdFxcdFxcdHR5cGUgPSBcXFwibnVtYmVyXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXFxuXFx0XFx0XFx0Ly8gVGhlIGlzQ3VzdG9tUHJvcCBjaGVjayBjYW4gYmUgcmVtb3ZlZCBpbiBqUXVlcnkgNC4wIHdoZW4gd2Ugb25seSBhdXRvLWFwcGVuZFxcblxcdFxcdFxcdC8vIFxcXCJweFxcXCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cXG5cXHRcXHRcXHRpZiAoIHR5cGUgPT09IFxcXCJudW1iZXJcXFwiICYmICFpc0N1c3RvbVByb3AgKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFxcXCJcXFwiIDogXFxcInB4XFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXFxuXFx0XFx0XFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFxcXCJcXFwiICYmIG5hbWUuaW5kZXhPZiggXFxcImJhY2tncm91bmRcXFwiICkgPT09IDAgKSB7XFxuXFx0XFx0XFx0XFx0c3R5bGVbIG5hbWUgXSA9IFxcXCJpbmhlcml0XFxcIjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXFxuXFx0XFx0XFx0aWYgKCAhaG9va3MgfHwgISggXFxcInNldFxcXCIgaW4gaG9va3MgKSB8fFxcblxcdFxcdFxcdFxcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcXG5cXHRcXHRcXHRcXHRcXHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXFxuXFx0XFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyAmJlxcblxcdFxcdFxcdFxcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3RcXG5cXHRcXHRcXHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xcblxcdFxcdHZhciB2YWwsIG51bSwgaG9va3MsXFxuXFx0XFx0XFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcXG5cXHRcXHRcXHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XFxuXFxuXFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxcblxcdFxcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcXG5cXHRcXHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXFxuXFx0XFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xcblxcdFxcdFxcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXFxuXFx0XFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XFxuXFxuXFx0XFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcXG5cXHRcXHRpZiAoIGhvb2tzICYmIFxcXCJnZXRcXFwiIGluIGhvb2tzICkge1xcblxcdFxcdFxcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcXG5cXHRcXHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENvbnZlcnQgXFxcIm5vcm1hbFxcXCIgdG8gY29tcHV0ZWQgdmFsdWVcXG5cXHRcXHRpZiAoIHZhbCA9PT0gXFxcIm5vcm1hbFxcXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XFxuXFx0XFx0XFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xcblxcdFxcdGlmICggZXh0cmEgPT09IFxcXCJcXFwiIHx8IGV4dHJhICkge1xcblxcdFxcdFxcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xcblxcdFxcdFxcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHZhbDtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5lYWNoKCBbIFxcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiIF0sIGZ1bmN0aW9uKCBfaSwgZGltZW5zaW9uICkge1xcblxcdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xcblxcdFxcdFxcdGlmICggY29tcHV0ZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXFxuXFx0XFx0XFx0XFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApICkgJiZcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcXG5cXHRcXHRcXHRcXHRcXHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xcblxcdFxcdFxcdFxcdFxcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxcblxcdFxcdFxcdFxcdFxcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cXG5cXHRcXHRcXHRcXHRcXHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xcblxcdFxcdFxcdFxcdFxcdFxcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xcblxcdFxcdFxcdHZhciBtYXRjaGVzLFxcblxcdFxcdFxcdFxcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxcblxcblxcdFxcdFxcdFxcdC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcXG5cXHRcXHRcXHRcXHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxcblxcdFxcdFxcdFxcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxcblxcdFxcdFxcdFxcdFxcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXFxcImFic29sdXRlXFxcIixcXG5cXG5cXHRcXHRcXHRcXHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxcblxcdFxcdFxcdFxcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcXG5cXHRcXHRcXHRcXHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJib3hTaXppbmdcXFwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFxcXCJib3JkZXItYm94XFxcIixcXG5cXHRcXHRcXHRcXHRzdWJ0cmFjdCA9IGV4dHJhID9cXG5cXHRcXHRcXHRcXHRcXHRib3hNb2RlbEFkanVzdG1lbnQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaW1lbnNpb24sXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0cmEsXFxuXFx0XFx0XFx0XFx0XFx0XFx0aXNCb3JkZXJCb3gsXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3R5bGVzXFxuXFx0XFx0XFx0XFx0XFx0KSA6XFxuXFx0XFx0XFx0XFx0XFx0MDtcXG5cXG5cXHRcXHRcXHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcXG5cXHRcXHRcXHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxcblxcdFxcdFxcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xcblxcdFxcdFxcdFxcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcXG5cXHRcXHRcXHRcXHRcXHRlbGVtWyBcXFwib2Zmc2V0XFxcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cXG5cXHRcXHRcXHRcXHRcXHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxcblxcdFxcdFxcdFxcdFxcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcXFwiYm9yZGVyXFxcIiwgZmFsc2UsIHN0eWxlcyApIC1cXG5cXHRcXHRcXHRcXHRcXHQwLjVcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxcblxcdFxcdFxcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcXG5cXHRcXHRcXHRcXHQoIG1hdGNoZXNbIDMgXSB8fCBcXFwicHhcXFwiICkgIT09IFxcXCJweFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xcblxcdFxcdH1cXG5cXHR9O1xcbn0gKTtcXG5cXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXFxuXFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xcblxcdFxcdGlmICggY29tcHV0ZWQgKSB7XFxuXFx0XFx0XFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcXFwibWFyZ2luTGVmdFxcXCIgKSApIHx8XFxuXFx0XFx0XFx0XFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cXG5cXHRcXHRcXHRcXHRcXHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcXG5cXHRcXHRcXHRcXHRcXHR9IClcXG5cXHRcXHRcXHRcXHQpICsgXFxcInB4XFxcIjtcXG5cXHRcXHR9XFxuXFx0fVxcbik7XFxuXFxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xcbmpRdWVyeS5lYWNoKCB7XFxuXFx0bWFyZ2luOiBcXFwiXFxcIixcXG5cXHRwYWRkaW5nOiBcXFwiXFxcIixcXG5cXHRib3JkZXI6IFxcXCJXaWR0aFxcXCJcXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XFxuXFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcXG5cXHRcXHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0XFx0XFx0ZXhwYW5kZWQgPSB7fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcXG5cXHRcXHRcXHRcXHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIgPyB2YWx1ZS5zcGxpdCggXFxcIiBcXFwiICkgOiBbIHZhbHVlIF07XFxuXFxuXFx0XFx0XFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xcblxcdFxcdFxcdFxcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cXG5cXHRcXHRcXHRcXHRcXHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBleHBhbmRlZDtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRpZiAoIHByZWZpeCAhPT0gXFxcIm1hcmdpblxcXCIgKSB7XFxuXFx0XFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0dmFyIHN0eWxlcywgbGVuLFxcblxcdFxcdFxcdFxcdG1hcCA9IHt9LFxcblxcdFxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xcblxcdFxcdFxcdFxcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xcblxcdFxcdFxcdFxcdGxlbiA9IG5hbWUubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG1hcDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdFxcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xcblxcdFxcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xcblxcdH1cXG59ICk7XFxuXFxuXFxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xcblxcdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XFxufVxcbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xcblxcblR3ZWVuLnByb3RvdHlwZSA9IHtcXG5cXHRjb25zdHJ1Y3RvcjogVHdlZW4sXFxuXFx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xcblxcdFxcdHRoaXMuZWxlbSA9IGVsZW07XFxuXFx0XFx0dGhpcy5wcm9wID0gcHJvcDtcXG5cXHRcXHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xcblxcdFxcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuXFx0XFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcXG5cXHRcXHR0aGlzLmVuZCA9IGVuZDtcXG5cXHRcXHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiICk7XFxuXFx0fSxcXG5cXHRjdXI6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XFxuXFxuXFx0XFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XFxuXFx0XFx0XFx0aG9va3MuZ2V0KCB0aGlzICkgOlxcblxcdFxcdFxcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcXG5cXHR9LFxcblxcdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XFxuXFx0XFx0dmFyIGVhc2VkLFxcblxcdFxcdFxcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcXG5cXG5cXHRcXHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcXG5cXHRcXHRcXHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcXG5cXHRcXHRcXHRcXHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cXG5cXHRcXHRcXHQpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XFxuXFx0XFx0fVxcblxcdFxcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcXG5cXG5cXHRcXHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xcblxcdFxcdFxcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XFxuXFx0XFx0XFx0aG9va3Muc2V0KCB0aGlzICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH1cXG59O1xcblxcblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcXG5cXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XFxuXFx0X2RlZmF1bHQ6IHtcXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcXG5cXHRcXHRcXHR2YXIgcmVzdWx0O1xcblxcblxcdFxcdFxcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXFxuXFx0XFx0XFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cXG5cXHRcXHRcXHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcXG5cXHRcXHRcXHRcXHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcXG5cXHRcXHRcXHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxcblxcdFxcdFxcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcXFwiMTBweFxcXCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcXG5cXHRcXHRcXHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFxcXCJyb3RhdGUoMXJhZClcXFwiIGFyZSByZXR1cm5lZCBhcy1pcy5cXG5cXHRcXHRcXHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcXFwiXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXFxcImF1dG9cXFwiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cXG5cXHRcXHRcXHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFxcXCJhdXRvXFxcIiA/IDAgOiByZXN1bHQ7XFxuXFx0XFx0fSxcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcXG5cXG5cXHRcXHRcXHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cXG5cXHRcXHRcXHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXFxuXFx0XFx0XFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cXG5cXHRcXHRcXHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxcblxcdFxcdFxcdFxcdFxcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59O1xcblxcbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XFxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXFxuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xcblxcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xcblxcdFxcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xcblxcdFxcdH1cXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkuZWFzaW5nID0ge1xcblxcdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XFxuXFx0XFx0cmV0dXJuIHA7XFxuXFx0fSxcXG5cXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XFxuXFx0XFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcXG5cXHR9LFxcblxcdF9kZWZhdWx0OiBcXFwic3dpbmdcXFwiXFxufTtcXG5cXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcXG5cXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxcbmpRdWVyeS5meC5zdGVwID0ge307XFxuXFxuXFxuXFxuXFxudmFyXFxuXFx0ZnhOb3csIGluUHJvZ3Jlc3MsXFxuXFx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXFxuXFx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XFxuXFxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XFxuXFx0aWYgKCBpblByb2dyZXNzICkge1xcblxcdFxcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xcblxcdFxcdFxcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRqUXVlcnkuZngudGljaygpO1xcblxcdH1cXG59XFxuXFxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xcblxcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcXG5cXHRcXHRmeE5vdyA9IHVuZGVmaW5lZDtcXG5cXHR9ICk7XFxuXFx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XFxufVxcblxcbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXFxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcXG5cXHR2YXIgd2hpY2gsXFxuXFx0XFx0aSA9IDAsXFxuXFx0XFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xcblxcblxcdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcXG5cXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxcblxcdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xcblxcdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcXG5cXHRcXHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xcblxcdFxcdGF0dHJzWyBcXFwibWFyZ2luXFxcIiArIHdoaWNoIF0gPSBhdHRyc1sgXFxcInBhZGRpbmdcXFwiICsgd2hpY2ggXSA9IHR5cGU7XFxuXFx0fVxcblxcblxcdGlmICggaW5jbHVkZVdpZHRoICkge1xcblxcdFxcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XFxuXFx0fVxcblxcblxcdHJldHVybiBhdHRycztcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XFxuXFx0dmFyIHR3ZWVuLFxcblxcdFxcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFxcXCIqXFxcIiBdICksXFxuXFx0XFx0aW5kZXggPSAwLFxcblxcdFxcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xcblxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxcblxcdFxcdFxcdHJldHVybiB0d2VlbjtcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcXG5cXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXFxuXFx0XFx0aXNCb3ggPSBcXFwid2lkdGhcXFwiIGluIHByb3BzIHx8IFxcXCJoZWlnaHRcXFwiIGluIHByb3BzLFxcblxcdFxcdGFuaW0gPSB0aGlzLFxcblxcdFxcdG9yaWcgPSB7fSxcXG5cXHRcXHRzdHlsZSA9IGVsZW0uc3R5bGUsXFxuXFx0XFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcXG5cXHRcXHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXFxcImZ4c2hvd1xcXCIgKTtcXG5cXG5cXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3NcXG5cXHRpZiAoICFvcHRzLnF1ZXVlICkge1xcblxcdFxcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcXFwiZnhcXFwiICk7XFxuXFx0XFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xcblxcdFxcdFxcdGhvb2tzLnVucXVldWVkID0gMDtcXG5cXHRcXHRcXHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcXG5cXHRcXHRcXHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0b2xkZmlyZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXHRcXHRob29rcy51bnF1ZXVlZCsrO1xcblxcblxcdFxcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xcblxcdFxcdFxcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRob29rcy51bnF1ZXVlZC0tO1xcblxcdFxcdFxcdFxcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXFxcImZ4XFxcIiApLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRcXHRob29rcy5lbXB0eS5maXJlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xcblxcdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XFxuXFx0XFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xcblxcdFxcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRkZWxldGUgcHJvcHNbIHByb3AgXTtcXG5cXHRcXHRcXHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFxcXCJ0b2dnbGVcXFwiO1xcblxcdFxcdFxcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXFxcImhpZGVcXFwiIDogXFxcInNob3dcXFwiICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFxcXCJzaG93XFxcIiBhbmRcXG5cXHRcXHRcXHRcXHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxcblxcdFxcdFxcdFxcdGlmICggdmFsdWUgPT09IFxcXCJzaG93XFxcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGlkZGVuID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxcblxcdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcXG5cXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdC8vIFJlc3RyaWN0IFxcXCJvdmVyZmxvd1xcXCIgYW5kIFxcXCJkaXNwbGF5XFxcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXFxuXFx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcXG5cXHRcXHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcXG5cXHRcXHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcXG5cXHRcXHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxcblxcdFxcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xcblxcblxcdFxcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxcblxcdFxcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcXG5cXHRcXHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XFxuXFx0XFx0XFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApO1xcblxcdFxcdH1cXG5cXHRcXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXFxcImRpc3BsYXlcXFwiICk7XFxuXFx0XFx0aWYgKCBkaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgKSB7XFxuXFx0XFx0XFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcXG5cXHRcXHRcXHRcXHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XFxuXFx0XFx0XFx0XFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XFxuXFx0XFx0XFx0XFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJkaXNwbGF5XFxcIiApO1xcblxcdFxcdFxcdFxcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXFxuXFx0XFx0aWYgKCBkaXNwbGF5ID09PSBcXFwiaW5saW5lXFxcIiB8fCBkaXNwbGF5ID09PSBcXFwiaW5saW5lLWJsb2NrXFxcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xcblxcdFxcdFxcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXFxcImZsb2F0XFxcIiApID09PSBcXFwibm9uZVxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcXG5cXHRcXHRcXHRcXHRpZiAoICFwcm9wVHdlZW4gKSB7XFxuXFx0XFx0XFx0XFx0XFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XFxuXFx0XFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFxcXCJub25lXFxcIiA/IFxcXCJcXFwiIDogZGlzcGxheTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHN0eWxlLmRpc3BsYXkgPSBcXFwiaW5saW5lLWJsb2NrXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XFxuXFx0XFx0c3R5bGUub3ZlcmZsb3cgPSBcXFwiaGlkZGVuXFxcIjtcXG5cXHRcXHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XFxuXFx0XFx0XFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xcblxcdFxcdFxcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcXG5cXHRcXHR9ICk7XFxuXFx0fVxcblxcblxcdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xcblxcdHByb3BUd2VlbiA9IGZhbHNlO1xcblxcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcXG5cXG5cXHRcXHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxcblxcdFxcdGlmICggIXByb3BUd2VlbiApIHtcXG5cXHRcXHRcXHRpZiAoIGRhdGFTaG93ICkge1xcblxcdFxcdFxcdFxcdGlmICggXFxcImhpZGRlblxcXCIgaW4gZGF0YVNob3cgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcXFwiZnhzaG93XFxcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFxcXCJyZXZlcnNlc1xcXCJcXG5cXHRcXHRcXHRpZiAoIHRvZ2dsZSApIHtcXG5cXHRcXHRcXHRcXHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxcblxcdFxcdFxcdGlmICggaGlkZGVuICkge1xcblxcdFxcdFxcdFxcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cXG5cXG5cXHRcXHRcXHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXFxuXFxuXFx0XFx0XFx0XFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcXFwiaGlkZVxcXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxcblxcdFxcdFxcdFxcdGlmICggIWhpZGRlbiApIHtcXG5cXHRcXHRcXHRcXHRcXHRzaG93SGlkZSggWyBlbGVtIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcXFwiZnhzaG93XFxcIiApO1xcblxcdFxcdFxcdFxcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxcblxcdFxcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xcblxcdFxcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xcblxcdFxcdFxcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XFxuXFx0XFx0XFx0aWYgKCBoaWRkZW4gKSB7XFxuXFx0XFx0XFx0XFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcXG5cXHRcXHRcXHRcXHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcXG5cXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xcblxcblxcdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xcblxcdGZvciAoIGluZGV4IGluIHByb3BzICkge1xcblxcdFxcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XFxuXFx0XFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xcblxcdFxcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XFxuXFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xcblxcdFxcdFxcdGVhc2luZyA9IHZhbHVlWyAxIF07XFxuXFx0XFx0XFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XFxuXFx0XFx0XFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xcblxcdFxcdFxcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcXG5cXHRcXHRpZiAoIGhvb2tzICYmIFxcXCJleHBhbmRcXFwiIGluIGhvb2tzICkge1xcblxcdFxcdFxcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xcblxcdFxcdFxcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cXG5cXHRcXHRcXHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFxcXCJuYW1lXFxcIlxcblxcdFxcdFxcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xcblxcdFxcdFxcdFxcdFxcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XFxuXFx0dmFyIHJlc3VsdCxcXG5cXHRcXHRzdG9wcGVkLFxcblxcdFxcdGluZGV4ID0gMCxcXG5cXHRcXHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXFxuXFx0XFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxcblxcdFxcdFxcdGRlbGV0ZSB0aWNrLmVsZW07XFxuXFx0XFx0fSApLFxcblxcdFxcdHRpY2sgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoIHN0b3BwZWQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxcblxcdFxcdFxcdFxcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxcblxcdFxcdFxcdFxcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcXG5cXHRcXHRcXHRcXHRwZXJjZW50ID0gMSAtIHRlbXAsXFxuXFx0XFx0XFx0XFx0aW5kZXggPSAwLFxcblxcdFxcdFxcdFxcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xcblxcblxcdFxcdFxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0XFx0XFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxcblxcdFxcdFxcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdHJldHVybiByZW1haW5pbmc7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxcblxcdFxcdFxcdGlmICggIWxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXFxuXFx0XFx0XFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXHRcXHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XFxuXFx0XFx0XFx0ZWxlbTogZWxlbSxcXG5cXHRcXHRcXHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcXG5cXHRcXHRcXHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XFxuXFx0XFx0XFx0XFx0c3BlY2lhbEVhc2luZzoge30sXFxuXFx0XFx0XFx0XFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XFxuXFx0XFx0XFx0fSwgb3B0aW9ucyApLFxcblxcdFxcdFxcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcXG5cXHRcXHRcXHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXFxuXFx0XFx0XFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxcblxcdFxcdFxcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxcblxcdFxcdFxcdHR3ZWVuczogW10sXFxuXFx0XFx0XFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxcblxcdFxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcXG5cXHRcXHRcXHRcXHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHR3ZWVuO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gMCxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcXG5cXHRcXHRcXHRcXHRcXHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcXG5cXHRcXHRcXHRcXHRcXHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xcblxcdFxcdFxcdFxcdGlmICggc3RvcHBlZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3RvcHBlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRcXHRcXHRcXHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxcblxcdFxcdFxcdFxcdGlmICggZ290b0VuZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKSxcXG5cXHRcXHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcXG5cXG5cXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xcblxcblxcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcXG5cXHRcXHRpZiAoIHJlc3VsdCApIHtcXG5cXHRcXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XFxuXFxuXFx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xcblxcdFxcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xcblxcdH1cXG5cXG5cXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xcblxcdGFuaW1hdGlvblxcblxcdFxcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxcblxcdFxcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXFxuXFx0XFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxcblxcdFxcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xcblxcblxcdGpRdWVyeS5meC50aW1lcihcXG5cXHRcXHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XFxuXFx0XFx0XFx0ZWxlbTogZWxlbSxcXG5cXHRcXHRcXHRhbmltOiBhbmltYXRpb24sXFxuXFx0XFx0XFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXFxuXFx0XFx0fSApXFxuXFx0KTtcXG5cXG5cXHRyZXR1cm4gYW5pbWF0aW9uO1xcbn1cXG5cXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XFxuXFxuXFx0dHdlZW5lcnM6IHtcXG5cXHRcXHRcXFwiKlxcXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XFxuXFx0XFx0XFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XFxuXFx0XFx0XFx0cmV0dXJuIHR3ZWVuO1xcblxcdFxcdH0gXVxcblxcdH0sXFxuXFxuXFx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XFxuXFx0XFx0XFx0Y2FsbGJhY2sgPSBwcm9wcztcXG5cXHRcXHRcXHRwcm9wcyA9IFsgXFxcIipcXFwiIF07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBwcm9wLFxcblxcdFxcdFxcdGluZGV4ID0gMCxcXG5cXHRcXHRcXHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XFxuXFxuXFx0XFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcXG5cXHRcXHRcXHRwcm9wID0gcHJvcHNbIGluZGV4IF07XFxuXFx0XFx0XFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcXG5cXHRcXHRcXHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxcblxcblxcdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xcblxcdFxcdGlmICggcHJlcGVuZCApIHtcXG5cXHRcXHRcXHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XFxuXFx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXFxcIm9iamVjdFxcXCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcXG5cXHRcXHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxcblxcdFxcdFxcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXFxuXFx0XFx0ZHVyYXRpb246IHNwZWVkLFxcblxcdFxcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXFxuXFx0fTtcXG5cXG5cXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcXG5cXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XFxuXFx0XFx0b3B0LmR1cmF0aW9uID0gMDtcXG5cXG5cXHR9IGVsc2Uge1xcblxcdFxcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXFxcIm51bWJlclxcXCIgKSB7XFxuXFx0XFx0XFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcXG5cXHRcXHRcXHRcXHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXFxcImZ4XFxcIlxcblxcdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xcblxcdFxcdG9wdC5xdWV1ZSA9IFxcXCJmeFxcXCI7XFxuXFx0fVxcblxcblxcdC8vIFF1ZXVlaW5nXFxuXFx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcXG5cXG5cXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcXG5cXHRcXHRcXHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBvcHQucXVldWUgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdHJldHVybiBvcHQ7XFxufTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xcblxcblxcdFxcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxcblxcdFxcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcXFwib3BhY2l0eVxcXCIsIDAgKS5zaG93KClcXG5cXG5cXHRcXHRcXHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcXG5cXHRcXHRcXHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xcblxcdH0sXFxuXFx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xcblxcdFxcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXFxuXFx0XFx0XFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxcblxcdFxcdFxcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3RcXG5cXHRcXHRcXHRcXHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XFxuXFx0XFx0XFx0XFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFxcXCJmaW5pc2hcXFwiICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0YW5pbS5zdG9wKCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XFxuXFxuXFx0XFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xcblxcdFxcdFxcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XFxuXFx0XFx0XFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xcblxcdH0sXFxuXFx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XFxuXFx0XFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcXG5cXHRcXHRcXHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XFxuXFx0XFx0XFx0ZGVsZXRlIGhvb2tzLnN0b3A7XFxuXFx0XFx0XFx0c3RvcCggZ290b0VuZCApO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XFxuXFx0XFx0XFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XFxuXFx0XFx0XFx0dHlwZSA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCBjbGVhclF1ZXVlICkge1xcblxcdFxcdFxcdHRoaXMucXVldWUoIHR5cGUgfHwgXFxcImZ4XFxcIiwgW10gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGRlcXVldWUgPSB0cnVlLFxcblxcdFxcdFxcdFxcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcXFwicXVldWVIb29rc1xcXCIsXFxuXFx0XFx0XFx0XFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcXG5cXHRcXHRcXHRcXHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmRleCApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xcblxcdFxcdFxcdFxcdFxcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXFxuXFx0XFx0XFx0XFx0XFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xcblxcdFxcdFxcdFxcdFxcdGRlcXVldWUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cXG5cXHRcXHRcXHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXFxuXFx0XFx0XFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxcblxcdFxcdFxcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xcblxcdFxcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0dHlwZSA9IHR5cGUgfHwgXFxcImZ4XFxcIjtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGluZGV4LFxcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcXG5cXHRcXHRcXHRcXHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcXFwicXVldWVcXFwiIF0sXFxuXFx0XFx0XFx0XFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXFxcInF1ZXVlSG9va3NcXFwiIF0sXFxuXFx0XFx0XFx0XFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcXG5cXHRcXHRcXHRcXHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XFxuXFxuXFx0XFx0XFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxcblxcdFxcdFxcdGRhdGEuZmluaXNoID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3RcXG5cXHRcXHRcXHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xcblxcdFxcdFxcdFxcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxcblxcdFxcdFxcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xcblxcdFxcdFxcdFxcdFxcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxcblxcdFxcdFxcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XFxuXFx0XFx0XFx0XFx0XFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXFxuXFx0XFx0XFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5lYWNoKCBbIFxcXCJ0b2dnbGVcXFwiLCBcXFwic2hvd1xcXCIsIFxcXCJoaWRlXFxcIiBdLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XFxuXFx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XFxuXFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcXFwiYm9vbGVhblxcXCIgP1xcblxcdFxcdFxcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XFxuXFx0XFx0XFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xcblxcdH07XFxufSApO1xcblxcbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcXG5qUXVlcnkuZWFjaCgge1xcblxcdHNsaWRlRG93bjogZ2VuRngoIFxcXCJzaG93XFxcIiApLFxcblxcdHNsaWRlVXA6IGdlbkZ4KCBcXFwiaGlkZVxcXCIgKSxcXG5cXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFxcXCJ0b2dnbGVcXFwiICksXFxuXFx0ZmFkZUluOiB7IG9wYWNpdHk6IFxcXCJzaG93XFxcIiB9LFxcblxcdGZhZGVPdXQ6IHsgb3BhY2l0eTogXFxcImhpZGVcXFwiIH0sXFxuXFx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcXFwidG9nZ2xlXFxcIiB9XFxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xcblxcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xcblxcdFxcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xcblxcdH07XFxufSApO1xcblxcbmpRdWVyeS50aW1lcnMgPSBbXTtcXG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xcblxcdHZhciB0aW1lcixcXG5cXHRcXHRpID0gMCxcXG5cXHRcXHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xcblxcblxcdGZ4Tm93ID0gRGF0ZS5ub3coKTtcXG5cXG5cXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XFxuXFx0XFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcXG5cXG5cXHRcXHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXFxuXFx0XFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XFxuXFx0XFx0XFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xcblxcdFxcdGpRdWVyeS5meC5zdG9wKCk7XFxuXFx0fVxcblxcdGZ4Tm93ID0gdW5kZWZpbmVkO1xcbn07XFxuXFxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xcblxcdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcXG5cXHRqUXVlcnkuZnguc3RhcnQoKTtcXG59O1xcblxcbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xcblxcdGlmICggaW5Qcm9ncmVzcyApIHtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdGluUHJvZ3Jlc3MgPSB0cnVlO1xcblxcdHNjaGVkdWxlKCk7XFxufTtcXG5cXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xcblxcdGluUHJvZ3Jlc3MgPSBudWxsO1xcbn07XFxuXFxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcXG5cXHRzbG93OiA2MDAsXFxuXFx0ZmFzdDogMjAwLFxcblxcblxcdC8vIERlZmF1bHQgc3BlZWRcXG5cXHRfZGVmYXVsdDogNDAwXFxufTtcXG5cXG5cXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXFxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcXG5cXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xcblxcdHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFxuXFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcXG5cXHRcXHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XFxuXFx0XFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcXG5cXHRcXHR9O1xcblxcdH0gKTtcXG59O1xcblxcblxcbiggZnVuY3Rpb24oKSB7XFxuXFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImlucHV0XFxcIiApLFxcblxcdFxcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJzZWxlY3RcXFwiICksXFxuXFx0XFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcXFwib3B0aW9uXFxcIiApICk7XFxuXFxuXFx0aW5wdXQudHlwZSA9IFxcXCJjaGVja2JveFxcXCI7XFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XFxuXFx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXFxcIm9uXFxcIlxcblxcdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcXFwiXFxcIjtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG5cXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxcblxcdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XFxuXFx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cXG5cXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJpbnB1dFxcXCIgKTtcXG5cXHRpbnB1dC52YWx1ZSA9IFxcXCJ0XFxcIjtcXG5cXHRpbnB1dC50eXBlID0gXFxcInJhZGlvXFxcIjtcXG5cXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXFxcInRcXFwiO1xcbn0gKSgpO1xcblxcblxcbnZhciBib29sSG9vayxcXG5cXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcXG5cXHR9LFxcblxcblxcdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgcmV0LCBob29rcyxcXG5cXHRcXHRcXHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0XFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xcblxcdFxcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxcblxcdFxcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcXFwidW5kZWZpbmVkXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cXG5cXHRcXHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXFxuXFx0XFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XFxuXFx0XFx0XFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxcblxcdFxcdFxcdFxcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBob29rcyAmJiBcXFwic2V0XFxcIiBpbiBob29rcyAmJlxcblxcdFxcdFxcdFxcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcXFwiXFxcIiApO1xcblxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xcblxcblxcdFxcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXFxuXFx0XFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xcblxcdH0sXFxuXFxuXFx0YXR0ckhvb2tzOiB7XFxuXFx0XFx0dHlwZToge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXFxcInJhZGlvXFxcIiAmJlxcblxcdFxcdFxcdFxcdFxcdG5vZGVOYW1lKCBlbGVtLCBcXFwiaW5wdXRcXFwiICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFxcXCJ0eXBlXFxcIiwgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZhbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLnZhbHVlID0gdmFsO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XFxuXFx0XFx0dmFyIG5hbWUsXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFxuXFx0XFx0XFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xcblxcdFxcdFxcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxcblxcdFxcdFxcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XFxuXFxuXFx0XFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXHRcXHRcXHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXFxuYm9vbEhvb2sgPSB7XFxuXFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XFxuXFx0XFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxcblxcdFxcdFxcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gbmFtZTtcXG5cXHR9XFxufTtcXG5cXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXFxcdysvZyApLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XFxuXFx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xcblxcblxcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcXG5cXHRcXHR2YXIgcmV0LCBoYW5kbGUsXFxuXFx0XFx0XFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXG5cXHRcXHRpZiAoICFpc1hNTCApIHtcXG5cXG5cXHRcXHRcXHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXFxuXFx0XFx0XFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xcblxcdFxcdFxcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcXG5cXHRcXHRcXHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XFxuXFx0XFx0XFx0XFx0bG93ZXJjYXNlTmFtZSA6XFxuXFx0XFx0XFx0XFx0bnVsbDtcXG5cXHRcXHRcXHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiByZXQ7XFxuXFx0fTtcXG59ICk7XFxuXFxuXFxuXFxuXFxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxcblxcdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XFxuXFx0XFx0fSApO1xcblxcdH1cXG59ICk7XFxuXFxualF1ZXJ5LmV4dGVuZCgge1xcblxcdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgcmV0LCBob29rcyxcXG5cXHRcXHRcXHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0XFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xcblxcdFxcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXFxuXFx0XFx0XFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcXG5cXHRcXHRcXHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdGlmICggaG9va3MgJiYgXFxcInNldFxcXCIgaW4gaG9va3MgJiZcXG5cXHRcXHRcXHRcXHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcXG5cXHR9LFxcblxcblxcdHByb3BIb29rczoge1xcblxcdFxcdHRhYkluZGV4OiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXFxuXFx0XFx0XFx0XFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XFxuXFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXFxuXFx0XFx0XFx0XFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3MilcXG5cXHRcXHRcXHRcXHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcXFwidGFiaW5kZXhcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0YWJpbmRleCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoXFxuXFx0XFx0XFx0XFx0XFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcXG5cXHRcXHRcXHRcXHRcXHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxcblxcdFxcdFxcdFxcdFxcdGVsZW0uaHJlZlxcblxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gLTE7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdHByb3BGaXg6IHtcXG5cXHRcXHRcXFwiZm9yXFxcIjogXFxcImh0bWxGb3JcXFwiLFxcblxcdFxcdFxcXCJjbGFzc1xcXCI6IFxcXCJjbGFzc05hbWVcXFwiXFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcXG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcXG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXFxuLy8gb24gdGhlIG9wdGlvblxcbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxcbi8vIGVzbGludCBydWxlIFxcXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcXFwiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xcblxcdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXG5cXHRcXHRcXHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcXFwib2ZmXFxcIiAqL1xcblxcblxcdFxcdFxcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XFxuXFx0XFx0XFx0XFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0fSxcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdFxcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFxcXCJvZmZcXFwiICovXFxuXFxuXFx0XFx0XFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRpZiAoIHBhcmVudCApIHtcXG5cXHRcXHRcXHRcXHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG59XFxuXFxualF1ZXJ5LmVhY2goIFtcXG5cXHRcXFwidGFiSW5kZXhcXFwiLFxcblxcdFxcXCJyZWFkT25seVxcXCIsXFxuXFx0XFxcIm1heExlbmd0aFxcXCIsXFxuXFx0XFxcImNlbGxTcGFjaW5nXFxcIixcXG5cXHRcXFwiY2VsbFBhZGRpbmdcXFwiLFxcblxcdFxcXCJyb3dTcGFuXFxcIixcXG5cXHRcXFwiY29sU3BhblxcXCIsXFxuXFx0XFxcInVzZU1hcFxcXCIsXFxuXFx0XFxcImZyYW1lQm9yZGVyXFxcIixcXG5cXHRcXFwiY29udGVudEVkaXRhYmxlXFxcIlxcbl0sIGZ1bmN0aW9uKCkge1xcblxcdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XFxufSApO1xcblxcblxcblxcblxcblxcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcXG5cXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2VcXG5cXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcXG5cXHRcXHRyZXR1cm4gdG9rZW5zLmpvaW4oIFxcXCIgXFxcIiApO1xcblxcdH1cXG5cXG5cXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcXG5cXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFxcXCJjbGFzc1xcXCIgKSB8fCBcXFwiXFxcIjtcXG59XFxuXFxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xcblxcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcXG5cXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0fVxcblxcdGlmICggdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcXG5cXHR9XFxuXFx0cmV0dXJuIFtdO1xcbn1cXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXFxuXFx0XFx0XFx0aSA9IDA7XFxuXFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcXG5cXG5cXHRcXHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xcblxcdFxcdFxcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcXG5cXHRcXHRcXHRcXHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XFxuXFx0XFx0XFx0XFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFxcXCIgXFxcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcXFwiIFxcXCIgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGN1ciApIHtcXG5cXHRcXHRcXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY3VyLmluZGV4T2YoIFxcXCIgXFxcIiArIGNsYXp6ICsgXFxcIiBcXFwiICkgPCAwICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1ciArPSBjbGF6eiArIFxcXCIgXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXFxuXFx0XFx0XFx0XFx0XFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFxcXCJjbGFzc1xcXCIsIGZpbmFsVmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcXG5cXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xcblxcdFxcdFxcdH0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hdHRyKCBcXFwiY2xhc3NcXFwiLCBcXFwiXFxcIiApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XFxuXFxuXFx0XFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XFxuXFx0XFx0XFx0XFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xcblxcblxcdFxcdFxcdFxcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXFxuXFx0XFx0XFx0XFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFxcXCIgXFxcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcXFwiIFxcXCIgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGN1ciApIHtcXG5cXHRcXHRcXHRcXHRcXHRqID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcXFwiIFxcXCIgKyBjbGF6eiArIFxcXCIgXFxcIiApID4gLTEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VyID0gY3VyLnJlcGxhY2UoIFxcXCIgXFxcIiArIGNsYXp6ICsgXFxcIiBcXFwiLCBcXFwiIFxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXFxuXFx0XFx0XFx0XFx0XFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFxcXCJjbGFzc1xcXCIsIGZpbmFsVmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fSxcXG5cXG5cXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcXG5cXHRcXHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcXG5cXHRcXHRcXHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcXFwic3RyaW5nXFxcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xcblxcblxcdFxcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcXFwiYm9vbGVhblxcXCIgJiYgaXNWYWxpZFZhbHVlICkge1xcblxcdFxcdFxcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZVZhbFxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xcblxcblxcdFxcdFxcdGlmICggaXNWYWxpZFZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXFxuXFx0XFx0XFx0XFx0aSA9IDA7XFxuXFx0XFx0XFx0XFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xcblxcdFxcdFxcdFxcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3RcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXFxcImJvb2xlYW5cXFwiICkge1xcblxcdFxcdFxcdFxcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBjbGFzc05hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxcblxcdFxcdFxcdFxcdFxcdGRhdGFQcml2LnNldCggdGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiLCBjbGFzc05hbWUgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcXG5cXHRcXHRcXHRcXHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXFxuXFx0XFx0XFx0XFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFxcXCJjbGFzc1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcIlxcXCIgOlxcblxcdFxcdFxcdFxcdFxcdFxcdGRhdGFQcml2LmdldCggdGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiICkgfHwgXFxcIlxcXCJcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcdH0sXFxuXFxuXFx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcXG5cXHRcXHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxcblxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdGNsYXNzTmFtZSA9IFxcXCIgXFxcIiArIHNlbGVjdG9yICsgXFxcIiBcXFwiO1xcblxcdFxcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcXG5cXHRcXHRcXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcXG5cXHRcXHRcXHRcXHQoIFxcXCIgXFxcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFxcXCIgXFxcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5cXG5cXG52YXIgcnJldHVybiA9IC9cXFxcci9nO1xcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxcblxcdFxcdFxcdGVsZW0gPSB0aGlzWyAwIF07XFxuXFxuXFx0XFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRpZiAoIGVsZW0gKSB7XFxuXFx0XFx0XFx0XFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGhvb2tzICYmXFxuXFx0XFx0XFx0XFx0XFx0XFxcImdldFxcXCIgaW4gaG9va3MgJiZcXG5cXHRcXHRcXHRcXHRcXHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXFxcInZhbHVlXFxcIiApICkgIT09IHVuZGVmaW5lZFxcblxcdFxcdFxcdFxcdCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldCA9IGVsZW0udmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xcblxcdFxcdFxcdFxcdGlmICggdHlwZW9mIHJldCA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcXFwiXFxcIiApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0ID09IG51bGwgPyBcXFwiXFxcIiA6IHJldDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdHZhciB2YWw7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHZhbCA9IHZhbHVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcXFwiXFxcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xcblxcdFxcdFxcdGlmICggdmFsID09IG51bGwgKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXFxcIm51bWJlclxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0dmFsICs9IFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xcblxcdFxcdFxcdFxcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXFxcIlxcXCIgOiB2YWx1ZSArIFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdH0gKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XFxuXFxuXFx0XFx0XFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcXG5cXHRcXHRcXHRpZiAoICFob29rcyB8fCAhKCBcXFwic2V0XFxcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcXFwidmFsdWVcXFwiICkgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnZhbHVlID0gdmFsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFx0dmFsSG9va3M6IHtcXG5cXHRcXHRvcHRpb246IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcXFwidmFsdWVcXFwiICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbCAhPSBudWxsID9cXG5cXHRcXHRcXHRcXHRcXHR2YWwgOlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XFxuXFx0XFx0XFx0XFx0XFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxcblxcdFxcdFxcdFxcdFxcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2VcXG5cXHRcXHRcXHRcXHRcXHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2VsZWN0OiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxcblxcdFxcdFxcdFxcdFxcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxcblxcdFxcdFxcdFxcdFxcdG9uZSA9IGVsZW0udHlwZSA9PT0gXFxcInNlbGVjdC1vbmVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcXG5cXHRcXHRcXHRcXHRcXHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGluZGV4IDwgMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRpID0gbWF4O1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0aSA9IG9uZSA/IGluZGV4IDogMDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xcblxcdFxcdFxcdFxcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xcblxcdFxcdFxcdFxcdFxcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcblxcdFxcdFxcdFxcdFxcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxcblxcdFxcdFxcdFxcdFxcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQhb3B0aW9uLmRpc2FibGVkICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcXFwib3B0Z3JvdXBcXFwiICkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBvbmUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlcztcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xcblxcdFxcdFxcdFxcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxcblxcdFxcdFxcdFxcdFxcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXFxuXFx0XFx0XFx0XFx0XFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdHdoaWxlICggaS0tICkge1xcblxcdFxcdFxcdFxcdFxcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXFxuXFx0XFx0XFx0XFx0XFx0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b3B0aW9uU2V0ID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxcblxcdFxcdFxcdFxcdGlmICggIW9wdGlvblNldCApIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlcztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG59ICk7XFxuXFxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcXG5qUXVlcnkuZWFjaCggWyBcXFwicmFkaW9cXFwiLCBcXFwiY2hlY2tib3hcXFwiIF0sIGZ1bmN0aW9uKCkge1xcblxcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xcblxcdFxcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XFxuXFx0XFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcXFwidmFsdWVcXFwiICkgPT09IG51bGwgPyBcXFwib25cXFwiIDogZWxlbS52YWx1ZTtcXG5cXHRcXHR9O1xcblxcdH1cXG59ICk7XFxuXFxuXFxuXFxuXFxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxcblxcblxcbnN1cHBvcnQuZm9jdXNpbiA9IFxcXCJvbmZvY3VzaW5cXFwiIGluIHdpbmRvdztcXG5cXG5cXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXFxuXFx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcXG5cXHRcXHRlLnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdH07XFxuXFxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XFxuXFxuXFx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XFxuXFxuXFx0XFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXFxuXFx0XFx0XFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXFxuXFx0XFx0XFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXFxcInR5cGVcXFwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXFxuXFx0XFx0XFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXFxcIm5hbWVzcGFjZVxcXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXFxcIi5cXFwiICkgOiBbXTtcXG5cXG5cXHRcXHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xcblxcblxcdFxcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXFxuXFx0XFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcXG5cXHRcXHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHR5cGUuaW5kZXhPZiggXFxcIi5cXFwiICkgPiAtMSApIHtcXG5cXG5cXHRcXHRcXHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXFxuXFx0XFx0XFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFxcXCIuXFxcIiApO1xcblxcdFxcdFxcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XFxuXFx0XFx0XFx0bmFtZXNwYWNlcy5zb3J0KCk7XFxuXFx0XFx0fVxcblxcdFxcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXFxcIjpcXFwiICkgPCAwICYmIFxcXCJvblxcXCIgKyB0eXBlO1xcblxcblxcdFxcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xcblxcdFxcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xcblxcdFxcdFxcdGV2ZW50IDpcXG5cXHRcXHRcXHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFxcXCJvYmplY3RcXFwiICYmIGV2ZW50ICk7XFxuXFxuXFx0XFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxcblxcdFxcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xcblxcdFxcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXFxcIi5cXFwiICk7XFxuXFx0XFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XFxuXFx0XFx0XFx0bmV3IFJlZ0V4cCggXFxcIihefFxcXFxcXFxcLilcXFwiICsgbmFtZXNwYWNlcy5qb2luKCBcXFwiXFxcXFxcXFwuKD86LipcXFxcXFxcXC58KVxcXCIgKSArIFxcXCIoXFxcXFxcXFwufCQpXFxcIiApIDpcXG5cXHRcXHRcXHRudWxsO1xcblxcblxcdFxcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxcblxcdFxcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcXG5cXHRcXHRpZiAoICFldmVudC50YXJnZXQgKSB7XFxuXFx0XFx0XFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxcblxcdFxcdGRhdGEgPSBkYXRhID09IG51bGwgP1xcblxcdFxcdFxcdFsgZXZlbnQgXSA6XFxuXFx0XFx0XFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XFxuXFxuXFx0XFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xcblxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xcblxcdFxcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXFxuXFx0XFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcXG5cXHRcXHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XFxuXFx0XFx0XFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcXG5cXHRcXHRcXHRcXHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xcblxcdFxcdFxcdFxcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcXG5cXHRcXHRcXHRcXHR0bXAgPSBjdXI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxcblxcdFxcdFxcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xcblxcdFxcdFxcdFxcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcXG5cXHRcXHRpID0gMDtcXG5cXHRcXHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xcblxcdFxcdFxcdGxhc3RFbGVtZW50ID0gY3VyO1xcblxcdFxcdFxcdGV2ZW50LnR5cGUgPSBpID4gMSA/XFxuXFx0XFx0XFx0XFx0YnViYmxlVHlwZSA6XFxuXFx0XFx0XFx0XFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xcblxcblxcdFxcdFxcdC8vIGpRdWVyeSBoYW5kbGVyXFxuXFx0XFx0XFx0aGFuZGxlID0gKFxcblxcdFxcdFxcdFxcdFxcdGRhdGFQcml2LmdldCggY3VyLCBcXFwiZXZlbnRzXFxcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxcblxcdFxcdFxcdFxcdClbIGV2ZW50LnR5cGUgXSAmJlxcblxcdFxcdFxcdFxcdGRhdGFQcml2LmdldCggY3VyLCBcXFwiaGFuZGxlXFxcIiApO1xcblxcdFxcdFxcdGlmICggaGFuZGxlICkge1xcblxcdFxcdFxcdFxcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE5hdGl2ZSBoYW5kbGVyXFxuXFx0XFx0XFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XFxuXFx0XFx0XFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xcblxcdFxcdFxcdFxcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0ZXZlbnQudHlwZSA9IHR5cGU7XFxuXFxuXFx0XFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xcblxcdFxcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XFxuXFx0XFx0XFx0XFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcXG5cXHRcXHRcXHRcXHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cXG5cXHRcXHRcXHRcXHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXFxuXFx0XFx0XFx0XFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxcblxcdFxcdFxcdFxcdFxcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdG1wICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZWxlbVsgdHlwZSBdKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0bXAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBldmVudC5yZXN1bHQ7XFxuXFx0fSxcXG5cXG5cXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcXG5cXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xcblxcdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XFxuXFx0XFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxcblxcdFxcdFxcdG5ldyBqUXVlcnkuRXZlbnQoKSxcXG5cXHRcXHRcXHRldmVudCxcXG5cXHRcXHRcXHR7XFxuXFx0XFx0XFx0XFx0dHlwZTogdHlwZSxcXG5cXHRcXHRcXHRcXHRpc1NpbXVsYXRlZDogdHJ1ZVxcblxcdFxcdFxcdH1cXG5cXHRcXHQpO1xcblxcblxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XFxuXFx0fVxcblxcbn0gKTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFxuXFx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcXG5cXHRcXHR9ICk7XFxuXFx0fSxcXG5cXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XFxuXFx0XFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XFxuXFx0XFx0aWYgKCBlbGVtICkge1xcblxcdFxcdFxcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xcblxcdFxcdH1cXG5cXHR9XFxufSApO1xcblxcblxcbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xcbi8vXFxuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXFxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXFxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcXG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XFxuXFx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFxcXCJmb2N1c2luXFxcIiwgYmx1cjogXFxcImZvY3Vzb3V0XFxcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xcblxcblxcdFxcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XFxuXFx0XFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xcblxcdFxcdFxcdHNldHVwOiBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xcblxcdFxcdFxcdFxcdC8vICh2aWEgYHRoaXMuZG9jdW1lbnRgKSAmIGRvY3VtZW50ICh2aWEgYHRoaXNgKS5cXG5cXHRcXHRcXHRcXHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcXG5cXHRcXHRcXHRcXHRcXHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICFhdHRhY2hlcyApIHtcXG5cXHRcXHRcXHRcXHRcXHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcXG5cXHRcXHRcXHRcXHRcXHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhYXR0YWNoZXMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9ICk7XFxufVxcbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcXG5cXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcXG5cXG52YXIgcnF1ZXJ5ID0gKCAvXFxcXD8vICk7XFxuXFxuXFxuXFxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xcblxcdHZhciB4bWw7XFxuXFx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0fVxcblxcblxcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XFxuXFx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXFxuXFx0dHJ5IHtcXG5cXHRcXHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFxcXCJ0ZXh0L3htbFxcXCIgKTtcXG5cXHR9IGNhdGNoICggZSApIHtcXG5cXHRcXHR4bWwgPSB1bmRlZmluZWQ7XFxuXFx0fVxcblxcblxcdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFxcXCJwYXJzZXJlcnJvclxcXCIgKS5sZW5ndGggKSB7XFxuXFx0XFx0alF1ZXJ5LmVycm9yKCBcXFwiSW52YWxpZCBYTUw6IFxcXCIgKyBkYXRhICk7XFxuXFx0fVxcblxcdHJldHVybiB4bWw7XFxufTtcXG5cXG5cXG52YXJcXG5cXHRyYnJhY2tldCA9IC9cXFxcW1xcXFxdJC8sXFxuXFx0ckNSTEYgPSAvXFxcXHI/XFxcXG4vZyxcXG5cXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXFxuXFx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xcblxcbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcXG5cXHR2YXIgbmFtZTtcXG5cXG5cXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xcblxcblxcdFxcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxcblxcdFxcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xcblxcdFxcdFxcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxcblxcdFxcdFxcdFxcdGFkZCggcHJlZml4LCB2ICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cXG5cXHRcXHRcXHRcXHRidWlsZFBhcmFtcyhcXG5cXHRcXHRcXHRcXHRcXHRwcmVmaXggKyBcXFwiW1xcXCIgKyAoIHR5cGVvZiB2ID09PSBcXFwib2JqZWN0XFxcIiAmJiB2ICE9IG51bGwgPyBpIDogXFxcIlxcXCIgKSArIFxcXCJdXFxcIixcXG5cXHRcXHRcXHRcXHRcXHR2LFxcblxcdFxcdFxcdFxcdFxcdHRyYWRpdGlvbmFsLFxcblxcdFxcdFxcdFxcdFxcdGFkZFxcblxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXG5cXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxcblxcdFxcdGZvciAoIG5hbWUgaW4gb2JqICkge1xcblxcdFxcdFxcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcXFwiW1xcXCIgKyBuYW1lICsgXFxcIl1cXFwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xcblxcdFxcdH1cXG5cXG5cXHR9IGVsc2Uge1xcblxcblxcdFxcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cXG5cXHRcXHRhZGQoIHByZWZpeCwgb2JqICk7XFxuXFx0fVxcbn1cXG5cXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcXG5cXHR2YXIgcHJlZml4LFxcblxcdFxcdHMgPSBbXSxcXG5cXHRcXHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxcblxcdFxcdFxcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cXG5cXHRcXHRcXHRcXHR2YWx1ZU9yRnVuY3Rpb24oKSA6XFxuXFx0XFx0XFx0XFx0dmFsdWVPckZ1bmN0aW9uO1xcblxcblxcdFxcdFxcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXFxcIj1cXFwiICtcXG5cXHRcXHRcXHRcXHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcXFwiXFxcIiA6IHZhbHVlICk7XFxuXFx0XFx0fTtcXG5cXG5cXHRpZiAoIGEgPT0gbnVsbCApIHtcXG5cXHRcXHRyZXR1cm4gXFxcIlxcXCI7XFxuXFx0fVxcblxcblxcdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXFxuXFx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xcblxcblxcdFxcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xcblxcdFxcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xcblxcdFxcdH0gKTtcXG5cXG5cXHR9IGVsc2Uge1xcblxcblxcdFxcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFxcXCJvbGRcXFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxcblxcdFxcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxcblxcdFxcdGZvciAoIHByZWZpeCBpbiBhICkge1xcblxcdFxcdFxcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXFxuXFx0cmV0dXJuIHMuam9pbiggXFxcIiZcXFwiICk7XFxufTtcXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcXG5cXHR9LFxcblxcdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xcblxcblxcdFxcdFxcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFxcXCJlbGVtZW50c1xcXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXFxuXFx0XFx0XFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFxcXCJlbGVtZW50c1xcXCIgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcXG5cXHRcXHR9IClcXG5cXHRcXHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgLmlzKCBcXFwiOmRpc2FibGVkXFxcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFxcXCI6ZGlzYWJsZWRcXFwiICkgJiZcXG5cXHRcXHRcXHRcXHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXFxuXFx0XFx0XFx0XFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xcblxcdFxcdH0gKVxcblxcdFxcdC5tYXAoIGZ1bmN0aW9uKCBfaSwgZWxlbSApIHtcXG5cXHRcXHRcXHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXFxcIlxcXFxyXFxcXG5cXFwiICkgfTtcXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXFxcIlxcXFxyXFxcXG5cXFwiICkgfTtcXG5cXHRcXHR9ICkuZ2V0KCk7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG52YXJcXG5cXHRyMjAgPSAvJTIwL2csXFxuXFx0cmhhc2ggPSAvIy4qJC8sXFxuXFx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcXG5cXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXFxcdF0qKFteXFxcXHJcXFxcbl0qKSQvbWcsXFxuXFxuXFx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXFxuXFx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcXG5cXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcXG5cXHRycHJvdG9jb2wgPSAvXlxcXFwvXFxcXC8vLFxcblxcblxcdC8qIFByZWZpbHRlcnNcXG5cXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxcblxcdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XFxuXFx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxcblxcdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcXG5cXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXFxuXFx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcXFwiKlxcXCIgY2FuIGJlIHVzZWRcXG5cXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFxcXCIqXFxcIiBpZiBuZWVkZWRcXG5cXHQgKi9cXG5cXHRwcmVmaWx0ZXJzID0ge30sXFxuXFxuXFx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xcblxcdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcXG5cXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFxcXCIqXFxcIiBjYW4gYmUgdXNlZFxcblxcdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFxcXCIqXFxcIiBpZiBuZWVkZWRcXG5cXHQgKi9cXG5cXHR0cmFuc3BvcnRzID0ge30sXFxuXFxuXFx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXFxuXFx0YWxsVHlwZXMgPSBcXFwiKi9cXFwiLmNvbmNhdCggXFxcIipcXFwiICksXFxuXFxuXFx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXFxuXFx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXFxcImFcXFwiICk7XFxuXFx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xcblxcbi8vIEJhc2UgXFxcImNvbnN0cnVjdG9yXFxcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XFxuXFxuXFx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcXFwiKlxcXCJcXG5cXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XFxuXFx0XFx0XFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXFxcIipcXFwiO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgZGF0YVR5cGUsXFxuXFx0XFx0XFx0aSA9IDAsXFxuXFx0XFx0XFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcXG5cXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXFxuXFx0XFx0XFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcXFwiK1xcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFxcXCIqXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UgYXBwZW5kXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcbn1cXG5cXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xcblxcblxcdHZhciBpbnNwZWN0ZWQgPSB7fSxcXG5cXHRcXHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcXG5cXG5cXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcXG5cXHRcXHR2YXIgc2VsZWN0ZWQ7XFxuXFx0XFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcXG5cXHRcXHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xcblxcdFxcdFxcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXFxcInN0cmluZ1xcXCIgJiZcXG5cXHRcXHRcXHRcXHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xcblxcdFxcdFxcdFxcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHRcXHRyZXR1cm4gc2VsZWN0ZWQ7XFxuXFx0fVxcblxcblxcdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXFxcIipcXFwiIF0gJiYgaW5zcGVjdCggXFxcIipcXFwiICk7XFxufVxcblxcbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xcbi8vIHRoYXQgdGFrZXMgXFxcImZsYXRcXFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxcbi8vIEZpeGVzICM5ODg3XFxuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XFxuXFx0dmFyIGtleSwgZGVlcCxcXG5cXHRcXHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XFxuXFxuXFx0Zm9yICgga2V5IGluIHNyYyApIHtcXG5cXHRcXHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0aWYgKCBkZWVwICkge1xcblxcdFxcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gdGFyZ2V0O1xcbn1cXG5cXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XFxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcXG4gKi9cXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xcblxcblxcdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcXG5cXHRcXHRjb250ZW50cyA9IHMuY29udGVudHMsXFxuXFx0XFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XFxuXFxuXFx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3NcXG5cXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcXFwiKlxcXCIgKSB7XFxuXFx0XFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XFxuXFx0XFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXFxcIkNvbnRlbnQtVHlwZVxcXCIgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxcblxcdGlmICggY3QgKSB7XFxuXFx0XFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcXG5cXHRcXHRcXHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xcblxcdFxcdFxcdFxcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXFxuXFx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XFxuXFx0XFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xcblxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xcblxcdFxcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xcblxcdFxcdFxcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFxcXCIgXFxcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XFxuXFx0XFx0XFx0XFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcXG5cXHRcXHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xcblxcdH1cXG5cXG5cXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXFxuXFx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcXG5cXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXFxuXFx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xcblxcdFxcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XFxuXFx0XFx0XFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xcblxcdH1cXG59XFxuXFxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxcbiAqL1xcbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcXG5cXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcXG5cXHRcXHRjb252ZXJ0ZXJzID0ge30sXFxuXFxuXFx0XFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxcblxcdFxcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XFxuXFxuXFx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXFxuXFx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcXG5cXHRcXHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcXG5cXHRcXHRcXHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xcblxcblxcdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXFxuXFx0d2hpbGUgKCBjdXJyZW50ICkge1xcblxcblxcdFxcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xcblxcdFxcdFxcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxcblxcdFxcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcXG5cXHRcXHRcXHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cHJldiA9IGN1cnJlbnQ7XFxuXFx0XFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xcblxcblxcdFxcdGlmICggY3VycmVudCApIHtcXG5cXG5cXHRcXHRcXHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXFxuXFx0XFx0XFx0aWYgKCBjdXJyZW50ID09PSBcXFwiKlxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y3VycmVudCA9IHByZXY7XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHByZXYgIT09IFxcXCIqXFxcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXFxuXFx0XFx0XFx0XFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcXFwiIFxcXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXFxcIiogXFxcIiArIGN1cnJlbnQgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxcblxcdFxcdFxcdFxcdGlmICggIWNvbnYgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSBjb252Mi5zcGxpdCggXFxcIiBcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFxcXCIgXFxcIiArIHRtcFsgMCBdIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb252ZXJ0ZXJzWyBcXFwiKiBcXFwiICsgdG1wWyAwIF0gXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNvbnYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50ID0gdG1wWyAwIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcXG5cXHRcXHRcXHRcXHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxcblxcdFxcdFxcdFxcdFxcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGNhdGNoICggZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlOiBcXFwicGFyc2VyZXJyb3JcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGVycm9yOiBjb252ID8gZSA6IFxcXCJObyBjb252ZXJzaW9uIGZyb20gXFxcIiArIHByZXYgKyBcXFwiIHRvIFxcXCIgKyBjdXJyZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4geyBzdGF0ZTogXFxcInN1Y2Nlc3NcXFwiLCBkYXRhOiByZXNwb25zZSB9O1xcbn1cXG5cXG5qUXVlcnkuZXh0ZW5kKCB7XFxuXFxuXFx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXFxuXFx0YWN0aXZlOiAwLFxcblxcblxcdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3RcXG5cXHRsYXN0TW9kaWZpZWQ6IHt9LFxcblxcdGV0YWc6IHt9LFxcblxcblxcdGFqYXhTZXR0aW5nczoge1xcblxcdFxcdHVybDogbG9jYXRpb24uaHJlZixcXG5cXHRcXHR0eXBlOiBcXFwiR0VUXFxcIixcXG5cXHRcXHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxcblxcdFxcdGdsb2JhbDogdHJ1ZSxcXG5cXHRcXHRwcm9jZXNzRGF0YTogdHJ1ZSxcXG5cXHRcXHRhc3luYzogdHJ1ZSxcXG5cXHRcXHRjb250ZW50VHlwZTogXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFxcXCIsXFxuXFxuXFx0XFx0LypcXG5cXHRcXHR0aW1lb3V0OiAwLFxcblxcdFxcdGRhdGE6IG51bGwsXFxuXFx0XFx0ZGF0YVR5cGU6IG51bGwsXFxuXFx0XFx0dXNlcm5hbWU6IG51bGwsXFxuXFx0XFx0cGFzc3dvcmQ6IG51bGwsXFxuXFx0XFx0Y2FjaGU6IG51bGwsXFxuXFx0XFx0dGhyb3dzOiBmYWxzZSxcXG5cXHRcXHR0cmFkaXRpb25hbDogZmFsc2UsXFxuXFx0XFx0aGVhZGVyczoge30sXFxuXFx0XFx0Ki9cXG5cXG5cXHRcXHRhY2NlcHRzOiB7XFxuXFx0XFx0XFx0XFxcIipcXFwiOiBhbGxUeXBlcyxcXG5cXHRcXHRcXHR0ZXh0OiBcXFwidGV4dC9wbGFpblxcXCIsXFxuXFx0XFx0XFx0aHRtbDogXFxcInRleHQvaHRtbFxcXCIsXFxuXFx0XFx0XFx0eG1sOiBcXFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFxcXCIsXFxuXFx0XFx0XFx0anNvbjogXFxcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFxcXCJcXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbnRlbnRzOiB7XFxuXFx0XFx0XFx0eG1sOiAvXFxcXGJ4bWxcXFxcYi8sXFxuXFx0XFx0XFx0aHRtbDogL1xcXFxiaHRtbC8sXFxuXFx0XFx0XFx0anNvbjogL1xcXFxianNvblxcXFxiL1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVzcG9uc2VGaWVsZHM6IHtcXG5cXHRcXHRcXHR4bWw6IFxcXCJyZXNwb25zZVhNTFxcXCIsXFxuXFx0XFx0XFx0dGV4dDogXFxcInJlc3BvbnNlVGV4dFxcXCIsXFxuXFx0XFx0XFx0anNvbjogXFxcInJlc3BvbnNlSlNPTlxcXCJcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIERhdGEgY29udmVydGVyc1xcblxcdFxcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcXFwiKlxcXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXFxuXFx0XFx0Y29udmVydGVyczoge1xcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxcblxcdFxcdFxcdFxcXCIqIHRleHRcXFwiOiBTdHJpbmcsXFxuXFxuXFx0XFx0XFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXFxuXFx0XFx0XFx0XFxcInRleHQgaHRtbFxcXCI6IHRydWUsXFxuXFxuXFx0XFx0XFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxcblxcdFxcdFxcdFxcXCJ0ZXh0IGpzb25cXFwiOiBKU09OLnBhcnNlLFxcblxcblxcdFxcdFxcdC8vIFBhcnNlIHRleHQgYXMgeG1sXFxuXFx0XFx0XFx0XFxcInRleHQgeG1sXFxcIjogalF1ZXJ5LnBhcnNlWE1MXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxcblxcdFxcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcXG5cXHRcXHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxcblxcdFxcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxcblxcdFxcdGZsYXRPcHRpb25zOiB7XFxuXFx0XFx0XFx0dXJsOiB0cnVlLFxcblxcdFxcdFxcdGNvbnRleHQ6IHRydWVcXG5cXHRcXHR9XFxuXFx0fSxcXG5cXG5cXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxcblxcdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cXG5cXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxcblxcdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XFxuXFx0XFx0cmV0dXJuIHNldHRpbmdzID9cXG5cXG5cXHRcXHRcXHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxcblxcdFxcdFxcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcXG5cXG5cXHRcXHRcXHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXFxuXFx0XFx0XFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XFxuXFx0fSxcXG5cXG5cXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcXG5cXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcXG5cXG5cXHQvLyBNYWluIG1ldGhvZFxcblxcdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XFxuXFxuXFx0XFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcXG5cXHRcXHRpZiAoIHR5cGVvZiB1cmwgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcdFxcdFxcdG9wdGlvbnMgPSB1cmw7XFxuXFx0XFx0XFx0dXJsID0gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxcblxcdFxcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcblxcdFxcdHZhciB0cmFuc3BvcnQsXFxuXFxuXFx0XFx0XFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxcblxcdFxcdFxcdGNhY2hlVVJMLFxcblxcblxcdFxcdFxcdC8vIFJlc3BvbnNlIGhlYWRlcnNcXG5cXHRcXHRcXHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXFxuXFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzLFxcblxcblxcdFxcdFxcdC8vIHRpbWVvdXQgaGFuZGxlXFxuXFx0XFx0XFx0dGltZW91dFRpbWVyLFxcblxcblxcdFxcdFxcdC8vIFVybCBjbGVhbnVwIHZhclxcblxcdFxcdFxcdHVybEFuY2hvcixcXG5cXG5cXHRcXHRcXHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXFxuXFx0XFx0XFx0Y29tcGxldGVkLFxcblxcblxcdFxcdFxcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxcblxcdFxcdFxcdGZpcmVHbG9iYWxzLFxcblxcblxcdFxcdFxcdC8vIExvb3AgdmFyaWFibGVcXG5cXHRcXHRcXHRpLFxcblxcblxcdFxcdFxcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxcblxcdFxcdFxcdHVuY2FjaGVkLFxcblxcblxcdFxcdFxcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3RcXG5cXHRcXHRcXHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcXG5cXG5cXHRcXHRcXHQvLyBDYWxsYmFja3MgY29udGV4dFxcblxcdFxcdFxcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxcblxcblxcdFxcdFxcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cXG5cXHRcXHRcXHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcXG5cXHRcXHRcXHRcXHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudCxcXG5cXG5cXHRcXHRcXHQvLyBEZWZlcnJlZHNcXG5cXHRcXHRcXHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxcblxcdFxcdFxcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcXFwib25jZSBtZW1vcnlcXFwiICksXFxuXFxuXFx0XFx0XFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcXG5cXHRcXHRcXHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxcblxcblxcdFxcdFxcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXFxuXFx0XFx0XFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcXG5cXHRcXHRcXHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXFxuXFxuXFx0XFx0XFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXFxuXFx0XFx0XFx0c3RyQWJvcnQgPSBcXFwiY2FuY2VsZWRcXFwiLFxcblxcblxcdFxcdFxcdC8vIEZha2UgeGhyXFxuXFx0XFx0XFx0anFYSFIgPSB7XFxuXFx0XFx0XFx0XFx0cmVhZHlTdGF0ZTogMCxcXG5cXG5cXHRcXHRcXHRcXHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXFxuXFx0XFx0XFx0XFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1hdGNoO1xcblxcdFxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXFxcIiBcXFwiIF0gPVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCggcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcXFwiIFxcXCIgXSB8fCBbXSApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0LmNvbmNhdCggbWF0Y2hbIDIgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXFxcIiBcXFwiIF07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFxcXCIsIFxcXCIgKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIFJhdyBzdHJpbmdcXG5cXHRcXHRcXHRcXHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcXG5cXHRcXHRcXHRcXHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXFxuXFx0XFx0XFx0XFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLm1pbWVUeXBlID0gdHlwZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xcblxcdFxcdFxcdFxcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNvZGU7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtYXAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjb21wbGV0ZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGNvZGUgaW4gbWFwICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XFxuXFx0XFx0XFx0XFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xcblxcdFxcdFxcdFxcdFxcdGlmICggdHJhbnNwb3J0ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdC8vIEF0dGFjaCBkZWZlcnJlZHNcXG5cXHRcXHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xcblxcblxcdFxcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxcblxcdFxcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXFxuXFx0XFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXFxuXFx0XFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFxcXCJcXFwiIClcXG5cXHRcXHRcXHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFxcXCIvL1xcXCIgKTtcXG5cXG5cXHRcXHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcXG5cXHRcXHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xcblxcblxcdFxcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3RcXG5cXHRcXHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcXFwiKlxcXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcXFwiXFxcIiBdO1xcblxcblxcdFxcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxcblxcdFxcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xcblxcdFxcdFxcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFxcXCJhXFxcIiApO1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcXG5cXHRcXHRcXHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxcblxcdFxcdFxcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cXG5cXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxcblxcdFxcdFxcdFxcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXFxuXFx0XFx0XFx0XFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcXG5cXHRcXHRcXHRcXHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXFxcIi8vXFxcIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxcblxcdFxcdFxcdFxcdFxcdHVybEFuY2hvci5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyB1cmxBbmNob3IuaG9zdDtcXG5cXHRcXHRcXHR9IGNhdGNoICggZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcXG5cXHRcXHRcXHRcXHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXFxuXFx0XFx0XFx0XFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcXG5cXHRcXHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFwcGx5IHByZWZpbHRlcnNcXG5cXHRcXHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcXG5cXG5cXHRcXHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxcblxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdHJldHVybiBqcVhIUjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cXG5cXHRcXHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxcblxcdFxcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xcblxcblxcdFxcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcXG5cXHRcXHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcXG5cXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXFxcImFqYXhTdGFydFxcXCIgKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXFxuXFx0XFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XFxuXFxuXFx0XFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcXG5cXHRcXHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcXG5cXG5cXHRcXHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2VcXG5cXHRcXHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cXG5cXHRcXHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXFxuXFx0XFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXFxcIlxcXCIgKTtcXG5cXG5cXHRcXHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxcblxcdFxcdGlmICggIXMuaGFzQ29udGVudCApIHtcXG5cXG5cXHRcXHRcXHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcXG5cXHRcXHRcXHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXFxuXFx0XFx0XFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFxcXCJzdHJpbmdcXFwiICkgKSB7XFxuXFx0XFx0XFx0XFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIiApICsgcy5kYXRhO1xcblxcblxcdFxcdFxcdFxcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcXG5cXHRcXHRcXHRcXHRkZWxldGUgcy5kYXRhO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXFxuXFx0XFx0XFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcXG5cXHRcXHRcXHRcXHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFxcXCIkMVxcXCIgKTtcXG5cXHRcXHRcXHRcXHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcXFwiJlxcXCIgOiBcXFwiP1xcXCIgKSArIFxcXCJfPVxcXCIgKyAoIG5vbmNlLmd1aWQrKyApICtcXG5cXHRcXHRcXHRcXHRcXHR1bmNhY2hlZDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxcblxcdFxcdFxcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcXG5cXG5cXHRcXHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcXG5cXHRcXHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxcblxcdFxcdFxcdCggcy5jb250ZW50VHlwZSB8fCBcXFwiXFxcIiApLmluZGV4T2YoIFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiICkgPT09IDAgKSB7XFxuXFx0XFx0XFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXFxcIitcXFwiICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXFxuXFx0XFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xcblxcdFxcdFxcdFxcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFxcXCJJZi1Nb2RpZmllZC1TaW5jZVxcXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcXG5cXHRcXHRcXHRcXHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcXFwiSWYtTm9uZS1NYXRjaFxcXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcXG5cXHRcXHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcXG5cXHRcXHRcXHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcXFwiQ29udGVudC1UeXBlXFxcIiwgcy5jb250ZW50VHlwZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXFxuXFx0XFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcXG5cXHRcXHRcXHRcXFwiQWNjZXB0XFxcIixcXG5cXHRcXHRcXHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cXG5cXHRcXHRcXHRcXHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXFxuXFx0XFx0XFx0XFx0XFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcXFwiKlxcXCIgPyBcXFwiLCBcXFwiICsgYWxsVHlwZXMgKyBcXFwiOyBxPTAuMDFcXFwiIDogXFxcIlxcXCIgKSA6XFxuXFx0XFx0XFx0XFx0cy5hY2NlcHRzWyBcXFwiKlxcXCIgXVxcblxcdFxcdCk7XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXFxuXFx0XFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XFxuXFx0XFx0XFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxcblxcdFxcdGlmICggcy5iZWZvcmVTZW5kICYmXFxuXFx0XFx0XFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcXG5cXG5cXHRcXHRcXHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cXG5cXHRcXHRcXHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXFxuXFx0XFx0c3RyQWJvcnQgPSBcXFwiYWJvcnRcXFwiO1xcblxcblxcdFxcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xcblxcdFxcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XFxuXFx0XFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XFxuXFx0XFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xcblxcblxcdFxcdC8vIEdldCB0cmFuc3BvcnRcXG5cXHRcXHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcXG5cXG5cXHRcXHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcXG5cXHRcXHRpZiAoICF0cmFuc3BvcnQgKSB7XFxuXFx0XFx0XFx0ZG9uZSggLTEsIFxcXCJObyBUcmFuc3BvcnRcXFwiICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcXG5cXG5cXHRcXHRcXHQvLyBTZW5kIGdsb2JhbCBldmVudFxcblxcdFxcdFxcdGlmICggZmlyZUdsb2JhbHMgKSB7XFxuXFx0XFx0XFx0XFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFxcXCJhamF4U2VuZFxcXCIsIFsganFYSFIsIHMgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxcblxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBqcVhIUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVGltZW91dFxcblxcdFxcdFxcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xcblxcdFxcdFxcdFxcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRqcVhIUi5hYm9ydCggXFxcInRpbWVvdXRcXFwiICk7XFxuXFx0XFx0XFx0XFx0fSwgcy50aW1lb3V0ICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0Y29tcGxldGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XFxuXFx0XFx0XFx0fSBjYXRjaCAoIGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xcblxcdFxcdFxcdFxcdGlmICggY29tcGxldGVkICkge1xcblxcdFxcdFxcdFxcdFxcdHRocm93IGU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xcblxcdFxcdFxcdFxcdGRvbmUoIC0xLCBlICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcXG5cXHRcXHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcXG5cXHRcXHRcXHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxcblxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xcblxcblxcdFxcdFxcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcXG5cXHRcXHRcXHRpZiAoIGNvbXBsZXRlZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGNvbXBsZXRlZCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcXG5cXHRcXHRcXHRpZiAoIHRpbWVvdXRUaW1lciApIHtcXG5cXHRcXHRcXHRcXHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cXG5cXHRcXHRcXHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxcblxcdFxcdFxcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXFxuXFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHQvLyBTZXQgcmVhZHlTdGF0ZVxcblxcdFxcdFxcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XFxuXFxuXFx0XFx0XFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcXG5cXHRcXHRcXHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcXG5cXG5cXHRcXHRcXHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxcblxcdFxcdFxcdGlmICggcmVzcG9uc2VzICkge1xcblxcdFxcdFxcdFxcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHRcXG5cXHRcXHRcXHRpZiAoICFpc1N1Y2Nlc3MgJiYgalF1ZXJ5LmluQXJyYXkoIFxcXCJzY3JpcHRcXFwiLCBzLmRhdGFUeXBlcyApID4gLTEgKSB7XFxuXFx0XFx0XFx0XFx0cy5jb252ZXJ0ZXJzWyBcXFwidGV4dCBzY3JpcHRcXFwiIF0gPSBmdW5jdGlvbigpIHt9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXFxuXFx0XFx0XFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xcblxcdFxcdFxcdGlmICggaXNTdWNjZXNzICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXFxuXFx0XFx0XFx0XFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXFxcIkxhc3QtTW9kaWZpZWRcXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtb2RpZmllZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFxcXCJldGFnXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggbW9kaWZpZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGlmIG5vIGNvbnRlbnRcXG5cXHRcXHRcXHRcXHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXFxcIkhFQURcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBcXFwibm9jb250ZW50XFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpZiBub3QgbW9kaWZpZWRcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0dXNUZXh0ID0gXFxcIm5vdG1vZGlmaWVkXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcXG5cXHRcXHRcXHRcXHRcXHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xcblxcdFxcdFxcdFxcdFxcdGlzU3VjY2VzcyA9ICFlcnJvcjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXFxuXFx0XFx0XFx0XFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xcblxcdFxcdFxcdFxcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xcblxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBcXFwiZXJyb3JcXFwiO1xcblxcdFxcdFxcdFxcdFxcdGlmICggc3RhdHVzIDwgMCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGF0dXMgPSAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XFxuXFx0XFx0XFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xcblxcdFxcdFxcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gU3VjY2Vzcy9FcnJvclxcblxcdFxcdFxcdGlmICggaXNTdWNjZXNzICkge1xcblxcdFxcdFxcdFxcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXFxuXFx0XFx0XFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xcblxcdFxcdFxcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBmaXJlR2xvYmFscyApIHtcXG5cXHRcXHRcXHRcXHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXFxcImFqYXhTdWNjZXNzXFxcIiA6IFxcXCJhamF4RXJyb3JcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbXBsZXRlXFxuXFx0XFx0XFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGZpcmVHbG9iYWxzICkge1xcblxcdFxcdFxcdFxcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcXFwiYWpheENvbXBsZXRlXFxcIiwgWyBqcVhIUiwgcyBdICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXFxuXFx0XFx0XFx0XFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXFxcImFqYXhTdG9wXFxcIiApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBqcVhIUjtcXG5cXHR9LFxcblxcblxcdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcXFwianNvblxcXCIgKTtcXG5cXHR9LFxcblxcblxcdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXFxcInNjcmlwdFxcXCIgKTtcXG5cXHR9XFxufSApO1xcblxcbmpRdWVyeS5lYWNoKCBbIFxcXCJnZXRcXFwiLCBcXFwicG9zdFxcXCIgXSwgZnVuY3Rpb24oIF9pLCBtZXRob2QgKSB7XFxuXFx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xcblxcblxcdFxcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXFxuXFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XFxuXFx0XFx0XFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XFxuXFx0XFx0XFx0Y2FsbGJhY2sgPSBkYXRhO1xcblxcdFxcdFxcdGRhdGEgPSB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxcblxcdFxcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xcblxcdFxcdFxcdHVybDogdXJsLFxcblxcdFxcdFxcdHR5cGU6IG1ldGhvZCxcXG5cXHRcXHRcXHRkYXRhVHlwZTogdHlwZSxcXG5cXHRcXHRcXHRkYXRhOiBkYXRhLFxcblxcdFxcdFxcdHN1Y2Nlc3M6IGNhbGxiYWNrXFxuXFx0XFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XFxuXFx0fTtcXG59ICk7XFxuXFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xcblxcdHZhciBpO1xcblxcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xcblxcdFxcdGlmICggaS50b0xvd2VyQ2FzZSgpID09PSBcXFwiY29udGVudC10eXBlXFxcIiApIHtcXG5cXHRcXHRcXHRzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzWyBpIF0gfHwgXFxcIlxcXCI7XFxuXFx0XFx0fVxcblxcdH1cXG59ICk7XFxuXFxuXFxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucywgZG9jICkge1xcblxcdHJldHVybiBqUXVlcnkuYWpheCgge1xcblxcdFxcdHVybDogdXJsLFxcblxcblxcdFxcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxcblxcdFxcdHR5cGU6IFxcXCJHRVRcXFwiLFxcblxcdFxcdGRhdGFUeXBlOiBcXFwic2NyaXB0XFxcIixcXG5cXHRcXHRjYWNoZTogdHJ1ZSxcXG5cXHRcXHRhc3luYzogZmFsc2UsXFxuXFx0XFx0Z2xvYmFsOiBmYWxzZSxcXG5cXG5cXHRcXHQvLyBPbmx5IGV2YWx1YXRlIHRoZSByZXNwb25zZSBpZiBpdCBpcyBzdWNjZXNzZnVsIChnaC00MTI2KVxcblxcdFxcdC8vIGRhdGFGaWx0ZXIgaXMgbm90IGludm9rZWQgZm9yIGZhaWx1cmUgcmVzcG9uc2VzLCBzbyB1c2luZyBpdCBpbnN0ZWFkXFxuXFx0XFx0Ly8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXFxuXFx0XFx0Y29udmVydGVyczoge1xcblxcdFxcdFxcdFxcXCJ0ZXh0IHNjcmlwdFxcXCI6IGZ1bmN0aW9uKCkge31cXG5cXHRcXHR9LFxcblxcdFxcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcXG5cXHRcXHRcXHRqUXVlcnkuZ2xvYmFsRXZhbCggcmVzcG9uc2UsIG9wdGlvbnMsIGRvYyApO1xcblxcdFxcdH1cXG5cXHR9ICk7XFxufTtcXG5cXG5cXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XFxuXFx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XFxuXFx0XFx0dmFyIHdyYXA7XFxuXFxuXFx0XFx0aWYgKCB0aGlzWyAwIF0gKSB7XFxuXFx0XFx0XFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XFxuXFx0XFx0XFx0XFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXFxuXFx0XFx0XFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcXG5cXHRcXHRcXHRcXHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWxlbSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xcblxcdFxcdFxcdFxcdFxcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbTtcXG5cXHRcXHRcXHR9ICkuYXBwZW5kKCB0aGlzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH0sXFxuXFxuXFx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcXG5cXHRcXHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XFxuXFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxcblxcdFxcdFxcdFxcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xcblxcblxcdFxcdFxcdGlmICggY29udGVudHMubGVuZ3RoICkge1xcblxcdFxcdFxcdFxcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHNlbGYuYXBwZW5kKCBodG1sICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xcblxcdFxcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcXG5cXHRcXHRcXHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xcblxcdFxcdH0gKTtcXG5cXHR9LFxcblxcblxcdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xcblxcdFxcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXFxcImJvZHlcXFwiICkuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xcblxcdFxcdH0gKTtcXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9XFxufSApO1xcblxcblxcbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XFxuXFx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcXG59O1xcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xcblxcdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XFxufTtcXG5cXG5cXG5cXG5cXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xcblxcdHRyeSB7XFxuXFx0XFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcXG5cXHR9IGNhdGNoICggZSApIHt9XFxufTtcXG5cXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcXG5cXG5cXHRcXHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxcblxcdFxcdDA6IDIwMCxcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxcblxcdFxcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxcblxcdFxcdDEyMjM6IDIwNFxcblxcdH0sXFxuXFx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcXG5cXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFxcXCJ3aXRoQ3JlZGVudGlhbHNcXFwiIGluIHhoclN1cHBvcnRlZCApO1xcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xcblxcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcXG5cXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XFxuXFxuXFx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxcblxcdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHRcXHRcXHR4aHIgPSBvcHRpb25zLnhocigpO1xcblxcblxcdFxcdFxcdFxcdHhoci5vcGVuKFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMudHlwZSxcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLnVybCxcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLmFzeW5jLFxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMudXNlcm5hbWUsXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5wYXNzd29yZFxcblxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxcblxcdFxcdFxcdFxcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXFxuXFx0XFx0XFx0XFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xcblxcdFxcdFxcdFxcdFxcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXFxuXFx0XFx0XFx0XFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxcblxcdFxcdFxcdFxcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXFxuXFx0XFx0XFx0XFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXFxuXFx0XFx0XFx0XFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXFxuXFx0XFx0XFx0XFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGVhZGVyc1sgXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiIF0gPSBcXFwiWE1MSHR0cFJlcXVlc3RcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTZXQgaGVhZGVyc1xcblxcdFxcdFxcdFxcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcXG5cXHRcXHRcXHRcXHRcXHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENhbGxiYWNrXFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0eXBlID09PSBcXFwiYWJvcnRcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5hYm9ydCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFxcXCJlcnJvclxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3NcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXFxcIm51bWJlclxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGxldGUoIDAsIFxcXCJlcnJvclxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLnN0YXR1cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4aHIuc3RhdHVzVGV4dFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGxldGUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLnN0YXR1c1RleHQsXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXFxcInRleHRcXFwiICkgIT09IFxcXCJ0ZXh0XFxcIiAgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXFxcInN0cmluZ1xcXCIgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBMaXN0ZW4gdG8gZXZlbnRzXFxuXFx0XFx0XFx0XFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XFxuXFx0XFx0XFx0XFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcXFwiZXJyb3JcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XFxuXFx0XFx0XFx0XFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcXG5cXHRcXHRcXHRcXHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXFxuXFx0XFx0XFx0XFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXJyb3JDYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcXG5cXHRcXHRcXHRcXHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcXFwiYWJvcnRcXFwiICk7XFxuXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXFxuXFx0XFx0XFx0XFx0XFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aHJvdyBlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRhYm9ydDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xcblxcdGlmICggcy5jcm9zc0RvbWFpbiApIHtcXG5cXHRcXHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xcblxcdH1cXG59ICk7XFxuXFxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcXG5qUXVlcnkuYWpheFNldHVwKCB7XFxuXFx0YWNjZXB0czoge1xcblxcdFxcdHNjcmlwdDogXFxcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXFxcIiArXFxuXFx0XFx0XFx0XFxcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFxcXCJcXG5cXHR9LFxcblxcdGNvbnRlbnRzOiB7XFxuXFx0XFx0c2NyaXB0OiAvXFxcXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxcXGIvXFxuXFx0fSxcXG5cXHRjb252ZXJ0ZXJzOiB7XFxuXFx0XFx0XFxcInRleHQgc2NyaXB0XFxcIjogZnVuY3Rpb24oIHRleHQgKSB7XFxuXFx0XFx0XFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dDtcXG5cXHRcXHR9XFxuXFx0fVxcbn0gKTtcXG5cXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFxcXCJzY3JpcHRcXFwiLCBmdW5jdGlvbiggcyApIHtcXG5cXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRzLmNhY2hlID0gZmFsc2U7XFxuXFx0fVxcblxcdGlmICggcy5jcm9zc0RvbWFpbiApIHtcXG5cXHRcXHRzLnR5cGUgPSBcXFwiR0VUXFxcIjtcXG5cXHR9XFxufSApO1xcblxcbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24oIHMgKSB7XFxuXFxuXFx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcXG5cXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcXG5cXHRcXHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcXG5cXHRcXHRcXHRcXHRzY3JpcHQgPSBqUXVlcnkoIFxcXCI8c2NyaXB0PlxcXCIgKVxcblxcdFxcdFxcdFxcdFxcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcXG5cXHRcXHRcXHRcXHRcXHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXFxuXFx0XFx0XFx0XFx0XFx0Lm9uKCBcXFwibG9hZCBlcnJvclxcXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY3JpcHQucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZXZ0ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXFxcImVycm9yXFxcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdFxcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxcblxcdFxcdFxcdFxcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRhYm9ydDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjayApIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9XFxufSApO1xcblxcblxcblxcblxcbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcXG5cXHRyanNvbnAgPSAvKD0pXFxcXD8oPz0mfCQpfFxcXFw/XFxcXD8vO1xcblxcbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcXG5qUXVlcnkuYWpheFNldHVwKCB7XFxuXFx0anNvbnA6IFxcXCJjYWxsYmFja1xcXCIsXFxuXFx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XFxuXFx0XFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcXFwiX1xcXCIgKyAoIG5vbmNlLmd1aWQrKyApICk7XFxuXFx0XFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XFxuXFx0XFx0cmV0dXJuIGNhbGxiYWNrO1xcblxcdH1cXG59ICk7XFxuXFxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXFxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFxcXCJqc29uIGpzb25wXFxcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xcblxcblxcdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcXG5cXHRcXHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xcblxcdFxcdFxcdFxcXCJ1cmxcXFwiIDpcXG5cXHRcXHRcXHR0eXBlb2Ygcy5kYXRhID09PSBcXFwic3RyaW5nXFxcIiAmJlxcblxcdFxcdFxcdFxcdCggcy5jb250ZW50VHlwZSB8fCBcXFwiXFxcIiApXFxuXFx0XFx0XFx0XFx0XFx0LmluZGV4T2YoIFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiICkgPT09IDAgJiZcXG5cXHRcXHRcXHRcXHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXFxcImRhdGFcXFwiXFxuXFx0XFx0KTtcXG5cXG5cXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXFxcImpzb25wXFxcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxcblxcdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXFxcImpzb25wXFxcIiApIHtcXG5cXG5cXHRcXHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XFxuXFx0XFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xcblxcdFxcdFxcdHMuanNvbnBDYWxsYmFjaygpIDpcXG5cXHRcXHRcXHRzLmpzb25wQ2FsbGJhY2s7XFxuXFxuXFx0XFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxcblxcdFxcdGlmICgganNvblByb3AgKSB7XFxuXFx0XFx0XFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcXFwiJDFcXFwiICsgY2FsbGJhY2tOYW1lICk7XFxuXFx0XFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XFxuXFx0XFx0XFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIiApICsgcy5qc29ucCArIFxcXCI9XFxcIiArIGNhbGxiYWNrTmFtZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxcblxcdFxcdHMuY29udmVydGVyc1sgXFxcInNjcmlwdCBqc29uXFxcIiBdID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcXFwiIHdhcyBub3QgY2FsbGVkXFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcXG5cXHRcXHRzLmRhdGFUeXBlc1sgMCBdID0gXFxcImpzb25cXFwiO1xcblxcblxcdFxcdC8vIEluc3RhbGwgY2FsbGJhY2tcXG5cXHRcXHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XFxuXFx0XFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXFxuXFx0XFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcXG5cXG5cXHRcXHRcXHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcXG5cXHRcXHRcXHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcXG5cXG5cXHRcXHRcXHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxcblxcdFxcdFxcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXFxuXFx0XFx0XFx0XFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xcblxcblxcdFxcdFxcdFxcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2VcXG5cXHRcXHRcXHRcXHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxcblxcdFxcdFxcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcXG5cXHRcXHRcXHRcXHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xcblxcdFxcdH0gKTtcXG5cXG5cXHRcXHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcXG5cXHRcXHRyZXR1cm4gXFxcInNjcmlwdFxcXCI7XFxuXFx0fVxcbn0gKTtcXG5cXG5cXG5cXG5cXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XFxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxcbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XFxuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xcblxcdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcXFwiXFxcIiApLmJvZHk7XFxuXFx0Ym9keS5pbm5lckhUTUwgPSBcXFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cXFwiO1xcblxcdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xcbn0gKSgpO1xcblxcblxcbi8vIEFyZ3VtZW50IFxcXCJkYXRhXFxcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcXG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXFxualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcXG5cXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHRyZXR1cm4gW107XFxuXFx0fVxcblxcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFxcXCJib29sZWFuXFxcIiApIHtcXG5cXHRcXHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XFxuXFx0XFx0Y29udGV4dCA9IGZhbHNlO1xcblxcdH1cXG5cXG5cXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xcblxcblxcdGlmICggIWNvbnRleHQgKSB7XFxuXFxuXFx0XFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XFxuXFx0XFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cXG5cXHRcXHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xcblxcdFxcdFxcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFxcXCJcXFwiICk7XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XFxuXFx0XFx0XFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcXG5cXHRcXHRcXHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxcblxcdFxcdFxcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFxcXCJiYXNlXFxcIiApO1xcblxcdFxcdFxcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XFxuXFx0XFx0XFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjb250ZXh0ID0gZG9jdW1lbnQ7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcXG5cXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xcblxcblxcdC8vIFNpbmdsZSB0YWdcXG5cXHRpZiAoIHBhcnNlZCApIHtcXG5cXHRcXHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcXG5cXHR9XFxuXFxuXFx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcXG5cXG5cXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XFxuXFx0XFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XFxuXFx0fVxcblxcblxcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xcbn07XFxuXFxuXFxuLyoqXFxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxcbiAqL1xcbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcXG5cXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxcblxcdFxcdHNlbGYgPSB0aGlzLFxcblxcdFxcdG9mZiA9IHVybC5pbmRleE9mKCBcXFwiIFxcXCIgKTtcXG5cXG5cXHRpZiAoIG9mZiA+IC0xICkge1xcblxcdFxcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xcblxcdFxcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XFxuXFx0fVxcblxcblxcdC8vIElmIGl0J3MgYSBmdW5jdGlvblxcblxcdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XFxuXFxuXFx0XFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcXG5cXHRcXHRjYWxsYmFjayA9IHBhcmFtcztcXG5cXHRcXHRwYXJhbXMgPSB1bmRlZmluZWQ7XFxuXFxuXFx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xcblxcdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXHRcXHR0eXBlID0gXFxcIlBPU1RcXFwiO1xcblxcdH1cXG5cXG5cXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxcblxcdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xcblxcdFxcdGpRdWVyeS5hamF4KCB7XFxuXFx0XFx0XFx0dXJsOiB1cmwsXFxuXFxuXFx0XFx0XFx0Ly8gSWYgXFxcInR5cGVcXFwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcXFwiR0VUXFxcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxcblxcdFxcdFxcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxcblxcdFxcdFxcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxcblxcdFxcdFxcdHR5cGU6IHR5cGUgfHwgXFxcIkdFVFxcXCIsXFxuXFx0XFx0XFx0ZGF0YVR5cGU6IFxcXCJodG1sXFxcIixcXG5cXHRcXHRcXHRkYXRhOiBwYXJhbXNcXG5cXHRcXHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcXG5cXG5cXHRcXHRcXHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcXG5cXHRcXHRcXHRyZXNwb25zZSA9IGFyZ3VtZW50cztcXG5cXG5cXHRcXHRcXHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcXG5cXHRcXHRcXHRcXHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcXG5cXHRcXHRcXHRcXHRqUXVlcnkoIFxcXCI8ZGl2PlxcXCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcXG5cXHRcXHRcXHRcXHRyZXNwb25zZVRleHQgKTtcXG5cXG5cXHRcXHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFxcXCJkYXRhXFxcIiwgXFxcInN0YXR1c1xcXCIsIFxcXCJqcVhIUlxcXCJcXG5cXHRcXHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXFxuXFx0XFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcXFwianFYSFJcXFwiLCBcXFwic3RhdHVzXFxcIiwgXFxcImVycm9yXFxcIlxcblxcdFxcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xcblxcdFxcdFxcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcXG5cXHRcXHRcXHR9ICk7XFxuXFx0XFx0fSApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gdGhpcztcXG59O1xcblxcblxcblxcblxcbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcXG5cXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcXG5cXHR9ICkubGVuZ3RoO1xcbn07XFxuXFxuXFxuXFxuXFxualF1ZXJ5Lm9mZnNldCA9IHtcXG5cXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xcblxcdFxcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXFxuXFx0XFx0XFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcXFwicG9zaXRpb25cXFwiICksXFxuXFx0XFx0XFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxcblxcdFxcdFxcdHByb3BzID0ge307XFxuXFxuXFx0XFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxcblxcdFxcdGlmICggcG9zaXRpb24gPT09IFxcXCJzdGF0aWNcXFwiICkge1xcblxcdFxcdFxcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcXFwicmVsYXRpdmVcXFwiO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xcblxcdFxcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJ0b3BcXFwiICk7XFxuXFx0XFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJsZWZ0XFxcIiApO1xcblxcdFxcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXFxcImFic29sdXRlXFxcIiB8fCBwb3NpdGlvbiA9PT0gXFxcImZpeGVkXFxcIiApICYmXFxuXFx0XFx0XFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXFxcImF1dG9cXFwiICkgPiAtMTtcXG5cXG5cXHRcXHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxcblxcdFxcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxcblxcdFxcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XFxuXFx0XFx0XFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XFxuXFx0XFx0XFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xcblxcdFxcdFxcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcXG5cXHRcXHRcXHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xcblxcblxcdFxcdFxcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxcblxcdFxcdFxcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XFxuXFx0XFx0XFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcXG5cXHRcXHRcXHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBcXFwidXNpbmdcXFwiIGluIG9wdGlvbnMgKSB7XFxuXFx0XFx0XFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgcHJvcHMudG9wID09PSBcXFwibnVtYmVyXFxcIiApIHtcXG5cXHRcXHRcXHRcXHRwcm9wcy50b3AgKz0gXFxcInB4XFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgcHJvcHMubGVmdCA9PT0gXFxcIm51bWJlclxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0cHJvcHMubGVmdCArPSBcXFwicHhcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcXG5cXHRcXHR9XFxuXFx0fVxcbn07XFxuXFxualF1ZXJ5LmZuLmV4dGVuZCgge1xcblxcblxcdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxcblxcdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XFxuXFxuXFx0XFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxcblxcdFxcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRcXHR0aGlzIDpcXG5cXHRcXHRcXHRcXHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XFxuXFx0XFx0XFx0XFx0fSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgcmVjdCwgd2luLFxcblxcdFxcdFxcdGVsZW0gPSB0aGlzWyAwIF07XFxuXFxuXFx0XFx0aWYgKCAhZWxlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxcblxcdFxcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcXG5cXHRcXHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3JcXG5cXHRcXHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xcblxcdFxcdFxcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXFxuXFx0XFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFx0XFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcXG5cXHRcXHRcXHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcXG5cXHRcXHR9O1xcblxcdH0sXFxuXFxuXFx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcXG5cXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcXG5cXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XFxuXFx0XFx0aWYgKCAhdGhpc1sgMCBdICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXFxuXFx0XFx0XFx0ZWxlbSA9IHRoaXNbIDAgXSxcXG5cXHRcXHRcXHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xcblxcblxcdFxcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XFxuXFx0XFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcXFwicG9zaXRpb25cXFwiICkgPT09IFxcXCJmaXhlZFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxcblxcdFxcdFxcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xcblxcblxcdFxcdFxcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XFxuXFx0XFx0XFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcXG5cXHRcXHRcXHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XFxuXFx0XFx0XFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcXG5cXHRcXHRcXHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxcblxcdFxcdFxcdFxcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxcblxcdFxcdFxcdFxcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXFxcInBvc2l0aW9uXFxcIiApID09PSBcXFwic3RhdGljXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRcXHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cXG5cXHRcXHRcXHRcXHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcXFwiYm9yZGVyVG9wV2lkdGhcXFwiLCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcXFwiYm9yZGVyTGVmdFdpZHRoXFxcIiwgdHJ1ZSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJtYXJnaW5Ub3BcXFwiLCB0cnVlICksXFxuXFx0XFx0XFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFxcXCJtYXJnaW5MZWZ0XFxcIiwgdHJ1ZSApXFxuXFx0XFx0fTtcXG5cXHR9LFxcblxcblxcdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxcblxcdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cXG5cXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcXG5cXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XFxuXFx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxcblxcdC8vXFxuXFx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXFxuXFx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXFxuXFx0Ly9cXG5cXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxcblxcdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XFxuXFxuXFx0XFx0XFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcXFwicG9zaXRpb25cXFwiICkgPT09IFxcXCJzdGF0aWNcXFwiICkge1xcblxcdFxcdFxcdFxcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xcblxcdFxcdH0gKTtcXG5cXHR9XFxufSApO1xcblxcbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFxcXCJwYWdlWE9mZnNldFxcXCIsIHNjcm9sbFRvcDogXFxcInBhZ2VZT2Zmc2V0XFxcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xcblxcdHZhciB0b3AgPSBcXFwicGFnZVlPZmZzZXRcXFwiID09PSBwcm9wO1xcblxcblxcdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xcblxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcXG5cXG5cXHRcXHRcXHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3NcXG5cXHRcXHRcXHR2YXIgd2luO1xcblxcdFxcdFxcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcXG5cXHRcXHRcXHRcXHR3aW4gPSBlbGVtO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XFxuXFx0XFx0XFx0XFx0d2luID0gZWxlbS5kZWZhdWx0VmlldztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB3aW4gKSB7XFxuXFx0XFx0XFx0XFx0d2luLnNjcm9sbFRvKFxcblxcdFxcdFxcdFxcdFxcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXFxuXFx0XFx0XFx0XFx0XFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XFxuXFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xcblxcdH07XFxufSApO1xcblxcbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxcbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XFxuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcXG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxcbmpRdWVyeS5lYWNoKCBbIFxcXCJ0b3BcXFwiLCBcXFwibGVmdFxcXCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xcblxcdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXFxuXFx0XFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xcblxcdFxcdFxcdGlmICggY29tcHV0ZWQgKSB7XFxuXFx0XFx0XFx0XFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFxcXCJweFxcXCIgOlxcblxcdFxcdFxcdFxcdFxcdGNvbXB1dGVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0KTtcXG59ICk7XFxuXFxuXFxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXFxualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcXFwiaGVpZ2h0XFxcIiwgV2lkdGg6IFxcXCJ3aWR0aFxcXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XFxuXFx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXFxcImlubmVyXFxcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFxcXCJcXFwiOiBcXFwib3V0ZXJcXFwiICsgbmFtZSB9LFxcblxcdFxcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xcblxcblxcdFxcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxcblxcdFxcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xcblxcdFxcdFxcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFxcXCJib29sZWFuXFxcIiApLFxcblxcdFxcdFxcdFxcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXFxcIm1hcmdpblxcXCIgOiBcXFwiYm9yZGVyXFxcIiApO1xcblxcblxcdFxcdFxcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgZG9jO1xcblxcblxcdFxcdFxcdFxcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcXFwib3V0ZXJcXFwiICkgPT09IDAgP1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bIFxcXCJpbm5lclxcXCIgKyBuYW1lIF0gOlxcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcXFwiY2xpZW50XFxcIiArIG5hbWUgXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxcblxcdFxcdFxcdFxcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcXG5cXHRcXHRcXHRcXHRcXHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXFxuXFx0XFx0XFx0XFx0XFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIE1hdGgubWF4KFxcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uYm9keVsgXFxcInNjcm9sbFxcXCIgKyBuYW1lIF0sIGRvY1sgXFxcInNjcm9sbFxcXCIgKyBuYW1lIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5ib2R5WyBcXFwib2Zmc2V0XFxcIiArIG5hbWUgXSwgZG9jWyBcXFwib2Zmc2V0XFxcIiArIG5hbWUgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb2NbIFxcXCJjbGllbnRcXFwiICsgbmFtZSBdXFxuXFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcXG5cXHRcXHRcXHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xcblxcdFxcdH07XFxuXFx0fSApO1xcbn0gKTtcXG5cXG5cXG5qUXVlcnkuZWFjaCggW1xcblxcdFxcXCJhamF4U3RhcnRcXFwiLFxcblxcdFxcXCJhamF4U3RvcFxcXCIsXFxuXFx0XFxcImFqYXhDb21wbGV0ZVxcXCIsXFxuXFx0XFxcImFqYXhFcnJvclxcXCIsXFxuXFx0XFxcImFqYXhTdWNjZXNzXFxcIixcXG5cXHRcXFwiYWpheFNlbmRcXFwiXFxuXSwgZnVuY3Rpb24oIF9pLCB0eXBlICkge1xcblxcdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xcblxcdFxcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xcblxcdH07XFxufSApO1xcblxcblxcblxcblxcbmpRdWVyeS5mbi5leHRlbmQoIHtcXG5cXG5cXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcXG5cXHR9LFxcblxcdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xcblxcdH0sXFxuXFxuXFx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xcblxcdFxcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XFxuXFx0fSxcXG5cXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcXG5cXG5cXHRcXHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXFxuXFx0XFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xcblxcdFxcdFxcdHRoaXMub2ZmKCBzZWxlY3RvciwgXFxcIioqXFxcIiApIDpcXG5cXHRcXHRcXHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFxcXCIqKlxcXCIsIGZuICk7XFxuXFx0fSxcXG5cXG5cXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XFxuXFx0fVxcbn0gKTtcXG5cXG5qUXVlcnkuZWFjaCggKCBcXFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXFxcIiArXFxuXFx0XFxcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFxcXCIgK1xcblxcdFxcXCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XFxcIiApLnNwbGl0KCBcXFwiIFxcXCIgKSxcXG5cXHRmdW5jdGlvbiggX2ksIG5hbWUgKSB7XFxuXFxuXFx0XFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcXG5cXHRcXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xcblxcdFxcdFxcdFxcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlciggbmFtZSApO1xcblxcdFxcdH07XFxuXFx0fSApO1xcblxcblxcblxcblxcbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxcbi8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxcbnZhciBydHJpbSA9IC9eW1xcXFxzXFxcXHVGRUZGXFxcXHhBMF0rfFtcXFxcc1xcXFx1RkVGRlxcXFx4QTBdKyQvZztcXG5cXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcXG4vLyBhcmd1bWVudHMuXFxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxcbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcXG5cXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcXG5cXG5cXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcXFwic3RyaW5nXFxcIiApIHtcXG5cXHRcXHR0bXAgPSBmblsgY29udGV4dCBdO1xcblxcdFxcdGNvbnRleHQgPSBmbjtcXG5cXHRcXHRmbiA9IHRtcDtcXG5cXHR9XFxuXFxuXFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcXG5cXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxcblxcdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XFxuXFx0XFx0cmV0dXJuIHVuZGVmaW5lZDtcXG5cXHR9XFxuXFxuXFx0Ly8gU2ltdWxhdGVkIGJpbmRcXG5cXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XFxuXFx0cHJveHkgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcXG5cXHR9O1xcblxcblxcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxcblxcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xcblxcblxcdHJldHVybiBwcm94eTtcXG59O1xcblxcbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcXG5cXHRpZiAoIGhvbGQgKSB7XFxuXFx0XFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XFxuXFx0fVxcbn07XFxualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcXG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcXG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xcblxcbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcXG5cXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcXG5cXG5cXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xcblxcdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcXG5cXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxcblxcdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xcblxcdHJldHVybiAoIHR5cGUgPT09IFxcXCJudW1iZXJcXFwiIHx8IHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiICkgJiZcXG5cXG5cXHRcXHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXFxcIlxcXCIpXFxuXFx0XFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXFxcIjB4Li4uXFxcIilcXG5cXHRcXHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cXG5cXHRcXHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XFxufTtcXG5cXG5qUXVlcnkudHJpbSA9IGZ1bmN0aW9uKCB0ZXh0ICkge1xcblxcdHJldHVybiB0ZXh0ID09IG51bGwgP1xcblxcdFxcdFxcXCJcXFwiIDpcXG5cXHRcXHQoIHRleHQgKyBcXFwiXFxcIiApLnJlcGxhY2UoIHJ0cmltLCBcXFwiXFxcIiApO1xcbn07XFxuXFxuXFxuXFxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXFxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2VcXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXFxuXFxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXFxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXFxuXFxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQgKSB7XFxuXFx0ZGVmaW5lKCBcXFwianF1ZXJ5XFxcIiwgW10sIGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBqUXVlcnk7XFxuXFx0fSApO1xcbn1cXG5cXG5cXG5cXG5cXG52YXJcXG5cXG5cXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcXG5cXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcXG5cXG5cXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxcblxcdF8kID0gd2luZG93LiQ7XFxuXFxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcXG5cXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XFxuXFx0XFx0d2luZG93LiQgPSBfJDtcXG5cXHR9XFxuXFxuXFx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcXG5cXHRcXHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGpRdWVyeTtcXG59O1xcblxcbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgKSB7XFxuXFx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xcbn1cXG5cXG5cXG5cXG5cXG5yZXR1cm4galF1ZXJ5O1xcbn0gKTtcXG5cIiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(5))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdmFsaWRhdGlvbi9kaXN0L2pxdWVyeS52YWxpZGF0ZS5taW4uanM/YjJmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXGpxdWVyeS12YWxpZGF0aW9uXFxcXGRpc3RcXFxcanF1ZXJ5LnZhbGlkYXRlLm1pbi5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")},function(module,exports){eval('module.exports = "/*! jQuery Validation Plugin - v1.19.1 - 6/15/2019\\n * https://jqueryvalidation.org/\\n * Copyright (c) 2019 Jrn Zaefferer; Licensed MIT */\\n!function(a){\\"function\\"==typeof define&&define.amd?define([\\"jquery\\"],a):\\"object\\"==typeof module&&module.exports?module.exports=a(require(\\"jquery\\")):a(jQuery)}(function(a){a.extend(a.fn,{validate:function(b){if(!this.length)return void(b&&b.debug&&window.console&&console.warn(\\"Nothing selected, can\'t validate, returning nothing.\\"));var c=a.data(this[0],\\"validator\\");return c?c:(this.attr(\\"novalidate\\",\\"novalidate\\"),c=new a.validator(b,this[0]),a.data(this[0],\\"validator\\",c),c.settings.onsubmit&&(this.on(\\"click.validate\\",\\":submit\\",function(b){c.submitButton=b.currentTarget,a(this).hasClass(\\"cancel\\")&&(c.cancelSubmit=!0),void 0!==a(this).attr(\\"formnovalidate\\")&&(c.cancelSubmit=!0)}),this.on(\\"submit.validate\\",function(b){function d(){var d,e;return c.submitButton&&(c.settings.submitHandler||c.formSubmitted)&&(d=a(\\"<input type=\'hidden\'/>\\").attr(\\"name\\",c.submitButton.name).val(a(c.submitButton).val()).appendTo(c.currentForm)),!(c.settings.submitHandler&&!c.settings.debug)||(e=c.settings.submitHandler.call(c,c.currentForm,b),d&&d.remove(),void 0!==e&&e)}return c.settings.debug&&b.preventDefault(),c.cancelSubmit?(c.cancelSubmit=!1,d()):c.form()?c.pendingRequest?(c.formSubmitted=!0,!1):d():(c.focusInvalid(),!1)})),c)},valid:function(){var b,c,d;return a(this[0]).is(\\"form\\")?b=this.validate().form():(d=[],b=!0,c=a(this[0].form).validate(),this.each(function(){b=c.element(this)&&b,b||(d=d.concat(c.errorList))}),c.errorList=d),b},rules:function(b,c){var d,e,f,g,h,i,j=this[0],k=\\"undefined\\"!=typeof this.attr(\\"contenteditable\\")&&\\"false\\"!==this.attr(\\"contenteditable\\");if(null!=j&&(!j.form&&k&&(j.form=this.closest(\\"form\\")[0],j.name=this.attr(\\"name\\")),null!=j.form)){if(b)switch(d=a.data(j.form,\\"validator\\").settings,e=d.rules,f=a.validator.staticRules(j),b){case\\"add\\":a.extend(f,a.validator.normalizeRule(c)),delete f.messages,e[j.name]=f,c.messages&&(d.messages[j.name]=a.extend(d.messages[j.name],c.messages));break;case\\"remove\\":return c?(i={},a.each(c.split(/\\\\s/),function(a,b){i[b]=f[b],delete f[b]}),i):(delete e[j.name],f)}return g=a.validator.normalizeRules(a.extend({},a.validator.classRules(j),a.validator.attributeRules(j),a.validator.dataRules(j),a.validator.staticRules(j)),j),g.required&&(h=g.required,delete g.required,g=a.extend({required:h},g)),g.remote&&(h=g.remote,delete g.remote,g=a.extend(g,{remote:h})),g}}}),a.extend(a.expr.pseudos||a.expr[\\":\\"],{blank:function(b){return!a.trim(\\"\\"+a(b).val())},filled:function(b){var c=a(b).val();return null!==c&&!!a.trim(\\"\\"+c)},unchecked:function(b){return!a(b).prop(\\"checked\\")}}),a.validator=function(b,c){this.settings=a.extend(!0,{},a.validator.defaults,b),this.currentForm=c,this.init()},a.validator.format=function(b,c){return 1===arguments.length?function(){var c=a.makeArray(arguments);return c.unshift(b),a.validator.format.apply(this,c)}:void 0===c?b:(arguments.length>2&&c.constructor!==Array&&(c=a.makeArray(arguments).slice(1)),c.constructor!==Array&&(c=[c]),a.each(c,function(a,c){b=b.replace(new RegExp(\\"\\\\\\\\{\\"+a+\\"\\\\\\\\}\\",\\"g\\"),function(){return c})}),b)},a.extend(a.validator,{defaults:{messages:{},groups:{},rules:{},errorClass:\\"error\\",pendingClass:\\"pending\\",validClass:\\"valid\\",errorElement:\\"label\\",focusCleanup:!1,focusInvalid:!0,errorContainer:a([]),errorLabelContainer:a([]),onsubmit:!0,ignore:\\":hidden\\",ignoreTitle:!1,onfocusin:function(a){this.lastActive=a,this.settings.focusCleanup&&(this.settings.unhighlight&&this.settings.unhighlight.call(this,a,this.settings.errorClass,this.settings.validClass),this.hideThese(this.errorsFor(a)))},onfocusout:function(a){this.checkable(a)||!(a.name in this.submitted)&&this.optional(a)||this.element(a)},onkeyup:function(b,c){var d=[16,17,18,20,35,36,37,38,39,40,45,144,225];9===c.which&&\\"\\"===this.elementValue(b)||a.inArray(c.keyCode,d)!==-1||(b.name in this.submitted||b.name in this.invalid)&&this.element(b)},onclick:function(a){a.name in this.submitted?this.element(a):a.parentNode.name in this.submitted&&this.element(a.parentNode)},highlight:function(b,c,d){\\"radio\\"===b.type?this.findByName(b.name).addClass(c).removeClass(d):a(b).addClass(c).removeClass(d)},unhighlight:function(b,c,d){\\"radio\\"===b.type?this.findByName(b.name).removeClass(c).addClass(d):a(b).removeClass(c).addClass(d)}},setDefaults:function(b){a.extend(a.validator.defaults,b)},messages:{required:\\"This field is required.\\",remote:\\"Please fix this field.\\",email:\\"Please enter a valid email address.\\",url:\\"Please enter a valid URL.\\",date:\\"Please enter a valid date.\\",dateISO:\\"Please enter a valid date (ISO).\\",number:\\"Please enter a valid number.\\",digits:\\"Please enter only digits.\\",equalTo:\\"Please enter the same value again.\\",maxlength:a.validator.format(\\"Please enter no more than {0} characters.\\"),minlength:a.validator.format(\\"Please enter at least {0} characters.\\"),rangelength:a.validator.format(\\"Please enter a value between {0} and {1} characters long.\\"),range:a.validator.format(\\"Please enter a value between {0} and {1}.\\"),max:a.validator.format(\\"Please enter a value less than or equal to {0}.\\"),min:a.validator.format(\\"Please enter a value greater than or equal to {0}.\\"),step:a.validator.format(\\"Please enter a multiple of {0}.\\")},autoCreateRanges:!1,prototype:{init:function(){function b(b){var c=\\"undefined\\"!=typeof a(this).attr(\\"contenteditable\\")&&\\"false\\"!==a(this).attr(\\"contenteditable\\");if(!this.form&&c&&(this.form=a(this).closest(\\"form\\")[0],this.name=a(this).attr(\\"name\\")),d===this.form){var e=a.data(this.form,\\"validator\\"),f=\\"on\\"+b.type.replace(/^validate/,\\"\\"),g=e.settings;g[f]&&!a(this).is(g.ignore)&&g[f].call(e,this,b)}}this.labelContainer=a(this.settings.errorLabelContainer),this.errorContext=this.labelContainer.length&&this.labelContainer||a(this.currentForm),this.containers=a(this.settings.errorContainer).add(this.settings.errorLabelContainer),this.submitted={},this.valueCache={},this.pendingRequest=0,this.pending={},this.invalid={},this.reset();var c,d=this.currentForm,e=this.groups={};a.each(this.settings.groups,function(b,c){\\"string\\"==typeof c&&(c=c.split(/\\\\s/)),a.each(c,function(a,c){e[c]=b})}),c=this.settings.rules,a.each(c,function(b,d){c[b]=a.validator.normalizeRule(d)}),a(this.currentForm).on(\\"focusin.validate focusout.validate keyup.validate\\",\\":text, [type=\'password\'], [type=\'file\'], select, textarea, [type=\'number\'], [type=\'search\'], [type=\'tel\'], [type=\'url\'], [type=\'email\'], [type=\'datetime\'], [type=\'date\'], [type=\'month\'], [type=\'week\'], [type=\'time\'], [type=\'datetime-local\'], [type=\'range\'], [type=\'color\'], [type=\'radio\'], [type=\'checkbox\'], [contenteditable], [type=\'button\']\\",b).on(\\"click.validate\\",\\"select, option, [type=\'radio\'], [type=\'checkbox\']\\",b),this.settings.invalidHandler&&a(this.currentForm).on(\\"invalid-form.validate\\",this.settings.invalidHandler)},form:function(){return this.checkForm(),a.extend(this.submitted,this.errorMap),this.invalid=a.extend({},this.errorMap),this.valid()||a(this.currentForm).triggerHandler(\\"invalid-form\\",[this]),this.showErrors(),this.valid()},checkForm:function(){this.prepareForm();for(var a=0,b=this.currentElements=this.elements();b[a];a++)this.check(b[a]);return this.valid()},element:function(b){var c,d,e=this.clean(b),f=this.validationTargetFor(e),g=this,h=!0;return void 0===f?delete this.invalid[e.name]:(this.prepareElement(f),this.currentElements=a(f),d=this.groups[f.name],d&&a.each(this.groups,function(a,b){b===d&&a!==f.name&&(e=g.validationTargetFor(g.clean(g.findByName(a))),e&&e.name in g.invalid&&(g.currentElements.push(e),h=g.check(e)&&h))}),c=this.check(f)!==!1,h=h&&c,c?this.invalid[f.name]=!1:this.invalid[f.name]=!0,this.numberOfInvalids()||(this.toHide=this.toHide.add(this.containers)),this.showErrors(),a(b).attr(\\"aria-invalid\\",!c)),h},showErrors:function(b){if(b){var c=this;a.extend(this.errorMap,b),this.errorList=a.map(this.errorMap,function(a,b){return{message:a,element:c.findByName(b)[0]}}),this.successList=a.grep(this.successList,function(a){return!(a.name in b)})}this.settings.showErrors?this.settings.showErrors.call(this,this.errorMap,this.errorList):this.defaultShowErrors()},resetForm:function(){a.fn.resetForm&&a(this.currentForm).resetForm(),this.invalid={},this.submitted={},this.prepareForm(),this.hideErrors();var b=this.elements().removeData(\\"previousValue\\").removeAttr(\\"aria-invalid\\");this.resetElements(b)},resetElements:function(a){var b;if(this.settings.unhighlight)for(b=0;a[b];b++)this.settings.unhighlight.call(this,a[b],this.settings.errorClass,\\"\\"),this.findByName(a[b].name).removeClass(this.settings.validClass);else a.removeClass(this.settings.errorClass).removeClass(this.settings.validClass)},numberOfInvalids:function(){return this.objectLength(this.invalid)},objectLength:function(a){var b,c=0;for(b in a)void 0!==a[b]&&null!==a[b]&&a[b]!==!1&&c++;return c},hideErrors:function(){this.hideThese(this.toHide)},hideThese:function(a){a.not(this.containers).text(\\"\\"),this.addWrapper(a).hide()},valid:function(){return 0===this.size()},size:function(){return this.errorList.length},focusInvalid:function(){if(this.settings.focusInvalid)try{a(this.findLastActive()||this.errorList.length&&this.errorList[0].element||[]).filter(\\":visible\\").trigger(\\"focus\\").trigger(\\"focusin\\")}catch(b){}},findLastActive:function(){var b=this.lastActive;return b&&1===a.grep(this.errorList,function(a){return a.element.name===b.name}).length&&b},elements:function(){var b=this,c={};return a(this.currentForm).find(\\"input, select, textarea, [contenteditable]\\").not(\\":submit, :reset, :image, :disabled\\").not(this.settings.ignore).filter(function(){var d=this.name||a(this).attr(\\"name\\"),e=\\"undefined\\"!=typeof a(this).attr(\\"contenteditable\\")&&\\"false\\"!==a(this).attr(\\"contenteditable\\");return!d&&b.settings.debug&&window.console&&console.error(\\"%o has no name assigned\\",this),e&&(this.form=a(this).closest(\\"form\\")[0],this.name=d),this.form===b.currentForm&&(!(d in c||!b.objectLength(a(this).rules()))&&(c[d]=!0,!0))})},clean:function(b){return a(b)[0]},errors:function(){var b=this.settings.errorClass.split(\\" \\").join(\\".\\");return a(this.settings.errorElement+\\".\\"+b,this.errorContext)},resetInternals:function(){this.successList=[],this.errorList=[],this.errorMap={},this.toShow=a([]),this.toHide=a([])},reset:function(){this.resetInternals(),this.currentElements=a([])},prepareForm:function(){this.reset(),this.toHide=this.errors().add(this.containers)},prepareElement:function(a){this.reset(),this.toHide=this.errorsFor(a)},elementValue:function(b){var c,d,e=a(b),f=b.type,g=\\"undefined\\"!=typeof e.attr(\\"contenteditable\\")&&\\"false\\"!==e.attr(\\"contenteditable\\");return\\"radio\\"===f||\\"checkbox\\"===f?this.findByName(b.name).filter(\\":checked\\").val():\\"number\\"===f&&\\"undefined\\"!=typeof b.validity?b.validity.badInput?\\"NaN\\":e.val():(c=g?e.text():e.val(),\\"file\\"===f?\\"C:\\\\\\\\fakepath\\\\\\\\\\"===c.substr(0,12)?c.substr(12):(d=c.lastIndexOf(\\"/\\"),d>=0?c.substr(d+1):(d=c.lastIndexOf(\\"\\\\\\\\\\"),d>=0?c.substr(d+1):c)):\\"string\\"==typeof c?c.replace(/\\\\r/g,\\"\\"):c)},check:function(b){b=this.validationTargetFor(this.clean(b));var c,d,e,f,g=a(b).rules(),h=a.map(g,function(a,b){return b}).length,i=!1,j=this.elementValue(b);\\"function\\"==typeof g.normalizer?f=g.normalizer:\\"function\\"==typeof this.settings.normalizer&&(f=this.settings.normalizer),f&&(j=f.call(b,j),delete g.normalizer);for(d in g){e={method:d,parameters:g[d]};try{if(c=a.validator.methods[d].call(this,j,b,e.parameters),\\"dependency-mismatch\\"===c&&1===h){i=!0;continue}if(i=!1,\\"pending\\"===c)return void(this.toHide=this.toHide.not(this.errorsFor(b)));if(!c)return this.formatAndAdd(b,e),!1}catch(k){throw this.settings.debug&&window.console&&console.log(\\"Exception occurred when checking element \\"+b.id+\\", check the \'\\"+e.method+\\"\' method.\\",k),k instanceof TypeError&&(k.message+=\\".  Exception occurred when checking element \\"+b.id+\\", check the \'\\"+e.method+\\"\' method.\\"),k}}if(!i)return this.objectLength(g)&&this.successList.push(b),!0},customDataMessage:function(b,c){return a(b).data(\\"msg\\"+c.charAt(0).toUpperCase()+c.substring(1).toLowerCase())||a(b).data(\\"msg\\")},customMessage:function(a,b){var c=this.settings.messages[a];return c&&(c.constructor===String?c:c[b])},findDefined:function(){for(var a=0;a<arguments.length;a++)if(void 0!==arguments[a])return arguments[a]},defaultMessage:function(b,c){\\"string\\"==typeof c&&(c={method:c});var d=this.findDefined(this.customMessage(b.name,c.method),this.customDataMessage(b,c.method),!this.settings.ignoreTitle&&b.title||void 0,a.validator.messages[c.method],\\"<strong>Warning: No message defined for \\"+b.name+\\"</strong>\\"),e=/\\\\$?\\\\{(\\\\d+)\\\\}/g;return\\"function\\"==typeof d?d=d.call(this,c.parameters,b):e.test(d)&&(d=a.validator.format(d.replace(e,\\"{$1}\\"),c.parameters)),d},formatAndAdd:function(a,b){var c=this.defaultMessage(a,b);this.errorList.push({message:c,element:a,method:b.method}),this.errorMap[a.name]=c,this.submitted[a.name]=c},addWrapper:function(a){return this.settings.wrapper&&(a=a.add(a.parent(this.settings.wrapper))),a},defaultShowErrors:function(){var a,b,c;for(a=0;this.errorList[a];a++)c=this.errorList[a],this.settings.highlight&&this.settings.highlight.call(this,c.element,this.settings.errorClass,this.settings.validClass),this.showLabel(c.element,c.message);if(this.errorList.length&&(this.toShow=this.toShow.add(this.containers)),this.settings.success)for(a=0;this.successList[a];a++)this.showLabel(this.successList[a]);if(this.settings.unhighlight)for(a=0,b=this.validElements();b[a];a++)this.settings.unhighlight.call(this,b[a],this.settings.errorClass,this.settings.validClass);this.toHide=this.toHide.not(this.toShow),this.hideErrors(),this.addWrapper(this.toShow).show()},validElements:function(){return this.currentElements.not(this.invalidElements())},invalidElements:function(){return a(this.errorList).map(function(){return this.element})},showLabel:function(b,c){var d,e,f,g,h=this.errorsFor(b),i=this.idOrName(b),j=a(b).attr(\\"aria-describedby\\");h.length?(h.removeClass(this.settings.validClass).addClass(this.settings.errorClass),h.html(c)):(h=a(\\"<\\"+this.settings.errorElement+\\">\\").attr(\\"id\\",i+\\"-error\\").addClass(this.settings.errorClass).html(c||\\"\\"),d=h,this.settings.wrapper&&(d=h.hide().show().wrap(\\"<\\"+this.settings.wrapper+\\"/>\\").parent()),this.labelContainer.length?this.labelContainer.append(d):this.settings.errorPlacement?this.settings.errorPlacement.call(this,d,a(b)):d.insertAfter(b),h.is(\\"label\\")?h.attr(\\"for\\",i):0===h.parents(\\"label[for=\'\\"+this.escapeCssMeta(i)+\\"\']\\").length&&(f=h.attr(\\"id\\"),j?j.match(new RegExp(\\"\\\\\\\\b\\"+this.escapeCssMeta(f)+\\"\\\\\\\\b\\"))||(j+=\\" \\"+f):j=f,a(b).attr(\\"aria-describedby\\",j),e=this.groups[b.name],e&&(g=this,a.each(g.groups,function(b,c){c===e&&a(\\"[name=\'\\"+g.escapeCssMeta(b)+\\"\']\\",g.currentForm).attr(\\"aria-describedby\\",h.attr(\\"id\\"))})))),!c&&this.settings.success&&(h.text(\\"\\"),\\"string\\"==typeof this.settings.success?h.addClass(this.settings.success):this.settings.success(h,b)),this.toShow=this.toShow.add(h)},errorsFor:function(b){var c=this.escapeCssMeta(this.idOrName(b)),d=a(b).attr(\\"aria-describedby\\"),e=\\"label[for=\'\\"+c+\\"\'], label[for=\'\\"+c+\\"\'] *\\";return d&&(e=e+\\", #\\"+this.escapeCssMeta(d).replace(/\\\\s+/g,\\", #\\")),this.errors().filter(e)},escapeCssMeta:function(a){return a.replace(/([\\\\\\\\!\\"#$%&\'()*+,.\\\\/:;<=>?@\\\\[\\\\]^`{|}~])/g,\\"\\\\\\\\$1\\")},idOrName:function(a){return this.groups[a.name]||(this.checkable(a)?a.name:a.id||a.name)},validationTargetFor:function(b){return this.checkable(b)&&(b=this.findByName(b.name)),a(b).not(this.settings.ignore)[0]},checkable:function(a){return/radio|checkbox/i.test(a.type)},findByName:function(b){return a(this.currentForm).find(\\"[name=\'\\"+this.escapeCssMeta(b)+\\"\']\\")},getLength:function(b,c){switch(c.nodeName.toLowerCase()){case\\"select\\":return a(\\"option:selected\\",c).length;case\\"input\\":if(this.checkable(c))return this.findByName(c.name).filter(\\":checked\\").length}return b.length},depend:function(a,b){return!this.dependTypes[typeof a]||this.dependTypes[typeof a](a,b)},dependTypes:{\\"boolean\\":function(a){return a},string:function(b,c){return!!a(b,c.form).length},\\"function\\":function(a,b){return a(b)}},optional:function(b){var c=this.elementValue(b);return!a.validator.methods.required.call(this,c,b)&&\\"dependency-mismatch\\"},startRequest:function(b){this.pending[b.name]||(this.pendingRequest++,a(b).addClass(this.settings.pendingClass),this.pending[b.name]=!0)},stopRequest:function(b,c){this.pendingRequest--,this.pendingRequest<0&&(this.pendingRequest=0),delete this.pending[b.name],a(b).removeClass(this.settings.pendingClass),c&&0===this.pendingRequest&&this.formSubmitted&&this.form()?(a(this.currentForm).submit(),this.submitButton&&a(\\"input:hidden[name=\'\\"+this.submitButton.name+\\"\']\\",this.currentForm).remove(),this.formSubmitted=!1):!c&&0===this.pendingRequest&&this.formSubmitted&&(a(this.currentForm).triggerHandler(\\"invalid-form\\",[this]),this.formSubmitted=!1)},previousValue:function(b,c){return c=\\"string\\"==typeof c&&c||\\"remote\\",a.data(b,\\"previousValue\\")||a.data(b,\\"previousValue\\",{old:null,valid:!0,message:this.defaultMessage(b,{method:c})})},destroy:function(){this.resetForm(),a(this.currentForm).off(\\".validate\\").removeData(\\"validator\\").find(\\".validate-equalTo-blur\\").off(\\".validate-equalTo\\").removeClass(\\"validate-equalTo-blur\\").find(\\".validate-lessThan-blur\\").off(\\".validate-lessThan\\").removeClass(\\"validate-lessThan-blur\\").find(\\".validate-lessThanEqual-blur\\").off(\\".validate-lessThanEqual\\").removeClass(\\"validate-lessThanEqual-blur\\").find(\\".validate-greaterThanEqual-blur\\").off(\\".validate-greaterThanEqual\\").removeClass(\\"validate-greaterThanEqual-blur\\").find(\\".validate-greaterThan-blur\\").off(\\".validate-greaterThan\\").removeClass(\\"validate-greaterThan-blur\\")}},classRuleSettings:{required:{required:!0},email:{email:!0},url:{url:!0},date:{date:!0},dateISO:{dateISO:!0},number:{number:!0},digits:{digits:!0},creditcard:{creditcard:!0}},addClassRules:function(b,c){b.constructor===String?this.classRuleSettings[b]=c:a.extend(this.classRuleSettings,b)},classRules:function(b){var c={},d=a(b).attr(\\"class\\");return d&&a.each(d.split(\\" \\"),function(){this in a.validator.classRuleSettings&&a.extend(c,a.validator.classRuleSettings[this])}),c},normalizeAttributeRule:function(a,b,c,d){/min|max|step/.test(c)&&(null===b||/number|range|text/.test(b))&&(d=Number(d),isNaN(d)&&(d=void 0)),d||0===d?a[c]=d:b===c&&\\"range\\"!==b&&(a[c]=!0)},attributeRules:function(b){var c,d,e={},f=a(b),g=b.getAttribute(\\"type\\");for(c in a.validator.methods)\\"required\\"===c?(d=b.getAttribute(c),\\"\\"===d&&(d=!0),d=!!d):d=f.attr(c),this.normalizeAttributeRule(e,g,c,d);return e.maxlength&&/-1|2147483647|524288/.test(e.maxlength)&&delete e.maxlength,e},dataRules:function(b){var c,d,e={},f=a(b),g=b.getAttribute(\\"type\\");for(c in a.validator.methods)d=f.data(\\"rule\\"+c.charAt(0).toUpperCase()+c.substring(1).toLowerCase()),\\"\\"===d&&(d=!0),this.normalizeAttributeRule(e,g,c,d);return e},staticRules:function(b){var c={},d=a.data(b.form,\\"validator\\");return d.settings.rules&&(c=a.validator.normalizeRule(d.settings.rules[b.name])||{}),c},normalizeRules:function(b,c){return a.each(b,function(d,e){if(e===!1)return void delete b[d];if(e.param||e.depends){var f=!0;switch(typeof e.depends){case\\"string\\":f=!!a(e.depends,c.form).length;break;case\\"function\\":f=e.depends.call(c,c)}f?b[d]=void 0===e.param||e.param:(a.data(c.form,\\"validator\\").resetElements(a(c)),delete b[d])}}),a.each(b,function(d,e){b[d]=a.isFunction(e)&&\\"normalizer\\"!==d?e(c):e}),a.each([\\"minlength\\",\\"maxlength\\"],function(){b[this]&&(b[this]=Number(b[this]))}),a.each([\\"rangelength\\",\\"range\\"],function(){var c;b[this]&&(a.isArray(b[this])?b[this]=[Number(b[this][0]),Number(b[this][1])]:\\"string\\"==typeof b[this]&&(c=b[this].replace(/[\\\\[\\\\]]/g,\\"\\").split(/[\\\\s,]+/),b[this]=[Number(c[0]),Number(c[1])]))}),a.validator.autoCreateRanges&&(null!=b.min&&null!=b.max&&(b.range=[b.min,b.max],delete b.min,delete b.max),null!=b.minlength&&null!=b.maxlength&&(b.rangelength=[b.minlength,b.maxlength],delete b.minlength,delete b.maxlength)),b},normalizeRule:function(b){if(\\"string\\"==typeof b){var c={};a.each(b.split(/\\\\s/),function(){c[this]=!0}),b=c}return b},addMethod:function(b,c,d){a.validator.methods[b]=c,a.validator.messages[b]=void 0!==d?d:a.validator.messages[b],c.length<3&&a.validator.addClassRules(b,a.validator.normalizeRule(b))},methods:{required:function(b,c,d){if(!this.depend(d,c))return\\"dependency-mismatch\\";if(\\"select\\"===c.nodeName.toLowerCase()){var e=a(c).val();return e&&e.length>0}return this.checkable(c)?this.getLength(b,c)>0:void 0!==b&&null!==b&&b.length>0},email:function(a,b){return this.optional(b)||/^[a-zA-Z0-9.!#$%&\'*+\\\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(a)},url:function(a,b){return this.optional(b)||/^(?:(?:(?:https?|ftp):)?\\\\/\\\\/)(?:\\\\S+(?::\\\\S*)?@)?(?:(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})).?)(?::\\\\d{2,5})?(?:[\\\\/?#]\\\\S*)?$/i.test(a)},date:function(){var a=!1;return function(b,c){return a||(a=!0,this.settings.debug&&window.console&&console.warn(\\"The `date` method is deprecated and will be removed in version \'2.0.0\'.\\\\nPlease don\'t use it, since it relies on the Date constructor, which\\\\nbehaves very differently across browsers and locales. Use `dateISO`\\\\ninstead or one of the locale specific methods in `localizations/`\\\\nand `additional-methods.js`.\\")),this.optional(c)||!/Invalid|NaN/.test(new Date(b).toString())}}(),dateISO:function(a,b){return this.optional(b)||/^\\\\d{4}[\\\\/\\\\-](0?[1-9]|1[012])[\\\\/\\\\-](0?[1-9]|[12][0-9]|3[01])$/.test(a)},number:function(a,b){return this.optional(b)||/^(?:-?\\\\d+|-?\\\\d{1,3}(?:,\\\\d{3})+)?(?:\\\\.\\\\d+)?$/.test(a)},digits:function(a,b){return this.optional(b)||/^\\\\d+$/.test(a)},minlength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(b,c);return this.optional(c)||e>=d},maxlength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(b,c);return this.optional(c)||e<=d},rangelength:function(b,c,d){var e=a.isArray(b)?b.length:this.getLength(b,c);return this.optional(c)||e>=d[0]&&e<=d[1]},min:function(a,b,c){return this.optional(b)||a>=c},max:function(a,b,c){return this.optional(b)||a<=c},range:function(a,b,c){return this.optional(b)||a>=c[0]&&a<=c[1]},step:function(b,c,d){var e,f=a(c).attr(\\"type\\"),g=\\"Step attribute on input type \\"+f+\\" is not supported.\\",h=[\\"text\\",\\"number\\",\\"range\\"],i=new RegExp(\\"\\\\\\\\b\\"+f+\\"\\\\\\\\b\\"),j=f&&!i.test(h.join()),k=function(a){var b=(\\"\\"+a).match(/(?:\\\\.(\\\\d+))?$/);return b&&b[1]?b[1].length:0},l=function(a){return Math.round(a*Math.pow(10,e))},m=!0;if(j)throw new Error(g);return e=k(d),(k(b)>e||l(b)%l(d)!==0)&&(m=!1),this.optional(c)||m},equalTo:function(b,c,d){var e=a(d);return this.settings.onfocusout&&e.not(\\".validate-equalTo-blur\\").length&&e.addClass(\\"validate-equalTo-blur\\").on(\\"blur.validate-equalTo\\",function(){a(c).valid()}),b===e.val()},remote:function(b,c,d,e){if(this.optional(c))return\\"dependency-mismatch\\";e=\\"string\\"==typeof e&&e||\\"remote\\";var f,g,h,i=this.previousValue(c,e);return this.settings.messages[c.name]||(this.settings.messages[c.name]={}),i.originalMessage=i.originalMessage||this.settings.messages[c.name][e],this.settings.messages[c.name][e]=i.message,d=\\"string\\"==typeof d&&{url:d}||d,h=a.param(a.extend({data:b},d.data)),i.old===h?i.valid:(i.old=h,f=this,this.startRequest(c),g={},g[c.name]=b,a.ajax(a.extend(!0,{mode:\\"abort\\",port:\\"validate\\"+c.name,dataType:\\"json\\",data:g,context:f.currentForm,success:function(a){var d,g,h,j=a===!0||\\"true\\"===a;f.settings.messages[c.name][e]=i.originalMessage,j?(h=f.formSubmitted,f.resetInternals(),f.toHide=f.errorsFor(c),f.formSubmitted=h,f.successList.push(c),f.invalid[c.name]=!1,f.showErrors()):(d={},g=a||f.defaultMessage(c,{method:e,parameters:b}),d[c.name]=i.message=g,f.invalid[c.name]=!0,f.showErrors(d)),i.valid=j,f.stopRequest(c,j)}},d)),\\"pending\\")}}});var b,c={};return a.ajaxPrefilter?a.ajaxPrefilter(function(a,b,d){var e=a.port;\\"abort\\"===a.mode&&(c[e]&&c[e].abort(),c[e]=d)}):(b=a.ajax,a.ajax=function(d){var e=(\\"mode\\"in d?d:a.ajaxSettings).mode,f=(\\"port\\"in d?d:a.ajaxSettings).port;return\\"abort\\"===e?(c[f]&&c[f].abort(),c[f]=b.apply(this,arguments),c[f]):b.apply(this,arguments)}),a});"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdmFsaWRhdGlvbi9kaXN0L2pxdWVyeS52YWxpZGF0ZS5taW4uanM/MTllMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohIGpRdWVyeSBWYWxpZGF0aW9uIFBsdWdpbiAtIHYxLjE5LjEgLSA2LzE1LzIwMTlcXG4gKiBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL1xcbiAqIENvcHlyaWdodCAoYykgMjAxOSBKw7ZybiBaYWVmZmVyZXI7IExpY2Vuc2VkIE1JVCAqL1xcbiFmdW5jdGlvbihhKXtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXFxcImpxdWVyeVxcXCJdLGEpOlxcXCJvYmplY3RcXFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1hKHJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKTphKGpRdWVyeSl9KGZ1bmN0aW9uKGEpe2EuZXh0ZW5kKGEuZm4se3ZhbGlkYXRlOmZ1bmN0aW9uKGIpe2lmKCF0aGlzLmxlbmd0aClyZXR1cm4gdm9pZChiJiZiLmRlYnVnJiZ3aW5kb3cuY29uc29sZSYmY29uc29sZS53YXJuKFxcXCJOb3RoaW5nIHNlbGVjdGVkLCBjYW4ndCB2YWxpZGF0ZSwgcmV0dXJuaW5nIG5vdGhpbmcuXFxcIikpO3ZhciBjPWEuZGF0YSh0aGlzWzBdLFxcXCJ2YWxpZGF0b3JcXFwiKTtyZXR1cm4gYz9jOih0aGlzLmF0dHIoXFxcIm5vdmFsaWRhdGVcXFwiLFxcXCJub3ZhbGlkYXRlXFxcIiksYz1uZXcgYS52YWxpZGF0b3IoYix0aGlzWzBdKSxhLmRhdGEodGhpc1swXSxcXFwidmFsaWRhdG9yXFxcIixjKSxjLnNldHRpbmdzLm9uc3VibWl0JiYodGhpcy5vbihcXFwiY2xpY2sudmFsaWRhdGVcXFwiLFxcXCI6c3VibWl0XFxcIixmdW5jdGlvbihiKXtjLnN1Ym1pdEJ1dHRvbj1iLmN1cnJlbnRUYXJnZXQsYSh0aGlzKS5oYXNDbGFzcyhcXFwiY2FuY2VsXFxcIikmJihjLmNhbmNlbFN1Ym1pdD0hMCksdm9pZCAwIT09YSh0aGlzKS5hdHRyKFxcXCJmb3Jtbm92YWxpZGF0ZVxcXCIpJiYoYy5jYW5jZWxTdWJtaXQ9ITApfSksdGhpcy5vbihcXFwic3VibWl0LnZhbGlkYXRlXFxcIixmdW5jdGlvbihiKXtmdW5jdGlvbiBkKCl7dmFyIGQsZTtyZXR1cm4gYy5zdWJtaXRCdXR0b24mJihjLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXJ8fGMuZm9ybVN1Ym1pdHRlZCkmJihkPWEoXFxcIjxpbnB1dCB0eXBlPSdoaWRkZW4nLz5cXFwiKS5hdHRyKFxcXCJuYW1lXFxcIixjLnN1Ym1pdEJ1dHRvbi5uYW1lKS52YWwoYShjLnN1Ym1pdEJ1dHRvbikudmFsKCkpLmFwcGVuZFRvKGMuY3VycmVudEZvcm0pKSwhKGMuc2V0dGluZ3Muc3VibWl0SGFuZGxlciYmIWMuc2V0dGluZ3MuZGVidWcpfHwoZT1jLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXIuY2FsbChjLGMuY3VycmVudEZvcm0sYiksZCYmZC5yZW1vdmUoKSx2b2lkIDAhPT1lJiZlKX1yZXR1cm4gYy5zZXR0aW5ncy5kZWJ1ZyYmYi5wcmV2ZW50RGVmYXVsdCgpLGMuY2FuY2VsU3VibWl0PyhjLmNhbmNlbFN1Ym1pdD0hMSxkKCkpOmMuZm9ybSgpP2MucGVuZGluZ1JlcXVlc3Q/KGMuZm9ybVN1Ym1pdHRlZD0hMCwhMSk6ZCgpOihjLmZvY3VzSW52YWxpZCgpLCExKX0pKSxjKX0sdmFsaWQ6ZnVuY3Rpb24oKXt2YXIgYixjLGQ7cmV0dXJuIGEodGhpc1swXSkuaXMoXFxcImZvcm1cXFwiKT9iPXRoaXMudmFsaWRhdGUoKS5mb3JtKCk6KGQ9W10sYj0hMCxjPWEodGhpc1swXS5mb3JtKS52YWxpZGF0ZSgpLHRoaXMuZWFjaChmdW5jdGlvbigpe2I9Yy5lbGVtZW50KHRoaXMpJiZiLGJ8fChkPWQuY29uY2F0KGMuZXJyb3JMaXN0KSl9KSxjLmVycm9yTGlzdD1kKSxifSxydWxlczpmdW5jdGlvbihiLGMpe3ZhciBkLGUsZixnLGgsaSxqPXRoaXNbMF0saz1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHRoaXMuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIikmJlxcXCJmYWxzZVxcXCIhPT10aGlzLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpO2lmKG51bGwhPWomJighai5mb3JtJiZrJiYoai5mb3JtPXRoaXMuY2xvc2VzdChcXFwiZm9ybVxcXCIpWzBdLGoubmFtZT10aGlzLmF0dHIoXFxcIm5hbWVcXFwiKSksbnVsbCE9ai5mb3JtKSl7aWYoYilzd2l0Y2goZD1hLmRhdGEoai5mb3JtLFxcXCJ2YWxpZGF0b3JcXFwiKS5zZXR0aW5ncyxlPWQucnVsZXMsZj1hLnZhbGlkYXRvci5zdGF0aWNSdWxlcyhqKSxiKXtjYXNlXFxcImFkZFxcXCI6YS5leHRlbmQoZixhLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlKGMpKSxkZWxldGUgZi5tZXNzYWdlcyxlW2oubmFtZV09ZixjLm1lc3NhZ2VzJiYoZC5tZXNzYWdlc1tqLm5hbWVdPWEuZXh0ZW5kKGQubWVzc2FnZXNbai5uYW1lXSxjLm1lc3NhZ2VzKSk7YnJlYWs7Y2FzZVxcXCJyZW1vdmVcXFwiOnJldHVybiBjPyhpPXt9LGEuZWFjaChjLnNwbGl0KC9cXFxccy8pLGZ1bmN0aW9uKGEsYil7aVtiXT1mW2JdLGRlbGV0ZSBmW2JdfSksaSk6KGRlbGV0ZSBlW2oubmFtZV0sZil9cmV0dXJuIGc9YS52YWxpZGF0b3Iubm9ybWFsaXplUnVsZXMoYS5leHRlbmQoe30sYS52YWxpZGF0b3IuY2xhc3NSdWxlcyhqKSxhLnZhbGlkYXRvci5hdHRyaWJ1dGVSdWxlcyhqKSxhLnZhbGlkYXRvci5kYXRhUnVsZXMoaiksYS52YWxpZGF0b3Iuc3RhdGljUnVsZXMoaikpLGopLGcucmVxdWlyZWQmJihoPWcucmVxdWlyZWQsZGVsZXRlIGcucmVxdWlyZWQsZz1hLmV4dGVuZCh7cmVxdWlyZWQ6aH0sZykpLGcucmVtb3RlJiYoaD1nLnJlbW90ZSxkZWxldGUgZy5yZW1vdGUsZz1hLmV4dGVuZChnLHtyZW1vdGU6aH0pKSxnfX19KSxhLmV4dGVuZChhLmV4cHIucHNldWRvc3x8YS5leHByW1xcXCI6XFxcIl0se2JsYW5rOmZ1bmN0aW9uKGIpe3JldHVybiFhLnRyaW0oXFxcIlxcXCIrYShiKS52YWwoKSl9LGZpbGxlZDpmdW5jdGlvbihiKXt2YXIgYz1hKGIpLnZhbCgpO3JldHVybiBudWxsIT09YyYmISFhLnRyaW0oXFxcIlxcXCIrYyl9LHVuY2hlY2tlZDpmdW5jdGlvbihiKXtyZXR1cm4hYShiKS5wcm9wKFxcXCJjaGVja2VkXFxcIil9fSksYS52YWxpZGF0b3I9ZnVuY3Rpb24oYixjKXt0aGlzLnNldHRpbmdzPWEuZXh0ZW5kKCEwLHt9LGEudmFsaWRhdG9yLmRlZmF1bHRzLGIpLHRoaXMuY3VycmVudEZvcm09Yyx0aGlzLmluaXQoKX0sYS52YWxpZGF0b3IuZm9ybWF0PWZ1bmN0aW9uKGIsYyl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP2Z1bmN0aW9uKCl7dmFyIGM9YS5tYWtlQXJyYXkoYXJndW1lbnRzKTtyZXR1cm4gYy51bnNoaWZ0KGIpLGEudmFsaWRhdG9yLmZvcm1hdC5hcHBseSh0aGlzLGMpfTp2b2lkIDA9PT1jP2I6KGFyZ3VtZW50cy5sZW5ndGg+MiYmYy5jb25zdHJ1Y3RvciE9PUFycmF5JiYoYz1hLm1ha2VBcnJheShhcmd1bWVudHMpLnNsaWNlKDEpKSxjLmNvbnN0cnVjdG9yIT09QXJyYXkmJihjPVtjXSksYS5lYWNoKGMsZnVuY3Rpb24oYSxjKXtiPWIucmVwbGFjZShuZXcgUmVnRXhwKFxcXCJcXFxcXFxcXHtcXFwiK2ErXFxcIlxcXFxcXFxcfVxcXCIsXFxcImdcXFwiKSxmdW5jdGlvbigpe3JldHVybiBjfSl9KSxiKX0sYS5leHRlbmQoYS52YWxpZGF0b3Ise2RlZmF1bHRzOnttZXNzYWdlczp7fSxncm91cHM6e30scnVsZXM6e30sZXJyb3JDbGFzczpcXFwiZXJyb3JcXFwiLHBlbmRpbmdDbGFzczpcXFwicGVuZGluZ1xcXCIsdmFsaWRDbGFzczpcXFwidmFsaWRcXFwiLGVycm9yRWxlbWVudDpcXFwibGFiZWxcXFwiLGZvY3VzQ2xlYW51cDohMSxmb2N1c0ludmFsaWQ6ITAsZXJyb3JDb250YWluZXI6YShbXSksZXJyb3JMYWJlbENvbnRhaW5lcjphKFtdKSxvbnN1Ym1pdDohMCxpZ25vcmU6XFxcIjpoaWRkZW5cXFwiLGlnbm9yZVRpdGxlOiExLG9uZm9jdXNpbjpmdW5jdGlvbihhKXt0aGlzLmxhc3RBY3RpdmU9YSx0aGlzLnNldHRpbmdzLmZvY3VzQ2xlYW51cCYmKHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQmJnRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQuY2FsbCh0aGlzLGEsdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyksdGhpcy5oaWRlVGhlc2UodGhpcy5lcnJvcnNGb3IoYSkpKX0sb25mb2N1c291dDpmdW5jdGlvbihhKXt0aGlzLmNoZWNrYWJsZShhKXx8IShhLm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQpJiZ0aGlzLm9wdGlvbmFsKGEpfHx0aGlzLmVsZW1lbnQoYSl9LG9ua2V5dXA6ZnVuY3Rpb24oYixjKXt2YXIgZD1bMTYsMTcsMTgsMjAsMzUsMzYsMzcsMzgsMzksNDAsNDUsMTQ0LDIyNV07OT09PWMud2hpY2gmJlxcXCJcXFwiPT09dGhpcy5lbGVtZW50VmFsdWUoYil8fGEuaW5BcnJheShjLmtleUNvZGUsZCkhPT0tMXx8KGIubmFtZSBpbiB0aGlzLnN1Ym1pdHRlZHx8Yi5uYW1lIGluIHRoaXMuaW52YWxpZCkmJnRoaXMuZWxlbWVudChiKX0sb25jbGljazpmdW5jdGlvbihhKXthLm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQ/dGhpcy5lbGVtZW50KGEpOmEucGFyZW50Tm9kZS5uYW1lIGluIHRoaXMuc3VibWl0dGVkJiZ0aGlzLmVsZW1lbnQoYS5wYXJlbnROb2RlKX0saGlnaGxpZ2h0OmZ1bmN0aW9uKGIsYyxkKXtcXFwicmFkaW9cXFwiPT09Yi50eXBlP3RoaXMuZmluZEJ5TmFtZShiLm5hbWUpLmFkZENsYXNzKGMpLnJlbW92ZUNsYXNzKGQpOmEoYikuYWRkQ2xhc3MoYykucmVtb3ZlQ2xhc3MoZCl9LHVuaGlnaGxpZ2h0OmZ1bmN0aW9uKGIsYyxkKXtcXFwicmFkaW9cXFwiPT09Yi50eXBlP3RoaXMuZmluZEJ5TmFtZShiLm5hbWUpLnJlbW92ZUNsYXNzKGMpLmFkZENsYXNzKGQpOmEoYikucmVtb3ZlQ2xhc3MoYykuYWRkQ2xhc3MoZCl9fSxzZXREZWZhdWx0czpmdW5jdGlvbihiKXthLmV4dGVuZChhLnZhbGlkYXRvci5kZWZhdWx0cyxiKX0sbWVzc2FnZXM6e3JlcXVpcmVkOlxcXCJUaGlzIGZpZWxkIGlzIHJlcXVpcmVkLlxcXCIscmVtb3RlOlxcXCJQbGVhc2UgZml4IHRoaXMgZmllbGQuXFxcIixlbWFpbDpcXFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cXFwiLHVybDpcXFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgVVJMLlxcXCIsZGF0ZTpcXFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZGF0ZS5cXFwiLGRhdGVJU086XFxcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGRhdGUgKElTTykuXFxcIixudW1iZXI6XFxcIlBsZWFzZSBlbnRlciBhIHZhbGlkIG51bWJlci5cXFwiLGRpZ2l0czpcXFwiUGxlYXNlIGVudGVyIG9ubHkgZGlnaXRzLlxcXCIsZXF1YWxUbzpcXFwiUGxlYXNlIGVudGVyIHRoZSBzYW1lIHZhbHVlIGFnYWluLlxcXCIsbWF4bGVuZ3RoOmEudmFsaWRhdG9yLmZvcm1hdChcXFwiUGxlYXNlIGVudGVyIG5vIG1vcmUgdGhhbiB7MH0gY2hhcmFjdGVycy5cXFwiKSxtaW5sZW5ndGg6YS52YWxpZGF0b3IuZm9ybWF0KFxcXCJQbGVhc2UgZW50ZXIgYXQgbGVhc3QgezB9IGNoYXJhY3RlcnMuXFxcIikscmFuZ2VsZW5ndGg6YS52YWxpZGF0b3IuZm9ybWF0KFxcXCJQbGVhc2UgZW50ZXIgYSB2YWx1ZSBiZXR3ZWVuIHswfSBhbmQgezF9IGNoYXJhY3RlcnMgbG9uZy5cXFwiKSxyYW5nZTphLnZhbGlkYXRvci5mb3JtYXQoXFxcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGJldHdlZW4gezB9IGFuZCB7MX0uXFxcIiksbWF4OmEudmFsaWRhdG9yLmZvcm1hdChcXFwiUGxlYXNlIGVudGVyIGEgdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHswfS5cXFwiKSxtaW46YS52YWxpZGF0b3IuZm9ybWF0KFxcXCJQbGVhc2UgZW50ZXIgYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gezB9LlxcXCIpLHN0ZXA6YS52YWxpZGF0b3IuZm9ybWF0KFxcXCJQbGVhc2UgZW50ZXIgYSBtdWx0aXBsZSBvZiB7MH0uXFxcIil9LGF1dG9DcmVhdGVSYW5nZXM6ITEscHJvdG90eXBlOntpbml0OmZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiKXt2YXIgYz1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGEodGhpcykuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIikmJlxcXCJmYWxzZVxcXCIhPT1hKHRoaXMpLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpO2lmKCF0aGlzLmZvcm0mJmMmJih0aGlzLmZvcm09YSh0aGlzKS5jbG9zZXN0KFxcXCJmb3JtXFxcIilbMF0sdGhpcy5uYW1lPWEodGhpcykuYXR0cihcXFwibmFtZVxcXCIpKSxkPT09dGhpcy5mb3JtKXt2YXIgZT1hLmRhdGEodGhpcy5mb3JtLFxcXCJ2YWxpZGF0b3JcXFwiKSxmPVxcXCJvblxcXCIrYi50eXBlLnJlcGxhY2UoL152YWxpZGF0ZS8sXFxcIlxcXCIpLGc9ZS5zZXR0aW5ncztnW2ZdJiYhYSh0aGlzKS5pcyhnLmlnbm9yZSkmJmdbZl0uY2FsbChlLHRoaXMsYil9fXRoaXMubGFiZWxDb250YWluZXI9YSh0aGlzLnNldHRpbmdzLmVycm9yTGFiZWxDb250YWluZXIpLHRoaXMuZXJyb3JDb250ZXh0PXRoaXMubGFiZWxDb250YWluZXIubGVuZ3RoJiZ0aGlzLmxhYmVsQ29udGFpbmVyfHxhKHRoaXMuY3VycmVudEZvcm0pLHRoaXMuY29udGFpbmVycz1hKHRoaXMuc2V0dGluZ3MuZXJyb3JDb250YWluZXIpLmFkZCh0aGlzLnNldHRpbmdzLmVycm9yTGFiZWxDb250YWluZXIpLHRoaXMuc3VibWl0dGVkPXt9LHRoaXMudmFsdWVDYWNoZT17fSx0aGlzLnBlbmRpbmdSZXF1ZXN0PTAsdGhpcy5wZW5kaW5nPXt9LHRoaXMuaW52YWxpZD17fSx0aGlzLnJlc2V0KCk7dmFyIGMsZD10aGlzLmN1cnJlbnRGb3JtLGU9dGhpcy5ncm91cHM9e307YS5lYWNoKHRoaXMuc2V0dGluZ3MuZ3JvdXBzLGZ1bmN0aW9uKGIsYyl7XFxcInN0cmluZ1xcXCI9PXR5cGVvZiBjJiYoYz1jLnNwbGl0KC9cXFxccy8pKSxhLmVhY2goYyxmdW5jdGlvbihhLGMpe2VbY109Yn0pfSksYz10aGlzLnNldHRpbmdzLnJ1bGVzLGEuZWFjaChjLGZ1bmN0aW9uKGIsZCl7Y1tiXT1hLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlKGQpfSksYSh0aGlzLmN1cnJlbnRGb3JtKS5vbihcXFwiZm9jdXNpbi52YWxpZGF0ZSBmb2N1c291dC52YWxpZGF0ZSBrZXl1cC52YWxpZGF0ZVxcXCIsXFxcIjp0ZXh0LCBbdHlwZT0ncGFzc3dvcmQnXSwgW3R5cGU9J2ZpbGUnXSwgc2VsZWN0LCB0ZXh0YXJlYSwgW3R5cGU9J251bWJlciddLCBbdHlwZT0nc2VhcmNoJ10sIFt0eXBlPSd0ZWwnXSwgW3R5cGU9J3VybCddLCBbdHlwZT0nZW1haWwnXSwgW3R5cGU9J2RhdGV0aW1lJ10sIFt0eXBlPSdkYXRlJ10sIFt0eXBlPSdtb250aCddLCBbdHlwZT0nd2VlayddLCBbdHlwZT0ndGltZSddLCBbdHlwZT0nZGF0ZXRpbWUtbG9jYWwnXSwgW3R5cGU9J3JhbmdlJ10sIFt0eXBlPSdjb2xvciddLCBbdHlwZT0ncmFkaW8nXSwgW3R5cGU9J2NoZWNrYm94J10sIFtjb250ZW50ZWRpdGFibGVdLCBbdHlwZT0nYnV0dG9uJ11cXFwiLGIpLm9uKFxcXCJjbGljay52YWxpZGF0ZVxcXCIsXFxcInNlbGVjdCwgb3B0aW9uLCBbdHlwZT0ncmFkaW8nXSwgW3R5cGU9J2NoZWNrYm94J11cXFwiLGIpLHRoaXMuc2V0dGluZ3MuaW52YWxpZEhhbmRsZXImJmEodGhpcy5jdXJyZW50Rm9ybSkub24oXFxcImludmFsaWQtZm9ybS52YWxpZGF0ZVxcXCIsdGhpcy5zZXR0aW5ncy5pbnZhbGlkSGFuZGxlcil9LGZvcm06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGVja0Zvcm0oKSxhLmV4dGVuZCh0aGlzLnN1Ym1pdHRlZCx0aGlzLmVycm9yTWFwKSx0aGlzLmludmFsaWQ9YS5leHRlbmQoe30sdGhpcy5lcnJvck1hcCksdGhpcy52YWxpZCgpfHxhKHRoaXMuY3VycmVudEZvcm0pLnRyaWdnZXJIYW5kbGVyKFxcXCJpbnZhbGlkLWZvcm1cXFwiLFt0aGlzXSksdGhpcy5zaG93RXJyb3JzKCksdGhpcy52YWxpZCgpfSxjaGVja0Zvcm06ZnVuY3Rpb24oKXt0aGlzLnByZXBhcmVGb3JtKCk7Zm9yKHZhciBhPTAsYj10aGlzLmN1cnJlbnRFbGVtZW50cz10aGlzLmVsZW1lbnRzKCk7YlthXTthKyspdGhpcy5jaGVjayhiW2FdKTtyZXR1cm4gdGhpcy52YWxpZCgpfSxlbGVtZW50OmZ1bmN0aW9uKGIpe3ZhciBjLGQsZT10aGlzLmNsZWFuKGIpLGY9dGhpcy52YWxpZGF0aW9uVGFyZ2V0Rm9yKGUpLGc9dGhpcyxoPSEwO3JldHVybiB2b2lkIDA9PT1mP2RlbGV0ZSB0aGlzLmludmFsaWRbZS5uYW1lXToodGhpcy5wcmVwYXJlRWxlbWVudChmKSx0aGlzLmN1cnJlbnRFbGVtZW50cz1hKGYpLGQ9dGhpcy5ncm91cHNbZi5uYW1lXSxkJiZhLmVhY2godGhpcy5ncm91cHMsZnVuY3Rpb24oYSxiKXtiPT09ZCYmYSE9PWYubmFtZSYmKGU9Zy52YWxpZGF0aW9uVGFyZ2V0Rm9yKGcuY2xlYW4oZy5maW5kQnlOYW1lKGEpKSksZSYmZS5uYW1lIGluIGcuaW52YWxpZCYmKGcuY3VycmVudEVsZW1lbnRzLnB1c2goZSksaD1nLmNoZWNrKGUpJiZoKSl9KSxjPXRoaXMuY2hlY2soZikhPT0hMSxoPWgmJmMsYz90aGlzLmludmFsaWRbZi5uYW1lXT0hMTp0aGlzLmludmFsaWRbZi5uYW1lXT0hMCx0aGlzLm51bWJlck9mSW52YWxpZHMoKXx8KHRoaXMudG9IaWRlPXRoaXMudG9IaWRlLmFkZCh0aGlzLmNvbnRhaW5lcnMpKSx0aGlzLnNob3dFcnJvcnMoKSxhKGIpLmF0dHIoXFxcImFyaWEtaW52YWxpZFxcXCIsIWMpKSxofSxzaG93RXJyb3JzOmZ1bmN0aW9uKGIpe2lmKGIpe3ZhciBjPXRoaXM7YS5leHRlbmQodGhpcy5lcnJvck1hcCxiKSx0aGlzLmVycm9yTGlzdD1hLm1hcCh0aGlzLmVycm9yTWFwLGZ1bmN0aW9uKGEsYil7cmV0dXJue21lc3NhZ2U6YSxlbGVtZW50OmMuZmluZEJ5TmFtZShiKVswXX19KSx0aGlzLnN1Y2Nlc3NMaXN0PWEuZ3JlcCh0aGlzLnN1Y2Nlc3NMaXN0LGZ1bmN0aW9uKGEpe3JldHVybiEoYS5uYW1lIGluIGIpfSl9dGhpcy5zZXR0aW5ncy5zaG93RXJyb3JzP3RoaXMuc2V0dGluZ3Muc2hvd0Vycm9ycy5jYWxsKHRoaXMsdGhpcy5lcnJvck1hcCx0aGlzLmVycm9yTGlzdCk6dGhpcy5kZWZhdWx0U2hvd0Vycm9ycygpfSxyZXNldEZvcm06ZnVuY3Rpb24oKXthLmZuLnJlc2V0Rm9ybSYmYSh0aGlzLmN1cnJlbnRGb3JtKS5yZXNldEZvcm0oKSx0aGlzLmludmFsaWQ9e30sdGhpcy5zdWJtaXR0ZWQ9e30sdGhpcy5wcmVwYXJlRm9ybSgpLHRoaXMuaGlkZUVycm9ycygpO3ZhciBiPXRoaXMuZWxlbWVudHMoKS5yZW1vdmVEYXRhKFxcXCJwcmV2aW91c1ZhbHVlXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1pbnZhbGlkXFxcIik7dGhpcy5yZXNldEVsZW1lbnRzKGIpfSxyZXNldEVsZW1lbnRzOmZ1bmN0aW9uKGEpe3ZhciBiO2lmKHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQpZm9yKGI9MDthW2JdO2IrKyl0aGlzLnNldHRpbmdzLnVuaGlnaGxpZ2h0LmNhbGwodGhpcyxhW2JdLHRoaXMuc2V0dGluZ3MuZXJyb3JDbGFzcyxcXFwiXFxcIiksdGhpcy5maW5kQnlOYW1lKGFbYl0ubmFtZSkucmVtb3ZlQ2xhc3ModGhpcy5zZXR0aW5ncy52YWxpZENsYXNzKTtlbHNlIGEucmVtb3ZlQ2xhc3ModGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLnNldHRpbmdzLnZhbGlkQ2xhc3MpfSxudW1iZXJPZkludmFsaWRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2JqZWN0TGVuZ3RoKHRoaXMuaW52YWxpZCl9LG9iamVjdExlbmd0aDpmdW5jdGlvbihhKXt2YXIgYixjPTA7Zm9yKGIgaW4gYSl2b2lkIDAhPT1hW2JdJiZudWxsIT09YVtiXSYmYVtiXSE9PSExJiZjKys7cmV0dXJuIGN9LGhpZGVFcnJvcnM6ZnVuY3Rpb24oKXt0aGlzLmhpZGVUaGVzZSh0aGlzLnRvSGlkZSl9LGhpZGVUaGVzZTpmdW5jdGlvbihhKXthLm5vdCh0aGlzLmNvbnRhaW5lcnMpLnRleHQoXFxcIlxcXCIpLHRoaXMuYWRkV3JhcHBlcihhKS5oaWRlKCl9LHZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLnNpemUoKX0sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVycm9yTGlzdC5sZW5ndGh9LGZvY3VzSW52YWxpZDpmdW5jdGlvbigpe2lmKHRoaXMuc2V0dGluZ3MuZm9jdXNJbnZhbGlkKXRyeXthKHRoaXMuZmluZExhc3RBY3RpdmUoKXx8dGhpcy5lcnJvckxpc3QubGVuZ3RoJiZ0aGlzLmVycm9yTGlzdFswXS5lbGVtZW50fHxbXSkuZmlsdGVyKFxcXCI6dmlzaWJsZVxcXCIpLnRyaWdnZXIoXFxcImZvY3VzXFxcIikudHJpZ2dlcihcXFwiZm9jdXNpblxcXCIpfWNhdGNoKGIpe319LGZpbmRMYXN0QWN0aXZlOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5sYXN0QWN0aXZlO3JldHVybiBiJiYxPT09YS5ncmVwKHRoaXMuZXJyb3JMaXN0LGZ1bmN0aW9uKGEpe3JldHVybiBhLmVsZW1lbnQubmFtZT09PWIubmFtZX0pLmxlbmd0aCYmYn0sZWxlbWVudHM6ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9e307cmV0dXJuIGEodGhpcy5jdXJyZW50Rm9ybSkuZmluZChcXFwiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFtjb250ZW50ZWRpdGFibGVdXFxcIikubm90KFxcXCI6c3VibWl0LCA6cmVzZXQsIDppbWFnZSwgOmRpc2FibGVkXFxcIikubm90KHRoaXMuc2V0dGluZ3MuaWdub3JlKS5maWx0ZXIoZnVuY3Rpb24oKXt2YXIgZD10aGlzLm5hbWV8fGEodGhpcykuYXR0cihcXFwibmFtZVxcXCIpLGU9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBhKHRoaXMpLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpJiZcXFwiZmFsc2VcXFwiIT09YSh0aGlzKS5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKTtyZXR1cm4hZCYmYi5zZXR0aW5ncy5kZWJ1ZyYmd2luZG93LmNvbnNvbGUmJmNvbnNvbGUuZXJyb3IoXFxcIiVvIGhhcyBubyBuYW1lIGFzc2lnbmVkXFxcIix0aGlzKSxlJiYodGhpcy5mb3JtPWEodGhpcykuY2xvc2VzdChcXFwiZm9ybVxcXCIpWzBdLHRoaXMubmFtZT1kKSx0aGlzLmZvcm09PT1iLmN1cnJlbnRGb3JtJiYoIShkIGluIGN8fCFiLm9iamVjdExlbmd0aChhKHRoaXMpLnJ1bGVzKCkpKSYmKGNbZF09ITAsITApKX0pfSxjbGVhbjpmdW5jdGlvbihiKXtyZXR1cm4gYShiKVswXX0sZXJyb3JzOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLnNwbGl0KFxcXCIgXFxcIikuam9pbihcXFwiLlxcXCIpO3JldHVybiBhKHRoaXMuc2V0dGluZ3MuZXJyb3JFbGVtZW50K1xcXCIuXFxcIitiLHRoaXMuZXJyb3JDb250ZXh0KX0scmVzZXRJbnRlcm5hbHM6ZnVuY3Rpb24oKXt0aGlzLnN1Y2Nlc3NMaXN0PVtdLHRoaXMuZXJyb3JMaXN0PVtdLHRoaXMuZXJyb3JNYXA9e30sdGhpcy50b1Nob3c9YShbXSksdGhpcy50b0hpZGU9YShbXSl9LHJlc2V0OmZ1bmN0aW9uKCl7dGhpcy5yZXNldEludGVybmFscygpLHRoaXMuY3VycmVudEVsZW1lbnRzPWEoW10pfSxwcmVwYXJlRm9ybTpmdW5jdGlvbigpe3RoaXMucmVzZXQoKSx0aGlzLnRvSGlkZT10aGlzLmVycm9ycygpLmFkZCh0aGlzLmNvbnRhaW5lcnMpfSxwcmVwYXJlRWxlbWVudDpmdW5jdGlvbihhKXt0aGlzLnJlc2V0KCksdGhpcy50b0hpZGU9dGhpcy5lcnJvcnNGb3IoYSl9LGVsZW1lbnRWYWx1ZTpmdW5jdGlvbihiKXt2YXIgYyxkLGU9YShiKSxmPWIudHlwZSxnPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZS5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKSYmXFxcImZhbHNlXFxcIiE9PWUuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIik7cmV0dXJuXFxcInJhZGlvXFxcIj09PWZ8fFxcXCJjaGVja2JveFxcXCI9PT1mP3RoaXMuZmluZEJ5TmFtZShiLm5hbWUpLmZpbHRlcihcXFwiOmNoZWNrZWRcXFwiKS52YWwoKTpcXFwibnVtYmVyXFxcIj09PWYmJlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi52YWxpZGl0eT9iLnZhbGlkaXR5LmJhZElucHV0P1xcXCJOYU5cXFwiOmUudmFsKCk6KGM9Zz9lLnRleHQoKTplLnZhbCgpLFxcXCJmaWxlXFxcIj09PWY/XFxcIkM6XFxcXFxcXFxmYWtlcGF0aFxcXFxcXFxcXFxcIj09PWMuc3Vic3RyKDAsMTIpP2Muc3Vic3RyKDEyKTooZD1jLmxhc3RJbmRleE9mKFxcXCIvXFxcIiksZD49MD9jLnN1YnN0cihkKzEpOihkPWMubGFzdEluZGV4T2YoXFxcIlxcXFxcXFxcXFxcIiksZD49MD9jLnN1YnN0cihkKzEpOmMpKTpcXFwic3RyaW5nXFxcIj09dHlwZW9mIGM/Yy5yZXBsYWNlKC9cXFxcci9nLFxcXCJcXFwiKTpjKX0sY2hlY2s6ZnVuY3Rpb24oYil7Yj10aGlzLnZhbGlkYXRpb25UYXJnZXRGb3IodGhpcy5jbGVhbihiKSk7dmFyIGMsZCxlLGYsZz1hKGIpLnJ1bGVzKCksaD1hLm1hcChnLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGJ9KS5sZW5ndGgsaT0hMSxqPXRoaXMuZWxlbWVudFZhbHVlKGIpO1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBnLm5vcm1hbGl6ZXI/Zj1nLm5vcm1hbGl6ZXI6XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHRoaXMuc2V0dGluZ3Mubm9ybWFsaXplciYmKGY9dGhpcy5zZXR0aW5ncy5ub3JtYWxpemVyKSxmJiYoaj1mLmNhbGwoYixqKSxkZWxldGUgZy5ub3JtYWxpemVyKTtmb3IoZCBpbiBnKXtlPXttZXRob2Q6ZCxwYXJhbWV0ZXJzOmdbZF19O3RyeXtpZihjPWEudmFsaWRhdG9yLm1ldGhvZHNbZF0uY2FsbCh0aGlzLGosYixlLnBhcmFtZXRlcnMpLFxcXCJkZXBlbmRlbmN5LW1pc21hdGNoXFxcIj09PWMmJjE9PT1oKXtpPSEwO2NvbnRpbnVlfWlmKGk9ITEsXFxcInBlbmRpbmdcXFwiPT09YylyZXR1cm4gdm9pZCh0aGlzLnRvSGlkZT10aGlzLnRvSGlkZS5ub3QodGhpcy5lcnJvcnNGb3IoYikpKTtpZighYylyZXR1cm4gdGhpcy5mb3JtYXRBbmRBZGQoYixlKSwhMX1jYXRjaChrKXt0aHJvdyB0aGlzLnNldHRpbmdzLmRlYnVnJiZ3aW5kb3cuY29uc29sZSYmY29uc29sZS5sb2coXFxcIkV4Y2VwdGlvbiBvY2N1cnJlZCB3aGVuIGNoZWNraW5nIGVsZW1lbnQgXFxcIitiLmlkK1xcXCIsIGNoZWNrIHRoZSAnXFxcIitlLm1ldGhvZCtcXFwiJyBtZXRob2QuXFxcIixrKSxrIGluc3RhbmNlb2YgVHlwZUVycm9yJiYoay5tZXNzYWdlKz1cXFwiLiAgRXhjZXB0aW9uIG9jY3VycmVkIHdoZW4gY2hlY2tpbmcgZWxlbWVudCBcXFwiK2IuaWQrXFxcIiwgY2hlY2sgdGhlICdcXFwiK2UubWV0aG9kK1xcXCInIG1ldGhvZC5cXFwiKSxrfX1pZighaSlyZXR1cm4gdGhpcy5vYmplY3RMZW5ndGgoZykmJnRoaXMuc3VjY2Vzc0xpc3QucHVzaChiKSwhMH0sY3VzdG9tRGF0YU1lc3NhZ2U6ZnVuY3Rpb24oYixjKXtyZXR1cm4gYShiKS5kYXRhKFxcXCJtc2dcXFwiK2MuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYy5zdWJzdHJpbmcoMSkudG9Mb3dlckNhc2UoKSl8fGEoYikuZGF0YShcXFwibXNnXFxcIil9LGN1c3RvbU1lc3NhZ2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLnNldHRpbmdzLm1lc3NhZ2VzW2FdO3JldHVybiBjJiYoYy5jb25zdHJ1Y3Rvcj09PVN0cmluZz9jOmNbYl0pfSxmaW5kRGVmaW5lZDpmdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8YXJndW1lbnRzLmxlbmd0aDthKyspaWYodm9pZCAwIT09YXJndW1lbnRzW2FdKXJldHVybiBhcmd1bWVudHNbYV19LGRlZmF1bHRNZXNzYWdlOmZ1bmN0aW9uKGIsYyl7XFxcInN0cmluZ1xcXCI9PXR5cGVvZiBjJiYoYz17bWV0aG9kOmN9KTt2YXIgZD10aGlzLmZpbmREZWZpbmVkKHRoaXMuY3VzdG9tTWVzc2FnZShiLm5hbWUsYy5tZXRob2QpLHRoaXMuY3VzdG9tRGF0YU1lc3NhZ2UoYixjLm1ldGhvZCksIXRoaXMuc2V0dGluZ3MuaWdub3JlVGl0bGUmJmIudGl0bGV8fHZvaWQgMCxhLnZhbGlkYXRvci5tZXNzYWdlc1tjLm1ldGhvZF0sXFxcIjxzdHJvbmc+V2FybmluZzogTm8gbWVzc2FnZSBkZWZpbmVkIGZvciBcXFwiK2IubmFtZStcXFwiPC9zdHJvbmc+XFxcIiksZT0vXFxcXCQ/XFxcXHsoXFxcXGQrKVxcXFx9L2c7cmV0dXJuXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGQ/ZD1kLmNhbGwodGhpcyxjLnBhcmFtZXRlcnMsYik6ZS50ZXN0KGQpJiYoZD1hLnZhbGlkYXRvci5mb3JtYXQoZC5yZXBsYWNlKGUsXFxcInskMX1cXFwiKSxjLnBhcmFtZXRlcnMpKSxkfSxmb3JtYXRBbmRBZGQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmRlZmF1bHRNZXNzYWdlKGEsYik7dGhpcy5lcnJvckxpc3QucHVzaCh7bWVzc2FnZTpjLGVsZW1lbnQ6YSxtZXRob2Q6Yi5tZXRob2R9KSx0aGlzLmVycm9yTWFwW2EubmFtZV09Yyx0aGlzLnN1Ym1pdHRlZFthLm5hbWVdPWN9LGFkZFdyYXBwZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuc2V0dGluZ3Mud3JhcHBlciYmKGE9YS5hZGQoYS5wYXJlbnQodGhpcy5zZXR0aW5ncy53cmFwcGVyKSkpLGF9LGRlZmF1bHRTaG93RXJyb3JzOmZ1bmN0aW9uKCl7dmFyIGEsYixjO2ZvcihhPTA7dGhpcy5lcnJvckxpc3RbYV07YSsrKWM9dGhpcy5lcnJvckxpc3RbYV0sdGhpcy5zZXR0aW5ncy5oaWdobGlnaHQmJnRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0LmNhbGwodGhpcyxjLmVsZW1lbnQsdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyksdGhpcy5zaG93TGFiZWwoYy5lbGVtZW50LGMubWVzc2FnZSk7aWYodGhpcy5lcnJvckxpc3QubGVuZ3RoJiYodGhpcy50b1Nob3c9dGhpcy50b1Nob3cuYWRkKHRoaXMuY29udGFpbmVycykpLHRoaXMuc2V0dGluZ3Muc3VjY2Vzcylmb3IoYT0wO3RoaXMuc3VjY2Vzc0xpc3RbYV07YSsrKXRoaXMuc2hvd0xhYmVsKHRoaXMuc3VjY2Vzc0xpc3RbYV0pO2lmKHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQpZm9yKGE9MCxiPXRoaXMudmFsaWRFbGVtZW50cygpO2JbYV07YSsrKXRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQuY2FsbCh0aGlzLGJbYV0sdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyk7dGhpcy50b0hpZGU9dGhpcy50b0hpZGUubm90KHRoaXMudG9TaG93KSx0aGlzLmhpZGVFcnJvcnMoKSx0aGlzLmFkZFdyYXBwZXIodGhpcy50b1Nob3cpLnNob3coKX0sdmFsaWRFbGVtZW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN1cnJlbnRFbGVtZW50cy5ub3QodGhpcy5pbnZhbGlkRWxlbWVudHMoKSl9LGludmFsaWRFbGVtZW50czpmdW5jdGlvbigpe3JldHVybiBhKHRoaXMuZXJyb3JMaXN0KS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbGVtZW50fSl9LHNob3dMYWJlbDpmdW5jdGlvbihiLGMpe3ZhciBkLGUsZixnLGg9dGhpcy5lcnJvcnNGb3IoYiksaT10aGlzLmlkT3JOYW1lKGIpLGo9YShiKS5hdHRyKFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIik7aC5sZW5ndGg/KGgucmVtb3ZlQ2xhc3ModGhpcy5zZXR0aW5ncy52YWxpZENsYXNzKS5hZGRDbGFzcyh0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MpLGguaHRtbChjKSk6KGg9YShcXFwiPFxcXCIrdGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQrXFxcIj5cXFwiKS5hdHRyKFxcXCJpZFxcXCIsaStcXFwiLWVycm9yXFxcIikuYWRkQ2xhc3ModGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzKS5odG1sKGN8fFxcXCJcXFwiKSxkPWgsdGhpcy5zZXR0aW5ncy53cmFwcGVyJiYoZD1oLmhpZGUoKS5zaG93KCkud3JhcChcXFwiPFxcXCIrdGhpcy5zZXR0aW5ncy53cmFwcGVyK1xcXCIvPlxcXCIpLnBhcmVudCgpKSx0aGlzLmxhYmVsQ29udGFpbmVyLmxlbmd0aD90aGlzLmxhYmVsQ29udGFpbmVyLmFwcGVuZChkKTp0aGlzLnNldHRpbmdzLmVycm9yUGxhY2VtZW50P3RoaXMuc2V0dGluZ3MuZXJyb3JQbGFjZW1lbnQuY2FsbCh0aGlzLGQsYShiKSk6ZC5pbnNlcnRBZnRlcihiKSxoLmlzKFxcXCJsYWJlbFxcXCIpP2guYXR0cihcXFwiZm9yXFxcIixpKTowPT09aC5wYXJlbnRzKFxcXCJsYWJlbFtmb3I9J1xcXCIrdGhpcy5lc2NhcGVDc3NNZXRhKGkpK1xcXCInXVxcXCIpLmxlbmd0aCYmKGY9aC5hdHRyKFxcXCJpZFxcXCIpLGo/ai5tYXRjaChuZXcgUmVnRXhwKFxcXCJcXFxcXFxcXGJcXFwiK3RoaXMuZXNjYXBlQ3NzTWV0YShmKStcXFwiXFxcXFxcXFxiXFxcIikpfHwoais9XFxcIiBcXFwiK2YpOmo9ZixhKGIpLmF0dHIoXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiLGopLGU9dGhpcy5ncm91cHNbYi5uYW1lXSxlJiYoZz10aGlzLGEuZWFjaChnLmdyb3VwcyxmdW5jdGlvbihiLGMpe2M9PT1lJiZhKFxcXCJbbmFtZT0nXFxcIitnLmVzY2FwZUNzc01ldGEoYikrXFxcIiddXFxcIixnLmN1cnJlbnRGb3JtKS5hdHRyKFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIixoLmF0dHIoXFxcImlkXFxcIikpfSkpKSksIWMmJnRoaXMuc2V0dGluZ3Muc3VjY2VzcyYmKGgudGV4dChcXFwiXFxcIiksXFxcInN0cmluZ1xcXCI9PXR5cGVvZiB0aGlzLnNldHRpbmdzLnN1Y2Nlc3M/aC5hZGRDbGFzcyh0aGlzLnNldHRpbmdzLnN1Y2Nlc3MpOnRoaXMuc2V0dGluZ3Muc3VjY2VzcyhoLGIpKSx0aGlzLnRvU2hvdz10aGlzLnRvU2hvdy5hZGQoaCl9LGVycm9yc0ZvcjpmdW5jdGlvbihiKXt2YXIgYz10aGlzLmVzY2FwZUNzc01ldGEodGhpcy5pZE9yTmFtZShiKSksZD1hKGIpLmF0dHIoXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiKSxlPVxcXCJsYWJlbFtmb3I9J1xcXCIrYytcXFwiJ10sIGxhYmVsW2Zvcj0nXFxcIitjK1xcXCInXSAqXFxcIjtyZXR1cm4gZCYmKGU9ZStcXFwiLCAjXFxcIit0aGlzLmVzY2FwZUNzc01ldGEoZCkucmVwbGFjZSgvXFxcXHMrL2csXFxcIiwgI1xcXCIpKSx0aGlzLmVycm9ycygpLmZpbHRlcihlKX0sZXNjYXBlQ3NzTWV0YTpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKC8oW1xcXFxcXFxcIVxcXCIjJCUmJygpKissLlxcXFwvOjs8PT4/QFxcXFxbXFxcXF1eYHt8fX5dKS9nLFxcXCJcXFxcXFxcXCQxXFxcIil9LGlkT3JOYW1lOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdyb3Vwc1thLm5hbWVdfHwodGhpcy5jaGVja2FibGUoYSk/YS5uYW1lOmEuaWR8fGEubmFtZSl9LHZhbGlkYXRpb25UYXJnZXRGb3I6ZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMuY2hlY2thYmxlKGIpJiYoYj10aGlzLmZpbmRCeU5hbWUoYi5uYW1lKSksYShiKS5ub3QodGhpcy5zZXR0aW5ncy5pZ25vcmUpWzBdfSxjaGVja2FibGU6ZnVuY3Rpb24oYSl7cmV0dXJuL3JhZGlvfGNoZWNrYm94L2kudGVzdChhLnR5cGUpfSxmaW5kQnlOYW1lOmZ1bmN0aW9uKGIpe3JldHVybiBhKHRoaXMuY3VycmVudEZvcm0pLmZpbmQoXFxcIltuYW1lPSdcXFwiK3RoaXMuZXNjYXBlQ3NzTWV0YShiKStcXFwiJ11cXFwiKX0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKGIsYyl7c3dpdGNoKGMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSl7Y2FzZVxcXCJzZWxlY3RcXFwiOnJldHVybiBhKFxcXCJvcHRpb246c2VsZWN0ZWRcXFwiLGMpLmxlbmd0aDtjYXNlXFxcImlucHV0XFxcIjppZih0aGlzLmNoZWNrYWJsZShjKSlyZXR1cm4gdGhpcy5maW5kQnlOYW1lKGMubmFtZSkuZmlsdGVyKFxcXCI6Y2hlY2tlZFxcXCIpLmxlbmd0aH1yZXR1cm4gYi5sZW5ndGh9LGRlcGVuZDpmdW5jdGlvbihhLGIpe3JldHVybiF0aGlzLmRlcGVuZFR5cGVzW3R5cGVvZiBhXXx8dGhpcy5kZXBlbmRUeXBlc1t0eXBlb2YgYV0oYSxiKX0sZGVwZW5kVHlwZXM6e1xcXCJib29sZWFuXFxcIjpmdW5jdGlvbihhKXtyZXR1cm4gYX0sc3RyaW5nOmZ1bmN0aW9uKGIsYyl7cmV0dXJuISFhKGIsYy5mb3JtKS5sZW5ndGh9LFxcXCJmdW5jdGlvblxcXCI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYShiKX19LG9wdGlvbmFsOmZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMuZWxlbWVudFZhbHVlKGIpO3JldHVybiFhLnZhbGlkYXRvci5tZXRob2RzLnJlcXVpcmVkLmNhbGwodGhpcyxjLGIpJiZcXFwiZGVwZW5kZW5jeS1taXNtYXRjaFxcXCJ9LHN0YXJ0UmVxdWVzdDpmdW5jdGlvbihiKXt0aGlzLnBlbmRpbmdbYi5uYW1lXXx8KHRoaXMucGVuZGluZ1JlcXVlc3QrKyxhKGIpLmFkZENsYXNzKHRoaXMuc2V0dGluZ3MucGVuZGluZ0NsYXNzKSx0aGlzLnBlbmRpbmdbYi5uYW1lXT0hMCl9LHN0b3BSZXF1ZXN0OmZ1bmN0aW9uKGIsYyl7dGhpcy5wZW5kaW5nUmVxdWVzdC0tLHRoaXMucGVuZGluZ1JlcXVlc3Q8MCYmKHRoaXMucGVuZGluZ1JlcXVlc3Q9MCksZGVsZXRlIHRoaXMucGVuZGluZ1tiLm5hbWVdLGEoYikucmVtb3ZlQ2xhc3ModGhpcy5zZXR0aW5ncy5wZW5kaW5nQ2xhc3MpLGMmJjA9PT10aGlzLnBlbmRpbmdSZXF1ZXN0JiZ0aGlzLmZvcm1TdWJtaXR0ZWQmJnRoaXMuZm9ybSgpPyhhKHRoaXMuY3VycmVudEZvcm0pLnN1Ym1pdCgpLHRoaXMuc3VibWl0QnV0dG9uJiZhKFxcXCJpbnB1dDpoaWRkZW5bbmFtZT0nXFxcIit0aGlzLnN1Ym1pdEJ1dHRvbi5uYW1lK1xcXCInXVxcXCIsdGhpcy5jdXJyZW50Rm9ybSkucmVtb3ZlKCksdGhpcy5mb3JtU3VibWl0dGVkPSExKTohYyYmMD09PXRoaXMucGVuZGluZ1JlcXVlc3QmJnRoaXMuZm9ybVN1Ym1pdHRlZCYmKGEodGhpcy5jdXJyZW50Rm9ybSkudHJpZ2dlckhhbmRsZXIoXFxcImludmFsaWQtZm9ybVxcXCIsW3RoaXNdKSx0aGlzLmZvcm1TdWJtaXR0ZWQ9ITEpfSxwcmV2aW91c1ZhbHVlOmZ1bmN0aW9uKGIsYyl7cmV0dXJuIGM9XFxcInN0cmluZ1xcXCI9PXR5cGVvZiBjJiZjfHxcXFwicmVtb3RlXFxcIixhLmRhdGEoYixcXFwicHJldmlvdXNWYWx1ZVxcXCIpfHxhLmRhdGEoYixcXFwicHJldmlvdXNWYWx1ZVxcXCIse29sZDpudWxsLHZhbGlkOiEwLG1lc3NhZ2U6dGhpcy5kZWZhdWx0TWVzc2FnZShiLHttZXRob2Q6Y30pfSl9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLnJlc2V0Rm9ybSgpLGEodGhpcy5jdXJyZW50Rm9ybSkub2ZmKFxcXCIudmFsaWRhdGVcXFwiKS5yZW1vdmVEYXRhKFxcXCJ2YWxpZGF0b3JcXFwiKS5maW5kKFxcXCIudmFsaWRhdGUtZXF1YWxUby1ibHVyXFxcIikub2ZmKFxcXCIudmFsaWRhdGUtZXF1YWxUb1xcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWxpZGF0ZS1lcXVhbFRvLWJsdXJcXFwiKS5maW5kKFxcXCIudmFsaWRhdGUtbGVzc1RoYW4tYmx1clxcXCIpLm9mZihcXFwiLnZhbGlkYXRlLWxlc3NUaGFuXFxcIikucmVtb3ZlQ2xhc3MoXFxcInZhbGlkYXRlLWxlc3NUaGFuLWJsdXJcXFwiKS5maW5kKFxcXCIudmFsaWRhdGUtbGVzc1RoYW5FcXVhbC1ibHVyXFxcIikub2ZmKFxcXCIudmFsaWRhdGUtbGVzc1RoYW5FcXVhbFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWxpZGF0ZS1sZXNzVGhhbkVxdWFsLWJsdXJcXFwiKS5maW5kKFxcXCIudmFsaWRhdGUtZ3JlYXRlclRoYW5FcXVhbC1ibHVyXFxcIikub2ZmKFxcXCIudmFsaWRhdGUtZ3JlYXRlclRoYW5FcXVhbFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWxpZGF0ZS1ncmVhdGVyVGhhbkVxdWFsLWJsdXJcXFwiKS5maW5kKFxcXCIudmFsaWRhdGUtZ3JlYXRlclRoYW4tYmx1clxcXCIpLm9mZihcXFwiLnZhbGlkYXRlLWdyZWF0ZXJUaGFuXFxcIikucmVtb3ZlQ2xhc3MoXFxcInZhbGlkYXRlLWdyZWF0ZXJUaGFuLWJsdXJcXFwiKX19LGNsYXNzUnVsZVNldHRpbmdzOntyZXF1aXJlZDp7cmVxdWlyZWQ6ITB9LGVtYWlsOntlbWFpbDohMH0sdXJsOnt1cmw6ITB9LGRhdGU6e2RhdGU6ITB9LGRhdGVJU086e2RhdGVJU086ITB9LG51bWJlcjp7bnVtYmVyOiEwfSxkaWdpdHM6e2RpZ2l0czohMH0sY3JlZGl0Y2FyZDp7Y3JlZGl0Y2FyZDohMH19LGFkZENsYXNzUnVsZXM6ZnVuY3Rpb24oYixjKXtiLmNvbnN0cnVjdG9yPT09U3RyaW5nP3RoaXMuY2xhc3NSdWxlU2V0dGluZ3NbYl09YzphLmV4dGVuZCh0aGlzLmNsYXNzUnVsZVNldHRpbmdzLGIpfSxjbGFzc1J1bGVzOmZ1bmN0aW9uKGIpe3ZhciBjPXt9LGQ9YShiKS5hdHRyKFxcXCJjbGFzc1xcXCIpO3JldHVybiBkJiZhLmVhY2goZC5zcGxpdChcXFwiIFxcXCIpLGZ1bmN0aW9uKCl7dGhpcyBpbiBhLnZhbGlkYXRvci5jbGFzc1J1bGVTZXR0aW5ncyYmYS5leHRlbmQoYyxhLnZhbGlkYXRvci5jbGFzc1J1bGVTZXR0aW5nc1t0aGlzXSl9KSxjfSxub3JtYWxpemVBdHRyaWJ1dGVSdWxlOmZ1bmN0aW9uKGEsYixjLGQpey9taW58bWF4fHN0ZXAvLnRlc3QoYykmJihudWxsPT09Ynx8L251bWJlcnxyYW5nZXx0ZXh0Ly50ZXN0KGIpKSYmKGQ9TnVtYmVyKGQpLGlzTmFOKGQpJiYoZD12b2lkIDApKSxkfHwwPT09ZD9hW2NdPWQ6Yj09PWMmJlxcXCJyYW5nZVxcXCIhPT1iJiYoYVtjXT0hMCl9LGF0dHJpYnV0ZVJ1bGVzOmZ1bmN0aW9uKGIpe3ZhciBjLGQsZT17fSxmPWEoYiksZz1iLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpO2ZvcihjIGluIGEudmFsaWRhdG9yLm1ldGhvZHMpXFxcInJlcXVpcmVkXFxcIj09PWM/KGQ9Yi5nZXRBdHRyaWJ1dGUoYyksXFxcIlxcXCI9PT1kJiYoZD0hMCksZD0hIWQpOmQ9Zi5hdHRyKGMpLHRoaXMubm9ybWFsaXplQXR0cmlidXRlUnVsZShlLGcsYyxkKTtyZXR1cm4gZS5tYXhsZW5ndGgmJi8tMXwyMTQ3NDgzNjQ3fDUyNDI4OC8udGVzdChlLm1heGxlbmd0aCkmJmRlbGV0ZSBlLm1heGxlbmd0aCxlfSxkYXRhUnVsZXM6ZnVuY3Rpb24oYil7dmFyIGMsZCxlPXt9LGY9YShiKSxnPWIuZ2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIik7Zm9yKGMgaW4gYS52YWxpZGF0b3IubWV0aG9kcylkPWYuZGF0YShcXFwicnVsZVxcXCIrYy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStjLnN1YnN0cmluZygxKS50b0xvd2VyQ2FzZSgpKSxcXFwiXFxcIj09PWQmJihkPSEwKSx0aGlzLm5vcm1hbGl6ZUF0dHJpYnV0ZVJ1bGUoZSxnLGMsZCk7cmV0dXJuIGV9LHN0YXRpY1J1bGVzOmZ1bmN0aW9uKGIpe3ZhciBjPXt9LGQ9YS5kYXRhKGIuZm9ybSxcXFwidmFsaWRhdG9yXFxcIik7cmV0dXJuIGQuc2V0dGluZ3MucnVsZXMmJihjPWEudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGUoZC5zZXR0aW5ncy5ydWxlc1tiLm5hbWVdKXx8e30pLGN9LG5vcm1hbGl6ZVJ1bGVzOmZ1bmN0aW9uKGIsYyl7cmV0dXJuIGEuZWFjaChiLGZ1bmN0aW9uKGQsZSl7aWYoZT09PSExKXJldHVybiB2b2lkIGRlbGV0ZSBiW2RdO2lmKGUucGFyYW18fGUuZGVwZW5kcyl7dmFyIGY9ITA7c3dpdGNoKHR5cGVvZiBlLmRlcGVuZHMpe2Nhc2VcXFwic3RyaW5nXFxcIjpmPSEhYShlLmRlcGVuZHMsYy5mb3JtKS5sZW5ndGg7YnJlYWs7Y2FzZVxcXCJmdW5jdGlvblxcXCI6Zj1lLmRlcGVuZHMuY2FsbChjLGMpfWY/YltkXT12b2lkIDA9PT1lLnBhcmFtfHxlLnBhcmFtOihhLmRhdGEoYy5mb3JtLFxcXCJ2YWxpZGF0b3JcXFwiKS5yZXNldEVsZW1lbnRzKGEoYykpLGRlbGV0ZSBiW2RdKX19KSxhLmVhY2goYixmdW5jdGlvbihkLGUpe2JbZF09YS5pc0Z1bmN0aW9uKGUpJiZcXFwibm9ybWFsaXplclxcXCIhPT1kP2UoYyk6ZX0pLGEuZWFjaChbXFxcIm1pbmxlbmd0aFxcXCIsXFxcIm1heGxlbmd0aFxcXCJdLGZ1bmN0aW9uKCl7Ylt0aGlzXSYmKGJbdGhpc109TnVtYmVyKGJbdGhpc10pKX0pLGEuZWFjaChbXFxcInJhbmdlbGVuZ3RoXFxcIixcXFwicmFuZ2VcXFwiXSxmdW5jdGlvbigpe3ZhciBjO2JbdGhpc10mJihhLmlzQXJyYXkoYlt0aGlzXSk/Ylt0aGlzXT1bTnVtYmVyKGJbdGhpc11bMF0pLE51bWJlcihiW3RoaXNdWzFdKV06XFxcInN0cmluZ1xcXCI9PXR5cGVvZiBiW3RoaXNdJiYoYz1iW3RoaXNdLnJlcGxhY2UoL1tcXFxcW1xcXFxdXS9nLFxcXCJcXFwiKS5zcGxpdCgvW1xcXFxzLF0rLyksYlt0aGlzXT1bTnVtYmVyKGNbMF0pLE51bWJlcihjWzFdKV0pKX0pLGEudmFsaWRhdG9yLmF1dG9DcmVhdGVSYW5nZXMmJihudWxsIT1iLm1pbiYmbnVsbCE9Yi5tYXgmJihiLnJhbmdlPVtiLm1pbixiLm1heF0sZGVsZXRlIGIubWluLGRlbGV0ZSBiLm1heCksbnVsbCE9Yi5taW5sZW5ndGgmJm51bGwhPWIubWF4bGVuZ3RoJiYoYi5yYW5nZWxlbmd0aD1bYi5taW5sZW5ndGgsYi5tYXhsZW5ndGhdLGRlbGV0ZSBiLm1pbmxlbmd0aCxkZWxldGUgYi5tYXhsZW5ndGgpKSxifSxub3JtYWxpemVSdWxlOmZ1bmN0aW9uKGIpe2lmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgYil7dmFyIGM9e307YS5lYWNoKGIuc3BsaXQoL1xcXFxzLyksZnVuY3Rpb24oKXtjW3RoaXNdPSEwfSksYj1jfXJldHVybiBifSxhZGRNZXRob2Q6ZnVuY3Rpb24oYixjLGQpe2EudmFsaWRhdG9yLm1ldGhvZHNbYl09YyxhLnZhbGlkYXRvci5tZXNzYWdlc1tiXT12b2lkIDAhPT1kP2Q6YS52YWxpZGF0b3IubWVzc2FnZXNbYl0sYy5sZW5ndGg8MyYmYS52YWxpZGF0b3IuYWRkQ2xhc3NSdWxlcyhiLGEudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGUoYikpfSxtZXRob2RzOntyZXF1aXJlZDpmdW5jdGlvbihiLGMsZCl7aWYoIXRoaXMuZGVwZW5kKGQsYykpcmV0dXJuXFxcImRlcGVuZGVuY3ktbWlzbWF0Y2hcXFwiO2lmKFxcXCJzZWxlY3RcXFwiPT09Yy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKXt2YXIgZT1hKGMpLnZhbCgpO3JldHVybiBlJiZlLmxlbmd0aD4wfXJldHVybiB0aGlzLmNoZWNrYWJsZShjKT90aGlzLmdldExlbmd0aChiLGMpPjA6dm9pZCAwIT09YiYmbnVsbCE9PWImJmIubGVuZ3RoPjB9LGVtYWlsOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMub3B0aW9uYWwoYil8fC9eW2EtekEtWjAtOS4hIyQlJicqK1xcXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcXFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLy50ZXN0KGEpfSx1cmw6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5vcHRpb25hbChiKXx8L14oPzooPzooPzpodHRwcz98ZnRwKTopP1xcXFwvXFxcXC8pKD86XFxcXFMrKD86OlxcXFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcXFwuXFxcXGR7MSwzfSl7M30pKD8hKD86MTY5XFxcXC4yNTR8MTkyXFxcXC4xNjgpKD86XFxcXC5cXFxcZHsxLDN9KXsyfSkoPyExNzJcXFxcLig/OjFbNi05XXwyXFxcXGR8M1swLTFdKSg/OlxcXFwuXFxcXGR7MSwzfSl7Mn0pKD86WzEtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswMV1cXFxcZHwyMlswLTNdKSg/OlxcXFwuKD86MT9cXFxcZHsxLDJ9fDJbMC00XVxcXFxkfDI1WzAtNV0pKXsyfSg/OlxcXFwuKD86WzEtOV1cXFxcZD98MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC00XSkpfCg/Oig/OlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XS0qKSpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0rKSg/OlxcXFwuKD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldLSopKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspKig/OlxcXFwuKD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmZdezIsfSkpLj8pKD86OlxcXFxkezIsNX0pPyg/OltcXFxcLz8jXVxcXFxTKik/JC9pLnRlc3QoYSl9LGRhdGU6ZnVuY3Rpb24oKXt2YXIgYT0hMTtyZXR1cm4gZnVuY3Rpb24oYixjKXtyZXR1cm4gYXx8KGE9ITAsdGhpcy5zZXR0aW5ncy5kZWJ1ZyYmd2luZG93LmNvbnNvbGUmJmNvbnNvbGUud2FybihcXFwiVGhlIGBkYXRlYCBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gJzIuMC4wJy5cXFxcblBsZWFzZSBkb24ndCB1c2UgaXQsIHNpbmNlIGl0IHJlbGllcyBvbiB0aGUgRGF0ZSBjb25zdHJ1Y3Rvciwgd2hpY2hcXFxcbmJlaGF2ZXMgdmVyeSBkaWZmZXJlbnRseSBhY3Jvc3MgYnJvd3NlcnMgYW5kIGxvY2FsZXMuIFVzZSBgZGF0ZUlTT2BcXFxcbmluc3RlYWQgb3Igb25lIG9mIHRoZSBsb2NhbGUgc3BlY2lmaWMgbWV0aG9kcyBpbiBgbG9jYWxpemF0aW9ucy9gXFxcXG5hbmQgYGFkZGl0aW9uYWwtbWV0aG9kcy5qc2AuXFxcIikpLHRoaXMub3B0aW9uYWwoYyl8fCEvSW52YWxpZHxOYU4vLnRlc3QobmV3IERhdGUoYikudG9TdHJpbmcoKSl9fSgpLGRhdGVJU086ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5vcHRpb25hbChiKXx8L15cXFxcZHs0fVtcXFxcL1xcXFwtXSgwP1sxLTldfDFbMDEyXSlbXFxcXC9cXFxcLV0oMD9bMS05XXxbMTJdWzAtOV18M1swMV0pJC8udGVzdChhKX0sbnVtYmVyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMub3B0aW9uYWwoYil8fC9eKD86LT9cXFxcZCt8LT9cXFxcZHsxLDN9KD86LFxcXFxkezN9KSspPyg/OlxcXFwuXFxcXGQrKT8kLy50ZXN0KGEpfSxkaWdpdHM6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5vcHRpb25hbChiKXx8L15cXFxcZCskLy50ZXN0KGEpfSxtaW5sZW5ndGg6ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEuaXNBcnJheShiKT9iLmxlbmd0aDp0aGlzLmdldExlbmd0aChiLGMpO3JldHVybiB0aGlzLm9wdGlvbmFsKGMpfHxlPj1kfSxtYXhsZW5ndGg6ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEuaXNBcnJheShiKT9iLmxlbmd0aDp0aGlzLmdldExlbmd0aChiLGMpO3JldHVybiB0aGlzLm9wdGlvbmFsKGMpfHxlPD1kfSxyYW5nZWxlbmd0aDpmdW5jdGlvbihiLGMsZCl7dmFyIGU9YS5pc0FycmF5KGIpP2IubGVuZ3RoOnRoaXMuZ2V0TGVuZ3RoKGIsYyk7cmV0dXJuIHRoaXMub3B0aW9uYWwoYyl8fGU+PWRbMF0mJmU8PWRbMV19LG1pbjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMub3B0aW9uYWwoYil8fGE+PWN9LG1heDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMub3B0aW9uYWwoYil8fGE8PWN9LHJhbmdlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdGhpcy5vcHRpb25hbChiKXx8YT49Y1swXSYmYTw9Y1sxXX0sc3RlcDpmdW5jdGlvbihiLGMsZCl7dmFyIGUsZj1hKGMpLmF0dHIoXFxcInR5cGVcXFwiKSxnPVxcXCJTdGVwIGF0dHJpYnV0ZSBvbiBpbnB1dCB0eXBlIFxcXCIrZitcXFwiIGlzIG5vdCBzdXBwb3J0ZWQuXFxcIixoPVtcXFwidGV4dFxcXCIsXFxcIm51bWJlclxcXCIsXFxcInJhbmdlXFxcIl0saT1uZXcgUmVnRXhwKFxcXCJcXFxcXFxcXGJcXFwiK2YrXFxcIlxcXFxcXFxcYlxcXCIpLGo9ZiYmIWkudGVzdChoLmpvaW4oKSksaz1mdW5jdGlvbihhKXt2YXIgYj0oXFxcIlxcXCIrYSkubWF0Y2goLyg/OlxcXFwuKFxcXFxkKykpPyQvKTtyZXR1cm4gYiYmYlsxXT9iWzFdLmxlbmd0aDowfSxsPWZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnJvdW5kKGEqTWF0aC5wb3coMTAsZSkpfSxtPSEwO2lmKGopdGhyb3cgbmV3IEVycm9yKGcpO3JldHVybiBlPWsoZCksKGsoYik+ZXx8bChiKSVsKGQpIT09MCkmJihtPSExKSx0aGlzLm9wdGlvbmFsKGMpfHxtfSxlcXVhbFRvOmZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1hKGQpO3JldHVybiB0aGlzLnNldHRpbmdzLm9uZm9jdXNvdXQmJmUubm90KFxcXCIudmFsaWRhdGUtZXF1YWxUby1ibHVyXFxcIikubGVuZ3RoJiZlLmFkZENsYXNzKFxcXCJ2YWxpZGF0ZS1lcXVhbFRvLWJsdXJcXFwiKS5vbihcXFwiYmx1ci52YWxpZGF0ZS1lcXVhbFRvXFxcIixmdW5jdGlvbigpe2EoYykudmFsaWQoKX0pLGI9PT1lLnZhbCgpfSxyZW1vdGU6ZnVuY3Rpb24oYixjLGQsZSl7aWYodGhpcy5vcHRpb25hbChjKSlyZXR1cm5cXFwiZGVwZW5kZW5jeS1taXNtYXRjaFxcXCI7ZT1cXFwic3RyaW5nXFxcIj09dHlwZW9mIGUmJmV8fFxcXCJyZW1vdGVcXFwiO3ZhciBmLGcsaCxpPXRoaXMucHJldmlvdXNWYWx1ZShjLGUpO3JldHVybiB0aGlzLnNldHRpbmdzLm1lc3NhZ2VzW2MubmFtZV18fCh0aGlzLnNldHRpbmdzLm1lc3NhZ2VzW2MubmFtZV09e30pLGkub3JpZ2luYWxNZXNzYWdlPWkub3JpZ2luYWxNZXNzYWdlfHx0aGlzLnNldHRpbmdzLm1lc3NhZ2VzW2MubmFtZV1bZV0sdGhpcy5zZXR0aW5ncy5tZXNzYWdlc1tjLm5hbWVdW2VdPWkubWVzc2FnZSxkPVxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZCYme3VybDpkfXx8ZCxoPWEucGFyYW0oYS5leHRlbmQoe2RhdGE6Yn0sZC5kYXRhKSksaS5vbGQ9PT1oP2kudmFsaWQ6KGkub2xkPWgsZj10aGlzLHRoaXMuc3RhcnRSZXF1ZXN0KGMpLGc9e30sZ1tjLm5hbWVdPWIsYS5hamF4KGEuZXh0ZW5kKCEwLHttb2RlOlxcXCJhYm9ydFxcXCIscG9ydDpcXFwidmFsaWRhdGVcXFwiK2MubmFtZSxkYXRhVHlwZTpcXFwianNvblxcXCIsZGF0YTpnLGNvbnRleHQ6Zi5jdXJyZW50Rm9ybSxzdWNjZXNzOmZ1bmN0aW9uKGEpe3ZhciBkLGcsaCxqPWE9PT0hMHx8XFxcInRydWVcXFwiPT09YTtmLnNldHRpbmdzLm1lc3NhZ2VzW2MubmFtZV1bZV09aS5vcmlnaW5hbE1lc3NhZ2Usaj8oaD1mLmZvcm1TdWJtaXR0ZWQsZi5yZXNldEludGVybmFscygpLGYudG9IaWRlPWYuZXJyb3JzRm9yKGMpLGYuZm9ybVN1Ym1pdHRlZD1oLGYuc3VjY2Vzc0xpc3QucHVzaChjKSxmLmludmFsaWRbYy5uYW1lXT0hMSxmLnNob3dFcnJvcnMoKSk6KGQ9e30sZz1hfHxmLmRlZmF1bHRNZXNzYWdlKGMse21ldGhvZDplLHBhcmFtZXRlcnM6Yn0pLGRbYy5uYW1lXT1pLm1lc3NhZ2U9ZyxmLmludmFsaWRbYy5uYW1lXT0hMCxmLnNob3dFcnJvcnMoZCkpLGkudmFsaWQ9aixmLnN0b3BSZXF1ZXN0KGMsail9fSxkKSksXFxcInBlbmRpbmdcXFwiKX19fSk7dmFyIGIsYz17fTtyZXR1cm4gYS5hamF4UHJlZmlsdGVyP2EuYWpheFByZWZpbHRlcihmdW5jdGlvbihhLGIsZCl7dmFyIGU9YS5wb3J0O1xcXCJhYm9ydFxcXCI9PT1hLm1vZGUmJihjW2VdJiZjW2VdLmFib3J0KCksY1tlXT1kKX0pOihiPWEuYWpheCxhLmFqYXg9ZnVuY3Rpb24oZCl7dmFyIGU9KFxcXCJtb2RlXFxcImluIGQ/ZDphLmFqYXhTZXR0aW5ncykubW9kZSxmPShcXFwicG9ydFxcXCJpbiBkP2Q6YS5hamF4U2V0dGluZ3MpLnBvcnQ7cmV0dXJuXFxcImFib3J0XFxcIj09PWU/KGNbZl0mJmNbZl0uYWJvcnQoKSxjW2ZdPWIuYXBwbHkodGhpcyxhcmd1bWVudHMpLGNbZl0pOmIuYXBwbHkodGhpcyxhcmd1bWVudHMpfSksYX0pO1wiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(7))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdmFsaWRhdGlvbi11bm9idHJ1c2l2ZS9kaXN0L2pxdWVyeS52YWxpZGF0ZS51bm9idHJ1c2l2ZS5taW4uanM/ODgyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXGpxdWVyeS12YWxpZGF0aW9uLXVub2J0cnVzaXZlXFxcXGRpc3RcXFxcanF1ZXJ5LnZhbGlkYXRlLnVub2J0cnVzaXZlLm1pbi5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n")},function(module,exports){eval('module.exports = "// Unobtrusive validation support library for jQuery and jQuery Validate\\r\\n// Copyright (c) .NET Foundation. All rights reserved.\\r\\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\\r\\n// @version v3.2.11\\r\\n!function(a){\\"function\\"==typeof define&&define.amd?define(\\"jquery.validate.unobtrusive\\",[\\"jquery-validation\\"],a):\\"object\\"==typeof module&&module.exports?module.exports=a(require(\\"jquery-validation\\")):jQuery.validator.unobtrusive=a(jQuery)}(function(a){function e(a,e,n){a.rules[e]=n,a.message&&(a.messages[e]=a.message)}function n(a){return a.replace(/^\\\\s+|\\\\s+$/g,\\"\\").split(/\\\\s*,\\\\s*/g)}function t(a){return a.replace(/([!\\"#$%&\'()*+,.\\\\/:;<=>?@\\\\[\\\\\\\\\\\\]^`{|}~])/g,\\"\\\\\\\\$1\\")}function r(a){return a.substr(0,a.lastIndexOf(\\".\\")+1)}function i(a,e){return 0===a.indexOf(\\"*.\\")&&(a=a.replace(\\"*.\\",e)),a}function o(e,n){var r=a(this).find(\\"[data-valmsg-for=\'\\"+t(n[0].name)+\\"\']\\"),i=r.attr(\\"data-valmsg-replace\\"),o=i?a.parseJSON(i)!==!1:null;r.removeClass(\\"field-validation-valid\\").addClass(\\"field-validation-error\\"),e.data(\\"unobtrusiveContainer\\",r),o?(r.empty(),e.removeClass(\\"input-validation-error\\").appendTo(r)):e.hide()}function d(e,n){var t=a(this).find(\\"[data-valmsg-summary=true]\\"),r=t.find(\\"ul\\");r&&r.length&&n.errorList.length&&(r.empty(),t.addClass(\\"validation-summary-errors\\").removeClass(\\"validation-summary-valid\\"),a.each(n.errorList,function(){a(\\"<li />\\").html(this.message).appendTo(r)}))}function s(e){var n=e.data(\\"unobtrusiveContainer\\");if(n){var t=n.attr(\\"data-valmsg-replace\\"),r=t?a.parseJSON(t):null;n.addClass(\\"field-validation-valid\\").removeClass(\\"field-validation-error\\"),e.removeData(\\"unobtrusiveContainer\\"),r&&n.empty()}}function l(e){var n=a(this),t=\\"__jquery_unobtrusive_validation_form_reset\\";if(!n.data(t)){n.data(t,!0);try{n.data(\\"validator\\").resetForm()}finally{n.removeData(t)}n.find(\\".validation-summary-errors\\").addClass(\\"validation-summary-valid\\").removeClass(\\"validation-summary-errors\\"),n.find(\\".field-validation-error\\").addClass(\\"field-validation-valid\\").removeClass(\\"field-validation-error\\").removeData(\\"unobtrusiveContainer\\").find(\\">*\\").removeData(\\"unobtrusiveContainer\\")}}function u(e){var n=a(e),t=n.data(v),r=a.proxy(l,e),i=f.unobtrusive.options||{},u=function(n,t){var r=i[n];r&&a.isFunction(r)&&r.apply(e,t)};return t||(t={options:{errorClass:i.errorClass||\\"input-validation-error\\",errorElement:i.errorElement||\\"span\\",errorPlacement:function(){o.apply(e,arguments),u(\\"errorPlacement\\",arguments)},invalidHandler:function(){d.apply(e,arguments),u(\\"invalidHandler\\",arguments)},messages:{},rules:{},success:function(){s.apply(e,arguments),u(\\"success\\",arguments)}},attachValidation:function(){n.off(\\"reset.\\"+v,r).on(\\"reset.\\"+v,r).validate(this.options)},validate:function(){return n.validate(),n.valid()}},n.data(v,t)),t}var m,f=a.validator,v=\\"unobtrusiveValidation\\";return f.unobtrusive={adapters:[],parseElement:function(e,n){var t,r,i,o=a(e),d=o.parents(\\"form\\")[0];d&&(t=u(d),t.options.rules[e.name]=r={},t.options.messages[e.name]=i={},a.each(this.adapters,function(){var n=\\"data-val-\\"+this.name,t=o.attr(n),s={};void 0!==t&&(n+=\\"-\\",a.each(this.params,function(){s[this]=o.attr(n+this)}),this.adapt({element:e,form:d,message:t,params:s,rules:r,messages:i}))}),a.extend(r,{__dummy__:!0}),n||t.attachValidation())},parse:function(e){var n=a(e),t=n.parents().addBack().filter(\\"form\\").add(n.find(\\"form\\")).has(\\"[data-val=true]\\");n.find(\\"[data-val=true]\\").each(function(){f.unobtrusive.parseElement(this,!0)}),t.each(function(){var a=u(this);a&&a.attachValidation()})}},m=f.unobtrusive.adapters,m.add=function(a,e,n){return n||(n=e,e=[]),this.push({name:a,params:e,adapt:n}),this},m.addBool=function(a,n){return this.add(a,function(t){e(t,n||a,!0)})},m.addMinMax=function(a,n,t,r,i,o){return this.add(a,[i||\\"min\\",o||\\"max\\"],function(a){var i=a.params.min,o=a.params.max;i&&o?e(a,r,[i,o]):i?e(a,n,i):o&&e(a,t,o)})},m.addSingleVal=function(a,n,t){return this.add(a,[n||\\"val\\"],function(r){e(r,t||a,r.params[n])})},f.addMethod(\\"__dummy__\\",function(a,e,n){return!0}),f.addMethod(\\"regex\\",function(a,e,n){var t;return!!this.optional(e)||(t=new RegExp(n).exec(a),t&&0===t.index&&t[0].length===a.length)}),f.addMethod(\\"nonalphamin\\",function(a,e,n){var t;return n&&(t=a.match(/\\\\W/g),t=t&&t.length>=n),t}),f.methods.extension?(m.addSingleVal(\\"accept\\",\\"mimtype\\"),m.addSingleVal(\\"extension\\",\\"extension\\")):m.addSingleVal(\\"extension\\",\\"extension\\",\\"accept\\"),m.addSingleVal(\\"regex\\",\\"pattern\\"),m.addBool(\\"creditcard\\").addBool(\\"date\\").addBool(\\"digits\\").addBool(\\"email\\").addBool(\\"number\\").addBool(\\"url\\"),m.addMinMax(\\"length\\",\\"minlength\\",\\"maxlength\\",\\"rangelength\\").addMinMax(\\"range\\",\\"min\\",\\"max\\",\\"range\\"),m.addMinMax(\\"minlength\\",\\"minlength\\").addMinMax(\\"maxlength\\",\\"minlength\\",\\"maxlength\\"),m.add(\\"equalto\\",[\\"other\\"],function(n){var o=r(n.element.name),d=n.params.other,s=i(d,o),l=a(n.form).find(\\":input\\").filter(\\"[name=\'\\"+t(s)+\\"\']\\")[0];e(n,\\"equalTo\\",l)}),m.add(\\"required\\",function(a){\\"INPUT\\"===a.element.tagName.toUpperCase()&&\\"CHECKBOX\\"===a.element.type.toUpperCase()||e(a,\\"required\\",!0)}),m.add(\\"remote\\",[\\"url\\",\\"type\\",\\"additionalfields\\"],function(o){var d={url:o.params.url,type:o.params.type||\\"GET\\",data:{}},s=r(o.element.name);a.each(n(o.params.additionalfields||o.element.name),function(e,n){var r=i(n,s);d.data[r]=function(){var e=a(o.form).find(\\":input\\").filter(\\"[name=\'\\"+t(r)+\\"\']\\");return e.is(\\":checkbox\\")?e.filter(\\":checked\\").val()||e.filter(\\":hidden\\").val()||\\"\\":e.is(\\":radio\\")?e.filter(\\":checked\\").val()||\\"\\":e.val()}}),e(o,\\"remote\\",d)}),m.add(\\"password\\",[\\"min\\",\\"nonalphamin\\",\\"regex\\"],function(a){a.params.min&&e(a,\\"minlength\\",a.params.min),a.params.nonalphamin&&e(a,\\"nonalphamin\\",a.params.nonalphamin),a.params.regex&&e(a,\\"regex\\",a.params.regex)}),m.add(\\"fileextensions\\",[\\"extensions\\"],function(a){e(a,\\"extension\\",a.params.extensions)}),a(function(){f.unobtrusive.parse(document)}),f.unobtrusive});"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdmFsaWRhdGlvbi11bm9idHJ1c2l2ZS9kaXN0L2pxdWVyeS52YWxpZGF0ZS51bm9idHJ1c2l2ZS5taW4uanM/MGZjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gVW5vYnRydXNpdmUgdmFsaWRhdGlvbiBzdXBwb3J0IGxpYnJhcnkgZm9yIGpRdWVyeSBhbmQgalF1ZXJ5IFZhbGlkYXRlXFxyXFxuLy8gQ29weXJpZ2h0IChjKSAuTkVUIEZvdW5kYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxyXFxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMC4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXFxyXFxuLy8gQHZlcnNpb24gdjMuMi4xMVxcclxcbiFmdW5jdGlvbihhKXtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcXFwianF1ZXJ5LnZhbGlkYXRlLnVub2J0cnVzaXZlXFxcIixbXFxcImpxdWVyeS12YWxpZGF0aW9uXFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWEocmVxdWlyZShcXFwianF1ZXJ5LXZhbGlkYXRpb25cXFwiKSk6alF1ZXJ5LnZhbGlkYXRvci51bm9idHJ1c2l2ZT1hKGpRdWVyeSl9KGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGUoYSxlLG4pe2EucnVsZXNbZV09bixhLm1lc3NhZ2UmJihhLm1lc3NhZ2VzW2VdPWEubWVzc2FnZSl9ZnVuY3Rpb24gbihhKXtyZXR1cm4gYS5yZXBsYWNlKC9eXFxcXHMrfFxcXFxzKyQvZyxcXFwiXFxcIikuc3BsaXQoL1xcXFxzKixcXFxccyovZyl9ZnVuY3Rpb24gdChhKXtyZXR1cm4gYS5yZXBsYWNlKC8oWyFcXFwiIyQlJicoKSorLC5cXFxcLzo7PD0+P0BcXFxcW1xcXFxcXFxcXFxcXF1eYHt8fX5dKS9nLFxcXCJcXFxcXFxcXCQxXFxcIil9ZnVuY3Rpb24gcihhKXtyZXR1cm4gYS5zdWJzdHIoMCxhLmxhc3RJbmRleE9mKFxcXCIuXFxcIikrMSl9ZnVuY3Rpb24gaShhLGUpe3JldHVybiAwPT09YS5pbmRleE9mKFxcXCIqLlxcXCIpJiYoYT1hLnJlcGxhY2UoXFxcIiouXFxcIixlKSksYX1mdW5jdGlvbiBvKGUsbil7dmFyIHI9YSh0aGlzKS5maW5kKFxcXCJbZGF0YS12YWxtc2ctZm9yPSdcXFwiK3QoblswXS5uYW1lKStcXFwiJ11cXFwiKSxpPXIuYXR0cihcXFwiZGF0YS12YWxtc2ctcmVwbGFjZVxcXCIpLG89aT9hLnBhcnNlSlNPTihpKSE9PSExOm51bGw7ci5yZW1vdmVDbGFzcyhcXFwiZmllbGQtdmFsaWRhdGlvbi12YWxpZFxcXCIpLmFkZENsYXNzKFxcXCJmaWVsZC12YWxpZGF0aW9uLWVycm9yXFxcIiksZS5kYXRhKFxcXCJ1bm9idHJ1c2l2ZUNvbnRhaW5lclxcXCIsciksbz8oci5lbXB0eSgpLGUucmVtb3ZlQ2xhc3MoXFxcImlucHV0LXZhbGlkYXRpb24tZXJyb3JcXFwiKS5hcHBlbmRUbyhyKSk6ZS5oaWRlKCl9ZnVuY3Rpb24gZChlLG4pe3ZhciB0PWEodGhpcykuZmluZChcXFwiW2RhdGEtdmFsbXNnLXN1bW1hcnk9dHJ1ZV1cXFwiKSxyPXQuZmluZChcXFwidWxcXFwiKTtyJiZyLmxlbmd0aCYmbi5lcnJvckxpc3QubGVuZ3RoJiYoci5lbXB0eSgpLHQuYWRkQ2xhc3MoXFxcInZhbGlkYXRpb24tc3VtbWFyeS1lcnJvcnNcXFwiKS5yZW1vdmVDbGFzcyhcXFwidmFsaWRhdGlvbi1zdW1tYXJ5LXZhbGlkXFxcIiksYS5lYWNoKG4uZXJyb3JMaXN0LGZ1bmN0aW9uKCl7YShcXFwiPGxpIC8+XFxcIikuaHRtbCh0aGlzLm1lc3NhZ2UpLmFwcGVuZFRvKHIpfSkpfWZ1bmN0aW9uIHMoZSl7dmFyIG49ZS5kYXRhKFxcXCJ1bm9idHJ1c2l2ZUNvbnRhaW5lclxcXCIpO2lmKG4pe3ZhciB0PW4uYXR0cihcXFwiZGF0YS12YWxtc2ctcmVwbGFjZVxcXCIpLHI9dD9hLnBhcnNlSlNPTih0KTpudWxsO24uYWRkQ2xhc3MoXFxcImZpZWxkLXZhbGlkYXRpb24tdmFsaWRcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZmllbGQtdmFsaWRhdGlvbi1lcnJvclxcXCIpLGUucmVtb3ZlRGF0YShcXFwidW5vYnRydXNpdmVDb250YWluZXJcXFwiKSxyJiZuLmVtcHR5KCl9fWZ1bmN0aW9uIGwoZSl7dmFyIG49YSh0aGlzKSx0PVxcXCJfX2pxdWVyeV91bm9idHJ1c2l2ZV92YWxpZGF0aW9uX2Zvcm1fcmVzZXRcXFwiO2lmKCFuLmRhdGEodCkpe24uZGF0YSh0LCEwKTt0cnl7bi5kYXRhKFxcXCJ2YWxpZGF0b3JcXFwiKS5yZXNldEZvcm0oKX1maW5hbGx5e24ucmVtb3ZlRGF0YSh0KX1uLmZpbmQoXFxcIi52YWxpZGF0aW9uLXN1bW1hcnktZXJyb3JzXFxcIikuYWRkQ2xhc3MoXFxcInZhbGlkYXRpb24tc3VtbWFyeS12YWxpZFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWxpZGF0aW9uLXN1bW1hcnktZXJyb3JzXFxcIiksbi5maW5kKFxcXCIuZmllbGQtdmFsaWRhdGlvbi1lcnJvclxcXCIpLmFkZENsYXNzKFxcXCJmaWVsZC12YWxpZGF0aW9uLXZhbGlkXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZpZWxkLXZhbGlkYXRpb24tZXJyb3JcXFwiKS5yZW1vdmVEYXRhKFxcXCJ1bm9idHJ1c2l2ZUNvbnRhaW5lclxcXCIpLmZpbmQoXFxcIj4qXFxcIikucmVtb3ZlRGF0YShcXFwidW5vYnRydXNpdmVDb250YWluZXJcXFwiKX19ZnVuY3Rpb24gdShlKXt2YXIgbj1hKGUpLHQ9bi5kYXRhKHYpLHI9YS5wcm94eShsLGUpLGk9Zi51bm9idHJ1c2l2ZS5vcHRpb25zfHx7fSx1PWZ1bmN0aW9uKG4sdCl7dmFyIHI9aVtuXTtyJiZhLmlzRnVuY3Rpb24ocikmJnIuYXBwbHkoZSx0KX07cmV0dXJuIHR8fCh0PXtvcHRpb25zOntlcnJvckNsYXNzOmkuZXJyb3JDbGFzc3x8XFxcImlucHV0LXZhbGlkYXRpb24tZXJyb3JcXFwiLGVycm9yRWxlbWVudDppLmVycm9yRWxlbWVudHx8XFxcInNwYW5cXFwiLGVycm9yUGxhY2VtZW50OmZ1bmN0aW9uKCl7by5hcHBseShlLGFyZ3VtZW50cyksdShcXFwiZXJyb3JQbGFjZW1lbnRcXFwiLGFyZ3VtZW50cyl9LGludmFsaWRIYW5kbGVyOmZ1bmN0aW9uKCl7ZC5hcHBseShlLGFyZ3VtZW50cyksdShcXFwiaW52YWxpZEhhbmRsZXJcXFwiLGFyZ3VtZW50cyl9LG1lc3NhZ2VzOnt9LHJ1bGVzOnt9LHN1Y2Nlc3M6ZnVuY3Rpb24oKXtzLmFwcGx5KGUsYXJndW1lbnRzKSx1KFxcXCJzdWNjZXNzXFxcIixhcmd1bWVudHMpfX0sYXR0YWNoVmFsaWRhdGlvbjpmdW5jdGlvbigpe24ub2ZmKFxcXCJyZXNldC5cXFwiK3Yscikub24oXFxcInJlc2V0LlxcXCIrdixyKS52YWxpZGF0ZSh0aGlzLm9wdGlvbnMpfSx2YWxpZGF0ZTpmdW5jdGlvbigpe3JldHVybiBuLnZhbGlkYXRlKCksbi52YWxpZCgpfX0sbi5kYXRhKHYsdCkpLHR9dmFyIG0sZj1hLnZhbGlkYXRvcix2PVxcXCJ1bm9idHJ1c2l2ZVZhbGlkYXRpb25cXFwiO3JldHVybiBmLnVub2J0cnVzaXZlPXthZGFwdGVyczpbXSxwYXJzZUVsZW1lbnQ6ZnVuY3Rpb24oZSxuKXt2YXIgdCxyLGksbz1hKGUpLGQ9by5wYXJlbnRzKFxcXCJmb3JtXFxcIilbMF07ZCYmKHQ9dShkKSx0Lm9wdGlvbnMucnVsZXNbZS5uYW1lXT1yPXt9LHQub3B0aW9ucy5tZXNzYWdlc1tlLm5hbWVdPWk9e30sYS5lYWNoKHRoaXMuYWRhcHRlcnMsZnVuY3Rpb24oKXt2YXIgbj1cXFwiZGF0YS12YWwtXFxcIit0aGlzLm5hbWUsdD1vLmF0dHIobikscz17fTt2b2lkIDAhPT10JiYobis9XFxcIi1cXFwiLGEuZWFjaCh0aGlzLnBhcmFtcyxmdW5jdGlvbigpe3NbdGhpc109by5hdHRyKG4rdGhpcyl9KSx0aGlzLmFkYXB0KHtlbGVtZW50OmUsZm9ybTpkLG1lc3NhZ2U6dCxwYXJhbXM6cyxydWxlczpyLG1lc3NhZ2VzOml9KSl9KSxhLmV4dGVuZChyLHtfX2R1bW15X186ITB9KSxufHx0LmF0dGFjaFZhbGlkYXRpb24oKSl9LHBhcnNlOmZ1bmN0aW9uKGUpe3ZhciBuPWEoZSksdD1uLnBhcmVudHMoKS5hZGRCYWNrKCkuZmlsdGVyKFxcXCJmb3JtXFxcIikuYWRkKG4uZmluZChcXFwiZm9ybVxcXCIpKS5oYXMoXFxcIltkYXRhLXZhbD10cnVlXVxcXCIpO24uZmluZChcXFwiW2RhdGEtdmFsPXRydWVdXFxcIikuZWFjaChmdW5jdGlvbigpe2YudW5vYnRydXNpdmUucGFyc2VFbGVtZW50KHRoaXMsITApfSksdC5lYWNoKGZ1bmN0aW9uKCl7dmFyIGE9dSh0aGlzKTthJiZhLmF0dGFjaFZhbGlkYXRpb24oKX0pfX0sbT1mLnVub2J0cnVzaXZlLmFkYXB0ZXJzLG0uYWRkPWZ1bmN0aW9uKGEsZSxuKXtyZXR1cm4gbnx8KG49ZSxlPVtdKSx0aGlzLnB1c2goe25hbWU6YSxwYXJhbXM6ZSxhZGFwdDpufSksdGhpc30sbS5hZGRCb29sPWZ1bmN0aW9uKGEsbil7cmV0dXJuIHRoaXMuYWRkKGEsZnVuY3Rpb24odCl7ZSh0LG58fGEsITApfSl9LG0uYWRkTWluTWF4PWZ1bmN0aW9uKGEsbix0LHIsaSxvKXtyZXR1cm4gdGhpcy5hZGQoYSxbaXx8XFxcIm1pblxcXCIsb3x8XFxcIm1heFxcXCJdLGZ1bmN0aW9uKGEpe3ZhciBpPWEucGFyYW1zLm1pbixvPWEucGFyYW1zLm1heDtpJiZvP2UoYSxyLFtpLG9dKTppP2UoYSxuLGkpOm8mJmUoYSx0LG8pfSl9LG0uYWRkU2luZ2xlVmFsPWZ1bmN0aW9uKGEsbix0KXtyZXR1cm4gdGhpcy5hZGQoYSxbbnx8XFxcInZhbFxcXCJdLGZ1bmN0aW9uKHIpe2Uocix0fHxhLHIucGFyYW1zW25dKX0pfSxmLmFkZE1ldGhvZChcXFwiX19kdW1teV9fXFxcIixmdW5jdGlvbihhLGUsbil7cmV0dXJuITB9KSxmLmFkZE1ldGhvZChcXFwicmVnZXhcXFwiLGZ1bmN0aW9uKGEsZSxuKXt2YXIgdDtyZXR1cm4hIXRoaXMub3B0aW9uYWwoZSl8fCh0PW5ldyBSZWdFeHAobikuZXhlYyhhKSx0JiYwPT09dC5pbmRleCYmdFswXS5sZW5ndGg9PT1hLmxlbmd0aCl9KSxmLmFkZE1ldGhvZChcXFwibm9uYWxwaGFtaW5cXFwiLGZ1bmN0aW9uKGEsZSxuKXt2YXIgdDtyZXR1cm4gbiYmKHQ9YS5tYXRjaCgvXFxcXFcvZyksdD10JiZ0Lmxlbmd0aD49biksdH0pLGYubWV0aG9kcy5leHRlbnNpb24/KG0uYWRkU2luZ2xlVmFsKFxcXCJhY2NlcHRcXFwiLFxcXCJtaW10eXBlXFxcIiksbS5hZGRTaW5nbGVWYWwoXFxcImV4dGVuc2lvblxcXCIsXFxcImV4dGVuc2lvblxcXCIpKTptLmFkZFNpbmdsZVZhbChcXFwiZXh0ZW5zaW9uXFxcIixcXFwiZXh0ZW5zaW9uXFxcIixcXFwiYWNjZXB0XFxcIiksbS5hZGRTaW5nbGVWYWwoXFxcInJlZ2V4XFxcIixcXFwicGF0dGVyblxcXCIpLG0uYWRkQm9vbChcXFwiY3JlZGl0Y2FyZFxcXCIpLmFkZEJvb2woXFxcImRhdGVcXFwiKS5hZGRCb29sKFxcXCJkaWdpdHNcXFwiKS5hZGRCb29sKFxcXCJlbWFpbFxcXCIpLmFkZEJvb2woXFxcIm51bWJlclxcXCIpLmFkZEJvb2woXFxcInVybFxcXCIpLG0uYWRkTWluTWF4KFxcXCJsZW5ndGhcXFwiLFxcXCJtaW5sZW5ndGhcXFwiLFxcXCJtYXhsZW5ndGhcXFwiLFxcXCJyYW5nZWxlbmd0aFxcXCIpLmFkZE1pbk1heChcXFwicmFuZ2VcXFwiLFxcXCJtaW5cXFwiLFxcXCJtYXhcXFwiLFxcXCJyYW5nZVxcXCIpLG0uYWRkTWluTWF4KFxcXCJtaW5sZW5ndGhcXFwiLFxcXCJtaW5sZW5ndGhcXFwiKS5hZGRNaW5NYXgoXFxcIm1heGxlbmd0aFxcXCIsXFxcIm1pbmxlbmd0aFxcXCIsXFxcIm1heGxlbmd0aFxcXCIpLG0uYWRkKFxcXCJlcXVhbHRvXFxcIixbXFxcIm90aGVyXFxcIl0sZnVuY3Rpb24obil7dmFyIG89cihuLmVsZW1lbnQubmFtZSksZD1uLnBhcmFtcy5vdGhlcixzPWkoZCxvKSxsPWEobi5mb3JtKS5maW5kKFxcXCI6aW5wdXRcXFwiKS5maWx0ZXIoXFxcIltuYW1lPSdcXFwiK3QocykrXFxcIiddXFxcIilbMF07ZShuLFxcXCJlcXVhbFRvXFxcIixsKX0pLG0uYWRkKFxcXCJyZXF1aXJlZFxcXCIsZnVuY3Rpb24oYSl7XFxcIklOUFVUXFxcIj09PWEuZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkmJlxcXCJDSEVDS0JPWFxcXCI9PT1hLmVsZW1lbnQudHlwZS50b1VwcGVyQ2FzZSgpfHxlKGEsXFxcInJlcXVpcmVkXFxcIiwhMCl9KSxtLmFkZChcXFwicmVtb3RlXFxcIixbXFxcInVybFxcXCIsXFxcInR5cGVcXFwiLFxcXCJhZGRpdGlvbmFsZmllbGRzXFxcIl0sZnVuY3Rpb24obyl7dmFyIGQ9e3VybDpvLnBhcmFtcy51cmwsdHlwZTpvLnBhcmFtcy50eXBlfHxcXFwiR0VUXFxcIixkYXRhOnt9fSxzPXIoby5lbGVtZW50Lm5hbWUpO2EuZWFjaChuKG8ucGFyYW1zLmFkZGl0aW9uYWxmaWVsZHN8fG8uZWxlbWVudC5uYW1lKSxmdW5jdGlvbihlLG4pe3ZhciByPWkobixzKTtkLmRhdGFbcl09ZnVuY3Rpb24oKXt2YXIgZT1hKG8uZm9ybSkuZmluZChcXFwiOmlucHV0XFxcIikuZmlsdGVyKFxcXCJbbmFtZT0nXFxcIit0KHIpK1xcXCInXVxcXCIpO3JldHVybiBlLmlzKFxcXCI6Y2hlY2tib3hcXFwiKT9lLmZpbHRlcihcXFwiOmNoZWNrZWRcXFwiKS52YWwoKXx8ZS5maWx0ZXIoXFxcIjpoaWRkZW5cXFwiKS52YWwoKXx8XFxcIlxcXCI6ZS5pcyhcXFwiOnJhZGlvXFxcIik/ZS5maWx0ZXIoXFxcIjpjaGVja2VkXFxcIikudmFsKCl8fFxcXCJcXFwiOmUudmFsKCl9fSksZShvLFxcXCJyZW1vdGVcXFwiLGQpfSksbS5hZGQoXFxcInBhc3N3b3JkXFxcIixbXFxcIm1pblxcXCIsXFxcIm5vbmFscGhhbWluXFxcIixcXFwicmVnZXhcXFwiXSxmdW5jdGlvbihhKXthLnBhcmFtcy5taW4mJmUoYSxcXFwibWlubGVuZ3RoXFxcIixhLnBhcmFtcy5taW4pLGEucGFyYW1zLm5vbmFscGhhbWluJiZlKGEsXFxcIm5vbmFscGhhbWluXFxcIixhLnBhcmFtcy5ub25hbHBoYW1pbiksYS5wYXJhbXMucmVnZXgmJmUoYSxcXFwicmVnZXhcXFwiLGEucGFyYW1zLnJlZ2V4KX0pLG0uYWRkKFxcXCJmaWxlZXh0ZW5zaW9uc1xcXCIsW1xcXCJleHRlbnNpb25zXFxcIl0sZnVuY3Rpb24oYSl7ZShhLFxcXCJleHRlbnNpb25cXFwiLGEucGFyYW1zLmV4dGVuc2lvbnMpfSksYShmdW5jdGlvbigpe2YudW5vYnRydXNpdmUucGFyc2UoZG9jdW1lbnQpfSksZi51bm9idHJ1c2l2ZX0pO1wiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(9))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuanM/NjVjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXGJvb3RzdHJhcFxcXFxkaXN0XFxcXGpzXFxcXGJvb3RzdHJhcC5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n")},function(module,exports){eval("module.exports = \"/*!\\n  * Bootstrap v4.4.1 (https://getbootstrap.com/)\\n  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n  */\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('jquery'), require('popper.js')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'jquery', 'popper.js'], factory) :\\n  (global = global || self, factory(global.bootstrap = {}, global.jQuery, global.Popper));\\n}(this, (function (exports, $, Popper) { 'use strict';\\n\\n  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;\\n  Popper = Popper && Popper.hasOwnProperty('default') ? Popper['default'] : Popper;\\n\\n  function _defineProperties(target, props) {\\n    for (var i = 0; i < props.length; i++) {\\n      var descriptor = props[i];\\n      descriptor.enumerable = descriptor.enumerable || false;\\n      descriptor.configurable = true;\\n      if (\\\"value\\\" in descriptor) descriptor.writable = true;\\n      Object.defineProperty(target, descriptor.key, descriptor);\\n    }\\n  }\\n\\n  function _createClass(Constructor, protoProps, staticProps) {\\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\\n    if (staticProps) _defineProperties(Constructor, staticProps);\\n    return Constructor;\\n  }\\n\\n  function _defineProperty(obj, key, value) {\\n    if (key in obj) {\\n      Object.defineProperty(obj, key, {\\n        value: value,\\n        enumerable: true,\\n        configurable: true,\\n        writable: true\\n      });\\n    } else {\\n      obj[key] = value;\\n    }\\n\\n    return obj;\\n  }\\n\\n  function ownKeys(object, enumerableOnly) {\\n    var keys = Object.keys(object);\\n\\n    if (Object.getOwnPropertySymbols) {\\n      var symbols = Object.getOwnPropertySymbols(object);\\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\\n      });\\n      keys.push.apply(keys, symbols);\\n    }\\n\\n    return keys;\\n  }\\n\\n  function _objectSpread2(target) {\\n    for (var i = 1; i < arguments.length; i++) {\\n      var source = arguments[i] != null ? arguments[i] : {};\\n\\n      if (i % 2) {\\n        ownKeys(Object(source), true).forEach(function (key) {\\n          _defineProperty(target, key, source[key]);\\n        });\\n      } else if (Object.getOwnPropertyDescriptors) {\\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\\n      } else {\\n        ownKeys(Object(source)).forEach(function (key) {\\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\\n        });\\n      }\\n    }\\n\\n    return target;\\n  }\\n\\n  function _inheritsLoose(subClass, superClass) {\\n    subClass.prototype = Object.create(superClass.prototype);\\n    subClass.prototype.constructor = subClass;\\n    subClass.__proto__ = superClass;\\n  }\\n\\n  /**\\n   * --------------------------------------------------------------------------\\n   * Bootstrap (v4.4.1): util.js\\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n   * --------------------------------------------------------------------------\\n   */\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Private TransitionEnd Helpers\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var TRANSITION_END = 'transitionend';\\n  var MAX_UID = 1000000;\\n  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\\n\\n  function toType(obj) {\\n    return {}.toString.call(obj).match(/\\\\s([a-z]+)/i)[1].toLowerCase();\\n  }\\n\\n  function getSpecialTransitionEndEvent() {\\n    return {\\n      bindType: TRANSITION_END,\\n      delegateType: TRANSITION_END,\\n      handle: function handle(event) {\\n        if ($(event.target).is(this)) {\\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\\n        }\\n\\n        return undefined; // eslint-disable-line no-undefined\\n      }\\n    };\\n  }\\n\\n  function transitionEndEmulator(duration) {\\n    var _this = this;\\n\\n    var called = false;\\n    $(this).one(Util.TRANSITION_END, function () {\\n      called = true;\\n    });\\n    setTimeout(function () {\\n      if (!called) {\\n        Util.triggerTransitionEnd(_this);\\n      }\\n    }, duration);\\n    return this;\\n  }\\n\\n  function setTransitionEndSupport() {\\n    $.fn.emulateTransitionEnd = transitionEndEmulator;\\n    $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\\n  }\\n  /**\\n   * --------------------------------------------------------------------------\\n   * Public Util Api\\n   * --------------------------------------------------------------------------\\n   */\\n\\n\\n  var Util = {\\n    TRANSITION_END: 'bsTransitionEnd',\\n    getUID: function getUID(prefix) {\\n      do {\\n        // eslint-disable-next-line no-bitwise\\n        prefix += ~~(Math.random() * MAX_UID); // \\\"~~\\\" acts like a faster Math.floor() here\\n      } while (document.getElementById(prefix));\\n\\n      return prefix;\\n    },\\n    getSelectorFromElement: function getSelectorFromElement(element) {\\n      var selector = element.getAttribute('data-target');\\n\\n      if (!selector || selector === '#') {\\n        var hrefAttr = element.getAttribute('href');\\n        selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';\\n      }\\n\\n      try {\\n        return document.querySelector(selector) ? selector : null;\\n      } catch (err) {\\n        return null;\\n      }\\n    },\\n    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\\n      if (!element) {\\n        return 0;\\n      } // Get transition-duration of the element\\n\\n\\n      var transitionDuration = $(element).css('transition-duration');\\n      var transitionDelay = $(element).css('transition-delay');\\n      var floatTransitionDuration = parseFloat(transitionDuration);\\n      var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\\n\\n      if (!floatTransitionDuration && !floatTransitionDelay) {\\n        return 0;\\n      } // If multiple durations are defined, take the first\\n\\n\\n      transitionDuration = transitionDuration.split(',')[0];\\n      transitionDelay = transitionDelay.split(',')[0];\\n      return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\\n    },\\n    reflow: function reflow(element) {\\n      return element.offsetHeight;\\n    },\\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\\n      $(element).trigger(TRANSITION_END);\\n    },\\n    // TODO: Remove in v5\\n    supportsTransitionEnd: function supportsTransitionEnd() {\\n      return Boolean(TRANSITION_END);\\n    },\\n    isElement: function isElement(obj) {\\n      return (obj[0] || obj).nodeType;\\n    },\\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\\n      for (var property in configTypes) {\\n        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\\n          var expectedTypes = configTypes[property];\\n          var value = config[property];\\n          var valueType = value && Util.isElement(value) ? 'element' : toType(value);\\n\\n          if (!new RegExp(expectedTypes).test(valueType)) {\\n            throw new Error(componentName.toUpperCase() + \\\": \\\" + (\\\"Option \\\\\\\"\\\" + property + \\\"\\\\\\\" provided type \\\\\\\"\\\" + valueType + \\\"\\\\\\\" \\\") + (\\\"but expected type \\\\\\\"\\\" + expectedTypes + \\\"\\\\\\\".\\\"));\\n          }\\n        }\\n      }\\n    },\\n    findShadowRoot: function findShadowRoot(element) {\\n      if (!document.documentElement.attachShadow) {\\n        return null;\\n      } // Can find the shadow root otherwise it'll return the document\\n\\n\\n      if (typeof element.getRootNode === 'function') {\\n        var root = element.getRootNode();\\n        return root instanceof ShadowRoot ? root : null;\\n      }\\n\\n      if (element instanceof ShadowRoot) {\\n        return element;\\n      } // when we don't find a shadow root\\n\\n\\n      if (!element.parentNode) {\\n        return null;\\n      }\\n\\n      return Util.findShadowRoot(element.parentNode);\\n    },\\n    jQueryDetection: function jQueryDetection() {\\n      if (typeof $ === 'undefined') {\\n        throw new TypeError('Bootstrap\\\\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\\\\'s JavaScript.');\\n      }\\n\\n      var version = $.fn.jquery.split(' ')[0].split('.');\\n      var minMajor = 1;\\n      var ltMajor = 2;\\n      var minMinor = 9;\\n      var minPatch = 1;\\n      var maxMajor = 4;\\n\\n      if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {\\n        throw new Error('Bootstrap\\\\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');\\n      }\\n    }\\n  };\\n  Util.jQueryDetection();\\n  setTransitionEndSupport();\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME = 'alert';\\n  var VERSION = '4.4.1';\\n  var DATA_KEY = 'bs.alert';\\n  var EVENT_KEY = \\\".\\\" + DATA_KEY;\\n  var DATA_API_KEY = '.data-api';\\n  var JQUERY_NO_CONFLICT = $.fn[NAME];\\n  var Selector = {\\n    DISMISS: '[data-dismiss=\\\"alert\\\"]'\\n  };\\n  var Event = {\\n    CLOSE: \\\"close\\\" + EVENT_KEY,\\n    CLOSED: \\\"closed\\\" + EVENT_KEY,\\n    CLICK_DATA_API: \\\"click\\\" + EVENT_KEY + DATA_API_KEY\\n  };\\n  var ClassName = {\\n    ALERT: 'alert',\\n    FADE: 'fade',\\n    SHOW: 'show'\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Alert =\\n  /*#__PURE__*/\\n  function () {\\n    function Alert(element) {\\n      this._element = element;\\n    } // Getters\\n\\n\\n    var _proto = Alert.prototype;\\n\\n    // Public\\n    _proto.close = function close(element) {\\n      var rootElement = this._element;\\n\\n      if (element) {\\n        rootElement = this._getRootElement(element);\\n      }\\n\\n      var customEvent = this._triggerCloseEvent(rootElement);\\n\\n      if (customEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      this._removeElement(rootElement);\\n    };\\n\\n    _proto.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY);\\n      this._element = null;\\n    } // Private\\n    ;\\n\\n    _proto._getRootElement = function _getRootElement(element) {\\n      var selector = Util.getSelectorFromElement(element);\\n      var parent = false;\\n\\n      if (selector) {\\n        parent = document.querySelector(selector);\\n      }\\n\\n      if (!parent) {\\n        parent = $(element).closest(\\\".\\\" + ClassName.ALERT)[0];\\n      }\\n\\n      return parent;\\n    };\\n\\n    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {\\n      var closeEvent = $.Event(Event.CLOSE);\\n      $(element).trigger(closeEvent);\\n      return closeEvent;\\n    };\\n\\n    _proto._removeElement = function _removeElement(element) {\\n      var _this = this;\\n\\n      $(element).removeClass(ClassName.SHOW);\\n\\n      if (!$(element).hasClass(ClassName.FADE)) {\\n        this._destroyElement(element);\\n\\n        return;\\n      }\\n\\n      var transitionDuration = Util.getTransitionDurationFromElement(element);\\n      $(element).one(Util.TRANSITION_END, function (event) {\\n        return _this._destroyElement(element, event);\\n      }).emulateTransitionEnd(transitionDuration);\\n    };\\n\\n    _proto._destroyElement = function _destroyElement(element) {\\n      $(element).detach().trigger(Event.CLOSED).remove();\\n    } // Static\\n    ;\\n\\n    Alert._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var $element = $(this);\\n        var data = $element.data(DATA_KEY);\\n\\n        if (!data) {\\n          data = new Alert(this);\\n          $element.data(DATA_KEY, data);\\n        }\\n\\n        if (config === 'close') {\\n          data[config](this);\\n        }\\n      });\\n    };\\n\\n    Alert._handleDismiss = function _handleDismiss(alertInstance) {\\n      return function (event) {\\n        if (event) {\\n          event.preventDefault();\\n        }\\n\\n        alertInstance.close(this);\\n      };\\n    };\\n\\n    _createClass(Alert, null, [{\\n      key: \\\"VERSION\\\",\\n      get: function get() {\\n        return VERSION;\\n      }\\n    }]);\\n\\n    return Alert;\\n  }();\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME] = Alert._jQueryInterface;\\n  $.fn[NAME].Constructor = Alert;\\n\\n  $.fn[NAME].noConflict = function () {\\n    $.fn[NAME] = JQUERY_NO_CONFLICT;\\n    return Alert._jQueryInterface;\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME$1 = 'button';\\n  var VERSION$1 = '4.4.1';\\n  var DATA_KEY$1 = 'bs.button';\\n  var EVENT_KEY$1 = \\\".\\\" + DATA_KEY$1;\\n  var DATA_API_KEY$1 = '.data-api';\\n  var JQUERY_NO_CONFLICT$1 = $.fn[NAME$1];\\n  var ClassName$1 = {\\n    ACTIVE: 'active',\\n    BUTTON: 'btn',\\n    FOCUS: 'focus'\\n  };\\n  var Selector$1 = {\\n    DATA_TOGGLE_CARROT: '[data-toggle^=\\\"button\\\"]',\\n    DATA_TOGGLES: '[data-toggle=\\\"buttons\\\"]',\\n    DATA_TOGGLE: '[data-toggle=\\\"button\\\"]',\\n    DATA_TOGGLES_BUTTONS: '[data-toggle=\\\"buttons\\\"] .btn',\\n    INPUT: 'input:not([type=\\\"hidden\\\"])',\\n    ACTIVE: '.active',\\n    BUTTON: '.btn'\\n  };\\n  var Event$1 = {\\n    CLICK_DATA_API: \\\"click\\\" + EVENT_KEY$1 + DATA_API_KEY$1,\\n    FOCUS_BLUR_DATA_API: \\\"focus\\\" + EVENT_KEY$1 + DATA_API_KEY$1 + \\\" \\\" + (\\\"blur\\\" + EVENT_KEY$1 + DATA_API_KEY$1),\\n    LOAD_DATA_API: \\\"load\\\" + EVENT_KEY$1 + DATA_API_KEY$1\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Button =\\n  /*#__PURE__*/\\n  function () {\\n    function Button(element) {\\n      this._element = element;\\n    } // Getters\\n\\n\\n    var _proto = Button.prototype;\\n\\n    // Public\\n    _proto.toggle = function toggle() {\\n      var triggerChangeEvent = true;\\n      var addAriaPressed = true;\\n      var rootElement = $(this._element).closest(Selector$1.DATA_TOGGLES)[0];\\n\\n      if (rootElement) {\\n        var input = this._element.querySelector(Selector$1.INPUT);\\n\\n        if (input) {\\n          if (input.type === 'radio') {\\n            if (input.checked && this._element.classList.contains(ClassName$1.ACTIVE)) {\\n              triggerChangeEvent = false;\\n            } else {\\n              var activeElement = rootElement.querySelector(Selector$1.ACTIVE);\\n\\n              if (activeElement) {\\n                $(activeElement).removeClass(ClassName$1.ACTIVE);\\n              }\\n            }\\n          } else if (input.type === 'checkbox') {\\n            if (this._element.tagName === 'LABEL' && input.checked === this._element.classList.contains(ClassName$1.ACTIVE)) {\\n              triggerChangeEvent = false;\\n            }\\n          } else {\\n            // if it's not a radio button or checkbox don't add a pointless/invalid checked property to the input\\n            triggerChangeEvent = false;\\n          }\\n\\n          if (triggerChangeEvent) {\\n            input.checked = !this._element.classList.contains(ClassName$1.ACTIVE);\\n            $(input).trigger('change');\\n          }\\n\\n          input.focus();\\n          addAriaPressed = false;\\n        }\\n      }\\n\\n      if (!(this._element.hasAttribute('disabled') || this._element.classList.contains('disabled'))) {\\n        if (addAriaPressed) {\\n          this._element.setAttribute('aria-pressed', !this._element.classList.contains(ClassName$1.ACTIVE));\\n        }\\n\\n        if (triggerChangeEvent) {\\n          $(this._element).toggleClass(ClassName$1.ACTIVE);\\n        }\\n      }\\n    };\\n\\n    _proto.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY$1);\\n      this._element = null;\\n    } // Static\\n    ;\\n\\n    Button._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY$1);\\n\\n        if (!data) {\\n          data = new Button(this);\\n          $(this).data(DATA_KEY$1, data);\\n        }\\n\\n        if (config === 'toggle') {\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Button, null, [{\\n      key: \\\"VERSION\\\",\\n      get: function get() {\\n        return VERSION$1;\\n      }\\n    }]);\\n\\n    return Button;\\n  }();\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $(document).on(Event$1.CLICK_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {\\n    var button = event.target;\\n\\n    if (!$(button).hasClass(ClassName$1.BUTTON)) {\\n      button = $(button).closest(Selector$1.BUTTON)[0];\\n    }\\n\\n    if (!button || button.hasAttribute('disabled') || button.classList.contains('disabled')) {\\n      event.preventDefault(); // work around Firefox bug #1540995\\n    } else {\\n      var inputBtn = button.querySelector(Selector$1.INPUT);\\n\\n      if (inputBtn && (inputBtn.hasAttribute('disabled') || inputBtn.classList.contains('disabled'))) {\\n        event.preventDefault(); // work around Firefox bug #1540995\\n\\n        return;\\n      }\\n\\n      Button._jQueryInterface.call($(button), 'toggle');\\n    }\\n  }).on(Event$1.FOCUS_BLUR_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {\\n    var button = $(event.target).closest(Selector$1.BUTTON)[0];\\n    $(button).toggleClass(ClassName$1.FOCUS, /^focus(in)?$/.test(event.type));\\n  });\\n  $(window).on(Event$1.LOAD_DATA_API, function () {\\n    // ensure correct active class is set to match the controls' actual values/states\\n    // find all checkboxes/readio buttons inside data-toggle groups\\n    var buttons = [].slice.call(document.querySelectorAll(Selector$1.DATA_TOGGLES_BUTTONS));\\n\\n    for (var i = 0, len = buttons.length; i < len; i++) {\\n      var button = buttons[i];\\n      var input = button.querySelector(Selector$1.INPUT);\\n\\n      if (input.checked || input.hasAttribute('checked')) {\\n        button.classList.add(ClassName$1.ACTIVE);\\n      } else {\\n        button.classList.remove(ClassName$1.ACTIVE);\\n      }\\n    } // find all button toggles\\n\\n\\n    buttons = [].slice.call(document.querySelectorAll(Selector$1.DATA_TOGGLE));\\n\\n    for (var _i = 0, _len = buttons.length; _i < _len; _i++) {\\n      var _button = buttons[_i];\\n\\n      if (_button.getAttribute('aria-pressed') === 'true') {\\n        _button.classList.add(ClassName$1.ACTIVE);\\n      } else {\\n        _button.classList.remove(ClassName$1.ACTIVE);\\n      }\\n    }\\n  });\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME$1] = Button._jQueryInterface;\\n  $.fn[NAME$1].Constructor = Button;\\n\\n  $.fn[NAME$1].noConflict = function () {\\n    $.fn[NAME$1] = JQUERY_NO_CONFLICT$1;\\n    return Button._jQueryInterface;\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME$2 = 'carousel';\\n  var VERSION$2 = '4.4.1';\\n  var DATA_KEY$2 = 'bs.carousel';\\n  var EVENT_KEY$2 = \\\".\\\" + DATA_KEY$2;\\n  var DATA_API_KEY$2 = '.data-api';\\n  var JQUERY_NO_CONFLICT$2 = $.fn[NAME$2];\\n  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key\\n\\n  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key\\n\\n  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\\n\\n  var SWIPE_THRESHOLD = 40;\\n  var Default = {\\n    interval: 5000,\\n    keyboard: true,\\n    slide: false,\\n    pause: 'hover',\\n    wrap: true,\\n    touch: true\\n  };\\n  var DefaultType = {\\n    interval: '(number|boolean)',\\n    keyboard: 'boolean',\\n    slide: '(boolean|string)',\\n    pause: '(string|boolean)',\\n    wrap: 'boolean',\\n    touch: 'boolean'\\n  };\\n  var Direction = {\\n    NEXT: 'next',\\n    PREV: 'prev',\\n    LEFT: 'left',\\n    RIGHT: 'right'\\n  };\\n  var Event$2 = {\\n    SLIDE: \\\"slide\\\" + EVENT_KEY$2,\\n    SLID: \\\"slid\\\" + EVENT_KEY$2,\\n    KEYDOWN: \\\"keydown\\\" + EVENT_KEY$2,\\n    MOUSEENTER: \\\"mouseenter\\\" + EVENT_KEY$2,\\n    MOUSELEAVE: \\\"mouseleave\\\" + EVENT_KEY$2,\\n    TOUCHSTART: \\\"touchstart\\\" + EVENT_KEY$2,\\n    TOUCHMOVE: \\\"touchmove\\\" + EVENT_KEY$2,\\n    TOUCHEND: \\\"touchend\\\" + EVENT_KEY$2,\\n    POINTERDOWN: \\\"pointerdown\\\" + EVENT_KEY$2,\\n    POINTERUP: \\\"pointerup\\\" + EVENT_KEY$2,\\n    DRAG_START: \\\"dragstart\\\" + EVENT_KEY$2,\\n    LOAD_DATA_API: \\\"load\\\" + EVENT_KEY$2 + DATA_API_KEY$2,\\n    CLICK_DATA_API: \\\"click\\\" + EVENT_KEY$2 + DATA_API_KEY$2\\n  };\\n  var ClassName$2 = {\\n    CAROUSEL: 'carousel',\\n    ACTIVE: 'active',\\n    SLIDE: 'slide',\\n    RIGHT: 'carousel-item-right',\\n    LEFT: 'carousel-item-left',\\n    NEXT: 'carousel-item-next',\\n    PREV: 'carousel-item-prev',\\n    ITEM: 'carousel-item',\\n    POINTER_EVENT: 'pointer-event'\\n  };\\n  var Selector$2 = {\\n    ACTIVE: '.active',\\n    ACTIVE_ITEM: '.active.carousel-item',\\n    ITEM: '.carousel-item',\\n    ITEM_IMG: '.carousel-item img',\\n    NEXT_PREV: '.carousel-item-next, .carousel-item-prev',\\n    INDICATORS: '.carousel-indicators',\\n    DATA_SLIDE: '[data-slide], [data-slide-to]',\\n    DATA_RIDE: '[data-ride=\\\"carousel\\\"]'\\n  };\\n  var PointerType = {\\n    TOUCH: 'touch',\\n    PEN: 'pen'\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Carousel =\\n  /*#__PURE__*/\\n  function () {\\n    function Carousel(element, config) {\\n      this._items = null;\\n      this._interval = null;\\n      this._activeElement = null;\\n      this._isPaused = false;\\n      this._isSliding = false;\\n      this.touchTimeout = null;\\n      this.touchStartX = 0;\\n      this.touchDeltaX = 0;\\n      this._config = this._getConfig(config);\\n      this._element = element;\\n      this._indicatorsElement = this._element.querySelector(Selector$2.INDICATORS);\\n      this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\\n      this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);\\n\\n      this._addEventListeners();\\n    } // Getters\\n\\n\\n    var _proto = Carousel.prototype;\\n\\n    // Public\\n    _proto.next = function next() {\\n      if (!this._isSliding) {\\n        this._slide(Direction.NEXT);\\n      }\\n    };\\n\\n    _proto.nextWhenVisible = function nextWhenVisible() {\\n      // Don't call next when the page isn't visible\\n      // or the carousel or its parent isn't visible\\n      if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {\\n        this.next();\\n      }\\n    };\\n\\n    _proto.prev = function prev() {\\n      if (!this._isSliding) {\\n        this._slide(Direction.PREV);\\n      }\\n    };\\n\\n    _proto.pause = function pause(event) {\\n      if (!event) {\\n        this._isPaused = true;\\n      }\\n\\n      if (this._element.querySelector(Selector$2.NEXT_PREV)) {\\n        Util.triggerTransitionEnd(this._element);\\n        this.cycle(true);\\n      }\\n\\n      clearInterval(this._interval);\\n      this._interval = null;\\n    };\\n\\n    _proto.cycle = function cycle(event) {\\n      if (!event) {\\n        this._isPaused = false;\\n      }\\n\\n      if (this._interval) {\\n        clearInterval(this._interval);\\n        this._interval = null;\\n      }\\n\\n      if (this._config.interval && !this._isPaused) {\\n        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\\n      }\\n    };\\n\\n    _proto.to = function to(index) {\\n      var _this = this;\\n\\n      this._activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);\\n\\n      var activeIndex = this._getItemIndex(this._activeElement);\\n\\n      if (index > this._items.length - 1 || index < 0) {\\n        return;\\n      }\\n\\n      if (this._isSliding) {\\n        $(this._element).one(Event$2.SLID, function () {\\n          return _this.to(index);\\n        });\\n        return;\\n      }\\n\\n      if (activeIndex === index) {\\n        this.pause();\\n        this.cycle();\\n        return;\\n      }\\n\\n      var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;\\n\\n      this._slide(direction, this._items[index]);\\n    };\\n\\n    _proto.dispose = function dispose() {\\n      $(this._element).off(EVENT_KEY$2);\\n      $.removeData(this._element, DATA_KEY$2);\\n      this._items = null;\\n      this._config = null;\\n      this._element = null;\\n      this._interval = null;\\n      this._isPaused = null;\\n      this._isSliding = null;\\n      this._activeElement = null;\\n      this._indicatorsElement = null;\\n    } // Private\\n    ;\\n\\n    _proto._getConfig = function _getConfig(config) {\\n      config = _objectSpread2({}, Default, {}, config);\\n      Util.typeCheckConfig(NAME$2, config, DefaultType);\\n      return config;\\n    };\\n\\n    _proto._handleSwipe = function _handleSwipe() {\\n      var absDeltax = Math.abs(this.touchDeltaX);\\n\\n      if (absDeltax <= SWIPE_THRESHOLD) {\\n        return;\\n      }\\n\\n      var direction = absDeltax / this.touchDeltaX;\\n      this.touchDeltaX = 0; // swipe left\\n\\n      if (direction > 0) {\\n        this.prev();\\n      } // swipe right\\n\\n\\n      if (direction < 0) {\\n        this.next();\\n      }\\n    };\\n\\n    _proto._addEventListeners = function _addEventListeners() {\\n      var _this2 = this;\\n\\n      if (this._config.keyboard) {\\n        $(this._element).on(Event$2.KEYDOWN, function (event) {\\n          return _this2._keydown(event);\\n        });\\n      }\\n\\n      if (this._config.pause === 'hover') {\\n        $(this._element).on(Event$2.MOUSEENTER, function (event) {\\n          return _this2.pause(event);\\n        }).on(Event$2.MOUSELEAVE, function (event) {\\n          return _this2.cycle(event);\\n        });\\n      }\\n\\n      if (this._config.touch) {\\n        this._addTouchEventListeners();\\n      }\\n    };\\n\\n    _proto._addTouchEventListeners = function _addTouchEventListeners() {\\n      var _this3 = this;\\n\\n      if (!this._touchSupported) {\\n        return;\\n      }\\n\\n      var start = function start(event) {\\n        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {\\n          _this3.touchStartX = event.originalEvent.clientX;\\n        } else if (!_this3._pointerEvent) {\\n          _this3.touchStartX = event.originalEvent.touches[0].clientX;\\n        }\\n      };\\n\\n      var move = function move(event) {\\n        // ensure swiping with one touch and not pinching\\n        if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {\\n          _this3.touchDeltaX = 0;\\n        } else {\\n          _this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;\\n        }\\n      };\\n\\n      var end = function end(event) {\\n        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {\\n          _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;\\n        }\\n\\n        _this3._handleSwipe();\\n\\n        if (_this3._config.pause === 'hover') {\\n          // If it's a touch-enabled device, mouseenter/leave are fired as\\n          // part of the mouse compatibility events on first tap - the carousel\\n          // would stop cycling until user tapped out of it;\\n          // here, we listen for touchend, explicitly pause the carousel\\n          // (as if it's the second time we tap on it, mouseenter compat event\\n          // is NOT fired) and after a timeout (to allow for mouse compatibility\\n          // events to fire) we explicitly restart cycling\\n          _this3.pause();\\n\\n          if (_this3.touchTimeout) {\\n            clearTimeout(_this3.touchTimeout);\\n          }\\n\\n          _this3.touchTimeout = setTimeout(function (event) {\\n            return _this3.cycle(event);\\n          }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);\\n        }\\n      };\\n\\n      $(this._element.querySelectorAll(Selector$2.ITEM_IMG)).on(Event$2.DRAG_START, function (e) {\\n        return e.preventDefault();\\n      });\\n\\n      if (this._pointerEvent) {\\n        $(this._element).on(Event$2.POINTERDOWN, function (event) {\\n          return start(event);\\n        });\\n        $(this._element).on(Event$2.POINTERUP, function (event) {\\n          return end(event);\\n        });\\n\\n        this._element.classList.add(ClassName$2.POINTER_EVENT);\\n      } else {\\n        $(this._element).on(Event$2.TOUCHSTART, function (event) {\\n          return start(event);\\n        });\\n        $(this._element).on(Event$2.TOUCHMOVE, function (event) {\\n          return move(event);\\n        });\\n        $(this._element).on(Event$2.TOUCHEND, function (event) {\\n          return end(event);\\n        });\\n      }\\n    };\\n\\n    _proto._keydown = function _keydown(event) {\\n      if (/input|textarea/i.test(event.target.tagName)) {\\n        return;\\n      }\\n\\n      switch (event.which) {\\n        case ARROW_LEFT_KEYCODE:\\n          event.preventDefault();\\n          this.prev();\\n          break;\\n\\n        case ARROW_RIGHT_KEYCODE:\\n          event.preventDefault();\\n          this.next();\\n          break;\\n      }\\n    };\\n\\n    _proto._getItemIndex = function _getItemIndex(element) {\\n      this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector$2.ITEM)) : [];\\n      return this._items.indexOf(element);\\n    };\\n\\n    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {\\n      var isNextDirection = direction === Direction.NEXT;\\n      var isPrevDirection = direction === Direction.PREV;\\n\\n      var activeIndex = this._getItemIndex(activeElement);\\n\\n      var lastItemIndex = this._items.length - 1;\\n      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;\\n\\n      if (isGoingToWrap && !this._config.wrap) {\\n        return activeElement;\\n      }\\n\\n      var delta = direction === Direction.PREV ? -1 : 1;\\n      var itemIndex = (activeIndex + delta) % this._items.length;\\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\\n    };\\n\\n    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {\\n      var targetIndex = this._getItemIndex(relatedTarget);\\n\\n      var fromIndex = this._getItemIndex(this._element.querySelector(Selector$2.ACTIVE_ITEM));\\n\\n      var slideEvent = $.Event(Event$2.SLIDE, {\\n        relatedTarget: relatedTarget,\\n        direction: eventDirectionName,\\n        from: fromIndex,\\n        to: targetIndex\\n      });\\n      $(this._element).trigger(slideEvent);\\n      return slideEvent;\\n    };\\n\\n    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {\\n      if (this._indicatorsElement) {\\n        var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(Selector$2.ACTIVE));\\n        $(indicators).removeClass(ClassName$2.ACTIVE);\\n\\n        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];\\n\\n        if (nextIndicator) {\\n          $(nextIndicator).addClass(ClassName$2.ACTIVE);\\n        }\\n      }\\n    };\\n\\n    _proto._slide = function _slide(direction, element) {\\n      var _this4 = this;\\n\\n      var activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);\\n\\n      var activeElementIndex = this._getItemIndex(activeElement);\\n\\n      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);\\n\\n      var nextElementIndex = this._getItemIndex(nextElement);\\n\\n      var isCycling = Boolean(this._interval);\\n      var directionalClassName;\\n      var orderClassName;\\n      var eventDirectionName;\\n\\n      if (direction === Direction.NEXT) {\\n        directionalClassName = ClassName$2.LEFT;\\n        orderClassName = ClassName$2.NEXT;\\n        eventDirectionName = Direction.LEFT;\\n      } else {\\n        directionalClassName = ClassName$2.RIGHT;\\n        orderClassName = ClassName$2.PREV;\\n        eventDirectionName = Direction.RIGHT;\\n      }\\n\\n      if (nextElement && $(nextElement).hasClass(ClassName$2.ACTIVE)) {\\n        this._isSliding = false;\\n        return;\\n      }\\n\\n      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\\n\\n      if (slideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (!activeElement || !nextElement) {\\n        // Some weirdness is happening, so we bail\\n        return;\\n      }\\n\\n      this._isSliding = true;\\n\\n      if (isCycling) {\\n        this.pause();\\n      }\\n\\n      this._setActiveIndicatorElement(nextElement);\\n\\n      var slidEvent = $.Event(Event$2.SLID, {\\n        relatedTarget: nextElement,\\n        direction: eventDirectionName,\\n        from: activeElementIndex,\\n        to: nextElementIndex\\n      });\\n\\n      if ($(this._element).hasClass(ClassName$2.SLIDE)) {\\n        $(nextElement).addClass(orderClassName);\\n        Util.reflow(nextElement);\\n        $(activeElement).addClass(directionalClassName);\\n        $(nextElement).addClass(directionalClassName);\\n        var nextElementInterval = parseInt(nextElement.getAttribute('data-interval'), 10);\\n\\n        if (nextElementInterval) {\\n          this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\\n          this._config.interval = nextElementInterval;\\n        } else {\\n          this._config.interval = this._config.defaultInterval || this._config.interval;\\n        }\\n\\n        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);\\n        $(activeElement).one(Util.TRANSITION_END, function () {\\n          $(nextElement).removeClass(directionalClassName + \\\" \\\" + orderClassName).addClass(ClassName$2.ACTIVE);\\n          $(activeElement).removeClass(ClassName$2.ACTIVE + \\\" \\\" + orderClassName + \\\" \\\" + directionalClassName);\\n          _this4._isSliding = false;\\n          setTimeout(function () {\\n            return $(_this4._element).trigger(slidEvent);\\n          }, 0);\\n        }).emulateTransitionEnd(transitionDuration);\\n      } else {\\n        $(activeElement).removeClass(ClassName$2.ACTIVE);\\n        $(nextElement).addClass(ClassName$2.ACTIVE);\\n        this._isSliding = false;\\n        $(this._element).trigger(slidEvent);\\n      }\\n\\n      if (isCycling) {\\n        this.cycle();\\n      }\\n    } // Static\\n    ;\\n\\n    Carousel._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY$2);\\n\\n        var _config = _objectSpread2({}, Default, {}, $(this).data());\\n\\n        if (typeof config === 'object') {\\n          _config = _objectSpread2({}, _config, {}, config);\\n        }\\n\\n        var action = typeof config === 'string' ? config : _config.slide;\\n\\n        if (!data) {\\n          data = new Carousel(this, _config);\\n          $(this).data(DATA_KEY$2, data);\\n        }\\n\\n        if (typeof config === 'number') {\\n          data.to(config);\\n        } else if (typeof action === 'string') {\\n          if (typeof data[action] === 'undefined') {\\n            throw new TypeError(\\\"No method named \\\\\\\"\\\" + action + \\\"\\\\\\\"\\\");\\n          }\\n\\n          data[action]();\\n        } else if (_config.interval && _config.ride) {\\n          data.pause();\\n          data.cycle();\\n        }\\n      });\\n    };\\n\\n    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {\\n      var selector = Util.getSelectorFromElement(this);\\n\\n      if (!selector) {\\n        return;\\n      }\\n\\n      var target = $(selector)[0];\\n\\n      if (!target || !$(target).hasClass(ClassName$2.CAROUSEL)) {\\n        return;\\n      }\\n\\n      var config = _objectSpread2({}, $(target).data(), {}, $(this).data());\\n\\n      var slideIndex = this.getAttribute('data-slide-to');\\n\\n      if (slideIndex) {\\n        config.interval = false;\\n      }\\n\\n      Carousel._jQueryInterface.call($(target), config);\\n\\n      if (slideIndex) {\\n        $(target).data(DATA_KEY$2).to(slideIndex);\\n      }\\n\\n      event.preventDefault();\\n    };\\n\\n    _createClass(Carousel, null, [{\\n      key: \\\"VERSION\\\",\\n      get: function get() {\\n        return VERSION$2;\\n      }\\n    }, {\\n      key: \\\"Default\\\",\\n      get: function get() {\\n        return Default;\\n      }\\n    }]);\\n\\n    return Carousel;\\n  }();\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $(document).on(Event$2.CLICK_DATA_API, Selector$2.DATA_SLIDE, Carousel._dataApiClickHandler);\\n  $(window).on(Event$2.LOAD_DATA_API, function () {\\n    var carousels = [].slice.call(document.querySelectorAll(Selector$2.DATA_RIDE));\\n\\n    for (var i = 0, len = carousels.length; i < len; i++) {\\n      var $carousel = $(carousels[i]);\\n\\n      Carousel._jQueryInterface.call($carousel, $carousel.data());\\n    }\\n  });\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME$2] = Carousel._jQueryInterface;\\n  $.fn[NAME$2].Constructor = Carousel;\\n\\n  $.fn[NAME$2].noConflict = function () {\\n    $.fn[NAME$2] = JQUERY_NO_CONFLICT$2;\\n    return Carousel._jQueryInterface;\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME$3 = 'collapse';\\n  var VERSION$3 = '4.4.1';\\n  var DATA_KEY$3 = 'bs.collapse';\\n  var EVENT_KEY$3 = \\\".\\\" + DATA_KEY$3;\\n  var DATA_API_KEY$3 = '.data-api';\\n  var JQUERY_NO_CONFLICT$3 = $.fn[NAME$3];\\n  var Default$1 = {\\n    toggle: true,\\n    parent: ''\\n  };\\n  var DefaultType$1 = {\\n    toggle: 'boolean',\\n    parent: '(string|element)'\\n  };\\n  var Event$3 = {\\n    SHOW: \\\"show\\\" + EVENT_KEY$3,\\n    SHOWN: \\\"shown\\\" + EVENT_KEY$3,\\n    HIDE: \\\"hide\\\" + EVENT_KEY$3,\\n    HIDDEN: \\\"hidden\\\" + EVENT_KEY$3,\\n    CLICK_DATA_API: \\\"click\\\" + EVENT_KEY$3 + DATA_API_KEY$3\\n  };\\n  var ClassName$3 = {\\n    SHOW: 'show',\\n    COLLAPSE: 'collapse',\\n    COLLAPSING: 'collapsing',\\n    COLLAPSED: 'collapsed'\\n  };\\n  var Dimension = {\\n    WIDTH: 'width',\\n    HEIGHT: 'height'\\n  };\\n  var Selector$3 = {\\n    ACTIVES: '.show, .collapsing',\\n    DATA_TOGGLE: '[data-toggle=\\\"collapse\\\"]'\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Collapse =\\n  /*#__PURE__*/\\n  function () {\\n    function Collapse(element, config) {\\n      this._isTransitioning = false;\\n      this._element = element;\\n      this._config = this._getConfig(config);\\n      this._triggerArray = [].slice.call(document.querySelectorAll(\\\"[data-toggle=\\\\\\\"collapse\\\\\\\"][href=\\\\\\\"#\\\" + element.id + \\\"\\\\\\\"],\\\" + (\\\"[data-toggle=\\\\\\\"collapse\\\\\\\"][data-target=\\\\\\\"#\\\" + element.id + \\\"\\\\\\\"]\\\")));\\n      var toggleList = [].slice.call(document.querySelectorAll(Selector$3.DATA_TOGGLE));\\n\\n      for (var i = 0, len = toggleList.length; i < len; i++) {\\n        var elem = toggleList[i];\\n        var selector = Util.getSelectorFromElement(elem);\\n        var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {\\n          return foundElem === element;\\n        });\\n\\n        if (selector !== null && filterElement.length > 0) {\\n          this._selector = selector;\\n\\n          this._triggerArray.push(elem);\\n        }\\n      }\\n\\n      this._parent = this._config.parent ? this._getParent() : null;\\n\\n      if (!this._config.parent) {\\n        this._addAriaAndCollapsedClass(this._element, this._triggerArray);\\n      }\\n\\n      if (this._config.toggle) {\\n        this.toggle();\\n      }\\n    } // Getters\\n\\n\\n    var _proto = Collapse.prototype;\\n\\n    // Public\\n    _proto.toggle = function toggle() {\\n      if ($(this._element).hasClass(ClassName$3.SHOW)) {\\n        this.hide();\\n      } else {\\n        this.show();\\n      }\\n    };\\n\\n    _proto.show = function show() {\\n      var _this = this;\\n\\n      if (this._isTransitioning || $(this._element).hasClass(ClassName$3.SHOW)) {\\n        return;\\n      }\\n\\n      var actives;\\n      var activesData;\\n\\n      if (this._parent) {\\n        actives = [].slice.call(this._parent.querySelectorAll(Selector$3.ACTIVES)).filter(function (elem) {\\n          if (typeof _this._config.parent === 'string') {\\n            return elem.getAttribute('data-parent') === _this._config.parent;\\n          }\\n\\n          return elem.classList.contains(ClassName$3.COLLAPSE);\\n        });\\n\\n        if (actives.length === 0) {\\n          actives = null;\\n        }\\n      }\\n\\n      if (actives) {\\n        activesData = $(actives).not(this._selector).data(DATA_KEY$3);\\n\\n        if (activesData && activesData._isTransitioning) {\\n          return;\\n        }\\n      }\\n\\n      var startEvent = $.Event(Event$3.SHOW);\\n      $(this._element).trigger(startEvent);\\n\\n      if (startEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (actives) {\\n        Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');\\n\\n        if (!activesData) {\\n          $(actives).data(DATA_KEY$3, null);\\n        }\\n      }\\n\\n      var dimension = this._getDimension();\\n\\n      $(this._element).removeClass(ClassName$3.COLLAPSE).addClass(ClassName$3.COLLAPSING);\\n      this._element.style[dimension] = 0;\\n\\n      if (this._triggerArray.length) {\\n        $(this._triggerArray).removeClass(ClassName$3.COLLAPSED).attr('aria-expanded', true);\\n      }\\n\\n      this.setTransitioning(true);\\n\\n      var complete = function complete() {\\n        $(_this._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).addClass(ClassName$3.SHOW);\\n        _this._element.style[dimension] = '';\\n\\n        _this.setTransitioning(false);\\n\\n        $(_this._element).trigger(Event$3.SHOWN);\\n      };\\n\\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\\n      var scrollSize = \\\"scroll\\\" + capitalizedDimension;\\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\\n      this._element.style[dimension] = this._element[scrollSize] + \\\"px\\\";\\n    };\\n\\n    _proto.hide = function hide() {\\n      var _this2 = this;\\n\\n      if (this._isTransitioning || !$(this._element).hasClass(ClassName$3.SHOW)) {\\n        return;\\n      }\\n\\n      var startEvent = $.Event(Event$3.HIDE);\\n      $(this._element).trigger(startEvent);\\n\\n      if (startEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      var dimension = this._getDimension();\\n\\n      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + \\\"px\\\";\\n      Util.reflow(this._element);\\n      $(this._element).addClass(ClassName$3.COLLAPSING).removeClass(ClassName$3.COLLAPSE).removeClass(ClassName$3.SHOW);\\n      var triggerArrayLength = this._triggerArray.length;\\n\\n      if (triggerArrayLength > 0) {\\n        for (var i = 0; i < triggerArrayLength; i++) {\\n          var trigger = this._triggerArray[i];\\n          var selector = Util.getSelectorFromElement(trigger);\\n\\n          if (selector !== null) {\\n            var $elem = $([].slice.call(document.querySelectorAll(selector)));\\n\\n            if (!$elem.hasClass(ClassName$3.SHOW)) {\\n              $(trigger).addClass(ClassName$3.COLLAPSED).attr('aria-expanded', false);\\n            }\\n          }\\n        }\\n      }\\n\\n      this.setTransitioning(true);\\n\\n      var complete = function complete() {\\n        _this2.setTransitioning(false);\\n\\n        $(_this2._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).trigger(Event$3.HIDDEN);\\n      };\\n\\n      this._element.style[dimension] = '';\\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\\n      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\\n    };\\n\\n    _proto.setTransitioning = function setTransitioning(isTransitioning) {\\n      this._isTransitioning = isTransitioning;\\n    };\\n\\n    _proto.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY$3);\\n      this._config = null;\\n      this._parent = null;\\n      this._element = null;\\n      this._triggerArray = null;\\n      this._isTransitioning = null;\\n    } // Private\\n    ;\\n\\n    _proto._getConfig = function _getConfig(config) {\\n      config = _objectSpread2({}, Default$1, {}, config);\\n      config.toggle = Boolean(config.toggle); // Coerce string values\\n\\n      Util.typeCheckConfig(NAME$3, config, DefaultType$1);\\n      return config;\\n    };\\n\\n    _proto._getDimension = function _getDimension() {\\n      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);\\n      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;\\n    };\\n\\n    _proto._getParent = function _getParent() {\\n      var _this3 = this;\\n\\n      var parent;\\n\\n      if (Util.isElement(this._config.parent)) {\\n        parent = this._config.parent; // It's a jQuery object\\n\\n        if (typeof this._config.parent.jquery !== 'undefined') {\\n          parent = this._config.parent[0];\\n        }\\n      } else {\\n        parent = document.querySelector(this._config.parent);\\n      }\\n\\n      var selector = \\\"[data-toggle=\\\\\\\"collapse\\\\\\\"][data-parent=\\\\\\\"\\\" + this._config.parent + \\\"\\\\\\\"]\\\";\\n      var children = [].slice.call(parent.querySelectorAll(selector));\\n      $(children).each(function (i, element) {\\n        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\\n      });\\n      return parent;\\n    };\\n\\n    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\\n      var isOpen = $(element).hasClass(ClassName$3.SHOW);\\n\\n      if (triggerArray.length) {\\n        $(triggerArray).toggleClass(ClassName$3.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\\n      }\\n    } // Static\\n    ;\\n\\n    Collapse._getTargetFromElement = function _getTargetFromElement(element) {\\n      var selector = Util.getSelectorFromElement(element);\\n      return selector ? document.querySelector(selector) : null;\\n    };\\n\\n    Collapse._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var $this = $(this);\\n        var data = $this.data(DATA_KEY$3);\\n\\n        var _config = _objectSpread2({}, Default$1, {}, $this.data(), {}, typeof config === 'object' && config ? config : {});\\n\\n        if (!data && _config.toggle && /show|hide/.test(config)) {\\n          _config.toggle = false;\\n        }\\n\\n        if (!data) {\\n          data = new Collapse(this, _config);\\n          $this.data(DATA_KEY$3, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (typeof data[config] === 'undefined') {\\n            throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n          }\\n\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Collapse, null, [{\\n      key: \\\"VERSION\\\",\\n      get: function get() {\\n        return VERSION$3;\\n      }\\n    }, {\\n      key: \\\"Default\\\",\\n      get: function get() {\\n        return Default$1;\\n      }\\n    }]);\\n\\n    return Collapse;\\n  }();\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $(document).on(Event$3.CLICK_DATA_API, Selector$3.DATA_TOGGLE, function (event) {\\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\\n    if (event.currentTarget.tagName === 'A') {\\n      event.preventDefault();\\n    }\\n\\n    var $trigger = $(this);\\n    var selector = Util.getSelectorFromElement(this);\\n    var selectors = [].slice.call(document.querySelectorAll(selector));\\n    $(selectors).each(function () {\\n      var $target = $(this);\\n      var data = $target.data(DATA_KEY$3);\\n      var config = data ? 'toggle' : $trigger.data();\\n\\n      Collapse._jQueryInterface.call($target, config);\\n    });\\n  });\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME$3] = Collapse._jQueryInterface;\\n  $.fn[NAME$3].Constructor = Collapse;\\n\\n  $.fn[NAME$3].noConflict = function () {\\n    $.fn[NAME$3] = JQUERY_NO_CONFLICT$3;\\n    return Collapse._jQueryInterface;\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME$4 = 'dropdown';\\n  var VERSION$4 = '4.4.1';\\n  var DATA_KEY$4 = 'bs.dropdown';\\n  var EVENT_KEY$4 = \\\".\\\" + DATA_KEY$4;\\n  var DATA_API_KEY$4 = '.data-api';\\n  var JQUERY_NO_CONFLICT$4 = $.fn[NAME$4];\\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\\n\\n  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key\\n\\n  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key\\n\\n  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\\n\\n  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\\n\\n  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\\n\\n  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + \\\"|\\\" + ARROW_DOWN_KEYCODE + \\\"|\\\" + ESCAPE_KEYCODE);\\n  var Event$4 = {\\n    HIDE: \\\"hide\\\" + EVENT_KEY$4,\\n    HIDDEN: \\\"hidden\\\" + EVENT_KEY$4,\\n    SHOW: \\\"show\\\" + EVENT_KEY$4,\\n    SHOWN: \\\"shown\\\" + EVENT_KEY$4,\\n    CLICK: \\\"click\\\" + EVENT_KEY$4,\\n    CLICK_DATA_API: \\\"click\\\" + EVENT_KEY$4 + DATA_API_KEY$4,\\n    KEYDOWN_DATA_API: \\\"keydown\\\" + EVENT_KEY$4 + DATA_API_KEY$4,\\n    KEYUP_DATA_API: \\\"keyup\\\" + EVENT_KEY$4 + DATA_API_KEY$4\\n  };\\n  var ClassName$4 = {\\n    DISABLED: 'disabled',\\n    SHOW: 'show',\\n    DROPUP: 'dropup',\\n    DROPRIGHT: 'dropright',\\n    DROPLEFT: 'dropleft',\\n    MENURIGHT: 'dropdown-menu-right',\\n    MENULEFT: 'dropdown-menu-left',\\n    POSITION_STATIC: 'position-static'\\n  };\\n  var Selector$4 = {\\n    DATA_TOGGLE: '[data-toggle=\\\"dropdown\\\"]',\\n    FORM_CHILD: '.dropdown form',\\n    MENU: '.dropdown-menu',\\n    NAVBAR_NAV: '.navbar-nav',\\n    VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'\\n  };\\n  var AttachmentMap = {\\n    TOP: 'top-start',\\n    TOPEND: 'top-end',\\n    BOTTOM: 'bottom-start',\\n    BOTTOMEND: 'bottom-end',\\n    RIGHT: 'right-start',\\n    RIGHTEND: 'right-end',\\n    LEFT: 'left-start',\\n    LEFTEND: 'left-end'\\n  };\\n  var Default$2 = {\\n    offset: 0,\\n    flip: true,\\n    boundary: 'scrollParent',\\n    reference: 'toggle',\\n    display: 'dynamic',\\n    popperConfig: null\\n  };\\n  var DefaultType$2 = {\\n    offset: '(number|string|function)',\\n    flip: 'boolean',\\n    boundary: '(string|element)',\\n    reference: '(string|element)',\\n    display: 'string',\\n    popperConfig: '(null|object)'\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Dropdown =\\n  /*#__PURE__*/\\n  function () {\\n    function Dropdown(element, config) {\\n      this._element = element;\\n      this._popper = null;\\n      this._config = this._getConfig(config);\\n      this._menu = this._getMenuElement();\\n      this._inNavbar = this._detectNavbar();\\n\\n      this._addEventListeners();\\n    } // Getters\\n\\n\\n    var _proto = Dropdown.prototype;\\n\\n    // Public\\n    _proto.toggle = function toggle() {\\n      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED)) {\\n        return;\\n      }\\n\\n      var isActive = $(this._menu).hasClass(ClassName$4.SHOW);\\n\\n      Dropdown._clearMenus();\\n\\n      if (isActive) {\\n        return;\\n      }\\n\\n      this.show(true);\\n    };\\n\\n    _proto.show = function show(usePopper) {\\n      if (usePopper === void 0) {\\n        usePopper = false;\\n      }\\n\\n      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || $(this._menu).hasClass(ClassName$4.SHOW)) {\\n        return;\\n      }\\n\\n      var relatedTarget = {\\n        relatedTarget: this._element\\n      };\\n      var showEvent = $.Event(Event$4.SHOW, relatedTarget);\\n\\n      var parent = Dropdown._getParentFromElement(this._element);\\n\\n      $(parent).trigger(showEvent);\\n\\n      if (showEvent.isDefaultPrevented()) {\\n        return;\\n      } // Disable totally Popper.js for Dropdown in Navbar\\n\\n\\n      if (!this._inNavbar && usePopper) {\\n        /**\\n         * Check for Popper dependency\\n         * Popper - https://popper.js.org\\n         */\\n        if (typeof Popper === 'undefined') {\\n          throw new TypeError('Bootstrap\\\\'s dropdowns require Popper.js (https://popper.js.org/)');\\n        }\\n\\n        var referenceElement = this._element;\\n\\n        if (this._config.reference === 'parent') {\\n          referenceElement = parent;\\n        } else if (Util.isElement(this._config.reference)) {\\n          referenceElement = this._config.reference; // Check if it's jQuery element\\n\\n          if (typeof this._config.reference.jquery !== 'undefined') {\\n            referenceElement = this._config.reference[0];\\n          }\\n        } // If boundary is not `scrollParent`, then set position to `static`\\n        // to allow the menu to \\\"escape\\\" the scroll parent's boundaries\\n        // https://github.com/twbs/bootstrap/issues/24251\\n\\n\\n        if (this._config.boundary !== 'scrollParent') {\\n          $(parent).addClass(ClassName$4.POSITION_STATIC);\\n        }\\n\\n        this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());\\n      } // If this is a touch-enabled device we add extra\\n      // empty mouseover listeners to the body's immediate children;\\n      // only needed because of broken event delegation on iOS\\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\\n\\n\\n      if ('ontouchstart' in document.documentElement && $(parent).closest(Selector$4.NAVBAR_NAV).length === 0) {\\n        $(document.body).children().on('mouseover', null, $.noop);\\n      }\\n\\n      this._element.focus();\\n\\n      this._element.setAttribute('aria-expanded', true);\\n\\n      $(this._menu).toggleClass(ClassName$4.SHOW);\\n      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));\\n    };\\n\\n    _proto.hide = function hide() {\\n      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || !$(this._menu).hasClass(ClassName$4.SHOW)) {\\n        return;\\n      }\\n\\n      var relatedTarget = {\\n        relatedTarget: this._element\\n      };\\n      var hideEvent = $.Event(Event$4.HIDE, relatedTarget);\\n\\n      var parent = Dropdown._getParentFromElement(this._element);\\n\\n      $(parent).trigger(hideEvent);\\n\\n      if (hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (this._popper) {\\n        this._popper.destroy();\\n      }\\n\\n      $(this._menu).toggleClass(ClassName$4.SHOW);\\n      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));\\n    };\\n\\n    _proto.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY$4);\\n      $(this._element).off(EVENT_KEY$4);\\n      this._element = null;\\n      this._menu = null;\\n\\n      if (this._popper !== null) {\\n        this._popper.destroy();\\n\\n        this._popper = null;\\n      }\\n    };\\n\\n    _proto.update = function update() {\\n      this._inNavbar = this._detectNavbar();\\n\\n      if (this._popper !== null) {\\n        this._popper.scheduleUpdate();\\n      }\\n    } // Private\\n    ;\\n\\n    _proto._addEventListeners = function _addEventListeners() {\\n      var _this = this;\\n\\n      $(this._element).on(Event$4.CLICK, function (event) {\\n        event.preventDefault();\\n        event.stopPropagation();\\n\\n        _this.toggle();\\n      });\\n    };\\n\\n    _proto._getConfig = function _getConfig(config) {\\n      config = _objectSpread2({}, this.constructor.Default, {}, $(this._element).data(), {}, config);\\n      Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);\\n      return config;\\n    };\\n\\n    _proto._getMenuElement = function _getMenuElement() {\\n      if (!this._menu) {\\n        var parent = Dropdown._getParentFromElement(this._element);\\n\\n        if (parent) {\\n          this._menu = parent.querySelector(Selector$4.MENU);\\n        }\\n      }\\n\\n      return this._menu;\\n    };\\n\\n    _proto._getPlacement = function _getPlacement() {\\n      var $parentDropdown = $(this._element.parentNode);\\n      var placement = AttachmentMap.BOTTOM; // Handle dropup\\n\\n      if ($parentDropdown.hasClass(ClassName$4.DROPUP)) {\\n        placement = AttachmentMap.TOP;\\n\\n        if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {\\n          placement = AttachmentMap.TOPEND;\\n        }\\n      } else if ($parentDropdown.hasClass(ClassName$4.DROPRIGHT)) {\\n        placement = AttachmentMap.RIGHT;\\n      } else if ($parentDropdown.hasClass(ClassName$4.DROPLEFT)) {\\n        placement = AttachmentMap.LEFT;\\n      } else if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {\\n        placement = AttachmentMap.BOTTOMEND;\\n      }\\n\\n      return placement;\\n    };\\n\\n    _proto._detectNavbar = function _detectNavbar() {\\n      return $(this._element).closest('.navbar').length > 0;\\n    };\\n\\n    _proto._getOffset = function _getOffset() {\\n      var _this2 = this;\\n\\n      var offset = {};\\n\\n      if (typeof this._config.offset === 'function') {\\n        offset.fn = function (data) {\\n          data.offsets = _objectSpread2({}, data.offsets, {}, _this2._config.offset(data.offsets, _this2._element) || {});\\n          return data;\\n        };\\n      } else {\\n        offset.offset = this._config.offset;\\n      }\\n\\n      return offset;\\n    };\\n\\n    _proto._getPopperConfig = function _getPopperConfig() {\\n      var popperConfig = {\\n        placement: this._getPlacement(),\\n        modifiers: {\\n          offset: this._getOffset(),\\n          flip: {\\n            enabled: this._config.flip\\n          },\\n          preventOverflow: {\\n            boundariesElement: this._config.boundary\\n          }\\n        }\\n      }; // Disable Popper.js if we have a static display\\n\\n      if (this._config.display === 'static') {\\n        popperConfig.modifiers.applyStyle = {\\n          enabled: false\\n        };\\n      }\\n\\n      return _objectSpread2({}, popperConfig, {}, this._config.popperConfig);\\n    } // Static\\n    ;\\n\\n    Dropdown._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY$4);\\n\\n        var _config = typeof config === 'object' ? config : null;\\n\\n        if (!data) {\\n          data = new Dropdown(this, _config);\\n          $(this).data(DATA_KEY$4, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (typeof data[config] === 'undefined') {\\n            throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n          }\\n\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    Dropdown._clearMenus = function _clearMenus(event) {\\n      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {\\n        return;\\n      }\\n\\n      var toggles = [].slice.call(document.querySelectorAll(Selector$4.DATA_TOGGLE));\\n\\n      for (var i = 0, len = toggles.length; i < len; i++) {\\n        var parent = Dropdown._getParentFromElement(toggles[i]);\\n\\n        var context = $(toggles[i]).data(DATA_KEY$4);\\n        var relatedTarget = {\\n          relatedTarget: toggles[i]\\n        };\\n\\n        if (event && event.type === 'click') {\\n          relatedTarget.clickEvent = event;\\n        }\\n\\n        if (!context) {\\n          continue;\\n        }\\n\\n        var dropdownMenu = context._menu;\\n\\n        if (!$(parent).hasClass(ClassName$4.SHOW)) {\\n          continue;\\n        }\\n\\n        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {\\n          continue;\\n        }\\n\\n        var hideEvent = $.Event(Event$4.HIDE, relatedTarget);\\n        $(parent).trigger(hideEvent);\\n\\n        if (hideEvent.isDefaultPrevented()) {\\n          continue;\\n        } // If this is a touch-enabled device we remove the extra\\n        // empty mouseover listeners we added for iOS support\\n\\n\\n        if ('ontouchstart' in document.documentElement) {\\n          $(document.body).children().off('mouseover', null, $.noop);\\n        }\\n\\n        toggles[i].setAttribute('aria-expanded', 'false');\\n\\n        if (context._popper) {\\n          context._popper.destroy();\\n        }\\n\\n        $(dropdownMenu).removeClass(ClassName$4.SHOW);\\n        $(parent).removeClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));\\n      }\\n    };\\n\\n    Dropdown._getParentFromElement = function _getParentFromElement(element) {\\n      var parent;\\n      var selector = Util.getSelectorFromElement(element);\\n\\n      if (selector) {\\n        parent = document.querySelector(selector);\\n      }\\n\\n      return parent || element.parentNode;\\n    } // eslint-disable-next-line complexity\\n    ;\\n\\n    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {\\n      // If not input/textarea:\\n      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\\n      // If input/textarea:\\n      //  - If space key => not a dropdown command\\n      //  - If key is other than escape\\n      //    - If key is not up or down => not a dropdown command\\n      //    - If trigger inside the menu => not a dropdown command\\n      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $(event.target).closest(Selector$4.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {\\n        return;\\n      }\\n\\n      event.preventDefault();\\n      event.stopPropagation();\\n\\n      if (this.disabled || $(this).hasClass(ClassName$4.DISABLED)) {\\n        return;\\n      }\\n\\n      var parent = Dropdown._getParentFromElement(this);\\n\\n      var isActive = $(parent).hasClass(ClassName$4.SHOW);\\n\\n      if (!isActive && event.which === ESCAPE_KEYCODE) {\\n        return;\\n      }\\n\\n      if (!isActive || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {\\n        if (event.which === ESCAPE_KEYCODE) {\\n          var toggle = parent.querySelector(Selector$4.DATA_TOGGLE);\\n          $(toggle).trigger('focus');\\n        }\\n\\n        $(this).trigger('click');\\n        return;\\n      }\\n\\n      var items = [].slice.call(parent.querySelectorAll(Selector$4.VISIBLE_ITEMS)).filter(function (item) {\\n        return $(item).is(':visible');\\n      });\\n\\n      if (items.length === 0) {\\n        return;\\n      }\\n\\n      var index = items.indexOf(event.target);\\n\\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\\n        // Up\\n        index--;\\n      }\\n\\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\\n        // Down\\n        index++;\\n      }\\n\\n      if (index < 0) {\\n        index = 0;\\n      }\\n\\n      items[index].focus();\\n    };\\n\\n    _createClass(Dropdown, null, [{\\n      key: \\\"VERSION\\\",\\n      get: function get() {\\n        return VERSION$4;\\n      }\\n    }, {\\n      key: \\\"Default\\\",\\n      get: function get() {\\n        return Default$2;\\n      }\\n    }, {\\n      key: \\\"DefaultType\\\",\\n      get: function get() {\\n        return DefaultType$2;\\n      }\\n    }]);\\n\\n    return Dropdown;\\n  }();\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $(document).on(Event$4.KEYDOWN_DATA_API, Selector$4.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event$4.KEYDOWN_DATA_API, Selector$4.MENU, Dropdown._dataApiKeydownHandler).on(Event$4.CLICK_DATA_API + \\\" \\\" + Event$4.KEYUP_DATA_API, Dropdown._clearMenus).on(Event$4.CLICK_DATA_API, Selector$4.DATA_TOGGLE, function (event) {\\n    event.preventDefault();\\n    event.stopPropagation();\\n\\n    Dropdown._jQueryInterface.call($(this), 'toggle');\\n  }).on(Event$4.CLICK_DATA_API, Selector$4.FORM_CHILD, function (e) {\\n    e.stopPropagation();\\n  });\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME$4] = Dropdown._jQueryInterface;\\n  $.fn[NAME$4].Constructor = Dropdown;\\n\\n  $.fn[NAME$4].noConflict = function () {\\n    $.fn[NAME$4] = JQUERY_NO_CONFLICT$4;\\n    return Dropdown._jQueryInterface;\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME$5 = 'modal';\\n  var VERSION$5 = '4.4.1';\\n  var DATA_KEY$5 = 'bs.modal';\\n  var EVENT_KEY$5 = \\\".\\\" + DATA_KEY$5;\\n  var DATA_API_KEY$5 = '.data-api';\\n  var JQUERY_NO_CONFLICT$5 = $.fn[NAME$5];\\n  var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key\\n\\n  var Default$3 = {\\n    backdrop: true,\\n    keyboard: true,\\n    focus: true,\\n    show: true\\n  };\\n  var DefaultType$3 = {\\n    backdrop: '(boolean|string)',\\n    keyboard: 'boolean',\\n    focus: 'boolean',\\n    show: 'boolean'\\n  };\\n  var Event$5 = {\\n    HIDE: \\\"hide\\\" + EVENT_KEY$5,\\n    HIDE_PREVENTED: \\\"hidePrevented\\\" + EVENT_KEY$5,\\n    HIDDEN: \\\"hidden\\\" + EVENT_KEY$5,\\n    SHOW: \\\"show\\\" + EVENT_KEY$5,\\n    SHOWN: \\\"shown\\\" + EVENT_KEY$5,\\n    FOCUSIN: \\\"focusin\\\" + EVENT_KEY$5,\\n    RESIZE: \\\"resize\\\" + EVENT_KEY$5,\\n    CLICK_DISMISS: \\\"click.dismiss\\\" + EVENT_KEY$5,\\n    KEYDOWN_DISMISS: \\\"keydown.dismiss\\\" + EVENT_KEY$5,\\n    MOUSEUP_DISMISS: \\\"mouseup.dismiss\\\" + EVENT_KEY$5,\\n    MOUSEDOWN_DISMISS: \\\"mousedown.dismiss\\\" + EVENT_KEY$5,\\n    CLICK_DATA_API: \\\"click\\\" + EVENT_KEY$5 + DATA_API_KEY$5\\n  };\\n  var ClassName$5 = {\\n    SCROLLABLE: 'modal-dialog-scrollable',\\n    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\\n    BACKDROP: 'modal-backdrop',\\n    OPEN: 'modal-open',\\n    FADE: 'fade',\\n    SHOW: 'show',\\n    STATIC: 'modal-static'\\n  };\\n  var Selector$5 = {\\n    DIALOG: '.modal-dialog',\\n    MODAL_BODY: '.modal-body',\\n    DATA_TOGGLE: '[data-toggle=\\\"modal\\\"]',\\n    DATA_DISMISS: '[data-dismiss=\\\"modal\\\"]',\\n    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',\\n    STICKY_CONTENT: '.sticky-top'\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Modal =\\n  /*#__PURE__*/\\n  function () {\\n    function Modal(element, config) {\\n      this._config = this._getConfig(config);\\n      this._element = element;\\n      this._dialog = element.querySelector(Selector$5.DIALOG);\\n      this._backdrop = null;\\n      this._isShown = false;\\n      this._isBodyOverflowing = false;\\n      this._ignoreBackdropClick = false;\\n      this._isTransitioning = false;\\n      this._scrollbarWidth = 0;\\n    } // Getters\\n\\n\\n    var _proto = Modal.prototype;\\n\\n    // Public\\n    _proto.toggle = function toggle(relatedTarget) {\\n      return this._isShown ? this.hide() : this.show(relatedTarget);\\n    };\\n\\n    _proto.show = function show(relatedTarget) {\\n      var _this = this;\\n\\n      if (this._isShown || this._isTransitioning) {\\n        return;\\n      }\\n\\n      if ($(this._element).hasClass(ClassName$5.FADE)) {\\n        this._isTransitioning = true;\\n      }\\n\\n      var showEvent = $.Event(Event$5.SHOW, {\\n        relatedTarget: relatedTarget\\n      });\\n      $(this._element).trigger(showEvent);\\n\\n      if (this._isShown || showEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      this._isShown = true;\\n\\n      this._checkScrollbar();\\n\\n      this._setScrollbar();\\n\\n      this._adjustDialog();\\n\\n      this._setEscapeEvent();\\n\\n      this._setResizeEvent();\\n\\n      $(this._element).on(Event$5.CLICK_DISMISS, Selector$5.DATA_DISMISS, function (event) {\\n        return _this.hide(event);\\n      });\\n      $(this._dialog).on(Event$5.MOUSEDOWN_DISMISS, function () {\\n        $(_this._element).one(Event$5.MOUSEUP_DISMISS, function (event) {\\n          if ($(event.target).is(_this._element)) {\\n            _this._ignoreBackdropClick = true;\\n          }\\n        });\\n      });\\n\\n      this._showBackdrop(function () {\\n        return _this._showElement(relatedTarget);\\n      });\\n    };\\n\\n    _proto.hide = function hide(event) {\\n      var _this2 = this;\\n\\n      if (event) {\\n        event.preventDefault();\\n      }\\n\\n      if (!this._isShown || this._isTransitioning) {\\n        return;\\n      }\\n\\n      var hideEvent = $.Event(Event$5.HIDE);\\n      $(this._element).trigger(hideEvent);\\n\\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      this._isShown = false;\\n      var transition = $(this._element).hasClass(ClassName$5.FADE);\\n\\n      if (transition) {\\n        this._isTransitioning = true;\\n      }\\n\\n      this._setEscapeEvent();\\n\\n      this._setResizeEvent();\\n\\n      $(document).off(Event$5.FOCUSIN);\\n      $(this._element).removeClass(ClassName$5.SHOW);\\n      $(this._element).off(Event$5.CLICK_DISMISS);\\n      $(this._dialog).off(Event$5.MOUSEDOWN_DISMISS);\\n\\n      if (transition) {\\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\\n        $(this._element).one(Util.TRANSITION_END, function (event) {\\n          return _this2._hideModal(event);\\n        }).emulateTransitionEnd(transitionDuration);\\n      } else {\\n        this._hideModal();\\n      }\\n    };\\n\\n    _proto.dispose = function dispose() {\\n      [window, this._element, this._dialog].forEach(function (htmlElement) {\\n        return $(htmlElement).off(EVENT_KEY$5);\\n      });\\n      /**\\n       * `document` has 2 events `Event.FOCUSIN` and `Event.CLICK_DATA_API`\\n       * Do not move `document` in `htmlElements` array\\n       * It will remove `Event.CLICK_DATA_API` event that should remain\\n       */\\n\\n      $(document).off(Event$5.FOCUSIN);\\n      $.removeData(this._element, DATA_KEY$5);\\n      this._config = null;\\n      this._element = null;\\n      this._dialog = null;\\n      this._backdrop = null;\\n      this._isShown = null;\\n      this._isBodyOverflowing = null;\\n      this._ignoreBackdropClick = null;\\n      this._isTransitioning = null;\\n      this._scrollbarWidth = null;\\n    };\\n\\n    _proto.handleUpdate = function handleUpdate() {\\n      this._adjustDialog();\\n    } // Private\\n    ;\\n\\n    _proto._getConfig = function _getConfig(config) {\\n      config = _objectSpread2({}, Default$3, {}, config);\\n      Util.typeCheckConfig(NAME$5, config, DefaultType$3);\\n      return config;\\n    };\\n\\n    _proto._triggerBackdropTransition = function _triggerBackdropTransition() {\\n      var _this3 = this;\\n\\n      if (this._config.backdrop === 'static') {\\n        var hideEventPrevented = $.Event(Event$5.HIDE_PREVENTED);\\n        $(this._element).trigger(hideEventPrevented);\\n\\n        if (hideEventPrevented.defaultPrevented) {\\n          return;\\n        }\\n\\n        this._element.classList.add(ClassName$5.STATIC);\\n\\n        var modalTransitionDuration = Util.getTransitionDurationFromElement(this._element);\\n        $(this._element).one(Util.TRANSITION_END, function () {\\n          _this3._element.classList.remove(ClassName$5.STATIC);\\n        }).emulateTransitionEnd(modalTransitionDuration);\\n\\n        this._element.focus();\\n      } else {\\n        this.hide();\\n      }\\n    };\\n\\n    _proto._showElement = function _showElement(relatedTarget) {\\n      var _this4 = this;\\n\\n      var transition = $(this._element).hasClass(ClassName$5.FADE);\\n      var modalBody = this._dialog ? this._dialog.querySelector(Selector$5.MODAL_BODY) : null;\\n\\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\\n        // Don't move modal's DOM position\\n        document.body.appendChild(this._element);\\n      }\\n\\n      this._element.style.display = 'block';\\n\\n      this._element.removeAttribute('aria-hidden');\\n\\n      this._element.setAttribute('aria-modal', true);\\n\\n      if ($(this._dialog).hasClass(ClassName$5.SCROLLABLE) && modalBody) {\\n        modalBody.scrollTop = 0;\\n      } else {\\n        this._element.scrollTop = 0;\\n      }\\n\\n      if (transition) {\\n        Util.reflow(this._element);\\n      }\\n\\n      $(this._element).addClass(ClassName$5.SHOW);\\n\\n      if (this._config.focus) {\\n        this._enforceFocus();\\n      }\\n\\n      var shownEvent = $.Event(Event$5.SHOWN, {\\n        relatedTarget: relatedTarget\\n      });\\n\\n      var transitionComplete = function transitionComplete() {\\n        if (_this4._config.focus) {\\n          _this4._element.focus();\\n        }\\n\\n        _this4._isTransitioning = false;\\n        $(_this4._element).trigger(shownEvent);\\n      };\\n\\n      if (transition) {\\n        var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);\\n        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);\\n      } else {\\n        transitionComplete();\\n      }\\n    };\\n\\n    _proto._enforceFocus = function _enforceFocus() {\\n      var _this5 = this;\\n\\n      $(document).off(Event$5.FOCUSIN) // Guard against infinite focus loop\\n      .on(Event$5.FOCUSIN, function (event) {\\n        if (document !== event.target && _this5._element !== event.target && $(_this5._element).has(event.target).length === 0) {\\n          _this5._element.focus();\\n        }\\n      });\\n    };\\n\\n    _proto._setEscapeEvent = function _setEscapeEvent() {\\n      var _this6 = this;\\n\\n      if (this._isShown && this._config.keyboard) {\\n        $(this._element).on(Event$5.KEYDOWN_DISMISS, function (event) {\\n          if (event.which === ESCAPE_KEYCODE$1) {\\n            _this6._triggerBackdropTransition();\\n          }\\n        });\\n      } else if (!this._isShown) {\\n        $(this._element).off(Event$5.KEYDOWN_DISMISS);\\n      }\\n    };\\n\\n    _proto._setResizeEvent = function _setResizeEvent() {\\n      var _this7 = this;\\n\\n      if (this._isShown) {\\n        $(window).on(Event$5.RESIZE, function (event) {\\n          return _this7.handleUpdate(event);\\n        });\\n      } else {\\n        $(window).off(Event$5.RESIZE);\\n      }\\n    };\\n\\n    _proto._hideModal = function _hideModal() {\\n      var _this8 = this;\\n\\n      this._element.style.display = 'none';\\n\\n      this._element.setAttribute('aria-hidden', true);\\n\\n      this._element.removeAttribute('aria-modal');\\n\\n      this._isTransitioning = false;\\n\\n      this._showBackdrop(function () {\\n        $(document.body).removeClass(ClassName$5.OPEN);\\n\\n        _this8._resetAdjustments();\\n\\n        _this8._resetScrollbar();\\n\\n        $(_this8._element).trigger(Event$5.HIDDEN);\\n      });\\n    };\\n\\n    _proto._removeBackdrop = function _removeBackdrop() {\\n      if (this._backdrop) {\\n        $(this._backdrop).remove();\\n        this._backdrop = null;\\n      }\\n    };\\n\\n    _proto._showBackdrop = function _showBackdrop(callback) {\\n      var _this9 = this;\\n\\n      var animate = $(this._element).hasClass(ClassName$5.FADE) ? ClassName$5.FADE : '';\\n\\n      if (this._isShown && this._config.backdrop) {\\n        this._backdrop = document.createElement('div');\\n        this._backdrop.className = ClassName$5.BACKDROP;\\n\\n        if (animate) {\\n          this._backdrop.classList.add(animate);\\n        }\\n\\n        $(this._backdrop).appendTo(document.body);\\n        $(this._element).on(Event$5.CLICK_DISMISS, function (event) {\\n          if (_this9._ignoreBackdropClick) {\\n            _this9._ignoreBackdropClick = false;\\n            return;\\n          }\\n\\n          if (event.target !== event.currentTarget) {\\n            return;\\n          }\\n\\n          _this9._triggerBackdropTransition();\\n        });\\n\\n        if (animate) {\\n          Util.reflow(this._backdrop);\\n        }\\n\\n        $(this._backdrop).addClass(ClassName$5.SHOW);\\n\\n        if (!callback) {\\n          return;\\n        }\\n\\n        if (!animate) {\\n          callback();\\n          return;\\n        }\\n\\n        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\\n        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);\\n      } else if (!this._isShown && this._backdrop) {\\n        $(this._backdrop).removeClass(ClassName$5.SHOW);\\n\\n        var callbackRemove = function callbackRemove() {\\n          _this9._removeBackdrop();\\n\\n          if (callback) {\\n            callback();\\n          }\\n        };\\n\\n        if ($(this._element).hasClass(ClassName$5.FADE)) {\\n          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\\n\\n          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);\\n        } else {\\n          callbackRemove();\\n        }\\n      } else if (callback) {\\n        callback();\\n      }\\n    } // ----------------------------------------------------------------------\\n    // the following methods are used to handle overflowing modals\\n    // todo (fat): these should probably be refactored out of modal.js\\n    // ----------------------------------------------------------------------\\n    ;\\n\\n    _proto._adjustDialog = function _adjustDialog() {\\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\\n\\n      if (!this._isBodyOverflowing && isModalOverflowing) {\\n        this._element.style.paddingLeft = this._scrollbarWidth + \\\"px\\\";\\n      }\\n\\n      if (this._isBodyOverflowing && !isModalOverflowing) {\\n        this._element.style.paddingRight = this._scrollbarWidth + \\\"px\\\";\\n      }\\n    };\\n\\n    _proto._resetAdjustments = function _resetAdjustments() {\\n      this._element.style.paddingLeft = '';\\n      this._element.style.paddingRight = '';\\n    };\\n\\n    _proto._checkScrollbar = function _checkScrollbar() {\\n      var rect = document.body.getBoundingClientRect();\\n      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;\\n      this._scrollbarWidth = this._getScrollbarWidth();\\n    };\\n\\n    _proto._setScrollbar = function _setScrollbar() {\\n      var _this10 = this;\\n\\n      if (this._isBodyOverflowing) {\\n        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set\\n        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set\\n        var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));\\n        var stickyContent = [].slice.call(document.querySelectorAll(Selector$5.STICKY_CONTENT)); // Adjust fixed content padding\\n\\n        $(fixedContent).each(function (index, element) {\\n          var actualPadding = element.style.paddingRight;\\n          var calculatedPadding = $(element).css('padding-right');\\n          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this10._scrollbarWidth + \\\"px\\\");\\n        }); // Adjust sticky content margin\\n\\n        $(stickyContent).each(function (index, element) {\\n          var actualMargin = element.style.marginRight;\\n          var calculatedMargin = $(element).css('margin-right');\\n          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this10._scrollbarWidth + \\\"px\\\");\\n        }); // Adjust body padding\\n\\n        var actualPadding = document.body.style.paddingRight;\\n        var calculatedPadding = $(document.body).css('padding-right');\\n        $(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + \\\"px\\\");\\n      }\\n\\n      $(document.body).addClass(ClassName$5.OPEN);\\n    };\\n\\n    _proto._resetScrollbar = function _resetScrollbar() {\\n      // Restore fixed content padding\\n      var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));\\n      $(fixedContent).each(function (index, element) {\\n        var padding = $(element).data('padding-right');\\n        $(element).removeData('padding-right');\\n        element.style.paddingRight = padding ? padding : '';\\n      }); // Restore sticky content\\n\\n      var elements = [].slice.call(document.querySelectorAll(\\\"\\\" + Selector$5.STICKY_CONTENT));\\n      $(elements).each(function (index, element) {\\n        var margin = $(element).data('margin-right');\\n\\n        if (typeof margin !== 'undefined') {\\n          $(element).css('margin-right', margin).removeData('margin-right');\\n        }\\n      }); // Restore body padding\\n\\n      var padding = $(document.body).data('padding-right');\\n      $(document.body).removeData('padding-right');\\n      document.body.style.paddingRight = padding ? padding : '';\\n    };\\n\\n    _proto._getScrollbarWidth = function _getScrollbarWidth() {\\n      // thx d.walsh\\n      var scrollDiv = document.createElement('div');\\n      scrollDiv.className = ClassName$5.SCROLLBAR_MEASURER;\\n      document.body.appendChild(scrollDiv);\\n      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\\n      document.body.removeChild(scrollDiv);\\n      return scrollbarWidth;\\n    } // Static\\n    ;\\n\\n    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY$5);\\n\\n        var _config = _objectSpread2({}, Default$3, {}, $(this).data(), {}, typeof config === 'object' && config ? config : {});\\n\\n        if (!data) {\\n          data = new Modal(this, _config);\\n          $(this).data(DATA_KEY$5, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (typeof data[config] === 'undefined') {\\n            throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n          }\\n\\n          data[config](relatedTarget);\\n        } else if (_config.show) {\\n          data.show(relatedTarget);\\n        }\\n      });\\n    };\\n\\n    _createClass(Modal, null, [{\\n      key: \\\"VERSION\\\",\\n      get: function get() {\\n        return VERSION$5;\\n      }\\n    }, {\\n      key: \\\"Default\\\",\\n      get: function get() {\\n        return Default$3;\\n      }\\n    }]);\\n\\n    return Modal;\\n  }();\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $(document).on(Event$5.CLICK_DATA_API, Selector$5.DATA_TOGGLE, function (event) {\\n    var _this11 = this;\\n\\n    var target;\\n    var selector = Util.getSelectorFromElement(this);\\n\\n    if (selector) {\\n      target = document.querySelector(selector);\\n    }\\n\\n    var config = $(target).data(DATA_KEY$5) ? 'toggle' : _objectSpread2({}, $(target).data(), {}, $(this).data());\\n\\n    if (this.tagName === 'A' || this.tagName === 'AREA') {\\n      event.preventDefault();\\n    }\\n\\n    var $target = $(target).one(Event$5.SHOW, function (showEvent) {\\n      if (showEvent.isDefaultPrevented()) {\\n        // Only register focus restorer if modal will actually get shown\\n        return;\\n      }\\n\\n      $target.one(Event$5.HIDDEN, function () {\\n        if ($(_this11).is(':visible')) {\\n          _this11.focus();\\n        }\\n      });\\n    });\\n\\n    Modal._jQueryInterface.call($(target), config, this);\\n  });\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME$5] = Modal._jQueryInterface;\\n  $.fn[NAME$5].Constructor = Modal;\\n\\n  $.fn[NAME$5].noConflict = function () {\\n    $.fn[NAME$5] = JQUERY_NO_CONFLICT$5;\\n    return Modal._jQueryInterface;\\n  };\\n\\n  /**\\n   * --------------------------------------------------------------------------\\n   * Bootstrap (v4.4.1): tools/sanitizer.js\\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n   * --------------------------------------------------------------------------\\n   */\\n  var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];\\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\\\w-]*$/i;\\n  var DefaultWhitelist = {\\n    // Global attributes allowed on any supplied element below.\\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\\n    a: ['target', 'href', 'title', 'rel'],\\n    area: [],\\n    b: [],\\n    br: [],\\n    col: [],\\n    code: [],\\n    div: [],\\n    em: [],\\n    hr: [],\\n    h1: [],\\n    h2: [],\\n    h3: [],\\n    h4: [],\\n    h5: [],\\n    h6: [],\\n    i: [],\\n    img: ['src', 'alt', 'title', 'width', 'height'],\\n    li: [],\\n    ol: [],\\n    p: [],\\n    pre: [],\\n    s: [],\\n    small: [],\\n    span: [],\\n    sub: [],\\n    sup: [],\\n    strong: [],\\n    u: [],\\n    ul: []\\n  };\\n  /**\\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\\n   *\\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\\n   */\\n\\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\\n  /**\\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\\n   *\\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\\n   */\\n\\n  var DATA_URL_PATTERN = /^data:(?:image\\\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\\\/(?:mpeg|mp4|ogg|webm)|audio\\\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;\\n\\n  function allowedAttribute(attr, allowedAttributeList) {\\n    var attrName = attr.nodeName.toLowerCase();\\n\\n    if (allowedAttributeList.indexOf(attrName) !== -1) {\\n      if (uriAttrs.indexOf(attrName) !== -1) {\\n        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));\\n      }\\n\\n      return true;\\n    }\\n\\n    var regExp = allowedAttributeList.filter(function (attrRegex) {\\n      return attrRegex instanceof RegExp;\\n    }); // Check if a regular expression validates the attribute.\\n\\n    for (var i = 0, l = regExp.length; i < l; i++) {\\n      if (attrName.match(regExp[i])) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {\\n    if (unsafeHtml.length === 0) {\\n      return unsafeHtml;\\n    }\\n\\n    if (sanitizeFn && typeof sanitizeFn === 'function') {\\n      return sanitizeFn(unsafeHtml);\\n    }\\n\\n    var domParser = new window.DOMParser();\\n    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\\n    var whitelistKeys = Object.keys(whiteList);\\n    var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));\\n\\n    var _loop = function _loop(i, len) {\\n      var el = elements[i];\\n      var elName = el.nodeName.toLowerCase();\\n\\n      if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {\\n        el.parentNode.removeChild(el);\\n        return \\\"continue\\\";\\n      }\\n\\n      var attributeList = [].slice.call(el.attributes);\\n      var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);\\n      attributeList.forEach(function (attr) {\\n        if (!allowedAttribute(attr, whitelistedAttributes)) {\\n          el.removeAttribute(attr.nodeName);\\n        }\\n      });\\n    };\\n\\n    for (var i = 0, len = elements.length; i < len; i++) {\\n      var _ret = _loop(i);\\n\\n      if (_ret === \\\"continue\\\") continue;\\n    }\\n\\n    return createdDocument.body.innerHTML;\\n  }\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME$6 = 'tooltip';\\n  var VERSION$6 = '4.4.1';\\n  var DATA_KEY$6 = 'bs.tooltip';\\n  var EVENT_KEY$6 = \\\".\\\" + DATA_KEY$6;\\n  var JQUERY_NO_CONFLICT$6 = $.fn[NAME$6];\\n  var CLASS_PREFIX = 'bs-tooltip';\\n  var BSCLS_PREFIX_REGEX = new RegExp(\\\"(^|\\\\\\\\s)\\\" + CLASS_PREFIX + \\\"\\\\\\\\S+\\\", 'g');\\n  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\\n  var DefaultType$4 = {\\n    animation: 'boolean',\\n    template: 'string',\\n    title: '(string|element|function)',\\n    trigger: 'string',\\n    delay: '(number|object)',\\n    html: 'boolean',\\n    selector: '(string|boolean)',\\n    placement: '(string|function)',\\n    offset: '(number|string|function)',\\n    container: '(string|element|boolean)',\\n    fallbackPlacement: '(string|array)',\\n    boundary: '(string|element)',\\n    sanitize: 'boolean',\\n    sanitizeFn: '(null|function)',\\n    whiteList: 'object',\\n    popperConfig: '(null|object)'\\n  };\\n  var AttachmentMap$1 = {\\n    AUTO: 'auto',\\n    TOP: 'top',\\n    RIGHT: 'right',\\n    BOTTOM: 'bottom',\\n    LEFT: 'left'\\n  };\\n  var Default$4 = {\\n    animation: true,\\n    template: '<div class=\\\"tooltip\\\" role=\\\"tooltip\\\">' + '<div class=\\\"arrow\\\"></div>' + '<div class=\\\"tooltip-inner\\\"></div></div>',\\n    trigger: 'hover focus',\\n    title: '',\\n    delay: 0,\\n    html: false,\\n    selector: false,\\n    placement: 'top',\\n    offset: 0,\\n    container: false,\\n    fallbackPlacement: 'flip',\\n    boundary: 'scrollParent',\\n    sanitize: true,\\n    sanitizeFn: null,\\n    whiteList: DefaultWhitelist,\\n    popperConfig: null\\n  };\\n  var HoverState = {\\n    SHOW: 'show',\\n    OUT: 'out'\\n  };\\n  var Event$6 = {\\n    HIDE: \\\"hide\\\" + EVENT_KEY$6,\\n    HIDDEN: \\\"hidden\\\" + EVENT_KEY$6,\\n    SHOW: \\\"show\\\" + EVENT_KEY$6,\\n    SHOWN: \\\"shown\\\" + EVENT_KEY$6,\\n    INSERTED: \\\"inserted\\\" + EVENT_KEY$6,\\n    CLICK: \\\"click\\\" + EVENT_KEY$6,\\n    FOCUSIN: \\\"focusin\\\" + EVENT_KEY$6,\\n    FOCUSOUT: \\\"focusout\\\" + EVENT_KEY$6,\\n    MOUSEENTER: \\\"mouseenter\\\" + EVENT_KEY$6,\\n    MOUSELEAVE: \\\"mouseleave\\\" + EVENT_KEY$6\\n  };\\n  var ClassName$6 = {\\n    FADE: 'fade',\\n    SHOW: 'show'\\n  };\\n  var Selector$6 = {\\n    TOOLTIP: '.tooltip',\\n    TOOLTIP_INNER: '.tooltip-inner',\\n    ARROW: '.arrow'\\n  };\\n  var Trigger = {\\n    HOVER: 'hover',\\n    FOCUS: 'focus',\\n    CLICK: 'click',\\n    MANUAL: 'manual'\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Tooltip =\\n  /*#__PURE__*/\\n  function () {\\n    function Tooltip(element, config) {\\n      if (typeof Popper === 'undefined') {\\n        throw new TypeError('Bootstrap\\\\'s tooltips require Popper.js (https://popper.js.org/)');\\n      } // private\\n\\n\\n      this._isEnabled = true;\\n      this._timeout = 0;\\n      this._hoverState = '';\\n      this._activeTrigger = {};\\n      this._popper = null; // Protected\\n\\n      this.element = element;\\n      this.config = this._getConfig(config);\\n      this.tip = null;\\n\\n      this._setListeners();\\n    } // Getters\\n\\n\\n    var _proto = Tooltip.prototype;\\n\\n    // Public\\n    _proto.enable = function enable() {\\n      this._isEnabled = true;\\n    };\\n\\n    _proto.disable = function disable() {\\n      this._isEnabled = false;\\n    };\\n\\n    _proto.toggleEnabled = function toggleEnabled() {\\n      this._isEnabled = !this._isEnabled;\\n    };\\n\\n    _proto.toggle = function toggle(event) {\\n      if (!this._isEnabled) {\\n        return;\\n      }\\n\\n      if (event) {\\n        var dataKey = this.constructor.DATA_KEY;\\n        var context = $(event.currentTarget).data(dataKey);\\n\\n        if (!context) {\\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\\n          $(event.currentTarget).data(dataKey, context);\\n        }\\n\\n        context._activeTrigger.click = !context._activeTrigger.click;\\n\\n        if (context._isWithActiveTrigger()) {\\n          context._enter(null, context);\\n        } else {\\n          context._leave(null, context);\\n        }\\n      } else {\\n        if ($(this.getTipElement()).hasClass(ClassName$6.SHOW)) {\\n          this._leave(null, this);\\n\\n          return;\\n        }\\n\\n        this._enter(null, this);\\n      }\\n    };\\n\\n    _proto.dispose = function dispose() {\\n      clearTimeout(this._timeout);\\n      $.removeData(this.element, this.constructor.DATA_KEY);\\n      $(this.element).off(this.constructor.EVENT_KEY);\\n      $(this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);\\n\\n      if (this.tip) {\\n        $(this.tip).remove();\\n      }\\n\\n      this._isEnabled = null;\\n      this._timeout = null;\\n      this._hoverState = null;\\n      this._activeTrigger = null;\\n\\n      if (this._popper) {\\n        this._popper.destroy();\\n      }\\n\\n      this._popper = null;\\n      this.element = null;\\n      this.config = null;\\n      this.tip = null;\\n    };\\n\\n    _proto.show = function show() {\\n      var _this = this;\\n\\n      if ($(this.element).css('display') === 'none') {\\n        throw new Error('Please use show on visible elements');\\n      }\\n\\n      var showEvent = $.Event(this.constructor.Event.SHOW);\\n\\n      if (this.isWithContent() && this._isEnabled) {\\n        $(this.element).trigger(showEvent);\\n        var shadowRoot = Util.findShadowRoot(this.element);\\n        var isInTheDom = $.contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);\\n\\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\\n          return;\\n        }\\n\\n        var tip = this.getTipElement();\\n        var tipId = Util.getUID(this.constructor.NAME);\\n        tip.setAttribute('id', tipId);\\n        this.element.setAttribute('aria-describedby', tipId);\\n        this.setContent();\\n\\n        if (this.config.animation) {\\n          $(tip).addClass(ClassName$6.FADE);\\n        }\\n\\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\\n\\n        var attachment = this._getAttachment(placement);\\n\\n        this.addAttachmentClass(attachment);\\n\\n        var container = this._getContainer();\\n\\n        $(tip).data(this.constructor.DATA_KEY, this);\\n\\n        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {\\n          $(tip).appendTo(container);\\n        }\\n\\n        $(this.element).trigger(this.constructor.Event.INSERTED);\\n        this._popper = new Popper(this.element, tip, this._getPopperConfig(attachment));\\n        $(tip).addClass(ClassName$6.SHOW); // If this is a touch-enabled device we add extra\\n        // empty mouseover listeners to the body's immediate children;\\n        // only needed because of broken event delegation on iOS\\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\\n\\n        if ('ontouchstart' in document.documentElement) {\\n          $(document.body).children().on('mouseover', null, $.noop);\\n        }\\n\\n        var complete = function complete() {\\n          if (_this.config.animation) {\\n            _this._fixTransition();\\n          }\\n\\n          var prevHoverState = _this._hoverState;\\n          _this._hoverState = null;\\n          $(_this.element).trigger(_this.constructor.Event.SHOWN);\\n\\n          if (prevHoverState === HoverState.OUT) {\\n            _this._leave(null, _this);\\n          }\\n        };\\n\\n        if ($(this.tip).hasClass(ClassName$6.FADE)) {\\n          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);\\n          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\\n        } else {\\n          complete();\\n        }\\n      }\\n    };\\n\\n    _proto.hide = function hide(callback) {\\n      var _this2 = this;\\n\\n      var tip = this.getTipElement();\\n      var hideEvent = $.Event(this.constructor.Event.HIDE);\\n\\n      var complete = function complete() {\\n        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {\\n          tip.parentNode.removeChild(tip);\\n        }\\n\\n        _this2._cleanTipClass();\\n\\n        _this2.element.removeAttribute('aria-describedby');\\n\\n        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);\\n\\n        if (_this2._popper !== null) {\\n          _this2._popper.destroy();\\n        }\\n\\n        if (callback) {\\n          callback();\\n        }\\n      };\\n\\n      $(this.element).trigger(hideEvent);\\n\\n      if (hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      $(tip).removeClass(ClassName$6.SHOW); // If this is a touch-enabled device we remove the extra\\n      // empty mouseover listeners we added for iOS support\\n\\n      if ('ontouchstart' in document.documentElement) {\\n        $(document.body).children().off('mouseover', null, $.noop);\\n      }\\n\\n      this._activeTrigger[Trigger.CLICK] = false;\\n      this._activeTrigger[Trigger.FOCUS] = false;\\n      this._activeTrigger[Trigger.HOVER] = false;\\n\\n      if ($(this.tip).hasClass(ClassName$6.FADE)) {\\n        var transitionDuration = Util.getTransitionDurationFromElement(tip);\\n        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\\n      } else {\\n        complete();\\n      }\\n\\n      this._hoverState = '';\\n    };\\n\\n    _proto.update = function update() {\\n      if (this._popper !== null) {\\n        this._popper.scheduleUpdate();\\n      }\\n    } // Protected\\n    ;\\n\\n    _proto.isWithContent = function isWithContent() {\\n      return Boolean(this.getTitle());\\n    };\\n\\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\\n      $(this.getTipElement()).addClass(CLASS_PREFIX + \\\"-\\\" + attachment);\\n    };\\n\\n    _proto.getTipElement = function getTipElement() {\\n      this.tip = this.tip || $(this.config.template)[0];\\n      return this.tip;\\n    };\\n\\n    _proto.setContent = function setContent() {\\n      var tip = this.getTipElement();\\n      this.setElementContent($(tip.querySelectorAll(Selector$6.TOOLTIP_INNER)), this.getTitle());\\n      $(tip).removeClass(ClassName$6.FADE + \\\" \\\" + ClassName$6.SHOW);\\n    };\\n\\n    _proto.setElementContent = function setElementContent($element, content) {\\n      if (typeof content === 'object' && (content.nodeType || content.jquery)) {\\n        // Content is a DOM node or a jQuery\\n        if (this.config.html) {\\n          if (!$(content).parent().is($element)) {\\n            $element.empty().append(content);\\n          }\\n        } else {\\n          $element.text($(content).text());\\n        }\\n\\n        return;\\n      }\\n\\n      if (this.config.html) {\\n        if (this.config.sanitize) {\\n          content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);\\n        }\\n\\n        $element.html(content);\\n      } else {\\n        $element.text(content);\\n      }\\n    };\\n\\n    _proto.getTitle = function getTitle() {\\n      var title = this.element.getAttribute('data-original-title');\\n\\n      if (!title) {\\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\\n      }\\n\\n      return title;\\n    } // Private\\n    ;\\n\\n    _proto._getPopperConfig = function _getPopperConfig(attachment) {\\n      var _this3 = this;\\n\\n      var defaultBsConfig = {\\n        placement: attachment,\\n        modifiers: {\\n          offset: this._getOffset(),\\n          flip: {\\n            behavior: this.config.fallbackPlacement\\n          },\\n          arrow: {\\n            element: Selector$6.ARROW\\n          },\\n          preventOverflow: {\\n            boundariesElement: this.config.boundary\\n          }\\n        },\\n        onCreate: function onCreate(data) {\\n          if (data.originalPlacement !== data.placement) {\\n            _this3._handlePopperPlacementChange(data);\\n          }\\n        },\\n        onUpdate: function onUpdate(data) {\\n          return _this3._handlePopperPlacementChange(data);\\n        }\\n      };\\n      return _objectSpread2({}, defaultBsConfig, {}, this.config.popperConfig);\\n    };\\n\\n    _proto._getOffset = function _getOffset() {\\n      var _this4 = this;\\n\\n      var offset = {};\\n\\n      if (typeof this.config.offset === 'function') {\\n        offset.fn = function (data) {\\n          data.offsets = _objectSpread2({}, data.offsets, {}, _this4.config.offset(data.offsets, _this4.element) || {});\\n          return data;\\n        };\\n      } else {\\n        offset.offset = this.config.offset;\\n      }\\n\\n      return offset;\\n    };\\n\\n    _proto._getContainer = function _getContainer() {\\n      if (this.config.container === false) {\\n        return document.body;\\n      }\\n\\n      if (Util.isElement(this.config.container)) {\\n        return $(this.config.container);\\n      }\\n\\n      return $(document).find(this.config.container);\\n    };\\n\\n    _proto._getAttachment = function _getAttachment(placement) {\\n      return AttachmentMap$1[placement.toUpperCase()];\\n    };\\n\\n    _proto._setListeners = function _setListeners() {\\n      var _this5 = this;\\n\\n      var triggers = this.config.trigger.split(' ');\\n      triggers.forEach(function (trigger) {\\n        if (trigger === 'click') {\\n          $(_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {\\n            return _this5.toggle(event);\\n          });\\n        } else if (trigger !== Trigger.MANUAL) {\\n          var eventIn = trigger === Trigger.HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;\\n          var eventOut = trigger === Trigger.HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;\\n          $(_this5.element).on(eventIn, _this5.config.selector, function (event) {\\n            return _this5._enter(event);\\n          }).on(eventOut, _this5.config.selector, function (event) {\\n            return _this5._leave(event);\\n          });\\n        }\\n      });\\n\\n      this._hideModalHandler = function () {\\n        if (_this5.element) {\\n          _this5.hide();\\n        }\\n      };\\n\\n      $(this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);\\n\\n      if (this.config.selector) {\\n        this.config = _objectSpread2({}, this.config, {\\n          trigger: 'manual',\\n          selector: ''\\n        });\\n      } else {\\n        this._fixTitle();\\n      }\\n    };\\n\\n    _proto._fixTitle = function _fixTitle() {\\n      var titleType = typeof this.element.getAttribute('data-original-title');\\n\\n      if (this.element.getAttribute('title') || titleType !== 'string') {\\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\\n        this.element.setAttribute('title', '');\\n      }\\n    };\\n\\n    _proto._enter = function _enter(event, context) {\\n      var dataKey = this.constructor.DATA_KEY;\\n      context = context || $(event.currentTarget).data(dataKey);\\n\\n      if (!context) {\\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\\n        $(event.currentTarget).data(dataKey, context);\\n      }\\n\\n      if (event) {\\n        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;\\n      }\\n\\n      if ($(context.getTipElement()).hasClass(ClassName$6.SHOW) || context._hoverState === HoverState.SHOW) {\\n        context._hoverState = HoverState.SHOW;\\n        return;\\n      }\\n\\n      clearTimeout(context._timeout);\\n      context._hoverState = HoverState.SHOW;\\n\\n      if (!context.config.delay || !context.config.delay.show) {\\n        context.show();\\n        return;\\n      }\\n\\n      context._timeout = setTimeout(function () {\\n        if (context._hoverState === HoverState.SHOW) {\\n          context.show();\\n        }\\n      }, context.config.delay.show);\\n    };\\n\\n    _proto._leave = function _leave(event, context) {\\n      var dataKey = this.constructor.DATA_KEY;\\n      context = context || $(event.currentTarget).data(dataKey);\\n\\n      if (!context) {\\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\\n        $(event.currentTarget).data(dataKey, context);\\n      }\\n\\n      if (event) {\\n        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;\\n      }\\n\\n      if (context._isWithActiveTrigger()) {\\n        return;\\n      }\\n\\n      clearTimeout(context._timeout);\\n      context._hoverState = HoverState.OUT;\\n\\n      if (!context.config.delay || !context.config.delay.hide) {\\n        context.hide();\\n        return;\\n      }\\n\\n      context._timeout = setTimeout(function () {\\n        if (context._hoverState === HoverState.OUT) {\\n          context.hide();\\n        }\\n      }, context.config.delay.hide);\\n    };\\n\\n    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {\\n      for (var trigger in this._activeTrigger) {\\n        if (this._activeTrigger[trigger]) {\\n          return true;\\n        }\\n      }\\n\\n      return false;\\n    };\\n\\n    _proto._getConfig = function _getConfig(config) {\\n      var dataAttributes = $(this.element).data();\\n      Object.keys(dataAttributes).forEach(function (dataAttr) {\\n        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {\\n          delete dataAttributes[dataAttr];\\n        }\\n      });\\n      config = _objectSpread2({}, this.constructor.Default, {}, dataAttributes, {}, typeof config === 'object' && config ? config : {});\\n\\n      if (typeof config.delay === 'number') {\\n        config.delay = {\\n          show: config.delay,\\n          hide: config.delay\\n        };\\n      }\\n\\n      if (typeof config.title === 'number') {\\n        config.title = config.title.toString();\\n      }\\n\\n      if (typeof config.content === 'number') {\\n        config.content = config.content.toString();\\n      }\\n\\n      Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);\\n\\n      if (config.sanitize) {\\n        config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);\\n      }\\n\\n      return config;\\n    };\\n\\n    _proto._getDelegateConfig = function _getDelegateConfig() {\\n      var config = {};\\n\\n      if (this.config) {\\n        for (var key in this.config) {\\n          if (this.constructor.Default[key] !== this.config[key]) {\\n            config[key] = this.config[key];\\n          }\\n        }\\n      }\\n\\n      return config;\\n    };\\n\\n    _proto._cleanTipClass = function _cleanTipClass() {\\n      var $tip = $(this.getTipElement());\\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\\n\\n      if (tabClass !== null && tabClass.length) {\\n        $tip.removeClass(tabClass.join(''));\\n      }\\n    };\\n\\n    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {\\n      var popperInstance = popperData.instance;\\n      this.tip = popperInstance.popper;\\n\\n      this._cleanTipClass();\\n\\n      this.addAttachmentClass(this._getAttachment(popperData.placement));\\n    };\\n\\n    _proto._fixTransition = function _fixTransition() {\\n      var tip = this.getTipElement();\\n      var initConfigAnimation = this.config.animation;\\n\\n      if (tip.getAttribute('x-placement') !== null) {\\n        return;\\n      }\\n\\n      $(tip).removeClass(ClassName$6.FADE);\\n      this.config.animation = false;\\n      this.hide();\\n      this.show();\\n      this.config.animation = initConfigAnimation;\\n    } // Static\\n    ;\\n\\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY$6);\\n\\n        var _config = typeof config === 'object' && config;\\n\\n        if (!data && /dispose|hide/.test(config)) {\\n          return;\\n        }\\n\\n        if (!data) {\\n          data = new Tooltip(this, _config);\\n          $(this).data(DATA_KEY$6, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (typeof data[config] === 'undefined') {\\n            throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n          }\\n\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Tooltip, null, [{\\n      key: \\\"VERSION\\\",\\n      get: function get() {\\n        return VERSION$6;\\n      }\\n    }, {\\n      key: \\\"Default\\\",\\n      get: function get() {\\n        return Default$4;\\n      }\\n    }, {\\n      key: \\\"NAME\\\",\\n      get: function get() {\\n        return NAME$6;\\n      }\\n    }, {\\n      key: \\\"DATA_KEY\\\",\\n      get: function get() {\\n        return DATA_KEY$6;\\n      }\\n    }, {\\n      key: \\\"Event\\\",\\n      get: function get() {\\n        return Event$6;\\n      }\\n    }, {\\n      key: \\\"EVENT_KEY\\\",\\n      get: function get() {\\n        return EVENT_KEY$6;\\n      }\\n    }, {\\n      key: \\\"DefaultType\\\",\\n      get: function get() {\\n        return DefaultType$4;\\n      }\\n    }]);\\n\\n    return Tooltip;\\n  }();\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $.fn[NAME$6] = Tooltip._jQueryInterface;\\n  $.fn[NAME$6].Constructor = Tooltip;\\n\\n  $.fn[NAME$6].noConflict = function () {\\n    $.fn[NAME$6] = JQUERY_NO_CONFLICT$6;\\n    return Tooltip._jQueryInterface;\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME$7 = 'popover';\\n  var VERSION$7 = '4.4.1';\\n  var DATA_KEY$7 = 'bs.popover';\\n  var EVENT_KEY$7 = \\\".\\\" + DATA_KEY$7;\\n  var JQUERY_NO_CONFLICT$7 = $.fn[NAME$7];\\n  var CLASS_PREFIX$1 = 'bs-popover';\\n  var BSCLS_PREFIX_REGEX$1 = new RegExp(\\\"(^|\\\\\\\\s)\\\" + CLASS_PREFIX$1 + \\\"\\\\\\\\S+\\\", 'g');\\n\\n  var Default$5 = _objectSpread2({}, Tooltip.Default, {\\n    placement: 'right',\\n    trigger: 'click',\\n    content: '',\\n    template: '<div class=\\\"popover\\\" role=\\\"tooltip\\\">' + '<div class=\\\"arrow\\\"></div>' + '<h3 class=\\\"popover-header\\\"></h3>' + '<div class=\\\"popover-body\\\"></div></div>'\\n  });\\n\\n  var DefaultType$5 = _objectSpread2({}, Tooltip.DefaultType, {\\n    content: '(string|element|function)'\\n  });\\n\\n  var ClassName$7 = {\\n    FADE: 'fade',\\n    SHOW: 'show'\\n  };\\n  var Selector$7 = {\\n    TITLE: '.popover-header',\\n    CONTENT: '.popover-body'\\n  };\\n  var Event$7 = {\\n    HIDE: \\\"hide\\\" + EVENT_KEY$7,\\n    HIDDEN: \\\"hidden\\\" + EVENT_KEY$7,\\n    SHOW: \\\"show\\\" + EVENT_KEY$7,\\n    SHOWN: \\\"shown\\\" + EVENT_KEY$7,\\n    INSERTED: \\\"inserted\\\" + EVENT_KEY$7,\\n    CLICK: \\\"click\\\" + EVENT_KEY$7,\\n    FOCUSIN: \\\"focusin\\\" + EVENT_KEY$7,\\n    FOCUSOUT: \\\"focusout\\\" + EVENT_KEY$7,\\n    MOUSEENTER: \\\"mouseenter\\\" + EVENT_KEY$7,\\n    MOUSELEAVE: \\\"mouseleave\\\" + EVENT_KEY$7\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Popover =\\n  /*#__PURE__*/\\n  function (_Tooltip) {\\n    _inheritsLoose(Popover, _Tooltip);\\n\\n    function Popover() {\\n      return _Tooltip.apply(this, arguments) || this;\\n    }\\n\\n    var _proto = Popover.prototype;\\n\\n    // Overrides\\n    _proto.isWithContent = function isWithContent() {\\n      return this.getTitle() || this._getContent();\\n    };\\n\\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\\n      $(this.getTipElement()).addClass(CLASS_PREFIX$1 + \\\"-\\\" + attachment);\\n    };\\n\\n    _proto.getTipElement = function getTipElement() {\\n      this.tip = this.tip || $(this.config.template)[0];\\n      return this.tip;\\n    };\\n\\n    _proto.setContent = function setContent() {\\n      var $tip = $(this.getTipElement()); // We use append for html objects to maintain js events\\n\\n      this.setElementContent($tip.find(Selector$7.TITLE), this.getTitle());\\n\\n      var content = this._getContent();\\n\\n      if (typeof content === 'function') {\\n        content = content.call(this.element);\\n      }\\n\\n      this.setElementContent($tip.find(Selector$7.CONTENT), content);\\n      $tip.removeClass(ClassName$7.FADE + \\\" \\\" + ClassName$7.SHOW);\\n    } // Private\\n    ;\\n\\n    _proto._getContent = function _getContent() {\\n      return this.element.getAttribute('data-content') || this.config.content;\\n    };\\n\\n    _proto._cleanTipClass = function _cleanTipClass() {\\n      var $tip = $(this.getTipElement());\\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);\\n\\n      if (tabClass !== null && tabClass.length > 0) {\\n        $tip.removeClass(tabClass.join(''));\\n      }\\n    } // Static\\n    ;\\n\\n    Popover._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY$7);\\n\\n        var _config = typeof config === 'object' ? config : null;\\n\\n        if (!data && /dispose|hide/.test(config)) {\\n          return;\\n        }\\n\\n        if (!data) {\\n          data = new Popover(this, _config);\\n          $(this).data(DATA_KEY$7, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (typeof data[config] === 'undefined') {\\n            throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n          }\\n\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Popover, null, [{\\n      key: \\\"VERSION\\\",\\n      // Getters\\n      get: function get() {\\n        return VERSION$7;\\n      }\\n    }, {\\n      key: \\\"Default\\\",\\n      get: function get() {\\n        return Default$5;\\n      }\\n    }, {\\n      key: \\\"NAME\\\",\\n      get: function get() {\\n        return NAME$7;\\n      }\\n    }, {\\n      key: \\\"DATA_KEY\\\",\\n      get: function get() {\\n        return DATA_KEY$7;\\n      }\\n    }, {\\n      key: \\\"Event\\\",\\n      get: function get() {\\n        return Event$7;\\n      }\\n    }, {\\n      key: \\\"EVENT_KEY\\\",\\n      get: function get() {\\n        return EVENT_KEY$7;\\n      }\\n    }, {\\n      key: \\\"DefaultType\\\",\\n      get: function get() {\\n        return DefaultType$5;\\n      }\\n    }]);\\n\\n    return Popover;\\n  }(Tooltip);\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $.fn[NAME$7] = Popover._jQueryInterface;\\n  $.fn[NAME$7].Constructor = Popover;\\n\\n  $.fn[NAME$7].noConflict = function () {\\n    $.fn[NAME$7] = JQUERY_NO_CONFLICT$7;\\n    return Popover._jQueryInterface;\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME$8 = 'scrollspy';\\n  var VERSION$8 = '4.4.1';\\n  var DATA_KEY$8 = 'bs.scrollspy';\\n  var EVENT_KEY$8 = \\\".\\\" + DATA_KEY$8;\\n  var DATA_API_KEY$6 = '.data-api';\\n  var JQUERY_NO_CONFLICT$8 = $.fn[NAME$8];\\n  var Default$6 = {\\n    offset: 10,\\n    method: 'auto',\\n    target: ''\\n  };\\n  var DefaultType$6 = {\\n    offset: 'number',\\n    method: 'string',\\n    target: '(string|element)'\\n  };\\n  var Event$8 = {\\n    ACTIVATE: \\\"activate\\\" + EVENT_KEY$8,\\n    SCROLL: \\\"scroll\\\" + EVENT_KEY$8,\\n    LOAD_DATA_API: \\\"load\\\" + EVENT_KEY$8 + DATA_API_KEY$6\\n  };\\n  var ClassName$8 = {\\n    DROPDOWN_ITEM: 'dropdown-item',\\n    DROPDOWN_MENU: 'dropdown-menu',\\n    ACTIVE: 'active'\\n  };\\n  var Selector$8 = {\\n    DATA_SPY: '[data-spy=\\\"scroll\\\"]',\\n    ACTIVE: '.active',\\n    NAV_LIST_GROUP: '.nav, .list-group',\\n    NAV_LINKS: '.nav-link',\\n    NAV_ITEMS: '.nav-item',\\n    LIST_ITEMS: '.list-group-item',\\n    DROPDOWN: '.dropdown',\\n    DROPDOWN_ITEMS: '.dropdown-item',\\n    DROPDOWN_TOGGLE: '.dropdown-toggle'\\n  };\\n  var OffsetMethod = {\\n    OFFSET: 'offset',\\n    POSITION: 'position'\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var ScrollSpy =\\n  /*#__PURE__*/\\n  function () {\\n    function ScrollSpy(element, config) {\\n      var _this = this;\\n\\n      this._element = element;\\n      this._scrollElement = element.tagName === 'BODY' ? window : element;\\n      this._config = this._getConfig(config);\\n      this._selector = this._config.target + \\\" \\\" + Selector$8.NAV_LINKS + \\\",\\\" + (this._config.target + \\\" \\\" + Selector$8.LIST_ITEMS + \\\",\\\") + (this._config.target + \\\" \\\" + Selector$8.DROPDOWN_ITEMS);\\n      this._offsets = [];\\n      this._targets = [];\\n      this._activeTarget = null;\\n      this._scrollHeight = 0;\\n      $(this._scrollElement).on(Event$8.SCROLL, function (event) {\\n        return _this._process(event);\\n      });\\n      this.refresh();\\n\\n      this._process();\\n    } // Getters\\n\\n\\n    var _proto = ScrollSpy.prototype;\\n\\n    // Public\\n    _proto.refresh = function refresh() {\\n      var _this2 = this;\\n\\n      var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;\\n      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\\n      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;\\n      this._offsets = [];\\n      this._targets = [];\\n      this._scrollHeight = this._getScrollHeight();\\n      var targets = [].slice.call(document.querySelectorAll(this._selector));\\n      targets.map(function (element) {\\n        var target;\\n        var targetSelector = Util.getSelectorFromElement(element);\\n\\n        if (targetSelector) {\\n          target = document.querySelector(targetSelector);\\n        }\\n\\n        if (target) {\\n          var targetBCR = target.getBoundingClientRect();\\n\\n          if (targetBCR.width || targetBCR.height) {\\n            // TODO (fat): remove sketch reliance on jQuery position/offset\\n            return [$(target)[offsetMethod]().top + offsetBase, targetSelector];\\n          }\\n        }\\n\\n        return null;\\n      }).filter(function (item) {\\n        return item;\\n      }).sort(function (a, b) {\\n        return a[0] - b[0];\\n      }).forEach(function (item) {\\n        _this2._offsets.push(item[0]);\\n\\n        _this2._targets.push(item[1]);\\n      });\\n    };\\n\\n    _proto.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY$8);\\n      $(this._scrollElement).off(EVENT_KEY$8);\\n      this._element = null;\\n      this._scrollElement = null;\\n      this._config = null;\\n      this._selector = null;\\n      this._offsets = null;\\n      this._targets = null;\\n      this._activeTarget = null;\\n      this._scrollHeight = null;\\n    } // Private\\n    ;\\n\\n    _proto._getConfig = function _getConfig(config) {\\n      config = _objectSpread2({}, Default$6, {}, typeof config === 'object' && config ? config : {});\\n\\n      if (typeof config.target !== 'string') {\\n        var id = $(config.target).attr('id');\\n\\n        if (!id) {\\n          id = Util.getUID(NAME$8);\\n          $(config.target).attr('id', id);\\n        }\\n\\n        config.target = \\\"#\\\" + id;\\n      }\\n\\n      Util.typeCheckConfig(NAME$8, config, DefaultType$6);\\n      return config;\\n    };\\n\\n    _proto._getScrollTop = function _getScrollTop() {\\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\\n    };\\n\\n    _proto._getScrollHeight = function _getScrollHeight() {\\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\\n    };\\n\\n    _proto._getOffsetHeight = function _getOffsetHeight() {\\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\\n    };\\n\\n    _proto._process = function _process() {\\n      var scrollTop = this._getScrollTop() + this._config.offset;\\n\\n      var scrollHeight = this._getScrollHeight();\\n\\n      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\\n\\n      if (this._scrollHeight !== scrollHeight) {\\n        this.refresh();\\n      }\\n\\n      if (scrollTop >= maxScroll) {\\n        var target = this._targets[this._targets.length - 1];\\n\\n        if (this._activeTarget !== target) {\\n          this._activate(target);\\n        }\\n\\n        return;\\n      }\\n\\n      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\\n        this._activeTarget = null;\\n\\n        this._clear();\\n\\n        return;\\n      }\\n\\n      var offsetLength = this._offsets.length;\\n\\n      for (var i = offsetLength; i--;) {\\n        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\\n\\n        if (isActiveTarget) {\\n          this._activate(this._targets[i]);\\n        }\\n      }\\n    };\\n\\n    _proto._activate = function _activate(target) {\\n      this._activeTarget = target;\\n\\n      this._clear();\\n\\n      var queries = this._selector.split(',').map(function (selector) {\\n        return selector + \\\"[data-target=\\\\\\\"\\\" + target + \\\"\\\\\\\"],\\\" + selector + \\\"[href=\\\\\\\"\\\" + target + \\\"\\\\\\\"]\\\";\\n      });\\n\\n      var $link = $([].slice.call(document.querySelectorAll(queries.join(','))));\\n\\n      if ($link.hasClass(ClassName$8.DROPDOWN_ITEM)) {\\n        $link.closest(Selector$8.DROPDOWN).find(Selector$8.DROPDOWN_TOGGLE).addClass(ClassName$8.ACTIVE);\\n        $link.addClass(ClassName$8.ACTIVE);\\n      } else {\\n        // Set triggered link as active\\n        $link.addClass(ClassName$8.ACTIVE); // Set triggered links parents as active\\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\\n\\n        $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_LINKS + \\\", \\\" + Selector$8.LIST_ITEMS).addClass(ClassName$8.ACTIVE); // Handle special case when .nav-link is inside .nav-item\\n\\n        $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_ITEMS).children(Selector$8.NAV_LINKS).addClass(ClassName$8.ACTIVE);\\n      }\\n\\n      $(this._scrollElement).trigger(Event$8.ACTIVATE, {\\n        relatedTarget: target\\n      });\\n    };\\n\\n    _proto._clear = function _clear() {\\n      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {\\n        return node.classList.contains(ClassName$8.ACTIVE);\\n      }).forEach(function (node) {\\n        return node.classList.remove(ClassName$8.ACTIVE);\\n      });\\n    } // Static\\n    ;\\n\\n    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var data = $(this).data(DATA_KEY$8);\\n\\n        var _config = typeof config === 'object' && config;\\n\\n        if (!data) {\\n          data = new ScrollSpy(this, _config);\\n          $(this).data(DATA_KEY$8, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (typeof data[config] === 'undefined') {\\n            throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n          }\\n\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(ScrollSpy, null, [{\\n      key: \\\"VERSION\\\",\\n      get: function get() {\\n        return VERSION$8;\\n      }\\n    }, {\\n      key: \\\"Default\\\",\\n      get: function get() {\\n        return Default$6;\\n      }\\n    }]);\\n\\n    return ScrollSpy;\\n  }();\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $(window).on(Event$8.LOAD_DATA_API, function () {\\n    var scrollSpys = [].slice.call(document.querySelectorAll(Selector$8.DATA_SPY));\\n    var scrollSpysLength = scrollSpys.length;\\n\\n    for (var i = scrollSpysLength; i--;) {\\n      var $spy = $(scrollSpys[i]);\\n\\n      ScrollSpy._jQueryInterface.call($spy, $spy.data());\\n    }\\n  });\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME$8] = ScrollSpy._jQueryInterface;\\n  $.fn[NAME$8].Constructor = ScrollSpy;\\n\\n  $.fn[NAME$8].noConflict = function () {\\n    $.fn[NAME$8] = JQUERY_NO_CONFLICT$8;\\n    return ScrollSpy._jQueryInterface;\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME$9 = 'tab';\\n  var VERSION$9 = '4.4.1';\\n  var DATA_KEY$9 = 'bs.tab';\\n  var EVENT_KEY$9 = \\\".\\\" + DATA_KEY$9;\\n  var DATA_API_KEY$7 = '.data-api';\\n  var JQUERY_NO_CONFLICT$9 = $.fn[NAME$9];\\n  var Event$9 = {\\n    HIDE: \\\"hide\\\" + EVENT_KEY$9,\\n    HIDDEN: \\\"hidden\\\" + EVENT_KEY$9,\\n    SHOW: \\\"show\\\" + EVENT_KEY$9,\\n    SHOWN: \\\"shown\\\" + EVENT_KEY$9,\\n    CLICK_DATA_API: \\\"click\\\" + EVENT_KEY$9 + DATA_API_KEY$7\\n  };\\n  var ClassName$9 = {\\n    DROPDOWN_MENU: 'dropdown-menu',\\n    ACTIVE: 'active',\\n    DISABLED: 'disabled',\\n    FADE: 'fade',\\n    SHOW: 'show'\\n  };\\n  var Selector$9 = {\\n    DROPDOWN: '.dropdown',\\n    NAV_LIST_GROUP: '.nav, .list-group',\\n    ACTIVE: '.active',\\n    ACTIVE_UL: '> li > .active',\\n    DATA_TOGGLE: '[data-toggle=\\\"tab\\\"], [data-toggle=\\\"pill\\\"], [data-toggle=\\\"list\\\"]',\\n    DROPDOWN_TOGGLE: '.dropdown-toggle',\\n    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Tab =\\n  /*#__PURE__*/\\n  function () {\\n    function Tab(element) {\\n      this._element = element;\\n    } // Getters\\n\\n\\n    var _proto = Tab.prototype;\\n\\n    // Public\\n    _proto.show = function show() {\\n      var _this = this;\\n\\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName$9.ACTIVE) || $(this._element).hasClass(ClassName$9.DISABLED)) {\\n        return;\\n      }\\n\\n      var target;\\n      var previous;\\n      var listElement = $(this._element).closest(Selector$9.NAV_LIST_GROUP)[0];\\n      var selector = Util.getSelectorFromElement(this._element);\\n\\n      if (listElement) {\\n        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? Selector$9.ACTIVE_UL : Selector$9.ACTIVE;\\n        previous = $.makeArray($(listElement).find(itemSelector));\\n        previous = previous[previous.length - 1];\\n      }\\n\\n      var hideEvent = $.Event(Event$9.HIDE, {\\n        relatedTarget: this._element\\n      });\\n      var showEvent = $.Event(Event$9.SHOW, {\\n        relatedTarget: previous\\n      });\\n\\n      if (previous) {\\n        $(previous).trigger(hideEvent);\\n      }\\n\\n      $(this._element).trigger(showEvent);\\n\\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (selector) {\\n        target = document.querySelector(selector);\\n      }\\n\\n      this._activate(this._element, listElement);\\n\\n      var complete = function complete() {\\n        var hiddenEvent = $.Event(Event$9.HIDDEN, {\\n          relatedTarget: _this._element\\n        });\\n        var shownEvent = $.Event(Event$9.SHOWN, {\\n          relatedTarget: previous\\n        });\\n        $(previous).trigger(hiddenEvent);\\n        $(_this._element).trigger(shownEvent);\\n      };\\n\\n      if (target) {\\n        this._activate(target, target.parentNode, complete);\\n      } else {\\n        complete();\\n      }\\n    };\\n\\n    _proto.dispose = function dispose() {\\n      $.removeData(this._element, DATA_KEY$9);\\n      this._element = null;\\n    } // Private\\n    ;\\n\\n    _proto._activate = function _activate(element, container, callback) {\\n      var _this2 = this;\\n\\n      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $(container).find(Selector$9.ACTIVE_UL) : $(container).children(Selector$9.ACTIVE);\\n      var active = activeElements[0];\\n      var isTransitioning = callback && active && $(active).hasClass(ClassName$9.FADE);\\n\\n      var complete = function complete() {\\n        return _this2._transitionComplete(element, active, callback);\\n      };\\n\\n      if (active && isTransitioning) {\\n        var transitionDuration = Util.getTransitionDurationFromElement(active);\\n        $(active).removeClass(ClassName$9.SHOW).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\\n      } else {\\n        complete();\\n      }\\n    };\\n\\n    _proto._transitionComplete = function _transitionComplete(element, active, callback) {\\n      if (active) {\\n        $(active).removeClass(ClassName$9.ACTIVE);\\n        var dropdownChild = $(active.parentNode).find(Selector$9.DROPDOWN_ACTIVE_CHILD)[0];\\n\\n        if (dropdownChild) {\\n          $(dropdownChild).removeClass(ClassName$9.ACTIVE);\\n        }\\n\\n        if (active.getAttribute('role') === 'tab') {\\n          active.setAttribute('aria-selected', false);\\n        }\\n      }\\n\\n      $(element).addClass(ClassName$9.ACTIVE);\\n\\n      if (element.getAttribute('role') === 'tab') {\\n        element.setAttribute('aria-selected', true);\\n      }\\n\\n      Util.reflow(element);\\n\\n      if (element.classList.contains(ClassName$9.FADE)) {\\n        element.classList.add(ClassName$9.SHOW);\\n      }\\n\\n      if (element.parentNode && $(element.parentNode).hasClass(ClassName$9.DROPDOWN_MENU)) {\\n        var dropdownElement = $(element).closest(Selector$9.DROPDOWN)[0];\\n\\n        if (dropdownElement) {\\n          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector$9.DROPDOWN_TOGGLE));\\n          $(dropdownToggleList).addClass(ClassName$9.ACTIVE);\\n        }\\n\\n        element.setAttribute('aria-expanded', true);\\n      }\\n\\n      if (callback) {\\n        callback();\\n      }\\n    } // Static\\n    ;\\n\\n    Tab._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var $this = $(this);\\n        var data = $this.data(DATA_KEY$9);\\n\\n        if (!data) {\\n          data = new Tab(this);\\n          $this.data(DATA_KEY$9, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (typeof data[config] === 'undefined') {\\n            throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n          }\\n\\n          data[config]();\\n        }\\n      });\\n    };\\n\\n    _createClass(Tab, null, [{\\n      key: \\\"VERSION\\\",\\n      get: function get() {\\n        return VERSION$9;\\n      }\\n    }]);\\n\\n    return Tab;\\n  }();\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Data Api implementation\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $(document).on(Event$9.CLICK_DATA_API, Selector$9.DATA_TOGGLE, function (event) {\\n    event.preventDefault();\\n\\n    Tab._jQueryInterface.call($(this), 'show');\\n  });\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  $.fn[NAME$9] = Tab._jQueryInterface;\\n  $.fn[NAME$9].Constructor = Tab;\\n\\n  $.fn[NAME$9].noConflict = function () {\\n    $.fn[NAME$9] = JQUERY_NO_CONFLICT$9;\\n    return Tab._jQueryInterface;\\n  };\\n\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Constants\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var NAME$a = 'toast';\\n  var VERSION$a = '4.4.1';\\n  var DATA_KEY$a = 'bs.toast';\\n  var EVENT_KEY$a = \\\".\\\" + DATA_KEY$a;\\n  var JQUERY_NO_CONFLICT$a = $.fn[NAME$a];\\n  var Event$a = {\\n    CLICK_DISMISS: \\\"click.dismiss\\\" + EVENT_KEY$a,\\n    HIDE: \\\"hide\\\" + EVENT_KEY$a,\\n    HIDDEN: \\\"hidden\\\" + EVENT_KEY$a,\\n    SHOW: \\\"show\\\" + EVENT_KEY$a,\\n    SHOWN: \\\"shown\\\" + EVENT_KEY$a\\n  };\\n  var ClassName$a = {\\n    FADE: 'fade',\\n    HIDE: 'hide',\\n    SHOW: 'show',\\n    SHOWING: 'showing'\\n  };\\n  var DefaultType$7 = {\\n    animation: 'boolean',\\n    autohide: 'boolean',\\n    delay: 'number'\\n  };\\n  var Default$7 = {\\n    animation: true,\\n    autohide: true,\\n    delay: 500\\n  };\\n  var Selector$a = {\\n    DATA_DISMISS: '[data-dismiss=\\\"toast\\\"]'\\n  };\\n  /**\\n   * ------------------------------------------------------------------------\\n   * Class Definition\\n   * ------------------------------------------------------------------------\\n   */\\n\\n  var Toast =\\n  /*#__PURE__*/\\n  function () {\\n    function Toast(element, config) {\\n      this._element = element;\\n      this._config = this._getConfig(config);\\n      this._timeout = null;\\n\\n      this._setListeners();\\n    } // Getters\\n\\n\\n    var _proto = Toast.prototype;\\n\\n    // Public\\n    _proto.show = function show() {\\n      var _this = this;\\n\\n      var showEvent = $.Event(Event$a.SHOW);\\n      $(this._element).trigger(showEvent);\\n\\n      if (showEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      if (this._config.animation) {\\n        this._element.classList.add(ClassName$a.FADE);\\n      }\\n\\n      var complete = function complete() {\\n        _this._element.classList.remove(ClassName$a.SHOWING);\\n\\n        _this._element.classList.add(ClassName$a.SHOW);\\n\\n        $(_this._element).trigger(Event$a.SHOWN);\\n\\n        if (_this._config.autohide) {\\n          _this._timeout = setTimeout(function () {\\n            _this.hide();\\n          }, _this._config.delay);\\n        }\\n      };\\n\\n      this._element.classList.remove(ClassName$a.HIDE);\\n\\n      Util.reflow(this._element);\\n\\n      this._element.classList.add(ClassName$a.SHOWING);\\n\\n      if (this._config.animation) {\\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\\n        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\\n      } else {\\n        complete();\\n      }\\n    };\\n\\n    _proto.hide = function hide() {\\n      if (!this._element.classList.contains(ClassName$a.SHOW)) {\\n        return;\\n      }\\n\\n      var hideEvent = $.Event(Event$a.HIDE);\\n      $(this._element).trigger(hideEvent);\\n\\n      if (hideEvent.isDefaultPrevented()) {\\n        return;\\n      }\\n\\n      this._close();\\n    };\\n\\n    _proto.dispose = function dispose() {\\n      clearTimeout(this._timeout);\\n      this._timeout = null;\\n\\n      if (this._element.classList.contains(ClassName$a.SHOW)) {\\n        this._element.classList.remove(ClassName$a.SHOW);\\n      }\\n\\n      $(this._element).off(Event$a.CLICK_DISMISS);\\n      $.removeData(this._element, DATA_KEY$a);\\n      this._element = null;\\n      this._config = null;\\n    } // Private\\n    ;\\n\\n    _proto._getConfig = function _getConfig(config) {\\n      config = _objectSpread2({}, Default$7, {}, $(this._element).data(), {}, typeof config === 'object' && config ? config : {});\\n      Util.typeCheckConfig(NAME$a, config, this.constructor.DefaultType);\\n      return config;\\n    };\\n\\n    _proto._setListeners = function _setListeners() {\\n      var _this2 = this;\\n\\n      $(this._element).on(Event$a.CLICK_DISMISS, Selector$a.DATA_DISMISS, function () {\\n        return _this2.hide();\\n      });\\n    };\\n\\n    _proto._close = function _close() {\\n      var _this3 = this;\\n\\n      var complete = function complete() {\\n        _this3._element.classList.add(ClassName$a.HIDE);\\n\\n        $(_this3._element).trigger(Event$a.HIDDEN);\\n      };\\n\\n      this._element.classList.remove(ClassName$a.SHOW);\\n\\n      if (this._config.animation) {\\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\\n        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\\n      } else {\\n        complete();\\n      }\\n    } // Static\\n    ;\\n\\n    Toast._jQueryInterface = function _jQueryInterface(config) {\\n      return this.each(function () {\\n        var $element = $(this);\\n        var data = $element.data(DATA_KEY$a);\\n\\n        var _config = typeof config === 'object' && config;\\n\\n        if (!data) {\\n          data = new Toast(this, _config);\\n          $element.data(DATA_KEY$a, data);\\n        }\\n\\n        if (typeof config === 'string') {\\n          if (typeof data[config] === 'undefined') {\\n            throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n          }\\n\\n          data[config](this);\\n        }\\n      });\\n    };\\n\\n    _createClass(Toast, null, [{\\n      key: \\\"VERSION\\\",\\n      get: function get() {\\n        return VERSION$a;\\n      }\\n    }, {\\n      key: \\\"DefaultType\\\",\\n      get: function get() {\\n        return DefaultType$7;\\n      }\\n    }, {\\n      key: \\\"Default\\\",\\n      get: function get() {\\n        return Default$7;\\n      }\\n    }]);\\n\\n    return Toast;\\n  }();\\n  /**\\n   * ------------------------------------------------------------------------\\n   * jQuery\\n   * ------------------------------------------------------------------------\\n   */\\n\\n\\n  $.fn[NAME$a] = Toast._jQueryInterface;\\n  $.fn[NAME$a].Constructor = Toast;\\n\\n  $.fn[NAME$a].noConflict = function () {\\n    $.fn[NAME$a] = JQUERY_NO_CONFLICT$a;\\n    return Toast._jQueryInterface;\\n  };\\n\\n  exports.Alert = Alert;\\n  exports.Button = Button;\\n  exports.Carousel = Carousel;\\n  exports.Collapse = Collapse;\\n  exports.Dropdown = Dropdown;\\n  exports.Modal = Modal;\\n  exports.Popover = Popover;\\n  exports.Scrollspy = ScrollSpy;\\n  exports.Tab = Tab;\\n  exports.Toast = Toast;\\n  exports.Tooltip = Tooltip;\\n  exports.Util = Util;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n//# sourceMappingURL=bootstrap.js.map\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuanM/MjAxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICAqIEJvb3RzdHJhcCB2NC40LjEgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXFxuICAqIENvcHlyaWdodCAyMDExLTIwMTkgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXG4gICovXFxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnanF1ZXJ5JyksIHJlcXVpcmUoJ3BvcHBlci5qcycpKSA6XFxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2pxdWVyeScsICdwb3BwZXIuanMnXSwgZmFjdG9yeSkgOlxcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5ib290c3RyYXAgPSB7fSwgZ2xvYmFsLmpRdWVyeSwgZ2xvYmFsLlBvcHBlcikpO1xcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCAkLCBQb3BwZXIpIHsgJ3VzZSBzdHJpY3QnO1xcblxcbiAgJCA9ICQgJiYgJC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpID8gJFsnZGVmYXVsdCddIDogJDtcXG4gIFBvcHBlciA9IFBvcHBlciAmJiBQb3BwZXIuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IFBvcHBlclsnZGVmYXVsdCddIDogUG9wcGVyO1xcblxcbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcXG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XFxuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xcbiAgICAgIGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcXG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XFxuICAgIGlmIChrZXkgaW4gb2JqKSB7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XFxuICAgICAgICB2YWx1ZTogdmFsdWUsXFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBvYmo7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xcblxcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xcbiAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xcbiAgICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xcbiAgICAgIH0pO1xcbiAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4ga2V5cztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xcblxcbiAgICAgIGlmIChpICUgMikge1xcbiAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB0YXJnZXQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcXG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XFxuICAgIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY0LjQuMSk6IHV0aWwuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogUHJpdmF0ZSBUcmFuc2l0aW9uRW5kIEhlbHBlcnNcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuICB2YXIgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCc7XFxuICB2YXIgTUFYX1VJRCA9IDEwMDAwMDA7XFxuICB2YXIgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwOyAvLyBTaG91dG91dCBBbmd1c0Nyb2xsIChodHRwczovL2dvby5nbC9weHdRR3ApXFxuXFxuICBmdW5jdGlvbiB0b1R5cGUob2JqKSB7XFxuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKG9iaikubWF0Y2goL1xcXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldFNwZWNpYWxUcmFuc2l0aW9uRW5kRXZlbnQoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgYmluZFR5cGU6IFRSQU5TSVRJT05fRU5ELFxcbiAgICAgIGRlbGVnYXRlVHlwZTogVFJBTlNJVElPTl9FTkQsXFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiBoYW5kbGUoZXZlbnQpIHtcXG4gICAgICAgIGlmICgkKGV2ZW50LnRhcmdldCkuaXModGhpcykpIHtcXG4gICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmaW5lZFxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRFbXVsYXRvcihkdXJhdGlvbikge1xcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XFxuICAgICQodGhpcykub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBjYWxsZWQgPSB0cnVlO1xcbiAgICB9KTtcXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKCFjYWxsZWQpIHtcXG4gICAgICAgIFV0aWwudHJpZ2dlclRyYW5zaXRpb25FbmQoX3RoaXMpO1xcbiAgICAgIH1cXG4gICAgfSwgZHVyYXRpb24pO1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNldFRyYW5zaXRpb25FbmRTdXBwb3J0KCkge1xcbiAgICAkLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kID0gdHJhbnNpdGlvbkVuZEVtdWxhdG9yO1xcbiAgICAkLmV2ZW50LnNwZWNpYWxbVXRpbC5UUkFOU0lUSU9OX0VORF0gPSBnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50KCk7XFxuICB9XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBQdWJsaWMgVXRpbCBBcGlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG5cXG4gIHZhciBVdGlsID0ge1xcbiAgICBUUkFOU0lUSU9OX0VORDogJ2JzVHJhbnNpdGlvbkVuZCcsXFxuICAgIGdldFVJRDogZnVuY3Rpb24gZ2V0VUlEKHByZWZpeCkge1xcbiAgICAgIGRvIHtcXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXFxuICAgICAgICBwcmVmaXggKz0gfn4oTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpOyAvLyBcXFwifn5cXFwiIGFjdHMgbGlrZSBhIGZhc3RlciBNYXRoLmZsb29yKCkgaGVyZVxcbiAgICAgIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpO1xcblxcbiAgICAgIHJldHVybiBwcmVmaXg7XFxuICAgIH0sXFxuICAgIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCkge1xcbiAgICAgIHZhciBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpO1xcblxcbiAgICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcjJykge1xcbiAgICAgICAgdmFyIGhyZWZBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcXG4gICAgICAgIHNlbGVjdG9yID0gaHJlZkF0dHIgJiYgaHJlZkF0dHIgIT09ICcjJyA/IGhyZWZBdHRyLnRyaW0oKSA6ICcnO1xcbiAgICAgIH1cXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsO1xcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudDogZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQoZWxlbWVudCkge1xcbiAgICAgIGlmICghZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgfSAvLyBHZXQgdHJhbnNpdGlvbi1kdXJhdGlvbiBvZiB0aGUgZWxlbWVudFxcblxcblxcbiAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSAkKGVsZW1lbnQpLmNzcygndHJhbnNpdGlvbi1kdXJhdGlvbicpO1xcbiAgICAgIHZhciB0cmFuc2l0aW9uRGVsYXkgPSAkKGVsZW1lbnQpLmNzcygndHJhbnNpdGlvbi1kZWxheScpO1xcbiAgICAgIHZhciBmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiA9IHBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKTtcXG4gICAgICB2YXIgZmxvYXRUcmFuc2l0aW9uRGVsYXkgPSBwYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSk7IC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcXG5cXG4gICAgICBpZiAoIWZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uICYmICFmbG9hdFRyYW5zaXRpb25EZWxheSkge1xcbiAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgfSAvLyBJZiBtdWx0aXBsZSBkdXJhdGlvbnMgYXJlIGRlZmluZWQsIHRha2UgdGhlIGZpcnN0XFxuXFxuXFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uLnNwbGl0KCcsJylbMF07XFxuICAgICAgdHJhbnNpdGlvbkRlbGF5ID0gdHJhbnNpdGlvbkRlbGF5LnNwbGl0KCcsJylbMF07XFxuICAgICAgcmV0dXJuIChwYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbikgKyBwYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSkpICogTUlMTElTRUNPTkRTX01VTFRJUExJRVI7XFxuICAgIH0sXFxuICAgIHJlZmxvdzogZnVuY3Rpb24gcmVmbG93KGVsZW1lbnQpIHtcXG4gICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XFxuICAgIH0sXFxuICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiB0cmlnZ2VyVHJhbnNpdGlvbkVuZChlbGVtZW50KSB7XFxuICAgICAgJChlbGVtZW50KS50cmlnZ2VyKFRSQU5TSVRJT05fRU5EKTtcXG4gICAgfSxcXG4gICAgLy8gVE9ETzogUmVtb3ZlIGluIHY1XFxuICAgIHN1cHBvcnRzVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkge1xcbiAgICAgIHJldHVybiBCb29sZWFuKFRSQU5TSVRJT05fRU5EKTtcXG4gICAgfSxcXG4gICAgaXNFbGVtZW50OiBmdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XFxuICAgICAgcmV0dXJuIChvYmpbMF0gfHwgb2JqKS5ub2RlVHlwZTtcXG4gICAgfSxcXG4gICAgdHlwZUNoZWNrQ29uZmlnOiBmdW5jdGlvbiB0eXBlQ2hlY2tDb25maWcoY29tcG9uZW50TmFtZSwgY29uZmlnLCBjb25maWdUeXBlcykge1xcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGNvbmZpZ1R5cGVzKSB7XFxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZ1R5cGVzLCBwcm9wZXJ0eSkpIHtcXG4gICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBjb25maWdUeXBlc1twcm9wZXJ0eV07XFxuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XFxuICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSB2YWx1ZSAmJiBVdGlsLmlzRWxlbWVudCh2YWx1ZSkgPyAnZWxlbWVudCcgOiB0b1R5cGUodmFsdWUpO1xcblxcbiAgICAgICAgICBpZiAoIW5ldyBSZWdFeHAoZXhwZWN0ZWRUeXBlcykudGVzdCh2YWx1ZVR5cGUpKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXBvbmVudE5hbWUudG9VcHBlckNhc2UoKSArIFxcXCI6IFxcXCIgKyAoXFxcIk9wdGlvbiBcXFxcXFxcIlxcXCIgKyBwcm9wZXJ0eSArIFxcXCJcXFxcXFxcIiBwcm92aWRlZCB0eXBlIFxcXFxcXFwiXFxcIiArIHZhbHVlVHlwZSArIFxcXCJcXFxcXFxcIiBcXFwiKSArIChcXFwiYnV0IGV4cGVjdGVkIHR5cGUgXFxcXFxcXCJcXFwiICsgZXhwZWN0ZWRUeXBlcyArIFxcXCJcXFxcXFxcIi5cXFwiKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGZpbmRTaGFkb3dSb290OiBmdW5jdGlvbiBmaW5kU2hhZG93Um9vdChlbGVtZW50KSB7XFxuICAgICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KSB7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICB9IC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxcblxcblxcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5nZXRSb290Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdmFyIHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XFxuICAgICAgICByZXR1cm4gcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByb290IDogbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XFxuICAgICAgICByZXR1cm4gZWxlbWVudDtcXG4gICAgICB9IC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XFxuXFxuXFxuICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gVXRpbC5maW5kU2hhZG93Um9vdChlbGVtZW50LnBhcmVudE5vZGUpO1xcbiAgICB9LFxcbiAgICBqUXVlcnlEZXRlY3Rpb246IGZ1bmN0aW9uIGpRdWVyeURldGVjdGlvbigpIHtcXG4gICAgICBpZiAodHlwZW9mICQgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnkuIGpRdWVyeSBtdXN0IGJlIGluY2x1ZGVkIGJlZm9yZSBCb290c3RyYXBcXFxcJ3MgSmF2YVNjcmlwdC4nKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHZlcnNpb24gPSAkLmZuLmpxdWVyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJyk7XFxuICAgICAgdmFyIG1pbk1ham9yID0gMTtcXG4gICAgICB2YXIgbHRNYWpvciA9IDI7XFxuICAgICAgdmFyIG1pbk1pbm9yID0gOTtcXG4gICAgICB2YXIgbWluUGF0Y2ggPSAxO1xcbiAgICAgIHZhciBtYXhNYWpvciA9IDQ7XFxuXFxuICAgICAgaWYgKHZlcnNpb25bMF0gPCBsdE1ham9yICYmIHZlcnNpb25bMV0gPCBtaW5NaW5vciB8fCB2ZXJzaW9uWzBdID09PSBtaW5NYWpvciAmJiB2ZXJzaW9uWzFdID09PSBtaW5NaW5vciAmJiB2ZXJzaW9uWzJdIDwgbWluUGF0Y2ggfHwgdmVyc2lvblswXSA+PSBtYXhNYWpvcikge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBhdCBsZWFzdCBqUXVlcnkgdjEuOS4xIGJ1dCBsZXNzIHRoYW4gdjQuMC4wJyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcbiAgVXRpbC5qUXVlcnlEZXRlY3Rpb24oKTtcXG4gIHNldFRyYW5zaXRpb25FbmRTdXBwb3J0KCk7XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQ29uc3RhbnRzXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgdmFyIE5BTUUgPSAnYWxlcnQnO1xcbiAgdmFyIFZFUlNJT04gPSAnNC40LjEnO1xcbiAgdmFyIERBVEFfS0VZID0gJ2JzLmFsZXJ0JztcXG4gIHZhciBFVkVOVF9LRVkgPSBcXFwiLlxcXCIgKyBEQVRBX0tFWTtcXG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcXG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdO1xcbiAgdmFyIFNlbGVjdG9yID0ge1xcbiAgICBESVNNSVNTOiAnW2RhdGEtZGlzbWlzcz1cXFwiYWxlcnRcXFwiXSdcXG4gIH07XFxuICB2YXIgRXZlbnQgPSB7XFxuICAgIENMT1NFOiBcXFwiY2xvc2VcXFwiICsgRVZFTlRfS0VZLFxcbiAgICBDTE9TRUQ6IFxcXCJjbG9zZWRcXFwiICsgRVZFTlRfS0VZLFxcbiAgICBDTElDS19EQVRBX0FQSTogXFxcImNsaWNrXFxcIiArIEVWRU5UX0tFWSArIERBVEFfQVBJX0tFWVxcbiAgfTtcXG4gIHZhciBDbGFzc05hbWUgPSB7XFxuICAgIEFMRVJUOiAnYWxlcnQnLFxcbiAgICBGQURFOiAnZmFkZScsXFxuICAgIFNIT1c6ICdzaG93J1xcbiAgfTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBDbGFzcyBEZWZpbml0aW9uXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgdmFyIEFsZXJ0ID1cXG4gIC8qI19fUFVSRV9fKi9cXG4gIGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gQWxlcnQoZWxlbWVudCkge1xcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xcbiAgICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gICAgdmFyIF9wcm90byA9IEFsZXJ0LnByb3RvdHlwZTtcXG5cXG4gICAgLy8gUHVibGljXFxuICAgIF9wcm90by5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKGVsZW1lbnQpIHtcXG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xcblxcbiAgICAgIGlmIChlbGVtZW50KSB7XFxuICAgICAgICByb290RWxlbWVudCA9IHRoaXMuX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgY3VzdG9tRXZlbnQgPSB0aGlzLl90cmlnZ2VyQ2xvc2VFdmVudChyb290RWxlbWVudCk7XFxuXFxuICAgICAgaWYgKGN1c3RvbUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQocm9vdEVsZW1lbnQpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XFxuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcXG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcXG4gICAgfSAvLyBQcml2YXRlXFxuICAgIDtcXG5cXG4gICAgX3Byb3RvLl9nZXRSb290RWxlbWVudCA9IGZ1bmN0aW9uIF9nZXRSb290RWxlbWVudChlbGVtZW50KSB7XFxuICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpO1xcbiAgICAgIHZhciBwYXJlbnQgPSBmYWxzZTtcXG5cXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcXG4gICAgICAgIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXBhcmVudCkge1xcbiAgICAgICAgcGFyZW50ID0gJChlbGVtZW50KS5jbG9zZXN0KFxcXCIuXFxcIiArIENsYXNzTmFtZS5BTEVSVClbMF07XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwYXJlbnQ7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fdHJpZ2dlckNsb3NlRXZlbnQgPSBmdW5jdGlvbiBfdHJpZ2dlckNsb3NlRXZlbnQoZWxlbWVudCkge1xcbiAgICAgIHZhciBjbG9zZUV2ZW50ID0gJC5FdmVudChFdmVudC5DTE9TRSk7XFxuICAgICAgJChlbGVtZW50KS50cmlnZ2VyKGNsb3NlRXZlbnQpO1xcbiAgICAgIHJldHVybiBjbG9zZUV2ZW50O1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX3JlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAkKGVsZW1lbnQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKTtcXG5cXG4gICAgICBpZiAoISQoZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XFxuICAgICAgICB0aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50KTtcXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQoZWxlbWVudCk7XFxuICAgICAgJChlbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQsIGV2ZW50KTtcXG4gICAgICB9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2Rlc3Ryb3lFbGVtZW50ID0gZnVuY3Rpb24gX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpIHtcXG4gICAgICAkKGVsZW1lbnQpLmRldGFjaCgpLnRyaWdnZXIoRXZlbnQuQ0xPU0VEKS5yZW1vdmUoKTtcXG4gICAgfSAvLyBTdGF0aWNcXG4gICAgO1xcblxcbiAgICBBbGVydC5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyk7XFxuICAgICAgICB2YXIgZGF0YSA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpO1xcblxcbiAgICAgICAgaWYgKCFkYXRhKSB7XFxuICAgICAgICAgIGRhdGEgPSBuZXcgQWxlcnQodGhpcyk7XFxuICAgICAgICAgICRlbGVtZW50LmRhdGEoREFUQV9LRVksIGRhdGEpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gJ2Nsb3NlJykge1xcbiAgICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIEFsZXJ0Ll9oYW5kbGVEaXNtaXNzID0gZnVuY3Rpb24gX2hhbmRsZURpc21pc3MoYWxlcnRJbnN0YW5jZSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgIGlmIChldmVudCkge1xcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYWxlcnRJbnN0YW5jZS5jbG9zZSh0aGlzKTtcXG4gICAgICB9O1xcbiAgICB9O1xcblxcbiAgICBfY3JlYXRlQ2xhc3MoQWxlcnQsIG51bGwsIFt7XFxuICAgICAga2V5OiBcXFwiVkVSU0lPTlxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gVkVSU0lPTjtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIEFsZXJ0O1xcbiAgfSgpO1xcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcblxcbiAgJChkb2N1bWVudCkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRJU01JU1MsIEFsZXJ0Ll9oYW5kbGVEaXNtaXNzKG5ldyBBbGVydCgpKSk7XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogalF1ZXJ5XFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgJC5mbltOQU1FXSA9IEFsZXJ0Ll9qUXVlcnlJbnRlcmZhY2U7XFxuICAkLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQWxlcnQ7XFxuXFxuICAkLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XFxuICAgICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XFxuICAgIHJldHVybiBBbGVydC5falF1ZXJ5SW50ZXJmYWNlO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBDb25zdGFudHNcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuICB2YXIgTkFNRSQxID0gJ2J1dHRvbic7XFxuICB2YXIgVkVSU0lPTiQxID0gJzQuNC4xJztcXG4gIHZhciBEQVRBX0tFWSQxID0gJ2JzLmJ1dHRvbic7XFxuICB2YXIgRVZFTlRfS0VZJDEgPSBcXFwiLlxcXCIgKyBEQVRBX0tFWSQxO1xcbiAgdmFyIERBVEFfQVBJX0tFWSQxID0gJy5kYXRhLWFwaSc7XFxuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUJDEgPSAkLmZuW05BTUUkMV07XFxuICB2YXIgQ2xhc3NOYW1lJDEgPSB7XFxuICAgIEFDVElWRTogJ2FjdGl2ZScsXFxuICAgIEJVVFRPTjogJ2J0bicsXFxuICAgIEZPQ1VTOiAnZm9jdXMnXFxuICB9O1xcbiAgdmFyIFNlbGVjdG9yJDEgPSB7XFxuICAgIERBVEFfVE9HR0xFX0NBUlJPVDogJ1tkYXRhLXRvZ2dsZV49XFxcImJ1dHRvblxcXCJdJyxcXG4gICAgREFUQV9UT0dHTEVTOiAnW2RhdGEtdG9nZ2xlPVxcXCJidXR0b25zXFxcIl0nLFxcbiAgICBEQVRBX1RPR0dMRTogJ1tkYXRhLXRvZ2dsZT1cXFwiYnV0dG9uXFxcIl0nLFxcbiAgICBEQVRBX1RPR0dMRVNfQlVUVE9OUzogJ1tkYXRhLXRvZ2dsZT1cXFwiYnV0dG9uc1xcXCJdIC5idG4nLFxcbiAgICBJTlBVVDogJ2lucHV0Om5vdChbdHlwZT1cXFwiaGlkZGVuXFxcIl0pJyxcXG4gICAgQUNUSVZFOiAnLmFjdGl2ZScsXFxuICAgIEJVVFRPTjogJy5idG4nXFxuICB9O1xcbiAgdmFyIEV2ZW50JDEgPSB7XFxuICAgIENMSUNLX0RBVEFfQVBJOiBcXFwiY2xpY2tcXFwiICsgRVZFTlRfS0VZJDEgKyBEQVRBX0FQSV9LRVkkMSxcXG4gICAgRk9DVVNfQkxVUl9EQVRBX0FQSTogXFxcImZvY3VzXFxcIiArIEVWRU5UX0tFWSQxICsgREFUQV9BUElfS0VZJDEgKyBcXFwiIFxcXCIgKyAoXFxcImJsdXJcXFwiICsgRVZFTlRfS0VZJDEgKyBEQVRBX0FQSV9LRVkkMSksXFxuICAgIExPQURfREFUQV9BUEk6IFxcXCJsb2FkXFxcIiArIEVWRU5UX0tFWSQxICsgREFUQV9BUElfS0VZJDFcXG4gIH07XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQ2xhc3MgRGVmaW5pdGlvblxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gIHZhciBCdXR0b24gPVxcbiAgLyojX19QVVJFX18qL1xcbiAgZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBCdXR0b24oZWxlbWVudCkge1xcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xcbiAgICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gICAgdmFyIF9wcm90byA9IEJ1dHRvbi5wcm90b3R5cGU7XFxuXFxuICAgIC8vIFB1YmxpY1xcbiAgICBfcHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge1xcbiAgICAgIHZhciB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlO1xcbiAgICAgIHZhciBhZGRBcmlhUHJlc3NlZCA9IHRydWU7XFxuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFNlbGVjdG9yJDEuREFUQV9UT0dHTEVTKVswXTtcXG5cXG4gICAgICBpZiAocm9vdEVsZW1lbnQpIHtcXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3RvciQxLklOUFVUKTtcXG5cXG4gICAgICAgIGlmIChpbnB1dCkge1xcbiAgICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3JhZGlvJykge1xcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkICYmIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENsYXNzTmFtZSQxLkFDVElWRSkpIHtcXG4gICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2VFdmVudCA9IGZhbHNlO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IHJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IkMS5BQ1RJVkUpO1xcblxcbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcXG4gICAgICAgICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkMS5BQ1RJVkUpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dC50eXBlID09PSAnY2hlY2tib3gnKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQudGFnTmFtZSA9PT0gJ0xBQkVMJyAmJiBpbnB1dC5jaGVja2VkID09PSB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUkMS5BQ1RJVkUpKSB7XFxuICAgICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy8gaWYgaXQncyBub3QgYSByYWRpbyBidXR0b24gb3IgY2hlY2tib3ggZG9uJ3QgYWRkIGEgcG9pbnRsZXNzL2ludmFsaWQgY2hlY2tlZCBwcm9wZXJ0eSB0byB0aGUgaW5wdXRcXG4gICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50KSB7XFxuICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9ICF0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUkMS5BQ1RJVkUpO1xcbiAgICAgICAgICAgICQoaW5wdXQpLnRyaWdnZXIoJ2NoYW5nZScpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0LmZvY3VzKCk7XFxuICAgICAgICAgIGFkZEFyaWFQcmVzc2VkID0gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghKHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSkge1xcbiAgICAgICAgaWYgKGFkZEFyaWFQcmVzc2VkKSB7XFxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCAhdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3NOYW1lJDEuQUNUSVZFKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50KSB7XFxuICAgICAgICAgICQodGhpcy5fZWxlbWVudCkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lJDEuQUNUSVZFKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcXG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkkMSk7XFxuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XFxuICAgIH0gLy8gU3RhdGljXFxuICAgIDtcXG5cXG4gICAgQnV0dG9uLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkkMSk7XFxuXFxuICAgICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgICAgZGF0YSA9IG5ldyBCdXR0b24odGhpcyk7XFxuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSQxLCBkYXRhKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XFxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBfY3JlYXRlQ2xhc3MoQnV0dG9uLCBudWxsLCBbe1xcbiAgICAgIGtleTogXFxcIlZFUlNJT05cXFwiLFxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIFZFUlNJT04kMTtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIEJ1dHRvbjtcXG4gIH0oKTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG5cXG4gICQoZG9jdW1lbnQpLm9uKEV2ZW50JDEuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yJDEuREFUQV9UT0dHTEVfQ0FSUk9ULCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LnRhcmdldDtcXG5cXG4gICAgaWYgKCEkKGJ1dHRvbikuaGFzQ2xhc3MoQ2xhc3NOYW1lJDEuQlVUVE9OKSkge1xcbiAgICAgIGJ1dHRvbiA9ICQoYnV0dG9uKS5jbG9zZXN0KFNlbGVjdG9yJDEuQlVUVE9OKVswXTtcXG4gICAgfVxcblxcbiAgICBpZiAoIWJ1dHRvbiB8fCBidXR0b24uaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IGJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMoJ2Rpc2FibGVkJykpIHtcXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyB3b3JrIGFyb3VuZCBGaXJlZm94IGJ1ZyAjMTU0MDk5NVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBpbnB1dEJ0biA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yJDEuSU5QVVQpO1xcblxcbiAgICAgIGlmIChpbnB1dEJ0biAmJiAoaW5wdXRCdG4uaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IGlucHV0QnRuLmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkpIHtcXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHdvcmsgYXJvdW5kIEZpcmVmb3ggYnVnICMxNTQwOTk1XFxuXFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJChidXR0b24pLCAndG9nZ2xlJyk7XFxuICAgIH1cXG4gIH0pLm9uKEV2ZW50JDEuRk9DVVNfQkxVUl9EQVRBX0FQSSwgU2VsZWN0b3IkMS5EQVRBX1RPR0dMRV9DQVJST1QsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICB2YXIgYnV0dG9uID0gJChldmVudC50YXJnZXQpLmNsb3Nlc3QoU2VsZWN0b3IkMS5CVVRUT04pWzBdO1xcbiAgICAkKGJ1dHRvbikudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lJDEuRk9DVVMsIC9eZm9jdXMoaW4pPyQvLnRlc3QoZXZlbnQudHlwZSkpO1xcbiAgfSk7XFxuICAkKHdpbmRvdykub24oRXZlbnQkMS5MT0FEX0RBVEFfQVBJLCBmdW5jdGlvbiAoKSB7XFxuICAgIC8vIGVuc3VyZSBjb3JyZWN0IGFjdGl2ZSBjbGFzcyBpcyBzZXQgdG8gbWF0Y2ggdGhlIGNvbnRyb2xzJyBhY3R1YWwgdmFsdWVzL3N0YXRlc1xcbiAgICAvLyBmaW5kIGFsbCBjaGVja2JveGVzL3JlYWRpbyBidXR0b25zIGluc2lkZSBkYXRhLXRvZ2dsZSBncm91cHNcXG4gICAgdmFyIGJ1dHRvbnMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IkMS5EQVRBX1RPR0dMRVNfQlVUVE9OUykpO1xcblxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIHZhciBidXR0b24gPSBidXR0b25zW2ldO1xcbiAgICAgIHZhciBpbnB1dCA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yJDEuSU5QVVQpO1xcblxcbiAgICAgIGlmIChpbnB1dC5jaGVja2VkIHx8IGlucHV0Lmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XFxuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChDbGFzc05hbWUkMS5BQ1RJVkUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShDbGFzc05hbWUkMS5BQ1RJVkUpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBmaW5kIGFsbCBidXR0b24gdG9nZ2xlc1xcblxcblxcbiAgICBidXR0b25zID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yJDEuREFUQV9UT0dHTEUpKTtcXG5cXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfbGVuID0gYnV0dG9ucy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xcbiAgICAgIHZhciBfYnV0dG9uID0gYnV0dG9uc1tfaV07XFxuXFxuICAgICAgaWYgKF9idXR0b24uZ2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnKSA9PT0gJ3RydWUnKSB7XFxuICAgICAgICBfYnV0dG9uLmNsYXNzTGlzdC5hZGQoQ2xhc3NOYW1lJDEuQUNUSVZFKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgX2J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZSQxLkFDVElWRSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBqUXVlcnlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuICAkLmZuW05BTUUkMV0gPSBCdXR0b24uX2pRdWVyeUludGVyZmFjZTtcXG4gICQuZm5bTkFNRSQxXS5Db25zdHJ1Y3RvciA9IEJ1dHRvbjtcXG5cXG4gICQuZm5bTkFNRSQxXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAkLmZuW05BTUUkMV0gPSBKUVVFUllfTk9fQ09ORkxJQ1QkMTtcXG4gICAgcmV0dXJuIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBDb25zdGFudHNcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuICB2YXIgTkFNRSQyID0gJ2Nhcm91c2VsJztcXG4gIHZhciBWRVJTSU9OJDIgPSAnNC40LjEnO1xcbiAgdmFyIERBVEFfS0VZJDIgPSAnYnMuY2Fyb3VzZWwnO1xcbiAgdmFyIEVWRU5UX0tFWSQyID0gXFxcIi5cXFwiICsgREFUQV9LRVkkMjtcXG4gIHZhciBEQVRBX0FQSV9LRVkkMiA9ICcuZGF0YS1hcGknO1xcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCQyID0gJC5mbltOQU1FJDJdO1xcbiAgdmFyIEFSUk9XX0xFRlRfS0VZQ09ERSA9IDM3OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBsZWZ0IGFycm93IGtleVxcblxcbiAgdmFyIEFSUk9XX1JJR0hUX0tFWUNPREUgPSAzOTsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgcmlnaHQgYXJyb3cga2V5XFxuXFxuICB2YXIgVE9VQ0hFVkVOVF9DT01QQVRfV0FJVCA9IDUwMDsgLy8gVGltZSBmb3IgbW91c2UgY29tcGF0IGV2ZW50cyB0byBmaXJlIGFmdGVyIHRvdWNoXFxuXFxuICB2YXIgU1dJUEVfVEhSRVNIT0xEID0gNDA7XFxuICB2YXIgRGVmYXVsdCA9IHtcXG4gICAgaW50ZXJ2YWw6IDUwMDAsXFxuICAgIGtleWJvYXJkOiB0cnVlLFxcbiAgICBzbGlkZTogZmFsc2UsXFxuICAgIHBhdXNlOiAnaG92ZXInLFxcbiAgICB3cmFwOiB0cnVlLFxcbiAgICB0b3VjaDogdHJ1ZVxcbiAgfTtcXG4gIHZhciBEZWZhdWx0VHlwZSA9IHtcXG4gICAgaW50ZXJ2YWw6ICcobnVtYmVyfGJvb2xlYW4pJyxcXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcXG4gICAgc2xpZGU6ICcoYm9vbGVhbnxzdHJpbmcpJyxcXG4gICAgcGF1c2U6ICcoc3RyaW5nfGJvb2xlYW4pJyxcXG4gICAgd3JhcDogJ2Jvb2xlYW4nLFxcbiAgICB0b3VjaDogJ2Jvb2xlYW4nXFxuICB9O1xcbiAgdmFyIERpcmVjdGlvbiA9IHtcXG4gICAgTkVYVDogJ25leHQnLFxcbiAgICBQUkVWOiAncHJldicsXFxuICAgIExFRlQ6ICdsZWZ0JyxcXG4gICAgUklHSFQ6ICdyaWdodCdcXG4gIH07XFxuICB2YXIgRXZlbnQkMiA9IHtcXG4gICAgU0xJREU6IFxcXCJzbGlkZVxcXCIgKyBFVkVOVF9LRVkkMixcXG4gICAgU0xJRDogXFxcInNsaWRcXFwiICsgRVZFTlRfS0VZJDIsXFxuICAgIEtFWURPV046IFxcXCJrZXlkb3duXFxcIiArIEVWRU5UX0tFWSQyLFxcbiAgICBNT1VTRUVOVEVSOiBcXFwibW91c2VlbnRlclxcXCIgKyBFVkVOVF9LRVkkMixcXG4gICAgTU9VU0VMRUFWRTogXFxcIm1vdXNlbGVhdmVcXFwiICsgRVZFTlRfS0VZJDIsXFxuICAgIFRPVUNIU1RBUlQ6IFxcXCJ0b3VjaHN0YXJ0XFxcIiArIEVWRU5UX0tFWSQyLFxcbiAgICBUT1VDSE1PVkU6IFxcXCJ0b3VjaG1vdmVcXFwiICsgRVZFTlRfS0VZJDIsXFxuICAgIFRPVUNIRU5EOiBcXFwidG91Y2hlbmRcXFwiICsgRVZFTlRfS0VZJDIsXFxuICAgIFBPSU5URVJET1dOOiBcXFwicG9pbnRlcmRvd25cXFwiICsgRVZFTlRfS0VZJDIsXFxuICAgIFBPSU5URVJVUDogXFxcInBvaW50ZXJ1cFxcXCIgKyBFVkVOVF9LRVkkMixcXG4gICAgRFJBR19TVEFSVDogXFxcImRyYWdzdGFydFxcXCIgKyBFVkVOVF9LRVkkMixcXG4gICAgTE9BRF9EQVRBX0FQSTogXFxcImxvYWRcXFwiICsgRVZFTlRfS0VZJDIgKyBEQVRBX0FQSV9LRVkkMixcXG4gICAgQ0xJQ0tfREFUQV9BUEk6IFxcXCJjbGlja1xcXCIgKyBFVkVOVF9LRVkkMiArIERBVEFfQVBJX0tFWSQyXFxuICB9O1xcbiAgdmFyIENsYXNzTmFtZSQyID0ge1xcbiAgICBDQVJPVVNFTDogJ2Nhcm91c2VsJyxcXG4gICAgQUNUSVZFOiAnYWN0aXZlJyxcXG4gICAgU0xJREU6ICdzbGlkZScsXFxuICAgIFJJR0hUOiAnY2Fyb3VzZWwtaXRlbS1yaWdodCcsXFxuICAgIExFRlQ6ICdjYXJvdXNlbC1pdGVtLWxlZnQnLFxcbiAgICBORVhUOiAnY2Fyb3VzZWwtaXRlbS1uZXh0JyxcXG4gICAgUFJFVjogJ2Nhcm91c2VsLWl0ZW0tcHJldicsXFxuICAgIElURU06ICdjYXJvdXNlbC1pdGVtJyxcXG4gICAgUE9JTlRFUl9FVkVOVDogJ3BvaW50ZXItZXZlbnQnXFxuICB9O1xcbiAgdmFyIFNlbGVjdG9yJDIgPSB7XFxuICAgIEFDVElWRTogJy5hY3RpdmUnLFxcbiAgICBBQ1RJVkVfSVRFTTogJy5hY3RpdmUuY2Fyb3VzZWwtaXRlbScsXFxuICAgIElURU06ICcuY2Fyb3VzZWwtaXRlbScsXFxuICAgIElURU1fSU1HOiAnLmNhcm91c2VsLWl0ZW0gaW1nJyxcXG4gICAgTkVYVF9QUkVWOiAnLmNhcm91c2VsLWl0ZW0tbmV4dCwgLmNhcm91c2VsLWl0ZW0tcHJldicsXFxuICAgIElORElDQVRPUlM6ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycycsXFxuICAgIERBVEFfU0xJREU6ICdbZGF0YS1zbGlkZV0sIFtkYXRhLXNsaWRlLXRvXScsXFxuICAgIERBVEFfUklERTogJ1tkYXRhLXJpZGU9XFxcImNhcm91c2VsXFxcIl0nXFxuICB9O1xcbiAgdmFyIFBvaW50ZXJUeXBlID0ge1xcbiAgICBUT1VDSDogJ3RvdWNoJyxcXG4gICAgUEVOOiAncGVuJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBDbGFzcyBEZWZpbml0aW9uXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgdmFyIENhcm91c2VsID1cXG4gIC8qI19fUFVSRV9fKi9cXG4gIGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gQ2Fyb3VzZWwoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgdGhpcy5faXRlbXMgPSBudWxsO1xcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcXG4gICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbDtcXG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xcbiAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbDtcXG4gICAgICB0aGlzLnRvdWNoU3RhcnRYID0gMDtcXG4gICAgICB0aGlzLnRvdWNoRGVsdGFYID0gMDtcXG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3RvciQyLklORElDQVRPUlMpO1xcbiAgICAgIHRoaXMuX3RvdWNoU3VwcG9ydGVkID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XFxuICAgICAgdGhpcy5fcG9pbnRlckV2ZW50ID0gQm9vbGVhbih3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudCk7XFxuXFxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHZhciBfcHJvdG8gPSBDYXJvdXNlbC5wcm90b3R5cGU7XFxuXFxuICAgIC8vIFB1YmxpY1xcbiAgICBfcHJvdG8ubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XFxuICAgICAgaWYgKCF0aGlzLl9pc1NsaWRpbmcpIHtcXG4gICAgICAgIHRoaXMuX3NsaWRlKERpcmVjdGlvbi5ORVhUKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5uZXh0V2hlblZpc2libGUgPSBmdW5jdGlvbiBuZXh0V2hlblZpc2libGUoKSB7XFxuICAgICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxcbiAgICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcXG4gICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiAkKHRoaXMuX2VsZW1lbnQpLmlzKCc6dmlzaWJsZScpICYmICQodGhpcy5fZWxlbWVudCkuY3NzKCd2aXNpYmlsaXR5JykgIT09ICdoaWRkZW4nKSB7XFxuICAgICAgICB0aGlzLm5leHQoKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5wcmV2ID0gZnVuY3Rpb24gcHJldigpIHtcXG4gICAgICBpZiAoIXRoaXMuX2lzU2xpZGluZykge1xcbiAgICAgICAgdGhpcy5fc2xpZGUoRGlyZWN0aW9uLlBSRVYpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoZXZlbnQpIHtcXG4gICAgICBpZiAoIWV2ZW50KSB7XFxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IkMi5ORVhUX1BSRVYpKSB7XFxuICAgICAgICBVdGlsLnRyaWdnZXJUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQpO1xcbiAgICAgICAgdGhpcy5jeWNsZSh0cnVlKTtcXG4gICAgICB9XFxuXFxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XFxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uY3ljbGUgPSBmdW5jdGlvbiBjeWNsZShldmVudCkge1xcbiAgICAgIGlmICghZXZlbnQpIHtcXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XFxuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaW50ZXJ2YWwgJiYgIXRoaXMuX2lzUGF1c2VkKSB7XFxuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPyB0aGlzLm5leHRXaGVuVmlzaWJsZSA6IHRoaXMubmV4dCkuYmluZCh0aGlzKSwgdGhpcy5fY29uZmlnLmludGVydmFsKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIF9wcm90by50byA9IGZ1bmN0aW9uIHRvKGluZGV4KSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yJDIuQUNUSVZFX0lURU0pO1xcblxcbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtcXG5cXG4gICAgICBpZiAoaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGggLSAxIHx8IGluZGV4IDwgMCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XFxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShFdmVudCQyLlNMSUQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIF90aGlzLnRvKGluZGV4KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XFxuICAgICAgICB0aGlzLnBhdXNlKCk7XFxuICAgICAgICB0aGlzLmN5Y2xlKCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBpbmRleCA+IGFjdGl2ZUluZGV4ID8gRGlyZWN0aW9uLk5FWFQgOiBEaXJlY3Rpb24uUFJFVjtcXG5cXG4gICAgICB0aGlzLl9zbGlkZShkaXJlY3Rpb24sIHRoaXMuX2l0ZW1zW2luZGV4XSk7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9LRVkkMik7XFxuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZJDIpO1xcbiAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcXG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcXG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IG51bGw7XFxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gbnVsbDtcXG4gICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbDtcXG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IG51bGw7XFxuICAgIH0gLy8gUHJpdmF0ZVxcbiAgICA7XFxuXFxuICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgICBjb25maWcgPSBfb2JqZWN0U3ByZWFkMih7fSwgRGVmYXVsdCwge30sIGNvbmZpZyk7XFxuICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSQyLCBjb25maWcsIERlZmF1bHRUeXBlKTtcXG4gICAgICByZXR1cm4gY29uZmlnO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2hhbmRsZVN3aXBlID0gZnVuY3Rpb24gX2hhbmRsZVN3aXBlKCkge1xcbiAgICAgIHZhciBhYnNEZWx0YXggPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGFYKTtcXG5cXG4gICAgICBpZiAoYWJzRGVsdGF4IDw9IFNXSVBFX1RIUkVTSE9MRCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZGlyZWN0aW9uID0gYWJzRGVsdGF4IC8gdGhpcy50b3VjaERlbHRhWDtcXG4gICAgICB0aGlzLnRvdWNoRGVsdGFYID0gMDsgLy8gc3dpcGUgbGVmdFxcblxcbiAgICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XFxuICAgICAgICB0aGlzLnByZXYoKTtcXG4gICAgICB9IC8vIHN3aXBlIHJpZ2h0XFxuXFxuXFxuICAgICAgaWYgKGRpcmVjdGlvbiA8IDApIHtcXG4gICAgICAgIHRoaXMubmV4dCgpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRFdmVudExpc3RlbmVycygpIHtcXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XFxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50JDIuS0VZRE9XTiwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgIHJldHVybiBfdGhpczIuX2tleWRvd24oZXZlbnQpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcXG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQkMi5NT1VTRUVOVEVSLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5wYXVzZShldmVudCk7XFxuICAgICAgICB9KS5vbihFdmVudCQyLk1PVVNFTEVBVkUsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmN5Y2xlKGV2ZW50KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnRvdWNoKSB7XFxuICAgICAgICB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkVG91Y2hFdmVudExpc3RlbmVycygpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICBpZiAoIXRoaXMuX3RvdWNoU3VwcG9ydGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBzdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KGV2ZW50KSB7XFxuICAgICAgICBpZiAoX3RoaXMzLl9wb2ludGVyRXZlbnQgJiYgUG9pbnRlclR5cGVbZXZlbnQub3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZS50b1VwcGVyQ2FzZSgpXSkge1xcbiAgICAgICAgICBfdGhpczMudG91Y2hTdGFydFggPSBldmVudC5vcmlnaW5hbEV2ZW50LmNsaWVudFg7XFxuICAgICAgICB9IGVsc2UgaWYgKCFfdGhpczMuX3BvaW50ZXJFdmVudCkge1xcbiAgICAgICAgICBfdGhpczMudG91Y2hTdGFydFggPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIHZhciBtb3ZlID0gZnVuY3Rpb24gbW92ZShldmVudCkge1xcbiAgICAgICAgLy8gZW5zdXJlIHN3aXBpbmcgd2l0aCBvbmUgdG91Y2ggYW5kIG5vdCBwaW5jaGluZ1xcbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICBfdGhpczMudG91Y2hEZWx0YVggPSAwO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgX3RoaXMzLnRvdWNoRGVsdGFYID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdLmNsaWVudFggLSBfdGhpczMudG91Y2hTdGFydFg7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICB2YXIgZW5kID0gZnVuY3Rpb24gZW5kKGV2ZW50KSB7XFxuICAgICAgICBpZiAoX3RoaXMzLl9wb2ludGVyRXZlbnQgJiYgUG9pbnRlclR5cGVbZXZlbnQub3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZS50b1VwcGVyQ2FzZSgpXSkge1xcbiAgICAgICAgICBfdGhpczMudG91Y2hEZWx0YVggPSBldmVudC5vcmlnaW5hbEV2ZW50LmNsaWVudFggLSBfdGhpczMudG91Y2hTdGFydFg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBfdGhpczMuX2hhbmRsZVN3aXBlKCk7XFxuXFxuICAgICAgICBpZiAoX3RoaXMzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcXG4gICAgICAgICAgLy8gSWYgaXQncyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlLCBtb3VzZWVudGVyL2xlYXZlIGFyZSBmaXJlZCBhc1xcbiAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcXG4gICAgICAgICAgLy8gd291bGQgc3RvcCBjeWNsaW5nIHVudGlsIHVzZXIgdGFwcGVkIG91dCBvZiBpdDtcXG4gICAgICAgICAgLy8gaGVyZSwgd2UgbGlzdGVuIGZvciB0b3VjaGVuZCwgZXhwbGljaXRseSBwYXVzZSB0aGUgY2Fyb3VzZWxcXG4gICAgICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcXG4gICAgICAgICAgLy8gaXMgTk9UIGZpcmVkKSBhbmQgYWZ0ZXIgYSB0aW1lb3V0ICh0byBhbGxvdyBmb3IgbW91c2UgY29tcGF0aWJpbGl0eVxcbiAgICAgICAgICAvLyBldmVudHMgdG8gZmlyZSkgd2UgZXhwbGljaXRseSByZXN0YXJ0IGN5Y2xpbmdcXG4gICAgICAgICAgX3RoaXMzLnBhdXNlKCk7XFxuXFxuICAgICAgICAgIGlmIChfdGhpczMudG91Y2hUaW1lb3V0KSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzMy50b3VjaFRpbWVvdXQpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIF90aGlzMy50b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuY3ljbGUoZXZlbnQpO1xcbiAgICAgICAgICB9LCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUICsgX3RoaXMzLl9jb25maWcuaW50ZXJ2YWwpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgJCh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IkMi5JVEVNX0lNRykpLm9uKEV2ZW50JDIuRFJBR19TVEFSVCwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCkge1xcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudCQyLlBPSU5URVJET1dOLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgcmV0dXJuIHN0YXJ0KGV2ZW50KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudCQyLlBPSU5URVJVUCwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgIHJldHVybiBlbmQoZXZlbnQpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ2xhc3NOYW1lJDIuUE9JTlRFUl9FVkVOVCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQkMi5UT1VDSFNUQVJULCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgcmV0dXJuIHN0YXJ0KGV2ZW50KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudCQyLlRPVUNITU9WRSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgIHJldHVybiBtb3ZlKGV2ZW50KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudCQyLlRPVUNIRU5ELCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgcmV0dXJuIGVuZChldmVudCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fa2V5ZG93biA9IGZ1bmN0aW9uIF9rZXlkb3duKGV2ZW50KSB7XFxuICAgICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHN3aXRjaCAoZXZlbnQud2hpY2gpIHtcXG4gICAgICAgIGNhc2UgQVJST1dfTEVGVF9LRVlDT0RFOlxcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB0aGlzLnByZXYoKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIEFSUk9XX1JJR0hUX0tFWUNPREU6XFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIHRoaXMubmV4dCgpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fZ2V0SXRlbUluZGV4ID0gZnVuY3Rpb24gX2dldEl0ZW1JbmRleChlbGVtZW50KSB7XFxuICAgICAgdGhpcy5faXRlbXMgPSBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZSA/IFtdLnNsaWNlLmNhbGwoZWxlbWVudC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IkMi5JVEVNKSkgOiBbXTtcXG4gICAgICByZXR1cm4gdGhpcy5faXRlbXMuaW5kZXhPZihlbGVtZW50KTtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9nZXRJdGVtQnlEaXJlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0SXRlbUJ5RGlyZWN0aW9uKGRpcmVjdGlvbiwgYWN0aXZlRWxlbWVudCkge1xcbiAgICAgIHZhciBpc05leHREaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5ORVhUO1xcbiAgICAgIHZhciBpc1ByZXZEaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5QUkVWO1xcblxcbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KTtcXG5cXG4gICAgICB2YXIgbGFzdEl0ZW1JbmRleCA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XFxuICAgICAgdmFyIGlzR29pbmdUb1dyYXAgPSBpc1ByZXZEaXJlY3Rpb24gJiYgYWN0aXZlSW5kZXggPT09IDAgfHwgaXNOZXh0RGlyZWN0aW9uICYmIGFjdGl2ZUluZGV4ID09PSBsYXN0SXRlbUluZGV4O1xcblxcbiAgICAgIGlmIChpc0dvaW5nVG9XcmFwICYmICF0aGlzLl9jb25maWcud3JhcCkge1xcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkZWx0YSA9IGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlBSRVYgPyAtMSA6IDE7XFxuICAgICAgdmFyIGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuX2l0ZW1zLmxlbmd0aDtcXG4gICAgICByZXR1cm4gaXRlbUluZGV4ID09PSAtMSA/IHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdIDogdGhpcy5faXRlbXNbaXRlbUluZGV4XTtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl90cmlnZ2VyU2xpZGVFdmVudCA9IGZ1bmN0aW9uIF90cmlnZ2VyU2xpZGVFdmVudChyZWxhdGVkVGFyZ2V0LCBldmVudERpcmVjdGlvbk5hbWUpIHtcXG4gICAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgocmVsYXRlZFRhcmdldCk7XFxuXFxuICAgICAgdmFyIGZyb21JbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IkMi5BQ1RJVkVfSVRFTSkpO1xcblxcbiAgICAgIHZhciBzbGlkZUV2ZW50ID0gJC5FdmVudChFdmVudCQyLlNMSURFLCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxcbiAgICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXFxuICAgICAgICBmcm9tOiBmcm9tSW5kZXgsXFxuICAgICAgICB0bzogdGFyZ2V0SW5kZXhcXG4gICAgICB9KTtcXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZGVFdmVudCk7XFxuICAgICAgcmV0dXJuIHNsaWRlRXZlbnQ7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCA9IGZ1bmN0aW9uIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KGVsZW1lbnQpIHtcXG4gICAgICBpZiAodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcXG4gICAgICAgIHZhciBpbmRpY2F0b3JzID0gW10uc2xpY2UuY2FsbCh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yJDIuQUNUSVZFKSk7XFxuICAgICAgICAkKGluZGljYXRvcnMpLnJlbW92ZUNsYXNzKENsYXNzTmFtZSQyLkFDVElWRSk7XFxuXFxuICAgICAgICB2YXIgbmV4dEluZGljYXRvciA9IHRoaXMuX2luZGljYXRvcnNFbGVtZW50LmNoaWxkcmVuW3RoaXMuX2dldEl0ZW1JbmRleChlbGVtZW50KV07XFxuXFxuICAgICAgICBpZiAobmV4dEluZGljYXRvcikge1xcbiAgICAgICAgICAkKG5leHRJbmRpY2F0b3IpLmFkZENsYXNzKENsYXNzTmFtZSQyLkFDVElWRSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX3NsaWRlID0gZnVuY3Rpb24gX3NsaWRlKGRpcmVjdGlvbiwgZWxlbWVudCkge1xcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xcblxcbiAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yJDIuQUNUSVZFX0lURU0pO1xcblxcbiAgICAgIHZhciBhY3RpdmVFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCk7XFxuXFxuICAgICAgdmFyIG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBhY3RpdmVFbGVtZW50ICYmIHRoaXMuX2dldEl0ZW1CeURpcmVjdGlvbihkaXJlY3Rpb24sIGFjdGl2ZUVsZW1lbnQpO1xcblxcbiAgICAgIHZhciBuZXh0RWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KG5leHRFbGVtZW50KTtcXG5cXG4gICAgICB2YXIgaXNDeWNsaW5nID0gQm9vbGVhbih0aGlzLl9pbnRlcnZhbCk7XFxuICAgICAgdmFyIGRpcmVjdGlvbmFsQ2xhc3NOYW1lO1xcbiAgICAgIHZhciBvcmRlckNsYXNzTmFtZTtcXG4gICAgICB2YXIgZXZlbnREaXJlY3Rpb25OYW1lO1xcblxcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5ORVhUKSB7XFxuICAgICAgICBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IENsYXNzTmFtZSQyLkxFRlQ7XFxuICAgICAgICBvcmRlckNsYXNzTmFtZSA9IENsYXNzTmFtZSQyLk5FWFQ7XFxuICAgICAgICBldmVudERpcmVjdGlvbk5hbWUgPSBEaXJlY3Rpb24uTEVGVDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSBDbGFzc05hbWUkMi5SSUdIVDtcXG4gICAgICAgIG9yZGVyQ2xhc3NOYW1lID0gQ2xhc3NOYW1lJDIuUFJFVjtcXG4gICAgICAgIGV2ZW50RGlyZWN0aW9uTmFtZSA9IERpcmVjdGlvbi5SSUdIVDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG5leHRFbGVtZW50ICYmICQobmV4dEVsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZSQyLkFDVElWRSkpIHtcXG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgc2xpZGVFdmVudCA9IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KG5leHRFbGVtZW50LCBldmVudERpcmVjdGlvbk5hbWUpO1xcblxcbiAgICAgIGlmIChzbGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcXG4gICAgICAgIC8vIFNvbWUgd2VpcmRuZXNzIGlzIGhhcHBlbmluZywgc28gd2UgYmFpbFxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlO1xcblxcbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcXG4gICAgICAgIHRoaXMucGF1c2UoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChuZXh0RWxlbWVudCk7XFxuXFxuICAgICAgdmFyIHNsaWRFdmVudCA9ICQuRXZlbnQoRXZlbnQkMi5TTElELCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcXG4gICAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxcbiAgICAgICAgZnJvbTogYWN0aXZlRWxlbWVudEluZGV4LFxcbiAgICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUkMi5TTElERSkpIHtcXG4gICAgICAgICQobmV4dEVsZW1lbnQpLmFkZENsYXNzKG9yZGVyQ2xhc3NOYW1lKTtcXG4gICAgICAgIFV0aWwucmVmbG93KG5leHRFbGVtZW50KTtcXG4gICAgICAgICQoYWN0aXZlRWxlbWVudCkuYWRkQ2xhc3MoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xcbiAgICAgICAgJChuZXh0RWxlbWVudCkuYWRkQ2xhc3MoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xcbiAgICAgICAgdmFyIG5leHRFbGVtZW50SW50ZXJ2YWwgPSBwYXJzZUludChuZXh0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW50ZXJ2YWwnKSwgMTApO1xcblxcbiAgICAgICAgaWYgKG5leHRFbGVtZW50SW50ZXJ2YWwpIHtcXG4gICAgICAgICAgdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsO1xcbiAgICAgICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBuZXh0RWxlbWVudEludGVydmFsO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChhY3RpdmVFbGVtZW50KTtcXG4gICAgICAgICQoYWN0aXZlRWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgJChuZXh0RWxlbWVudCkucmVtb3ZlQ2xhc3MoZGlyZWN0aW9uYWxDbGFzc05hbWUgKyBcXFwiIFxcXCIgKyBvcmRlckNsYXNzTmFtZSkuYWRkQ2xhc3MoQ2xhc3NOYW1lJDIuQUNUSVZFKTtcXG4gICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkMi5BQ1RJVkUgKyBcXFwiIFxcXCIgKyBvcmRlckNsYXNzTmFtZSArIFxcXCIgXFxcIiArIGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcXG4gICAgICAgICAgX3RoaXM0Ll9pc1NsaWRpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuICQoX3RoaXM0Ll9lbGVtZW50KS50cmlnZ2VyKHNsaWRFdmVudCk7XFxuICAgICAgICAgIH0sIDApO1xcbiAgICAgICAgfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkMi5BQ1RJVkUpO1xcbiAgICAgICAgJChuZXh0RWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lJDIuQUNUSVZFKTtcXG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNsaWRFdmVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcXG4gICAgICAgIHRoaXMuY3ljbGUoKTtcXG4gICAgICB9XFxuICAgIH0gLy8gU3RhdGljXFxuICAgIDtcXG5cXG4gICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSQyKTtcXG5cXG4gICAgICAgIHZhciBfY29uZmlnID0gX29iamVjdFNwcmVhZDIoe30sIERlZmF1bHQsIHt9LCAkKHRoaXMpLmRhdGEoKSk7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgICAgX2NvbmZpZyA9IF9vYmplY3RTcHJlYWQyKHt9LCBfY29uZmlnLCB7fSwgY29uZmlnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBhY3Rpb24gPSB0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyA/IGNvbmZpZyA6IF9jb25maWcuc2xpZGU7XFxuXFxuICAgICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgICAgZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBfY29uZmlnKTtcXG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZJDIsIGRhdGEpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XFxuICAgICAgICAgIGRhdGEudG8oY29uZmlnKTtcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2FjdGlvbl0gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiTm8gbWV0aG9kIG5hbWVkIFxcXFxcXFwiXFxcIiArIGFjdGlvbiArIFxcXCJcXFxcXFxcIlxcXCIpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGRhdGFbYWN0aW9uXSgpO1xcbiAgICAgICAgfSBlbHNlIGlmIChfY29uZmlnLmludGVydmFsICYmIF9jb25maWcucmlkZSkge1xcbiAgICAgICAgICBkYXRhLnBhdXNlKCk7XFxuICAgICAgICAgIGRhdGEuY3ljbGUoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgQ2Fyb3VzZWwuX2RhdGFBcGlDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiBfZGF0YUFwaUNsaWNrSGFuZGxlcihldmVudCkge1xcbiAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcXG5cXG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0YXJnZXQgPSAkKHNlbGVjdG9yKVswXTtcXG5cXG4gICAgICBpZiAoIXRhcmdldCB8fCAhJCh0YXJnZXQpLmhhc0NsYXNzKENsYXNzTmFtZSQyLkNBUk9VU0VMKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgY29uZmlnID0gX29iamVjdFNwcmVhZDIoe30sICQodGFyZ2V0KS5kYXRhKCksIHt9LCAkKHRoaXMpLmRhdGEoKSk7XFxuXFxuICAgICAgdmFyIHNsaWRlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGlkZS10bycpO1xcblxcbiAgICAgIGlmIChzbGlkZUluZGV4KSB7XFxuICAgICAgICBjb25maWcuaW50ZXJ2YWwgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnKTtcXG5cXG4gICAgICBpZiAoc2xpZGVJbmRleCkge1xcbiAgICAgICAgJCh0YXJnZXQpLmRhdGEoREFUQV9LRVkkMikudG8oc2xpZGVJbmRleCk7XFxuICAgICAgfVxcblxcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH07XFxuXFxuICAgIF9jcmVhdGVDbGFzcyhDYXJvdXNlbCwgbnVsbCwgW3tcXG4gICAgICBrZXk6IFxcXCJWRVJTSU9OXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBWRVJTSU9OJDI7XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiRGVmYXVsdFxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gRGVmYXVsdDtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIENhcm91c2VsO1xcbiAgfSgpO1xcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcblxcbiAgJChkb2N1bWVudCkub24oRXZlbnQkMi5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IkMi5EQVRBX1NMSURFLCBDYXJvdXNlbC5fZGF0YUFwaUNsaWNrSGFuZGxlcik7XFxuICAkKHdpbmRvdykub24oRXZlbnQkMi5MT0FEX0RBVEFfQVBJLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBjYXJvdXNlbHMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IkMi5EQVRBX1JJREUpKTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhcm91c2Vscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIHZhciAkY2Fyb3VzZWwgPSAkKGNhcm91c2Vsc1tpXSk7XFxuXFxuICAgICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCRjYXJvdXNlbCwgJGNhcm91c2VsLmRhdGEoKSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIGpRdWVyeVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gICQuZm5bTkFNRSQyXSA9IENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2U7XFxuICAkLmZuW05BTUUkMl0uQ29uc3RydWN0b3IgPSBDYXJvdXNlbDtcXG5cXG4gICQuZm5bTkFNRSQyXS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAkLmZuW05BTUUkMl0gPSBKUVVFUllfTk9fQ09ORkxJQ1QkMjtcXG4gICAgcmV0dXJuIENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2U7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIENvbnN0YW50c1xcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gIHZhciBOQU1FJDMgPSAnY29sbGFwc2UnO1xcbiAgdmFyIFZFUlNJT04kMyA9ICc0LjQuMSc7XFxuICB2YXIgREFUQV9LRVkkMyA9ICdicy5jb2xsYXBzZSc7XFxuICB2YXIgRVZFTlRfS0VZJDMgPSBcXFwiLlxcXCIgKyBEQVRBX0tFWSQzO1xcbiAgdmFyIERBVEFfQVBJX0tFWSQzID0gJy5kYXRhLWFwaSc7XFxuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUJDMgPSAkLmZuW05BTUUkM107XFxuICB2YXIgRGVmYXVsdCQxID0ge1xcbiAgICB0b2dnbGU6IHRydWUsXFxuICAgIHBhcmVudDogJydcXG4gIH07XFxuICB2YXIgRGVmYXVsdFR5cGUkMSA9IHtcXG4gICAgdG9nZ2xlOiAnYm9vbGVhbicsXFxuICAgIHBhcmVudDogJyhzdHJpbmd8ZWxlbWVudCknXFxuICB9O1xcbiAgdmFyIEV2ZW50JDMgPSB7XFxuICAgIFNIT1c6IFxcXCJzaG93XFxcIiArIEVWRU5UX0tFWSQzLFxcbiAgICBTSE9XTjogXFxcInNob3duXFxcIiArIEVWRU5UX0tFWSQzLFxcbiAgICBISURFOiBcXFwiaGlkZVxcXCIgKyBFVkVOVF9LRVkkMyxcXG4gICAgSElEREVOOiBcXFwiaGlkZGVuXFxcIiArIEVWRU5UX0tFWSQzLFxcbiAgICBDTElDS19EQVRBX0FQSTogXFxcImNsaWNrXFxcIiArIEVWRU5UX0tFWSQzICsgREFUQV9BUElfS0VZJDNcXG4gIH07XFxuICB2YXIgQ2xhc3NOYW1lJDMgPSB7XFxuICAgIFNIT1c6ICdzaG93JyxcXG4gICAgQ09MTEFQU0U6ICdjb2xsYXBzZScsXFxuICAgIENPTExBUFNJTkc6ICdjb2xsYXBzaW5nJyxcXG4gICAgQ09MTEFQU0VEOiAnY29sbGFwc2VkJ1xcbiAgfTtcXG4gIHZhciBEaW1lbnNpb24gPSB7XFxuICAgIFdJRFRIOiAnd2lkdGgnLFxcbiAgICBIRUlHSFQ6ICdoZWlnaHQnXFxuICB9O1xcbiAgdmFyIFNlbGVjdG9yJDMgPSB7XFxuICAgIEFDVElWRVM6ICcuc2hvdywgLmNvbGxhcHNpbmcnLFxcbiAgICBEQVRBX1RPR0dMRTogJ1tkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXSdcXG4gIH07XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQ2xhc3MgRGVmaW5pdGlvblxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gIHZhciBDb2xsYXBzZSA9XFxuICAvKiNfX1BVUkVfXyovXFxuICBmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIENvbGxhcHNlKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xcbiAgICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcXFwiW2RhdGEtdG9nZ2xlPVxcXFxcXFwiY29sbGFwc2VcXFxcXFxcIl1baHJlZj1cXFxcXFxcIiNcXFwiICsgZWxlbWVudC5pZCArIFxcXCJcXFxcXFxcIl0sXFxcIiArIChcXFwiW2RhdGEtdG9nZ2xlPVxcXFxcXFwiY29sbGFwc2VcXFxcXFxcIl1bZGF0YS10YXJnZXQ9XFxcXFxcXCIjXFxcIiArIGVsZW1lbnQuaWQgKyBcXFwiXFxcXFxcXCJdXFxcIikpKTtcXG4gICAgICB2YXIgdG9nZ2xlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvciQzLkRBVEFfVE9HR0xFKSk7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvZ2dsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIHZhciBlbGVtID0gdG9nZ2xlTGlzdFtpXTtcXG4gICAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtKTtcXG4gICAgICAgIHZhciBmaWx0ZXJFbGVtZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkuZmlsdGVyKGZ1bmN0aW9uIChmb3VuZEVsZW0pIHtcXG4gICAgICAgICAgcmV0dXJuIGZvdW5kRWxlbSA9PT0gZWxlbWVudDtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmIGZpbHRlckVsZW1lbnQubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xcblxcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyQXJyYXkucHVzaChlbGVtKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fY29uZmlnLnBhcmVudCA/IHRoaXMuX2dldFBhcmVudCgpIDogbnVsbDtcXG5cXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcXG4gICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl90cmlnZ2VyQXJyYXkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnRvZ2dsZSkge1xcbiAgICAgICAgdGhpcy50b2dnbGUoKTtcXG4gICAgICB9XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICB2YXIgX3Byb3RvID0gQ29sbGFwc2UucHJvdG90eXBlO1xcblxcbiAgICAvLyBQdWJsaWNcXG4gICAgX3Byb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUkMy5TSE9XKSkge1xcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuc2hvdygpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZSQzLlNIT1cpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBhY3RpdmVzO1xcbiAgICAgIHZhciBhY3RpdmVzRGF0YTtcXG5cXG4gICAgICBpZiAodGhpcy5fcGFyZW50KSB7XFxuICAgICAgICBhY3RpdmVzID0gW10uc2xpY2UuY2FsbCh0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvciQzLkFDVElWRVMpKS5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHtcXG4gICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5fY29uZmlnLnBhcmVudCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFyZW50JykgPT09IF90aGlzLl9jb25maWcucGFyZW50O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUkMy5DT0xMQVBTRSk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICBhY3RpdmVzID0gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGFjdGl2ZXMpIHtcXG4gICAgICAgIGFjdGl2ZXNEYXRhID0gJChhY3RpdmVzKS5ub3QodGhpcy5fc2VsZWN0b3IpLmRhdGEoREFUQV9LRVkkMyk7XFxuXFxuICAgICAgICBpZiAoYWN0aXZlc0RhdGEgJiYgYWN0aXZlc0RhdGEuX2lzVHJhbnNpdGlvbmluZykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudChFdmVudCQzLlNIT1cpO1xcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KTtcXG5cXG4gICAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYWN0aXZlcykge1xcbiAgICAgICAgQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQoYWN0aXZlcykubm90KHRoaXMuX3NlbGVjdG9yKSwgJ2hpZGUnKTtcXG5cXG4gICAgICAgIGlmICghYWN0aXZlc0RhdGEpIHtcXG4gICAgICAgICAgJChhY3RpdmVzKS5kYXRhKERBVEFfS0VZJDMsIG51bGwpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XFxuXFxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkMy5DT0xMQVBTRSkuYWRkQ2xhc3MoQ2xhc3NOYW1lJDMuQ09MTEFQU0lORyk7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gMDtcXG5cXG4gICAgICBpZiAodGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xcbiAgICAgICAgJCh0aGlzLl90cmlnZ2VyQXJyYXkpLnJlbW92ZUNsYXNzKENsYXNzTmFtZSQzLkNPTExBUFNFRCkuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcodHJ1ZSk7XFxuXFxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XFxuICAgICAgICAkKF90aGlzLl9lbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkMy5DT0xMQVBTSU5HKS5hZGRDbGFzcyhDbGFzc05hbWUkMy5DT0xMQVBTRSkuYWRkQ2xhc3MoQ2xhc3NOYW1lJDMuU0hPVyk7XFxuICAgICAgICBfdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XFxuXFxuICAgICAgICBfdGhpcy5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKTtcXG5cXG4gICAgICAgICQoX3RoaXMuX2VsZW1lbnQpLnRyaWdnZXIoRXZlbnQkMy5TSE9XTik7XFxuICAgICAgfTtcXG5cXG4gICAgICB2YXIgY2FwaXRhbGl6ZWREaW1lbnNpb24gPSBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcXG4gICAgICB2YXIgc2Nyb2xsU2l6ZSA9IFxcXCJzY3JvbGxcXFwiICsgY2FwaXRhbGl6ZWREaW1lbnNpb247XFxuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XFxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gdGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXSArIFxcXCJweFxcXCI7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICEkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZSQzLlNIT1cpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudChFdmVudCQzLkhJREUpO1xcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KTtcXG5cXG4gICAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkaW1lbnNpb25dICsgXFxcInB4XFxcIjtcXG4gICAgICBVdGlsLnJlZmxvdyh0aGlzLl9lbGVtZW50KTtcXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLmFkZENsYXNzKENsYXNzTmFtZSQzLkNPTExBUFNJTkcpLnJlbW92ZUNsYXNzKENsYXNzTmFtZSQzLkNPTExBUFNFKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkMy5TSE9XKTtcXG4gICAgICB2YXIgdHJpZ2dlckFycmF5TGVuZ3RoID0gdGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aDtcXG5cXG4gICAgICBpZiAodHJpZ2dlckFycmF5TGVuZ3RoID4gMCkge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlnZ2VyQXJyYXlMZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJBcnJheVtpXTtcXG4gICAgICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRyaWdnZXIpO1xcblxcbiAgICAgICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwpIHtcXG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpKTtcXG5cXG4gICAgICAgICAgICBpZiAoISRlbGVtLmhhc0NsYXNzKENsYXNzTmFtZSQzLlNIT1cpKSB7XFxuICAgICAgICAgICAgICAkKHRyaWdnZXIpLmFkZENsYXNzKENsYXNzTmFtZSQzLkNPTExBUFNFRCkuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpO1xcblxcbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xcbiAgICAgICAgX3RoaXMyLnNldFRyYW5zaXRpb25pbmcoZmFsc2UpO1xcblxcbiAgICAgICAgJChfdGhpczIuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZSQzLkNPTExBUFNJTkcpLmFkZENsYXNzKENsYXNzTmFtZSQzLkNPTExBUFNFKS50cmlnZ2VyKEV2ZW50JDMuSElEREVOKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xcbiAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xcbiAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uc2V0VHJhbnNpdGlvbmluZyA9IGZ1bmN0aW9uIHNldFRyYW5zaXRpb25pbmcoaXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gaXNUcmFuc2l0aW9uaW5nO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XFxuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZJDMpO1xcbiAgICAgIHRoaXMuX2NvbmZpZyA9IG51bGw7XFxuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcXG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcXG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBudWxsO1xcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IG51bGw7XFxuICAgIH0gLy8gUHJpdmF0ZVxcbiAgICA7XFxuXFxuICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgICBjb25maWcgPSBfb2JqZWN0U3ByZWFkMih7fSwgRGVmYXVsdCQxLCB7fSwgY29uZmlnKTtcXG4gICAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKTsgLy8gQ29lcmNlIHN0cmluZyB2YWx1ZXNcXG5cXG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FJDMsIGNvbmZpZywgRGVmYXVsdFR5cGUkMSk7XFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBfZ2V0RGltZW5zaW9uKCkge1xcbiAgICAgIHZhciBoYXNXaWR0aCA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoRGltZW5zaW9uLldJRFRIKTtcXG4gICAgICByZXR1cm4gaGFzV2lkdGggPyBEaW1lbnNpb24uV0lEVEggOiBEaW1lbnNpb24uSEVJR0hUO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2dldFBhcmVudCA9IGZ1bmN0aW9uIF9nZXRQYXJlbnQoKSB7XFxuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgdmFyIHBhcmVudDtcXG5cXG4gICAgICBpZiAoVXRpbC5pc0VsZW1lbnQodGhpcy5fY29uZmlnLnBhcmVudCkpIHtcXG4gICAgICAgIHBhcmVudCA9IHRoaXMuX2NvbmZpZy5wYXJlbnQ7IC8vIEl0J3MgYSBqUXVlcnkgb2JqZWN0XFxuXFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5wYXJlbnQuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50WzBdO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBwYXJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuX2NvbmZpZy5wYXJlbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgc2VsZWN0b3IgPSBcXFwiW2RhdGEtdG9nZ2xlPVxcXFxcXFwiY29sbGFwc2VcXFxcXFxcIl1bZGF0YS1wYXJlbnQ9XFxcXFxcXCJcXFwiICsgdGhpcy5fY29uZmlnLnBhcmVudCArIFxcXCJcXFxcXFxcIl1cXFwiO1xcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdLnNsaWNlLmNhbGwocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcXG4gICAgICAkKGNoaWxkcmVuKS5lYWNoKGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XFxuICAgICAgICBfdGhpczMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhDb2xsYXBzZS5fZ2V0VGFyZ2V0RnJvbUVsZW1lbnQoZWxlbWVudCksIFtlbGVtZW50XSk7XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIHBhcmVudDtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MgPSBmdW5jdGlvbiBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGVsZW1lbnQsIHRyaWdnZXJBcnJheSkge1xcbiAgICAgIHZhciBpc09wZW4gPSAkKGVsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZSQzLlNIT1cpO1xcblxcbiAgICAgIGlmICh0cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XFxuICAgICAgICAkKHRyaWdnZXJBcnJheSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lJDMuQ09MTEFQU0VELCAhaXNPcGVuKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcXG4gICAgICB9XFxuICAgIH0gLy8gU3RhdGljXFxuICAgIDtcXG5cXG4gICAgQ29sbGFwc2UuX2dldFRhcmdldEZyb21FbGVtZW50ID0gZnVuY3Rpb24gX2dldFRhcmdldEZyb21FbGVtZW50KGVsZW1lbnQpIHtcXG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XFxuICAgICAgcmV0dXJuIHNlbGVjdG9yID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBudWxsO1xcbiAgICB9O1xcblxcbiAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XFxuICAgICAgICB2YXIgZGF0YSA9ICR0aGlzLmRhdGEoREFUQV9LRVkkMyk7XFxuXFxuICAgICAgICB2YXIgX2NvbmZpZyA9IF9vYmplY3RTcHJlYWQyKHt9LCBEZWZhdWx0JDEsIHt9LCAkdGhpcy5kYXRhKCksIHt9LCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSk7XFxuXFxuICAgICAgICBpZiAoIWRhdGEgJiYgX2NvbmZpZy50b2dnbGUgJiYgL3Nob3d8aGlkZS8udGVzdChjb25maWcpKSB7XFxuICAgICAgICAgIF9jb25maWcudG9nZ2xlID0gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgICAgZGF0YSA9IG5ldyBDb2xsYXBzZSh0aGlzLCBfY29uZmlnKTtcXG4gICAgICAgICAgJHRoaXMuZGF0YShEQVRBX0tFWSQzLCBkYXRhKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJObyBtZXRob2QgbmFtZWQgXFxcXFxcXCJcXFwiICsgY29uZmlnICsgXFxcIlxcXFxcXFwiXFxcIik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIF9jcmVhdGVDbGFzcyhDb2xsYXBzZSwgbnVsbCwgW3tcXG4gICAgICBrZXk6IFxcXCJWRVJTSU9OXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBWRVJTSU9OJDM7XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiRGVmYXVsdFxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gRGVmYXVsdCQxO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gQ29sbGFwc2U7XFxuICB9KCk7XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuXFxuICAkKGRvY3VtZW50KS5vbihFdmVudCQzLkNMSUNLX0RBVEFfQVBJLCBTZWxlY3RvciQzLkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgLy8gcHJldmVudERlZmF1bHQgb25seSBmb3IgPGE+IGVsZW1lbnRzICh3aGljaCBjaGFuZ2UgdGhlIFVSTCkgbm90IGluc2lkZSB0aGUgY29sbGFwc2libGUgZWxlbWVudFxcbiAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldC50YWdOYW1lID09PSAnQScpIHtcXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB9XFxuXFxuICAgIHZhciAkdHJpZ2dlciA9ICQodGhpcyk7XFxuICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcXG4gICAgdmFyIHNlbGVjdG9ycyA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xcbiAgICAkKHNlbGVjdG9ycykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyICR0YXJnZXQgPSAkKHRoaXMpO1xcbiAgICAgIHZhciBkYXRhID0gJHRhcmdldC5kYXRhKERBVEFfS0VZJDMpO1xcbiAgICAgIHZhciBjb25maWcgPSBkYXRhID8gJ3RvZ2dsZScgOiAkdHJpZ2dlci5kYXRhKCk7XFxuXFxuICAgICAgQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZS5jYWxsKCR0YXJnZXQsIGNvbmZpZyk7XFxuICAgIH0pO1xcbiAgfSk7XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogalF1ZXJ5XFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgJC5mbltOQU1FJDNdID0gQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZTtcXG4gICQuZm5bTkFNRSQzXS5Db25zdHJ1Y3RvciA9IENvbGxhcHNlO1xcblxcbiAgJC5mbltOQU1FJDNdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XFxuICAgICQuZm5bTkFNRSQzXSA9IEpRVUVSWV9OT19DT05GTElDVCQzO1xcbiAgICByZXR1cm4gQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZTtcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQ29uc3RhbnRzXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgdmFyIE5BTUUkNCA9ICdkcm9wZG93bic7XFxuICB2YXIgVkVSU0lPTiQ0ID0gJzQuNC4xJztcXG4gIHZhciBEQVRBX0tFWSQ0ID0gJ2JzLmRyb3Bkb3duJztcXG4gIHZhciBFVkVOVF9LRVkkNCA9IFxcXCIuXFxcIiArIERBVEFfS0VZJDQ7XFxuICB2YXIgREFUQV9BUElfS0VZJDQgPSAnLmRhdGEtYXBpJztcXG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QkNCA9ICQuZm5bTkFNRSQ0XTtcXG4gIHZhciBFU0NBUEVfS0VZQ09ERSA9IDI3OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBFc2NhcGUgKEVzYykga2V5XFxuXFxuICB2YXIgU1BBQ0VfS0VZQ09ERSA9IDMyOyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBzcGFjZSBrZXlcXG5cXG4gIHZhciBUQUJfS0VZQ09ERSA9IDk7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIHRhYiBrZXlcXG5cXG4gIHZhciBBUlJPV19VUF9LRVlDT0RFID0gMzg7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIHVwIGFycm93IGtleVxcblxcbiAgdmFyIEFSUk9XX0RPV05fS0VZQ09ERSA9IDQwOyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBkb3duIGFycm93IGtleVxcblxcbiAgdmFyIFJJR0hUX01PVVNFX0JVVFRPTl9XSElDSCA9IDM7IC8vIE1vdXNlRXZlbnQud2hpY2ggdmFsdWUgZm9yIHRoZSByaWdodCBidXR0b24gKGFzc3VtaW5nIGEgcmlnaHQtaGFuZGVkIG1vdXNlKVxcblxcbiAgdmFyIFJFR0VYUF9LRVlET1dOID0gbmV3IFJlZ0V4cChBUlJPV19VUF9LRVlDT0RFICsgXFxcInxcXFwiICsgQVJST1dfRE9XTl9LRVlDT0RFICsgXFxcInxcXFwiICsgRVNDQVBFX0tFWUNPREUpO1xcbiAgdmFyIEV2ZW50JDQgPSB7XFxuICAgIEhJREU6IFxcXCJoaWRlXFxcIiArIEVWRU5UX0tFWSQ0LFxcbiAgICBISURERU46IFxcXCJoaWRkZW5cXFwiICsgRVZFTlRfS0VZJDQsXFxuICAgIFNIT1c6IFxcXCJzaG93XFxcIiArIEVWRU5UX0tFWSQ0LFxcbiAgICBTSE9XTjogXFxcInNob3duXFxcIiArIEVWRU5UX0tFWSQ0LFxcbiAgICBDTElDSzogXFxcImNsaWNrXFxcIiArIEVWRU5UX0tFWSQ0LFxcbiAgICBDTElDS19EQVRBX0FQSTogXFxcImNsaWNrXFxcIiArIEVWRU5UX0tFWSQ0ICsgREFUQV9BUElfS0VZJDQsXFxuICAgIEtFWURPV05fREFUQV9BUEk6IFxcXCJrZXlkb3duXFxcIiArIEVWRU5UX0tFWSQ0ICsgREFUQV9BUElfS0VZJDQsXFxuICAgIEtFWVVQX0RBVEFfQVBJOiBcXFwia2V5dXBcXFwiICsgRVZFTlRfS0VZJDQgKyBEQVRBX0FQSV9LRVkkNFxcbiAgfTtcXG4gIHZhciBDbGFzc05hbWUkNCA9IHtcXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXFxuICAgIFNIT1c6ICdzaG93JyxcXG4gICAgRFJPUFVQOiAnZHJvcHVwJyxcXG4gICAgRFJPUFJJR0hUOiAnZHJvcHJpZ2h0JyxcXG4gICAgRFJPUExFRlQ6ICdkcm9wbGVmdCcsXFxuICAgIE1FTlVSSUdIVDogJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnLFxcbiAgICBNRU5VTEVGVDogJ2Ryb3Bkb3duLW1lbnUtbGVmdCcsXFxuICAgIFBPU0lUSU9OX1NUQVRJQzogJ3Bvc2l0aW9uLXN0YXRpYydcXG4gIH07XFxuICB2YXIgU2VsZWN0b3IkNCA9IHtcXG4gICAgREFUQV9UT0dHTEU6ICdbZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIl0nLFxcbiAgICBGT1JNX0NISUxEOiAnLmRyb3Bkb3duIGZvcm0nLFxcbiAgICBNRU5VOiAnLmRyb3Bkb3duLW1lbnUnLFxcbiAgICBOQVZCQVJfTkFWOiAnLm5hdmJhci1uYXYnLFxcbiAgICBWSVNJQkxFX0lURU1TOiAnLmRyb3Bkb3duLW1lbnUgLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknXFxuICB9O1xcbiAgdmFyIEF0dGFjaG1lbnRNYXAgPSB7XFxuICAgIFRPUDogJ3RvcC1zdGFydCcsXFxuICAgIFRPUEVORDogJ3RvcC1lbmQnLFxcbiAgICBCT1RUT006ICdib3R0b20tc3RhcnQnLFxcbiAgICBCT1RUT01FTkQ6ICdib3R0b20tZW5kJyxcXG4gICAgUklHSFQ6ICdyaWdodC1zdGFydCcsXFxuICAgIFJJR0hURU5EOiAncmlnaHQtZW5kJyxcXG4gICAgTEVGVDogJ2xlZnQtc3RhcnQnLFxcbiAgICBMRUZURU5EOiAnbGVmdC1lbmQnXFxuICB9O1xcbiAgdmFyIERlZmF1bHQkMiA9IHtcXG4gICAgb2Zmc2V0OiAwLFxcbiAgICBmbGlwOiB0cnVlLFxcbiAgICBib3VuZGFyeTogJ3Njcm9sbFBhcmVudCcsXFxuICAgIHJlZmVyZW5jZTogJ3RvZ2dsZScsXFxuICAgIGRpc3BsYXk6ICdkeW5hbWljJyxcXG4gICAgcG9wcGVyQ29uZmlnOiBudWxsXFxuICB9O1xcbiAgdmFyIERlZmF1bHRUeXBlJDIgPSB7XFxuICAgIG9mZnNldDogJyhudW1iZXJ8c3RyaW5nfGZ1bmN0aW9uKScsXFxuICAgIGZsaXA6ICdib29sZWFuJyxcXG4gICAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcXG4gICAgcmVmZXJlbmNlOiAnKHN0cmluZ3xlbGVtZW50KScsXFxuICAgIGRpc3BsYXk6ICdzdHJpbmcnLFxcbiAgICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3QpJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBDbGFzcyBEZWZpbml0aW9uXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgdmFyIERyb3Bkb3duID1cXG4gIC8qI19fUFVSRV9fKi9cXG4gIGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gRHJvcGRvd24oZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcXG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgICB0aGlzLl9tZW51ID0gdGhpcy5fZ2V0TWVudUVsZW1lbnQoKTtcXG4gICAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xcblxcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICB2YXIgX3Byb3RvID0gRHJvcGRvd24ucHJvdG90eXBlO1xcblxcbiAgICAvLyBQdWJsaWNcXG4gICAgX3Byb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5kaXNhYmxlZCB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZSQ0LkRJU0FCTEVEKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaXNBY3RpdmUgPSAkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZSQ0LlNIT1cpO1xcblxcbiAgICAgIERyb3Bkb3duLl9jbGVhck1lbnVzKCk7XFxuXFxuICAgICAgaWYgKGlzQWN0aXZlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuc2hvdyh0cnVlKTtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KHVzZVBvcHBlcikge1xcbiAgICAgIGlmICh1c2VQb3BwZXIgPT09IHZvaWQgMCkge1xcbiAgICAgICAgdXNlUG9wcGVyID0gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LmRpc2FibGVkIHx8ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lJDQuRElTQUJMRUQpIHx8ICQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ2xhc3NOYW1lJDQuU0hPVykpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XFxuICAgICAgfTtcXG4gICAgICB2YXIgc2hvd0V2ZW50ID0gJC5FdmVudChFdmVudCQ0LlNIT1csIHJlbGF0ZWRUYXJnZXQpO1xcblxcbiAgICAgIHZhciBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XFxuXFxuICAgICAgJChwYXJlbnQpLnRyaWdnZXIoc2hvd0V2ZW50KTtcXG5cXG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBEaXNhYmxlIHRvdGFsbHkgUG9wcGVyLmpzIGZvciBEcm9wZG93biBpbiBOYXZiYXJcXG5cXG5cXG4gICAgICBpZiAoIXRoaXMuX2luTmF2YmFyICYmIHVzZVBvcHBlcikge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBDaGVjayBmb3IgUG9wcGVyIGRlcGVuZGVuY3lcXG4gICAgICAgICAqIFBvcHBlciAtIGh0dHBzOi8vcG9wcGVyLmpzLm9yZ1xcbiAgICAgICAgICovXFxuICAgICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFxcXCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlci5qcyAoaHR0cHM6Ly9wb3BwZXIuanMub3JnLyknKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAncGFyZW50Jykge1xcbiAgICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gcGFyZW50O1xcbiAgICAgICAgfSBlbHNlIGlmIChVdGlsLmlzRWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKSkge1xcbiAgICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZTsgLy8gQ2hlY2sgaWYgaXQncyBqUXVlcnkgZWxlbWVudFxcblxcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlWzBdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIElmIGJvdW5kYXJ5IGlzIG5vdCBgc2Nyb2xsUGFyZW50YCwgdGhlbiBzZXQgcG9zaXRpb24gdG8gYHN0YXRpY2BcXG4gICAgICAgIC8vIHRvIGFsbG93IHRoZSBtZW51IHRvIFxcXCJlc2NhcGVcXFwiIHRoZSBzY3JvbGwgcGFyZW50J3MgYm91bmRhcmllc1xcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8yNDI1MVxcblxcblxcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5ib3VuZGFyeSAhPT0gJ3Njcm9sbFBhcmVudCcpIHtcXG4gICAgICAgICAgJChwYXJlbnQpLmFkZENsYXNzKENsYXNzTmFtZSQ0LlBPU0lUSU9OX1NUQVRJQyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9wb3BwZXIgPSBuZXcgUG9wcGVyKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHRoaXMuX2dldFBvcHBlckNvbmZpZygpKTtcXG4gICAgICB9IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXFxuICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXFxuXFxuXFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAkKHBhcmVudCkuY2xvc2VzdChTZWxlY3RvciQ0Lk5BVkJBUl9OQVYpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgJChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9uKCdtb3VzZW92ZXInLCBudWxsLCAkLm5vb3ApO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcXG5cXG4gICAgICAkKHRoaXMuX21lbnUpLnRvZ2dsZUNsYXNzKENsYXNzTmFtZSQ0LlNIT1cpO1xcbiAgICAgICQocGFyZW50KS50b2dnbGVDbGFzcyhDbGFzc05hbWUkNC5TSE9XKS50cmlnZ2VyKCQuRXZlbnQoRXZlbnQkNC5TSE9XTiwgcmVsYXRlZFRhcmdldCkpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XFxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUkNC5ESVNBQkxFRCkgfHwgISQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ2xhc3NOYW1lJDQuU0hPVykpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XFxuICAgICAgfTtcXG4gICAgICB2YXIgaGlkZUV2ZW50ID0gJC5FdmVudChFdmVudCQ0LkhJREUsIHJlbGF0ZWRUYXJnZXQpO1xcblxcbiAgICAgIHZhciBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XFxuXFxuICAgICAgJChwYXJlbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcXG5cXG4gICAgICBpZiAoaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcXG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XFxuICAgICAgfVxcblxcbiAgICAgICQodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lJDQuU0hPVyk7XFxuICAgICAgJChwYXJlbnQpLnRvZ2dsZUNsYXNzKENsYXNzTmFtZSQ0LlNIT1cpLnRyaWdnZXIoJC5FdmVudChFdmVudCQ0LkhJRERFTiwgcmVsYXRlZFRhcmdldCkpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XFxuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZJDQpO1xcbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0tFWSQ0KTtcXG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcXG4gICAgICB0aGlzLl9tZW51ID0gbnVsbDtcXG5cXG4gICAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XFxuICAgICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xcblxcbiAgICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XFxuICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcXG5cXG4gICAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XFxuICAgICAgICB0aGlzLl9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKTtcXG4gICAgICB9XFxuICAgIH0gLy8gUHJpdmF0ZVxcbiAgICA7XFxuXFxuICAgIF9wcm90by5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50JDQuQ0xJQ0ssIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcbiAgICAgICAgX3RoaXMudG9nZ2xlKCk7XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgICBjb25maWcgPSBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LCB7fSwgJCh0aGlzLl9lbGVtZW50KS5kYXRhKCksIHt9LCBjb25maWcpO1xcbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUkNCwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcXG4gICAgICByZXR1cm4gY29uZmlnO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2dldE1lbnVFbGVtZW50ID0gZnVuY3Rpb24gX2dldE1lbnVFbGVtZW50KCkge1xcbiAgICAgIGlmICghdGhpcy5fbWVudSkge1xcbiAgICAgICAgdmFyIHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgICAgIGlmIChwYXJlbnQpIHtcXG4gICAgICAgICAgdGhpcy5fbWVudSA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yJDQuTUVOVSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLl9tZW51O1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2dldFBsYWNlbWVudCA9IGZ1bmN0aW9uIF9nZXRQbGFjZW1lbnQoKSB7XFxuICAgICAgdmFyICRwYXJlbnREcm9wZG93biA9ICQodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlKTtcXG4gICAgICB2YXIgcGxhY2VtZW50ID0gQXR0YWNobWVudE1hcC5CT1RUT007IC8vIEhhbmRsZSBkcm9wdXBcXG5cXG4gICAgICBpZiAoJHBhcmVudERyb3Bkb3duLmhhc0NsYXNzKENsYXNzTmFtZSQ0LkRST1BVUCkpIHtcXG4gICAgICAgIHBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXAuVE9QO1xcblxcbiAgICAgICAgaWYgKCQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ2xhc3NOYW1lJDQuTUVOVVJJR0hUKSkge1xcbiAgICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLlRPUEVORDtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKCRwYXJlbnREcm9wZG93bi5oYXNDbGFzcyhDbGFzc05hbWUkNC5EUk9QUklHSFQpKSB7XFxuICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLlJJR0hUO1xcbiAgICAgIH0gZWxzZSBpZiAoJHBhcmVudERyb3Bkb3duLmhhc0NsYXNzKENsYXNzTmFtZSQ0LkRST1BMRUZUKSkge1xcbiAgICAgICAgcGxhY2VtZW50ID0gQXR0YWNobWVudE1hcC5MRUZUO1xcbiAgICAgIH0gZWxzZSBpZiAoJCh0aGlzLl9tZW51KS5oYXNDbGFzcyhDbGFzc05hbWUkNC5NRU5VUklHSFQpKSB7XFxuICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLkJPVFRPTUVORDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHBsYWNlbWVudDtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9kZXRlY3ROYXZiYXIgPSBmdW5jdGlvbiBfZGV0ZWN0TmF2YmFyKCkge1xcbiAgICAgIHJldHVybiAkKHRoaXMuX2VsZW1lbnQpLmNsb3Nlc3QoJy5uYXZiYXInKS5sZW5ndGggPiAwO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2dldE9mZnNldCA9IGZ1bmN0aW9uIF9nZXRPZmZzZXQoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdmFyIG9mZnNldCA9IHt9O1xcblxcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLm9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgb2Zmc2V0LmZuID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgICAgZGF0YS5vZmZzZXRzID0gX29iamVjdFNwcmVhZDIoe30sIGRhdGEub2Zmc2V0cywge30sIF90aGlzMi5fY29uZmlnLm9mZnNldChkYXRhLm9mZnNldHMsIF90aGlzMi5fZWxlbWVudCkgfHwge30pO1xcbiAgICAgICAgICByZXR1cm4gZGF0YTtcXG4gICAgICAgIH07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG9mZnNldC5vZmZzZXQgPSB0aGlzLl9jb25maWcub2Zmc2V0O1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2Zmc2V0O1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2dldFBvcHBlckNvbmZpZyA9IGZ1bmN0aW9uIF9nZXRQb3BwZXJDb25maWcoKSB7XFxuICAgICAgdmFyIHBvcHBlckNvbmZpZyA9IHtcXG4gICAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXFxuICAgICAgICBtb2RpZmllcnM6IHtcXG4gICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKSxcXG4gICAgICAgICAgZmxpcDoge1xcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuX2NvbmZpZy5mbGlwXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xcbiAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLl9jb25maWcuYm91bmRhcnlcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07IC8vIERpc2FibGUgUG9wcGVyLmpzIGlmIHdlIGhhdmUgYSBzdGF0aWMgZGlzcGxheVxcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcXG4gICAgICAgIHBvcHBlckNvbmZpZy5tb2RpZmllcnMuYXBwbHlTdHlsZSA9IHtcXG4gICAgICAgICAgZW5hYmxlZDogZmFsc2VcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7fSwgcG9wcGVyQ29uZmlnLCB7fSwgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyk7XFxuICAgIH0gLy8gU3RhdGljXFxuICAgIDtcXG5cXG4gICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSQ0KTtcXG5cXG4gICAgICAgIHZhciBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsO1xcblxcbiAgICAgICAgaWYgKCFkYXRhKSB7XFxuICAgICAgICAgIGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcywgX2NvbmZpZyk7XFxuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSQ0LCBkYXRhKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJObyBtZXRob2QgbmFtZWQgXFxcXFxcXCJcXFwiICsgY29uZmlnICsgXFxcIlxcXFxcXFwiXFxcIik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIERyb3Bkb3duLl9jbGVhck1lbnVzID0gZnVuY3Rpb24gX2NsZWFyTWVudXMoZXZlbnQpIHtcXG4gICAgICBpZiAoZXZlbnQgJiYgKGV2ZW50LndoaWNoID09PSBSSUdIVF9NT1VTRV9CVVRUT05fV0hJQ0ggfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC53aGljaCAhPT0gVEFCX0tFWUNPREUpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0b2dnbGVzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yJDQuREFUQV9UT0dHTEUpKTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9nZ2xlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgdmFyIHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0b2dnbGVzW2ldKTtcXG5cXG4gICAgICAgIHZhciBjb250ZXh0ID0gJCh0b2dnbGVzW2ldKS5kYXRhKERBVEFfS0VZJDQpO1xcbiAgICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7XFxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRvZ2dsZXNbaV1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghY29udGV4dCkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBkcm9wZG93bk1lbnUgPSBjb250ZXh0Ll9tZW51O1xcblxcbiAgICAgICAgaWYgKCEkKHBhcmVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lJDQuU0hPVykpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC53aGljaCA9PT0gVEFCX0tFWUNPREUpICYmICQuY29udGFpbnMocGFyZW50LCBldmVudC50YXJnZXQpKSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoRXZlbnQkNC5ISURFLCByZWxhdGVkVGFyZ2V0KTtcXG4gICAgICAgICQocGFyZW50KS50cmlnZ2VyKGhpZGVFdmVudCk7XFxuXFxuICAgICAgICBpZiAoaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfSAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxcbiAgICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcXG5cXG5cXG4gICAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgICAgICAgJChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9mZignbW91c2VvdmVyJywgbnVsbCwgJC5ub29wKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRvZ2dsZXNbaV0uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XFxuXFxuICAgICAgICBpZiAoY29udGV4dC5fcG9wcGVyKSB7XFxuICAgICAgICAgIGNvbnRleHQuX3BvcHBlci5kZXN0cm95KCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkKGRyb3Bkb3duTWVudSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lJDQuU0hPVyk7XFxuICAgICAgICAkKHBhcmVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lJDQuU0hPVykudHJpZ2dlcigkLkV2ZW50KEV2ZW50JDQuSElEREVOLCByZWxhdGVkVGFyZ2V0KSk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCkge1xcbiAgICAgIHZhciBwYXJlbnQ7XFxuICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpO1xcblxcbiAgICAgIGlmIChzZWxlY3Rvcikge1xcbiAgICAgICAgcGFyZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwYXJlbnQgfHwgZWxlbWVudC5wYXJlbnROb2RlO1xcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XFxuICAgIDtcXG5cXG4gICAgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlciA9IGZ1bmN0aW9uIF9kYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcXG4gICAgICAvLyBJZiBub3QgaW5wdXQvdGV4dGFyZWE6XFxuICAgICAgLy8gIC0gQW5kIG5vdCBhIGtleSBpbiBSRUdFWFBfS0VZRE9XTiA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXFxuICAgICAgLy8gSWYgaW5wdXQvdGV4dGFyZWE6XFxuICAgICAgLy8gIC0gSWYgc3BhY2Uga2V5ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcXG4gICAgICAvLyAgLSBJZiBrZXkgaXMgb3RoZXIgdGhhbiBlc2NhcGVcXG4gICAgICAvLyAgICAtIElmIGtleSBpcyBub3QgdXAgb3IgZG93biA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXFxuICAgICAgLy8gICAgLSBJZiB0cmlnZ2VyIGluc2lkZSB0aGUgbWVudSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXFxuICAgICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpID8gZXZlbnQud2hpY2ggPT09IFNQQUNFX0tFWUNPREUgfHwgZXZlbnQud2hpY2ggIT09IEVTQ0FQRV9LRVlDT0RFICYmIChldmVudC53aGljaCAhPT0gQVJST1dfRE9XTl9LRVlDT0RFICYmIGV2ZW50LndoaWNoICE9PSBBUlJPV19VUF9LRVlDT0RFIHx8ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNlbGVjdG9yJDQuTUVOVSkubGVuZ3RoKSA6ICFSRUdFWFBfS0VZRE9XTi50ZXN0KGV2ZW50LndoaWNoKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICQodGhpcykuaGFzQ2xhc3MoQ2xhc3NOYW1lJDQuRElTQUJMRUQpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcyk7XFxuXFxuICAgICAgdmFyIGlzQWN0aXZlID0gJChwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZSQ0LlNIT1cpO1xcblxcbiAgICAgIGlmICghaXNBY3RpdmUgJiYgZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaXNBY3RpdmUgfHwgaXNBY3RpdmUgJiYgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSB8fCBldmVudC53aGljaCA9PT0gU1BBQ0VfS0VZQ09ERSkpIHtcXG4gICAgICAgIGlmIChldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcXG4gICAgICAgICAgdmFyIHRvZ2dsZSA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yJDQuREFUQV9UT0dHTEUpO1xcbiAgICAgICAgICAkKHRvZ2dsZSkudHJpZ2dlcignZm9jdXMnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQodGhpcykudHJpZ2dlcignY2xpY2snKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGl0ZW1zID0gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvciQ0LlZJU0lCTEVfSVRFTVMpKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgICAgIHJldHVybiAkKGl0ZW0pLmlzKCc6dmlzaWJsZScpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGluZGV4ID0gaXRlbXMuaW5kZXhPZihldmVudC50YXJnZXQpO1xcblxcbiAgICAgIGlmIChldmVudC53aGljaCA9PT0gQVJST1dfVVBfS0VZQ09ERSAmJiBpbmRleCA+IDApIHtcXG4gICAgICAgIC8vIFVwXFxuICAgICAgICBpbmRleC0tO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZXZlbnQud2hpY2ggPT09IEFSUk9XX0RPV05fS0VZQ09ERSAmJiBpbmRleCA8IGl0ZW1zLmxlbmd0aCAtIDEpIHtcXG4gICAgICAgIC8vIERvd25cXG4gICAgICAgIGluZGV4Kys7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpbmRleCA8IDApIHtcXG4gICAgICAgIGluZGV4ID0gMDtcXG4gICAgICB9XFxuXFxuICAgICAgaXRlbXNbaW5kZXhdLmZvY3VzKCk7XFxuICAgIH07XFxuXFxuICAgIF9jcmVhdGVDbGFzcyhEcm9wZG93biwgbnVsbCwgW3tcXG4gICAgICBrZXk6IFxcXCJWRVJTSU9OXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBWRVJTSU9OJDQ7XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiRGVmYXVsdFxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gRGVmYXVsdCQyO1xcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcIkRlZmF1bHRUeXBlXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQyO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gRHJvcGRvd247XFxuICB9KCk7XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuXFxuICAkKGRvY3VtZW50KS5vbihFdmVudCQ0LktFWURPV05fREFUQV9BUEksIFNlbGVjdG9yJDQuREFUQV9UT0dHTEUsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpLm9uKEV2ZW50JDQuS0VZRE9XTl9EQVRBX0FQSSwgU2VsZWN0b3IkNC5NRU5VLCBEcm9wZG93bi5fZGF0YUFwaUtleWRvd25IYW5kbGVyKS5vbihFdmVudCQ0LkNMSUNLX0RBVEFfQVBJICsgXFxcIiBcXFwiICsgRXZlbnQkNC5LRVlVUF9EQVRBX0FQSSwgRHJvcGRvd24uX2NsZWFyTWVudXMpLm9uKEV2ZW50JDQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yJDQuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICd0b2dnbGUnKTtcXG4gIH0pLm9uKEV2ZW50JDQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yJDQuRk9STV9DSElMRCwgZnVuY3Rpb24gKGUpIHtcXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gIH0pO1xcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIGpRdWVyeVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gICQuZm5bTkFNRSQ0XSA9IERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2U7XFxuICAkLmZuW05BTUUkNF0uQ29uc3RydWN0b3IgPSBEcm9wZG93bjtcXG5cXG4gICQuZm5bTkFNRSQ0XS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAkLmZuW05BTUUkNF0gPSBKUVVFUllfTk9fQ09ORkxJQ1QkNDtcXG4gICAgcmV0dXJuIERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2U7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIENvbnN0YW50c1xcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gIHZhciBOQU1FJDUgPSAnbW9kYWwnO1xcbiAgdmFyIFZFUlNJT04kNSA9ICc0LjQuMSc7XFxuICB2YXIgREFUQV9LRVkkNSA9ICdicy5tb2RhbCc7XFxuICB2YXIgRVZFTlRfS0VZJDUgPSBcXFwiLlxcXCIgKyBEQVRBX0tFWSQ1O1xcbiAgdmFyIERBVEFfQVBJX0tFWSQ1ID0gJy5kYXRhLWFwaSc7XFxuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUJDUgPSAkLmZuW05BTUUkNV07XFxuICB2YXIgRVNDQVBFX0tFWUNPREUkMSA9IDI3OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBFc2NhcGUgKEVzYykga2V5XFxuXFxuICB2YXIgRGVmYXVsdCQzID0ge1xcbiAgICBiYWNrZHJvcDogdHJ1ZSxcXG4gICAga2V5Ym9hcmQ6IHRydWUsXFxuICAgIGZvY3VzOiB0cnVlLFxcbiAgICBzaG93OiB0cnVlXFxuICB9O1xcbiAgdmFyIERlZmF1bHRUeXBlJDMgPSB7XFxuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXFxuICAgIGtleWJvYXJkOiAnYm9vbGVhbicsXFxuICAgIGZvY3VzOiAnYm9vbGVhbicsXFxuICAgIHNob3c6ICdib29sZWFuJ1xcbiAgfTtcXG4gIHZhciBFdmVudCQ1ID0ge1xcbiAgICBISURFOiBcXFwiaGlkZVxcXCIgKyBFVkVOVF9LRVkkNSxcXG4gICAgSElERV9QUkVWRU5URUQ6IFxcXCJoaWRlUHJldmVudGVkXFxcIiArIEVWRU5UX0tFWSQ1LFxcbiAgICBISURERU46IFxcXCJoaWRkZW5cXFwiICsgRVZFTlRfS0VZJDUsXFxuICAgIFNIT1c6IFxcXCJzaG93XFxcIiArIEVWRU5UX0tFWSQ1LFxcbiAgICBTSE9XTjogXFxcInNob3duXFxcIiArIEVWRU5UX0tFWSQ1LFxcbiAgICBGT0NVU0lOOiBcXFwiZm9jdXNpblxcXCIgKyBFVkVOVF9LRVkkNSxcXG4gICAgUkVTSVpFOiBcXFwicmVzaXplXFxcIiArIEVWRU5UX0tFWSQ1LFxcbiAgICBDTElDS19ESVNNSVNTOiBcXFwiY2xpY2suZGlzbWlzc1xcXCIgKyBFVkVOVF9LRVkkNSxcXG4gICAgS0VZRE9XTl9ESVNNSVNTOiBcXFwia2V5ZG93bi5kaXNtaXNzXFxcIiArIEVWRU5UX0tFWSQ1LFxcbiAgICBNT1VTRVVQX0RJU01JU1M6IFxcXCJtb3VzZXVwLmRpc21pc3NcXFwiICsgRVZFTlRfS0VZJDUsXFxuICAgIE1PVVNFRE9XTl9ESVNNSVNTOiBcXFwibW91c2Vkb3duLmRpc21pc3NcXFwiICsgRVZFTlRfS0VZJDUsXFxuICAgIENMSUNLX0RBVEFfQVBJOiBcXFwiY2xpY2tcXFwiICsgRVZFTlRfS0VZJDUgKyBEQVRBX0FQSV9LRVkkNVxcbiAgfTtcXG4gIHZhciBDbGFzc05hbWUkNSA9IHtcXG4gICAgU0NST0xMQUJMRTogJ21vZGFsLWRpYWxvZy1zY3JvbGxhYmxlJyxcXG4gICAgU0NST0xMQkFSX01FQVNVUkVSOiAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnLFxcbiAgICBCQUNLRFJPUDogJ21vZGFsLWJhY2tkcm9wJyxcXG4gICAgT1BFTjogJ21vZGFsLW9wZW4nLFxcbiAgICBGQURFOiAnZmFkZScsXFxuICAgIFNIT1c6ICdzaG93JyxcXG4gICAgU1RBVElDOiAnbW9kYWwtc3RhdGljJ1xcbiAgfTtcXG4gIHZhciBTZWxlY3RvciQ1ID0ge1xcbiAgICBESUFMT0c6ICcubW9kYWwtZGlhbG9nJyxcXG4gICAgTU9EQUxfQk9EWTogJy5tb2RhbC1ib2R5JyxcXG4gICAgREFUQV9UT0dHTEU6ICdbZGF0YS10b2dnbGU9XFxcIm1vZGFsXFxcIl0nLFxcbiAgICBEQVRBX0RJU01JU1M6ICdbZGF0YS1kaXNtaXNzPVxcXCJtb2RhbFxcXCJdJyxcXG4gICAgRklYRURfQ09OVEVOVDogJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnLFxcbiAgICBTVElDS1lfQ09OVEVOVDogJy5zdGlja3ktdG9wJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBDbGFzcyBEZWZpbml0aW9uXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgdmFyIE1vZGFsID1cXG4gIC8qI19fUFVSRV9fKi9cXG4gIGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gTW9kYWwoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5fZGlhbG9nID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yJDUuRElBTE9HKTtcXG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGw7XFxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gZmFsc2U7XFxuICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gMDtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHZhciBfcHJvdG8gPSBNb2RhbC5wcm90b3R5cGU7XFxuXFxuICAgIC8vIFB1YmxpY1xcbiAgICBfcHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3cocmVsYXRlZFRhcmdldCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZSQ1LkZBREUpKSB7XFxuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgc2hvd0V2ZW50ID0gJC5FdmVudChFdmVudCQ1LlNIT1csIHtcXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXRcXG4gICAgICB9KTtcXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KTtcXG5cXG4gICAgICBpZiAodGhpcy5faXNTaG93biB8fCBzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XFxuXFxuICAgICAgdGhpcy5fY2hlY2tTY3JvbGxiYXIoKTtcXG5cXG4gICAgICB0aGlzLl9zZXRTY3JvbGxiYXIoKTtcXG5cXG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcXG5cXG4gICAgICB0aGlzLl9zZXRFc2NhcGVFdmVudCgpO1xcblxcbiAgICAgIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCk7XFxuXFxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudCQ1LkNMSUNLX0RJU01JU1MsIFNlbGVjdG9yJDUuREFUQV9ESVNNSVNTLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgIHJldHVybiBfdGhpcy5oaWRlKGV2ZW50KTtcXG4gICAgICB9KTtcXG4gICAgICAkKHRoaXMuX2RpYWxvZykub24oRXZlbnQkNS5NT1VTRURPV05fRElTTUlTUywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgJChfdGhpcy5fZWxlbWVudCkub25lKEV2ZW50JDUuTU9VU0VVUF9ESVNNSVNTLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyhfdGhpcy5fZWxlbWVudCkpIHtcXG4gICAgICAgICAgICBfdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IHRydWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX3Nob3dCYWNrZHJvcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpO1xcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIGhpZGUoZXZlbnQpIHtcXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICBpZiAoZXZlbnQpIHtcXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoRXZlbnQkNS5ISURFKTtcXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcXG5cXG4gICAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcXG4gICAgICB2YXIgdHJhbnNpdGlvbiA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lJDUuRkFERSk7XFxuXFxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KCk7XFxuXFxuICAgICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKTtcXG5cXG4gICAgICAkKGRvY3VtZW50KS5vZmYoRXZlbnQkNS5GT0NVU0lOKTtcXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKENsYXNzTmFtZSQ1LlNIT1cpO1xcbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEV2ZW50JDUuQ0xJQ0tfRElTTUlTUyk7XFxuICAgICAgJCh0aGlzLl9kaWFsb2cpLm9mZihFdmVudCQ1Lk1PVVNFRE9XTl9ESVNNSVNTKTtcXG5cXG4gICAgICBpZiAodHJhbnNpdGlvbikge1xcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XFxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5faGlkZU1vZGFsKGV2ZW50KTtcXG4gICAgICAgIH0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX2hpZGVNb2RhbCgpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xcbiAgICAgIFt3aW5kb3csIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2RpYWxvZ10uZm9yRWFjaChmdW5jdGlvbiAoaHRtbEVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybiAkKGh0bWxFbGVtZW50KS5vZmYoRVZFTlRfS0VZJDUpO1xcbiAgICAgIH0pO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIGBkb2N1bWVudGAgaGFzIDIgZXZlbnRzIGBFdmVudC5GT0NVU0lOYCBhbmQgYEV2ZW50LkNMSUNLX0RBVEFfQVBJYFxcbiAgICAgICAqIERvIG5vdCBtb3ZlIGBkb2N1bWVudGAgaW4gYGh0bWxFbGVtZW50c2AgYXJyYXlcXG4gICAgICAgKiBJdCB3aWxsIHJlbW92ZSBgRXZlbnQuQ0xJQ0tfREFUQV9BUElgIGV2ZW50IHRoYXQgc2hvdWxkIHJlbWFpblxcbiAgICAgICAqL1xcblxcbiAgICAgICQoZG9jdW1lbnQpLm9mZihFdmVudCQ1LkZPQ1VTSU4pO1xcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSQ1KTtcXG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xcbiAgICAgIHRoaXMuX2RpYWxvZyA9IG51bGw7XFxuICAgICAgdGhpcy5fYmFja2Ryb3AgPSBudWxsO1xcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBudWxsO1xcbiAgICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gbnVsbDtcXG4gICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gbnVsbDtcXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBudWxsO1xcbiAgICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gbnVsbDtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLmhhbmRsZVVwZGF0ZSA9IGZ1bmN0aW9uIGhhbmRsZVVwZGF0ZSgpIHtcXG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcXG4gICAgfSAvLyBQcml2YXRlXFxuICAgIDtcXG5cXG4gICAgX3Byb3RvLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xcbiAgICAgIGNvbmZpZyA9IF9vYmplY3RTcHJlYWQyKHt9LCBEZWZhdWx0JDMsIHt9LCBjb25maWcpO1xcbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUkNSwgY29uZmlnLCBEZWZhdWx0VHlwZSQzKTtcXG4gICAgICByZXR1cm4gY29uZmlnO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24gPSBmdW5jdGlvbiBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xcbiAgICAgICAgdmFyIGhpZGVFdmVudFByZXZlbnRlZCA9ICQuRXZlbnQoRXZlbnQkNS5ISURFX1BSRVZFTlRFRCk7XFxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50UHJldmVudGVkKTtcXG5cXG4gICAgICAgIGlmIChoaWRlRXZlbnRQcmV2ZW50ZWQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ2xhc3NOYW1lJDUuU1RBVElDKTtcXG5cXG4gICAgICAgIHZhciBtb2RhbFRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XFxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzMy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZSQ1LlNUQVRJQyk7XFxuICAgICAgICB9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChtb2RhbFRyYW5zaXRpb25EdXJhdGlvbik7XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9zaG93RWxlbWVudCA9IGZ1bmN0aW9uIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XFxuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XFxuXFxuICAgICAgdmFyIHRyYW5zaXRpb24gPSAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZSQ1LkZBREUpO1xcbiAgICAgIHZhciBtb2RhbEJvZHkgPSB0aGlzLl9kaWFsb2cgPyB0aGlzLl9kaWFsb2cucXVlcnlTZWxlY3RvcihTZWxlY3RvciQ1Lk1PREFMX0JPRFkpIDogbnVsbDtcXG5cXG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSB8fCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XFxuICAgICAgICAvLyBEb24ndCBtb3ZlIG1vZGFsJ3MgRE9NIHBvc2l0aW9uXFxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKCQodGhpcy5fZGlhbG9nKS5oYXNDbGFzcyhDbGFzc05hbWUkNS5TQ1JPTExBQkxFKSAmJiBtb2RhbEJvZHkpIHtcXG4gICAgICAgIG1vZGFsQm9keS5zY3JvbGxUb3AgPSAwO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IDA7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XFxuICAgICAgICBVdGlsLnJlZmxvdyh0aGlzLl9lbGVtZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5hZGRDbGFzcyhDbGFzc05hbWUkNS5TSE9XKTtcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XFxuICAgICAgICB0aGlzLl9lbmZvcmNlRm9jdXMoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHNob3duRXZlbnQgPSAkLkV2ZW50KEV2ZW50JDUuU0hPV04sIHtcXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXRcXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgdHJhbnNpdGlvbkNvbXBsZXRlID0gZnVuY3Rpb24gdHJhbnNpdGlvbkNvbXBsZXRlKCkge1xcbiAgICAgICAgaWYgKF90aGlzNC5fY29uZmlnLmZvY3VzKSB7XFxuICAgICAgICAgIF90aGlzNC5fZWxlbWVudC5mb2N1cygpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgX3RoaXM0Ll9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcXG4gICAgICAgICQoX3RoaXM0Ll9lbGVtZW50KS50cmlnZ2VyKHNob3duRXZlbnQpO1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcXG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2RpYWxvZyk7XFxuICAgICAgICAkKHRoaXMuX2RpYWxvZykub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIHRyYW5zaXRpb25Db21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdHJhbnNpdGlvbkNvbXBsZXRlKCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2VuZm9yY2VGb2N1cyA9IGZ1bmN0aW9uIF9lbmZvcmNlRm9jdXMoKSB7XFxuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XFxuXFxuICAgICAgJChkb2N1bWVudCkub2ZmKEV2ZW50JDUuRk9DVVNJTikgLy8gR3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXFxuICAgICAgLm9uKEV2ZW50JDUuRk9DVVNJTiwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICBpZiAoZG9jdW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJiBfdGhpczUuX2VsZW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJiAkKF90aGlzNS5fZWxlbWVudCkuaGFzKGV2ZW50LnRhcmdldCkubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgIF90aGlzNS5fZWxlbWVudC5mb2N1cygpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX3NldEVzY2FwZUV2ZW50ID0gZnVuY3Rpb24gX3NldEVzY2FwZUV2ZW50KCkge1xcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xcblxcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmIHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudCQ1LktFWURPV05fRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgIGlmIChldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUkMSkge1xcbiAgICAgICAgICAgIF90aGlzNi5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1Nob3duKSB7XFxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFdmVudCQ1LktFWURPV05fRElTTUlTUyk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX3NldFJlc2l6ZUV2ZW50ID0gZnVuY3Rpb24gX3NldFJlc2l6ZUV2ZW50KCkge1xcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xcblxcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XFxuICAgICAgICAkKHdpbmRvdykub24oRXZlbnQkNS5SRVNJWkUsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICByZXR1cm4gX3RoaXM3LmhhbmRsZVVwZGF0ZShldmVudCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJCh3aW5kb3cpLm9mZihFdmVudCQ1LlJFU0laRSk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2hpZGVNb2RhbCA9IGZ1bmN0aW9uIF9oaWRlTW9kYWwoKSB7XFxuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XFxuXFxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XFxuXFxuICAgICAgdGhpcy5fc2hvd0JhY2tkcm9wKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICQoZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lJDUuT1BFTik7XFxuXFxuICAgICAgICBfdGhpczguX3Jlc2V0QWRqdXN0bWVudHMoKTtcXG5cXG4gICAgICAgIF90aGlzOC5fcmVzZXRTY3JvbGxiYXIoKTtcXG5cXG4gICAgICAgICQoX3RoaXM4Ll9lbGVtZW50KS50cmlnZ2VyKEV2ZW50JDUuSElEREVOKTtcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9yZW1vdmVCYWNrZHJvcCA9IGZ1bmN0aW9uIF9yZW1vdmVCYWNrZHJvcCgpIHtcXG4gICAgICBpZiAodGhpcy5fYmFja2Ryb3ApIHtcXG4gICAgICAgICQodGhpcy5fYmFja2Ryb3ApLnJlbW92ZSgpO1xcbiAgICAgICAgdGhpcy5fYmFja2Ryb3AgPSBudWxsO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9zaG93QmFja2Ryb3AgPSBmdW5jdGlvbiBfc2hvd0JhY2tkcm9wKGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIGFuaW1hdGUgPSAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZSQ1LkZBREUpID8gQ2xhc3NOYW1lJDUuRkFERSA6ICcnO1xcblxcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmIHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xcbiAgICAgICAgdGhpcy5fYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTmFtZSA9IENsYXNzTmFtZSQ1LkJBQ0tEUk9QO1xcblxcbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcXG4gICAgICAgICAgdGhpcy5fYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChhbmltYXRlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQodGhpcy5fYmFja2Ryb3ApLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudCQ1LkNMSUNLX0RJU01JU1MsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICBpZiAoX3RoaXM5Ll9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XFxuICAgICAgICAgICAgX3RoaXM5Ll9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgX3RoaXM5Ll90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmIChhbmltYXRlKSB7XFxuICAgICAgICAgIFV0aWwucmVmbG93KHRoaXMuX2JhY2tkcm9wKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQodGhpcy5fYmFja2Ryb3ApLmFkZENsYXNzKENsYXNzTmFtZSQ1LlNIT1cpO1xcblxcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIWFuaW1hdGUpIHtcXG4gICAgICAgICAgY2FsbGJhY2soKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9iYWNrZHJvcCk7XFxuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY2FsbGJhY2spLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uKTtcXG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1Nob3duICYmIHRoaXMuX2JhY2tkcm9wKSB7XFxuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkNS5TSE9XKTtcXG5cXG4gICAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uIGNhbGxiYWNrUmVtb3ZlKCkge1xcbiAgICAgICAgICBfdGhpczkuX3JlbW92ZUJhY2tkcm9wKCk7XFxuXFxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUkNS5GQURFKSkge1xcbiAgICAgICAgICB2YXIgX2JhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9iYWNrZHJvcCk7XFxuXFxuICAgICAgICAgICQodGhpcy5fYmFja2Ryb3ApLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjYWxsYmFja1JlbW92ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoX2JhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNhbGxiYWNrUmVtb3ZlKCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xcbiAgICAgICAgY2FsbGJhY2soKTtcXG4gICAgICB9XFxuICAgIH0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xcbiAgICAvLyB0b2RvIChmYXQpOiB0aGVzZSBzaG91bGQgcHJvYmFibHkgYmUgcmVmYWN0b3JlZCBvdXQgb2YgbW9kYWwuanNcXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICA7XFxuXFxuICAgIF9wcm90by5fYWRqdXN0RGlhbG9nID0gZnVuY3Rpb24gX2FkanVzdERpYWxvZygpIHtcXG4gICAgICB2YXIgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xcblxcbiAgICAgIGlmICghdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nKSB7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gdGhpcy5fc2Nyb2xsYmFyV2lkdGggKyBcXFwicHhcXFwiO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgIWlzTW9kYWxPdmVyZmxvd2luZykge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSB0aGlzLl9zY3JvbGxiYXJXaWR0aCArIFxcXCJweFxcXCI7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX3Jlc2V0QWRqdXN0bWVudHMgPSBmdW5jdGlvbiBfcmVzZXRBZGp1c3RtZW50cygpIHtcXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uIF9jaGVja1Njcm9sbGJhcigpIHtcXG4gICAgICB2YXIgcmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSByZWN0LmxlZnQgKyByZWN0LnJpZ2h0IDwgd2luZG93LmlubmVyV2lkdGg7XFxuICAgICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggPSB0aGlzLl9nZXRTY3JvbGxiYXJXaWR0aCgpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX3NldFNjcm9sbGJhciA9IGZ1bmN0aW9uIF9zZXRTY3JvbGxiYXIoKSB7XFxuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xcblxcbiAgICAgIGlmICh0aGlzLl9pc0JvZHlPdmVyZmxvd2luZykge1xcbiAgICAgICAgLy8gTm90ZTogRE9NTm9kZS5zdHlsZS5wYWRkaW5nUmlnaHQgcmV0dXJucyB0aGUgYWN0dWFsIHZhbHVlIG9yICcnIGlmIG5vdCBzZXRcXG4gICAgICAgIC8vICAgd2hpbGUgJChET01Ob2RlKS5jc3MoJ3BhZGRpbmctcmlnaHQnKSByZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHZhbHVlIG9yIDAgaWYgbm90IHNldFxcbiAgICAgICAgdmFyIGZpeGVkQ29udGVudCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3RvciQ1LkZJWEVEX0NPTlRFTlQpKTtcXG4gICAgICAgIHZhciBzdGlja3lDb250ZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yJDUuU1RJQ0tZX0NPTlRFTlQpKTsgLy8gQWRqdXN0IGZpeGVkIGNvbnRlbnQgcGFkZGluZ1xcblxcbiAgICAgICAgJChmaXhlZENvbnRlbnQpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XFxuICAgICAgICAgIHZhciBhY3R1YWxQYWRkaW5nID0gZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQ7XFxuICAgICAgICAgIHZhciBjYWxjdWxhdGVkUGFkZGluZyA9ICQoZWxlbWVudCkuY3NzKCdwYWRkaW5nLXJpZ2h0Jyk7XFxuICAgICAgICAgICQoZWxlbWVudCkuZGF0YSgncGFkZGluZy1yaWdodCcsIGFjdHVhbFBhZGRpbmcpLmNzcygncGFkZGluZy1yaWdodCcsIHBhcnNlRmxvYXQoY2FsY3VsYXRlZFBhZGRpbmcpICsgX3RoaXMxMC5fc2Nyb2xsYmFyV2lkdGggKyBcXFwicHhcXFwiKTtcXG4gICAgICAgIH0pOyAvLyBBZGp1c3Qgc3RpY2t5IGNvbnRlbnQgbWFyZ2luXFxuXFxuICAgICAgICAkKHN0aWNreUNvbnRlbnQpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XFxuICAgICAgICAgIHZhciBhY3R1YWxNYXJnaW4gPSBlbGVtZW50LnN0eWxlLm1hcmdpblJpZ2h0O1xcbiAgICAgICAgICB2YXIgY2FsY3VsYXRlZE1hcmdpbiA9ICQoZWxlbWVudCkuY3NzKCdtYXJnaW4tcmlnaHQnKTtcXG4gICAgICAgICAgJChlbGVtZW50KS5kYXRhKCdtYXJnaW4tcmlnaHQnLCBhY3R1YWxNYXJnaW4pLmNzcygnbWFyZ2luLXJpZ2h0JywgcGFyc2VGbG9hdChjYWxjdWxhdGVkTWFyZ2luKSAtIF90aGlzMTAuX3Njcm9sbGJhcldpZHRoICsgXFxcInB4XFxcIik7XFxuICAgICAgICB9KTsgLy8gQWRqdXN0IGJvZHkgcGFkZGluZ1xcblxcbiAgICAgICAgdmFyIGFjdHVhbFBhZGRpbmcgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcXG4gICAgICAgIHZhciBjYWxjdWxhdGVkUGFkZGluZyA9ICQoZG9jdW1lbnQuYm9keSkuY3NzKCdwYWRkaW5nLXJpZ2h0Jyk7XFxuICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmRhdGEoJ3BhZGRpbmctcmlnaHQnLCBhY3R1YWxQYWRkaW5nKS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBwYXJzZUZsb2F0KGNhbGN1bGF0ZWRQYWRkaW5nKSArIHRoaXMuX3Njcm9sbGJhcldpZHRoICsgXFxcInB4XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgICQoZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3MoQ2xhc3NOYW1lJDUuT1BFTik7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fcmVzZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiBfcmVzZXRTY3JvbGxiYXIoKSB7XFxuICAgICAgLy8gUmVzdG9yZSBmaXhlZCBjb250ZW50IHBhZGRpbmdcXG4gICAgICB2YXIgZml4ZWRDb250ZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yJDUuRklYRURfQ09OVEVOVCkpO1xcbiAgICAgICQoZml4ZWRDb250ZW50KS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAkKGVsZW1lbnQpLmRhdGEoJ3BhZGRpbmctcmlnaHQnKTtcXG4gICAgICAgICQoZWxlbWVudCkucmVtb3ZlRGF0YSgncGFkZGluZy1yaWdodCcpO1xcbiAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nID8gcGFkZGluZyA6ICcnO1xcbiAgICAgIH0pOyAvLyBSZXN0b3JlIHN0aWNreSBjb250ZW50XFxuXFxuICAgICAgdmFyIGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJcXFwiICsgU2VsZWN0b3IkNS5TVElDS1lfQ09OVEVOVCkpO1xcbiAgICAgICQoZWxlbWVudHMpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XFxuICAgICAgICB2YXIgbWFyZ2luID0gJChlbGVtZW50KS5kYXRhKCdtYXJnaW4tcmlnaHQnKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgbWFyZ2luICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAkKGVsZW1lbnQpLmNzcygnbWFyZ2luLXJpZ2h0JywgbWFyZ2luKS5yZW1vdmVEYXRhKCdtYXJnaW4tcmlnaHQnKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTsgLy8gUmVzdG9yZSBib2R5IHBhZGRpbmdcXG5cXG4gICAgICB2YXIgcGFkZGluZyA9ICQoZG9jdW1lbnQuYm9keSkuZGF0YSgncGFkZGluZy1yaWdodCcpO1xcbiAgICAgICQoZG9jdW1lbnQuYm9keSkucmVtb3ZlRGF0YSgncGFkZGluZy1yaWdodCcpO1xcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gcGFkZGluZyA/IHBhZGRpbmcgOiAnJztcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9nZXRTY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxiYXJXaWR0aCgpIHtcXG4gICAgICAvLyB0aHggZC53YWxzaFxcbiAgICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gQ2xhc3NOYW1lJDUuU0NST0xMQkFSX01FQVNVUkVSO1xcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcXG4gICAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XFxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xcbiAgICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aDtcXG4gICAgfSAvLyBTdGF0aWNcXG4gICAgO1xcblxcbiAgICBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcsIHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZJDUpO1xcblxcbiAgICAgICAgdmFyIF9jb25maWcgPSBfb2JqZWN0U3ByZWFkMih7fSwgRGVmYXVsdCQzLCB7fSwgJCh0aGlzKS5kYXRhKCksIHt9LCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSk7XFxuXFxuICAgICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgICAgZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBfY29uZmlnKTtcXG4gICAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZJDUsIGRhdGEpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIk5vIG1ldGhvZCBuYW1lZCBcXFxcXFxcIlxcXCIgKyBjb25maWcgKyBcXFwiXFxcXFxcXCJcXFwiKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkYXRhW2NvbmZpZ10ocmVsYXRlZFRhcmdldCk7XFxuICAgICAgICB9IGVsc2UgaWYgKF9jb25maWcuc2hvdykge1xcbiAgICAgICAgICBkYXRhLnNob3cocmVsYXRlZFRhcmdldCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIF9jcmVhdGVDbGFzcyhNb2RhbCwgbnVsbCwgW3tcXG4gICAgICBrZXk6IFxcXCJWRVJTSU9OXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBWRVJTSU9OJDU7XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiRGVmYXVsdFxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gRGVmYXVsdCQzO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gTW9kYWw7XFxuICB9KCk7XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuXFxuICAkKGRvY3VtZW50KS5vbihFdmVudCQ1LkNMSUNLX0RBVEFfQVBJLCBTZWxlY3RvciQ1LkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgdmFyIF90aGlzMTEgPSB0aGlzO1xcblxcbiAgICB2YXIgdGFyZ2V0O1xcbiAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7XFxuXFxuICAgIGlmIChzZWxlY3Rvcikge1xcbiAgICAgIHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjb25maWcgPSAkKHRhcmdldCkuZGF0YShEQVRBX0tFWSQ1KSA/ICd0b2dnbGUnIDogX29iamVjdFNwcmVhZDIoe30sICQodGFyZ2V0KS5kYXRhKCksIHt9LCAkKHRoaXMpLmRhdGEoKSk7XFxuXFxuICAgIGlmICh0aGlzLnRhZ05hbWUgPT09ICdBJyB8fCB0aGlzLnRhZ05hbWUgPT09ICdBUkVBJykge1xcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH1cXG5cXG4gICAgdmFyICR0YXJnZXQgPSAkKHRhcmdldCkub25lKEV2ZW50JDUuU0hPVywgZnVuY3Rpb24gKHNob3dFdmVudCkge1xcbiAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG4gICAgICAgIC8vIE9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgJHRhcmdldC5vbmUoRXZlbnQkNS5ISURERU4sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICgkKF90aGlzMTEpLmlzKCc6dmlzaWJsZScpKSB7XFxuICAgICAgICAgIF90aGlzMTEuZm9jdXMoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSk7XFxuXFxuICAgIE1vZGFsLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKHRhcmdldCksIGNvbmZpZywgdGhpcyk7XFxuICB9KTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBqUXVlcnlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuICAkLmZuW05BTUUkNV0gPSBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlO1xcbiAgJC5mbltOQU1FJDVdLkNvbnN0cnVjdG9yID0gTW9kYWw7XFxuXFxuICAkLmZuW05BTUUkNV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgJC5mbltOQU1FJDVdID0gSlFVRVJZX05PX0NPTkZMSUNUJDU7XFxuICAgIHJldHVybiBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjQuNC4xKTogdG9vbHMvc2FuaXRpemVyLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgdmFyIHVyaUF0dHJzID0gWydiYWNrZ3JvdW5kJywgJ2NpdGUnLCAnaHJlZicsICdpdGVtdHlwZScsICdsb25nZGVzYycsICdwb3N0ZXInLCAnc3JjJywgJ3hsaW5rOmhyZWYnXTtcXG4gIHZhciBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXFxcdy1dKiQvaTtcXG4gIHZhciBEZWZhdWx0V2hpdGVsaXN0ID0ge1xcbiAgICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxcbiAgICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxcbiAgICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxcbiAgICBhcmVhOiBbXSxcXG4gICAgYjogW10sXFxuICAgIGJyOiBbXSxcXG4gICAgY29sOiBbXSxcXG4gICAgY29kZTogW10sXFxuICAgIGRpdjogW10sXFxuICAgIGVtOiBbXSxcXG4gICAgaHI6IFtdLFxcbiAgICBoMTogW10sXFxuICAgIGgyOiBbXSxcXG4gICAgaDM6IFtdLFxcbiAgICBoNDogW10sXFxuICAgIGg1OiBbXSxcXG4gICAgaDY6IFtdLFxcbiAgICBpOiBbXSxcXG4gICAgaW1nOiBbJ3NyYycsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXFxuICAgIGxpOiBbXSxcXG4gICAgb2w6IFtdLFxcbiAgICBwOiBbXSxcXG4gICAgcHJlOiBbXSxcXG4gICAgczogW10sXFxuICAgIHNtYWxsOiBbXSxcXG4gICAgc3BhbjogW10sXFxuICAgIHN1YjogW10sXFxuICAgIHN1cDogW10sXFxuICAgIHN0cm9uZzogW10sXFxuICAgIHU6IFtdLFxcbiAgICB1bDogW11cXG4gIH07XFxuICAvKipcXG4gICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cXG4gICAqXFxuICAgKiBTaG91dG91dCB0byBBbmd1bGFyIDcgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzcuMi40L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXFxuICAgKi9cXG5cXG4gIHZhciBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteJjovPyNdKig/OlsvPyNdfCQpKS9naTtcXG4gIC8qKlxcbiAgICogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuXFxuICAgKlxcbiAgICogU2hvdXRvdXQgdG8gQW5ndWxhciA3IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi83LjIuNC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xcbiAgICovXFxuXFxuICB2YXIgREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTooPzppbWFnZVxcXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFxcXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFthLXowLTkrL10rPSokL2k7XFxuXFxuICBmdW5jdGlvbiBhbGxvd2VkQXR0cmlidXRlKGF0dHIsIGFsbG93ZWRBdHRyaWJ1dGVMaXN0KSB7XFxuICAgIHZhciBhdHRyTmFtZSA9IGF0dHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXG4gICAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluZGV4T2YoYXR0ck5hbWUpICE9PSAtMSkge1xcbiAgICAgIGlmICh1cmlBdHRycy5pbmRleE9mKGF0dHJOYW1lKSAhPT0gLTEpIHtcXG4gICAgICAgIHJldHVybiBCb29sZWFuKGF0dHIubm9kZVZhbHVlLm1hdGNoKFNBRkVfVVJMX1BBVFRFUk4pIHx8IGF0dHIubm9kZVZhbHVlLm1hdGNoKERBVEFfVVJMX1BBVFRFUk4pKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgdmFyIHJlZ0V4cCA9IGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihmdW5jdGlvbiAoYXR0clJlZ2V4KSB7XFxuICAgICAgcmV0dXJuIGF0dHJSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cDtcXG4gICAgfSk7IC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxcblxcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlZ0V4cC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICBpZiAoYXR0ck5hbWUubWF0Y2gocmVnRXhwW2ldKSkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sLCB3aGl0ZUxpc3QsIHNhbml0aXplRm4pIHtcXG4gICAgaWYgKHVuc2FmZUh0bWwubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuIHVuc2FmZUh0bWw7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNhbml0aXplRm4gJiYgdHlwZW9mIHNhbml0aXplRm4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICByZXR1cm4gc2FuaXRpemVGbih1bnNhZmVIdG1sKTtcXG4gICAgfVxcblxcbiAgICB2YXIgZG9tUGFyc2VyID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKTtcXG4gICAgdmFyIGNyZWF0ZWREb2N1bWVudCA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcodW5zYWZlSHRtbCwgJ3RleHQvaHRtbCcpO1xcbiAgICB2YXIgd2hpdGVsaXN0S2V5cyA9IE9iamVjdC5rZXlzKHdoaXRlTGlzdCk7XFxuICAgIHZhciBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcXG5cXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSwgbGVuKSB7XFxuICAgICAgdmFyIGVsID0gZWxlbWVudHNbaV07XFxuICAgICAgdmFyIGVsTmFtZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgICAgaWYgKHdoaXRlbGlzdEtleXMuaW5kZXhPZihlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcXG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xcbiAgICAgICAgcmV0dXJuIFxcXCJjb250aW51ZVxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBhdHRyaWJ1dGVMaXN0ID0gW10uc2xpY2UuY2FsbChlbC5hdHRyaWJ1dGVzKTtcXG4gICAgICB2YXIgd2hpdGVsaXN0ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KHdoaXRlTGlzdFsnKiddIHx8IFtdLCB3aGl0ZUxpc3RbZWxOYW1lXSB8fCBbXSk7XFxuICAgICAgYXR0cmlidXRlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XFxuICAgICAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGUoYXR0ciwgd2hpdGVsaXN0ZWRBdHRyaWJ1dGVzKSkge1xcbiAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoaSk7XFxuXFxuICAgICAgaWYgKF9yZXQgPT09IFxcXCJjb250aW51ZVxcXCIpIGNvbnRpbnVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUw7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQ29uc3RhbnRzXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgdmFyIE5BTUUkNiA9ICd0b29sdGlwJztcXG4gIHZhciBWRVJTSU9OJDYgPSAnNC40LjEnO1xcbiAgdmFyIERBVEFfS0VZJDYgPSAnYnMudG9vbHRpcCc7XFxuICB2YXIgRVZFTlRfS0VZJDYgPSBcXFwiLlxcXCIgKyBEQVRBX0tFWSQ2O1xcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCQ2ID0gJC5mbltOQU1FJDZdO1xcbiAgdmFyIENMQVNTX1BSRUZJWCA9ICdicy10b29sdGlwJztcXG4gIHZhciBCU0NMU19QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKFxcXCIoXnxcXFxcXFxcXHMpXFxcIiArIENMQVNTX1BSRUZJWCArIFxcXCJcXFxcXFxcXFMrXFxcIiwgJ2cnKTtcXG4gIHZhciBESVNBTExPV0VEX0FUVFJJQlVURVMgPSBbJ3Nhbml0aXplJywgJ3doaXRlTGlzdCcsICdzYW5pdGl6ZUZuJ107XFxuICB2YXIgRGVmYXVsdFR5cGUkNCA9IHtcXG4gICAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXFxuICAgIHRlbXBsYXRlOiAnc3RyaW5nJyxcXG4gICAgdGl0bGU6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJyxcXG4gICAgdHJpZ2dlcjogJ3N0cmluZycsXFxuICAgIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcXG4gICAgaHRtbDogJ2Jvb2xlYW4nLFxcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8Ym9vbGVhbiknLFxcbiAgICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXFxuICAgIG9mZnNldDogJyhudW1iZXJ8c3RyaW5nfGZ1bmN0aW9uKScsXFxuICAgIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXFxuICAgIGZhbGxiYWNrUGxhY2VtZW50OiAnKHN0cmluZ3xhcnJheSknLFxcbiAgICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknLFxcbiAgICBzYW5pdGl6ZTogJ2Jvb2xlYW4nLFxcbiAgICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcXG4gICAgd2hpdGVMaXN0OiAnb2JqZWN0JyxcXG4gICAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0KSdcXG4gIH07XFxuICB2YXIgQXR0YWNobWVudE1hcCQxID0ge1xcbiAgICBBVVRPOiAnYXV0bycsXFxuICAgIFRPUDogJ3RvcCcsXFxuICAgIFJJR0hUOiAncmlnaHQnLFxcbiAgICBCT1RUT006ICdib3R0b20nLFxcbiAgICBMRUZUOiAnbGVmdCdcXG4gIH07XFxuICB2YXIgRGVmYXVsdCQ0ID0ge1xcbiAgICBhbmltYXRpb246IHRydWUsXFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cXFwidG9vbHRpcFxcXCIgcm9sZT1cXFwidG9vbHRpcFxcXCI+JyArICc8ZGl2IGNsYXNzPVxcXCJhcnJvd1xcXCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWlubmVyXFxcIj48L2Rpdj48L2Rpdj4nLFxcbiAgICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnLFxcbiAgICB0aXRsZTogJycsXFxuICAgIGRlbGF5OiAwLFxcbiAgICBodG1sOiBmYWxzZSxcXG4gICAgc2VsZWN0b3I6IGZhbHNlLFxcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxcbiAgICBvZmZzZXQ6IDAsXFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXFxuICAgIGZhbGxiYWNrUGxhY2VtZW50OiAnZmxpcCcsXFxuICAgIGJvdW5kYXJ5OiAnc2Nyb2xsUGFyZW50JyxcXG4gICAgc2FuaXRpemU6IHRydWUsXFxuICAgIHNhbml0aXplRm46IG51bGwsXFxuICAgIHdoaXRlTGlzdDogRGVmYXVsdFdoaXRlbGlzdCxcXG4gICAgcG9wcGVyQ29uZmlnOiBudWxsXFxuICB9O1xcbiAgdmFyIEhvdmVyU3RhdGUgPSB7XFxuICAgIFNIT1c6ICdzaG93JyxcXG4gICAgT1VUOiAnb3V0J1xcbiAgfTtcXG4gIHZhciBFdmVudCQ2ID0ge1xcbiAgICBISURFOiBcXFwiaGlkZVxcXCIgKyBFVkVOVF9LRVkkNixcXG4gICAgSElEREVOOiBcXFwiaGlkZGVuXFxcIiArIEVWRU5UX0tFWSQ2LFxcbiAgICBTSE9XOiBcXFwic2hvd1xcXCIgKyBFVkVOVF9LRVkkNixcXG4gICAgU0hPV046IFxcXCJzaG93blxcXCIgKyBFVkVOVF9LRVkkNixcXG4gICAgSU5TRVJURUQ6IFxcXCJpbnNlcnRlZFxcXCIgKyBFVkVOVF9LRVkkNixcXG4gICAgQ0xJQ0s6IFxcXCJjbGlja1xcXCIgKyBFVkVOVF9LRVkkNixcXG4gICAgRk9DVVNJTjogXFxcImZvY3VzaW5cXFwiICsgRVZFTlRfS0VZJDYsXFxuICAgIEZPQ1VTT1VUOiBcXFwiZm9jdXNvdXRcXFwiICsgRVZFTlRfS0VZJDYsXFxuICAgIE1PVVNFRU5URVI6IFxcXCJtb3VzZWVudGVyXFxcIiArIEVWRU5UX0tFWSQ2LFxcbiAgICBNT1VTRUxFQVZFOiBcXFwibW91c2VsZWF2ZVxcXCIgKyBFVkVOVF9LRVkkNlxcbiAgfTtcXG4gIHZhciBDbGFzc05hbWUkNiA9IHtcXG4gICAgRkFERTogJ2ZhZGUnLFxcbiAgICBTSE9XOiAnc2hvdydcXG4gIH07XFxuICB2YXIgU2VsZWN0b3IkNiA9IHtcXG4gICAgVE9PTFRJUDogJy50b29sdGlwJyxcXG4gICAgVE9PTFRJUF9JTk5FUjogJy50b29sdGlwLWlubmVyJyxcXG4gICAgQVJST1c6ICcuYXJyb3cnXFxuICB9O1xcbiAgdmFyIFRyaWdnZXIgPSB7XFxuICAgIEhPVkVSOiAnaG92ZXInLFxcbiAgICBGT0NVUzogJ2ZvY3VzJyxcXG4gICAgQ0xJQ0s6ICdjbGljaycsXFxuICAgIE1BTlVBTDogJ21hbnVhbCdcXG4gIH07XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQ2xhc3MgRGVmaW5pdGlvblxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gIHZhciBUb29sdGlwID1cXG4gIC8qI19fUFVSRV9fKi9cXG4gIGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gVG9vbHRpcChlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlci5qcyAoaHR0cHM6Ly9wb3BwZXIuanMub3JnLyknKTtcXG4gICAgICB9IC8vIHByaXZhdGVcXG5cXG5cXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSAnJztcXG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge307XFxuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDsgLy8gUHJvdGVjdGVkXFxuXFxuICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLmNvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xcbiAgICAgIHRoaXMudGlwID0gbnVsbDtcXG5cXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHZhciBfcHJvdG8gPSBUb29sdGlwLnByb3RvdHlwZTtcXG5cXG4gICAgLy8gUHVibGljXFxuICAgIF9wcm90by5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XFxuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8udG9nZ2xlRW5hYmxlZCA9IGZ1bmN0aW9uIHRvZ2dsZUVuYWJsZWQoKSB7XFxuICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZShldmVudCkge1xcbiAgICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChldmVudCkge1xcbiAgICAgICAgdmFyIGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZO1xcbiAgICAgICAgdmFyIGNvbnRleHQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSk7XFxuXFxuICAgICAgICBpZiAoIWNvbnRleHQpIHtcXG4gICAgICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGV2ZW50LmN1cnJlbnRUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpO1xcbiAgICAgICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSwgY29udGV4dCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWNvbnRleHQuX2FjdGl2ZVRyaWdnZXIuY2xpY2s7XFxuXFxuICAgICAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XFxuICAgICAgICAgIGNvbnRleHQuX2VudGVyKG51bGwsIGNvbnRleHQpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgY29udGV4dC5fbGVhdmUobnVsbCwgY29udGV4dCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICgkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5oYXNDbGFzcyhDbGFzc05hbWUkNi5TSE9XKSkge1xcbiAgICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcXG5cXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fZW50ZXIobnVsbCwgdGhpcyk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLmVsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpO1xcbiAgICAgICQodGhpcy5lbGVtZW50KS5vZmYodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpO1xcbiAgICAgICQodGhpcy5lbGVtZW50KS5jbG9zZXN0KCcubW9kYWwnKS5vZmYoJ2hpZGUuYnMubW9kYWwnLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKTtcXG5cXG4gICAgICBpZiAodGhpcy50aXApIHtcXG4gICAgICAgICQodGhpcy50aXApLnJlbW92ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSBudWxsO1xcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsO1xcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSBudWxsO1xcblxcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcXG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XFxuICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcXG4gICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XFxuICAgICAgdGhpcy50aXAgPSBudWxsO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICBpZiAoJCh0aGlzLmVsZW1lbnQpLmNzcygnZGlzcGxheScpID09PSAnbm9uZScpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XKTtcXG5cXG4gICAgICBpZiAodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSB7XFxuICAgICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xcbiAgICAgICAgdmFyIHNoYWRvd1Jvb3QgPSBVdGlsLmZpbmRTaGFkb3dSb290KHRoaXMuZWxlbWVudCk7XFxuICAgICAgICB2YXIgaXNJblRoZURvbSA9ICQuY29udGFpbnMoc2hhZG93Um9vdCAhPT0gbnVsbCA/IHNoYWRvd1Jvb3QgOiB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuZWxlbWVudCk7XFxuXFxuICAgICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8ICFpc0luVGhlRG9tKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcXG4gICAgICAgIHZhciB0aXBJZCA9IFV0aWwuZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSk7XFxuICAgICAgICB0aXAuc2V0QXR0cmlidXRlKCdpZCcsIHRpcElkKTtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXBJZCk7XFxuICAgICAgICB0aGlzLnNldENvbnRlbnQoKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hbmltYXRpb24pIHtcXG4gICAgICAgICAgJCh0aXApLmFkZENsYXNzKENsYXNzTmFtZSQ2LkZBREUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLmNvbmZpZy5wbGFjZW1lbnQgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNvbmZpZy5wbGFjZW1lbnQuY2FsbCh0aGlzLCB0aXAsIHRoaXMuZWxlbWVudCkgOiB0aGlzLmNvbmZpZy5wbGFjZW1lbnQ7XFxuXFxuICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoaXMuX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KTtcXG5cXG4gICAgICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpO1xcblxcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xcblxcbiAgICAgICAgJCh0aXApLmRhdGEodGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XFxuXFxuICAgICAgICBpZiAoISQuY29udGFpbnModGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLnRpcCkpIHtcXG4gICAgICAgICAgJCh0aXApLmFwcGVuZFRvKGNvbnRhaW5lcik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKTtcXG4gICAgICAgIHRoaXMuX3BvcHBlciA9IG5ldyBQb3BwZXIodGhpcy5lbGVtZW50LCB0aXAsIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSk7XFxuICAgICAgICAkKHRpcCkuYWRkQ2xhc3MoQ2xhc3NOYW1lJDYuU0hPVyk7IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcXG4gICAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XFxuICAgICAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXFxuXFxuICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XFxuICAgICAgICAgICQoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vbignbW91c2VvdmVyJywgbnVsbCwgJC5ub29wKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xcbiAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmFuaW1hdGlvbikge1xcbiAgICAgICAgICAgIF90aGlzLl9maXhUcmFuc2l0aW9uKCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFyIHByZXZIb3ZlclN0YXRlID0gX3RoaXMuX2hvdmVyU3RhdGU7XFxuICAgICAgICAgIF90aGlzLl9ob3ZlclN0YXRlID0gbnVsbDtcXG4gICAgICAgICAgJChfdGhpcy5lbGVtZW50KS50cmlnZ2VyKF90aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1dOKTtcXG5cXG4gICAgICAgICAgaWYgKHByZXZIb3ZlclN0YXRlID09PSBIb3ZlclN0YXRlLk9VVCkge1xcbiAgICAgICAgICAgIF90aGlzLl9sZWF2ZShudWxsLCBfdGhpcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBpZiAoJCh0aGlzLnRpcCkuaGFzQ2xhc3MoQ2xhc3NOYW1lJDYuRkFERSkpIHtcXG4gICAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy50aXApO1xcbiAgICAgICAgICAkKHRoaXMudGlwKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjb21wbGV0ZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xcbiAgICAgIHZhciBoaWRlRXZlbnQgPSAkLkV2ZW50KHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElERSk7XFxuXFxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XFxuICAgICAgICBpZiAoX3RoaXMyLl9ob3ZlclN0YXRlICE9PSBIb3ZlclN0YXRlLlNIT1cgJiYgdGlwLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgdGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGlwKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIF90aGlzMi5fY2xlYW5UaXBDbGFzcygpO1xcblxcbiAgICAgICAgX3RoaXMyLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XFxuXFxuICAgICAgICAkKF90aGlzMi5lbGVtZW50KS50cmlnZ2VyKF90aGlzMi5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pO1xcblxcbiAgICAgICAgaWYgKF90aGlzMi5fcG9wcGVyICE9PSBudWxsKSB7XFxuICAgICAgICAgIF90aGlzMi5fcG9wcGVyLmRlc3Ryb3koKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xcbiAgICAgICAgICBjYWxsYmFjaygpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcXG5cXG4gICAgICBpZiAoaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgICQodGlwKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkNi5TSE9XKTsgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxcblxcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgICAgICQoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVHJpZ2dlci5DTElDS10gPSBmYWxzZTtcXG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RyaWdnZXIuRk9DVVNdID0gZmFsc2U7XFxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUcmlnZ2VyLkhPVkVSXSA9IGZhbHNlO1xcblxcbiAgICAgIGlmICgkKHRoaXMudGlwKS5oYXNDbGFzcyhDbGFzc05hbWUkNi5GQURFKSkge1xcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGlwKTtcXG4gICAgICAgICQodGlwKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbXBsZXRlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSAnJztcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcXG4gICAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XFxuICAgICAgICB0aGlzLl9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKTtcXG4gICAgICB9XFxuICAgIH0gLy8gUHJvdGVjdGVkXFxuICAgIDtcXG5cXG4gICAgX3Byb3RvLmlzV2l0aENvbnRlbnQgPSBmdW5jdGlvbiBpc1dpdGhDb250ZW50KCkge1xcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0VGl0bGUoKSk7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5hZGRBdHRhY2htZW50Q2xhc3MgPSBmdW5jdGlvbiBhZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudCkge1xcbiAgICAgICQodGhpcy5nZXRUaXBFbGVtZW50KCkpLmFkZENsYXNzKENMQVNTX1BSRUZJWCArIFxcXCItXFxcIiArIGF0dGFjaG1lbnQpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uZ2V0VGlwRWxlbWVudCA9IGZ1bmN0aW9uIGdldFRpcEVsZW1lbnQoKSB7XFxuICAgICAgdGhpcy50aXAgPSB0aGlzLnRpcCB8fCAkKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXTtcXG4gICAgICByZXR1cm4gdGhpcy50aXA7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5zZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudCgpIHtcXG4gICAgICB2YXIgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KCk7XFxuICAgICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkKHRpcC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yJDYuVE9PTFRJUF9JTk5FUikpLCB0aGlzLmdldFRpdGxlKCkpO1xcbiAgICAgICQodGlwKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkNi5GQURFICsgXFxcIiBcXFwiICsgQ2xhc3NOYW1lJDYuU0hPVyk7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5zZXRFbGVtZW50Q29udGVudCA9IGZ1bmN0aW9uIHNldEVsZW1lbnRDb250ZW50KCRlbGVtZW50LCBjb250ZW50KSB7XFxuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0JyAmJiAoY29udGVudC5ub2RlVHlwZSB8fCBjb250ZW50LmpxdWVyeSkpIHtcXG4gICAgICAgIC8vIENvbnRlbnQgaXMgYSBET00gbm9kZSBvciBhIGpRdWVyeVxcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmh0bWwpIHtcXG4gICAgICAgICAgaWYgKCEkKGNvbnRlbnQpLnBhcmVudCgpLmlzKCRlbGVtZW50KSkge1xcbiAgICAgICAgICAgICRlbGVtZW50LmVtcHR5KCkuYXBwZW5kKGNvbnRlbnQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAkZWxlbWVudC50ZXh0KCQoY29udGVudCkudGV4dCgpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuY29uZmlnLmh0bWwpIHtcXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5zYW5pdGl6ZSkge1xcbiAgICAgICAgICBjb250ZW50ID0gc2FuaXRpemVIdG1sKGNvbnRlbnQsIHRoaXMuY29uZmlnLndoaXRlTGlzdCwgdGhpcy5jb25maWcuc2FuaXRpemVGbik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkZWxlbWVudC5odG1sKGNvbnRlbnQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAkZWxlbWVudC50ZXh0KGNvbnRlbnQpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLmdldFRpdGxlID0gZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XFxuICAgICAgdmFyIHRpdGxlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpO1xcblxcbiAgICAgIGlmICghdGl0bGUpIHtcXG4gICAgICAgIHRpdGxlID0gdHlwZW9mIHRoaXMuY29uZmlnLnRpdGxlID09PSAnZnVuY3Rpb24nID8gdGhpcy5jb25maWcudGl0bGUuY2FsbCh0aGlzLmVsZW1lbnQpIDogdGhpcy5jb25maWcudGl0bGU7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aXRsZTtcXG4gICAgfSAvLyBQcml2YXRlXFxuICAgIDtcXG5cXG4gICAgX3Byb3RvLl9nZXRQb3BwZXJDb25maWcgPSBmdW5jdGlvbiBfZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICB2YXIgZGVmYXVsdEJzQ29uZmlnID0ge1xcbiAgICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxcbiAgICAgICAgbW9kaWZpZXJzOiB7XFxuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KCksXFxuICAgICAgICAgIGZsaXA6IHtcXG4gICAgICAgICAgICBiZWhhdmlvcjogdGhpcy5jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgYXJyb3c6IHtcXG4gICAgICAgICAgICBlbGVtZW50OiBTZWxlY3RvciQ2LkFSUk9XXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xcbiAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLmNvbmZpZy5ib3VuZGFyeVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKGRhdGEpIHtcXG4gICAgICAgICAgaWYgKGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgIT09IGRhdGEucGxhY2VtZW50KSB7XFxuICAgICAgICAgICAgX3RoaXMzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSkge1xcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRCc0NvbmZpZywge30sIHRoaXMuY29uZmlnLnBvcHBlckNvbmZpZyk7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gX2dldE9mZnNldCgpIHtcXG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcXG5cXG4gICAgICB2YXIgb2Zmc2V0ID0ge307XFxuXFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5vZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIG9mZnNldC5mbiA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgICAgIGRhdGEub2Zmc2V0cyA9IF9vYmplY3RTcHJlYWQyKHt9LCBkYXRhLm9mZnNldHMsIHt9LCBfdGhpczQuY29uZmlnLm9mZnNldChkYXRhLm9mZnNldHMsIF90aGlzNC5lbGVtZW50KSB8fCB7fSk7XFxuICAgICAgICAgIHJldHVybiBkYXRhO1xcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb2Zmc2V0Lm9mZnNldCA9IHRoaXMuY29uZmlnLm9mZnNldDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG9mZnNldDtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9nZXRDb250YWluZXIgPSBmdW5jdGlvbiBfZ2V0Q29udGFpbmVyKCkge1xcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlKSB7XFxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKFV0aWwuaXNFbGVtZW50KHRoaXMuY29uZmlnLmNvbnRhaW5lcikpIHtcXG4gICAgICAgIHJldHVybiAkKHRoaXMuY29uZmlnLmNvbnRhaW5lcik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiAkKGRvY3VtZW50KS5maW5kKHRoaXMuY29uZmlnLmNvbnRhaW5lcik7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fZ2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uIF9nZXRBdHRhY2htZW50KHBsYWNlbWVudCkge1xcbiAgICAgIHJldHVybiBBdHRhY2htZW50TWFwJDFbcGxhY2VtZW50LnRvVXBwZXJDYXNlKCldO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX3NldExpc3RlbmVycyA9IGZ1bmN0aW9uIF9zZXRMaXN0ZW5lcnMoKSB7XFxuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIHRyaWdnZXJzID0gdGhpcy5jb25maWcudHJpZ2dlci5zcGxpdCgnICcpO1xcbiAgICAgIHRyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcXG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XFxuICAgICAgICAgICQoX3RoaXM1LmVsZW1lbnQpLm9uKF90aGlzNS5jb25zdHJ1Y3Rvci5FdmVudC5DTElDSywgX3RoaXM1LmNvbmZpZy5zZWxlY3RvciwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgICAgcmV0dXJuIF90aGlzNS50b2dnbGUoZXZlbnQpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPT0gVHJpZ2dlci5NQU5VQUwpIHtcXG4gICAgICAgICAgdmFyIGV2ZW50SW4gPSB0cmlnZ2VyID09PSBUcmlnZ2VyLkhPVkVSID8gX3RoaXM1LmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFRU5URVIgOiBfdGhpczUuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTjtcXG4gICAgICAgICAgdmFyIGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVHJpZ2dlci5IT1ZFUiA/IF90aGlzNS5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogX3RoaXM1LmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUO1xcbiAgICAgICAgICAkKF90aGlzNS5lbGVtZW50KS5vbihldmVudEluLCBfdGhpczUuY29uZmlnLnNlbGVjdG9yLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM1Ll9lbnRlcihldmVudCk7XFxuICAgICAgICAgIH0pLm9uKGV2ZW50T3V0LCBfdGhpczUuY29uZmlnLnNlbGVjdG9yLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM1Ll9sZWF2ZShldmVudCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoX3RoaXM1LmVsZW1lbnQpIHtcXG4gICAgICAgICAgX3RoaXM1LmhpZGUoKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgICQodGhpcy5lbGVtZW50KS5jbG9zZXN0KCcubW9kYWwnKS5vbignaGlkZS5icy5tb2RhbCcsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xcblxcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5zZWxlY3Rvcikge1xcbiAgICAgICAgdGhpcy5jb25maWcgPSBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5jb25maWcsIHtcXG4gICAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXFxuICAgICAgICAgIHNlbGVjdG9yOiAnJ1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX2ZpeFRpdGxlKCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2ZpeFRpdGxlID0gZnVuY3Rpb24gX2ZpeFRpdGxlKCkge1xcbiAgICAgIHZhciB0aXRsZVR5cGUgPSB0eXBlb2YgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpO1xcblxcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IHRpdGxlVHlwZSAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8ICcnKTtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJycpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9lbnRlciA9IGZ1bmN0aW9uIF9lbnRlcihldmVudCwgY29udGV4dCkge1xcbiAgICAgIHZhciBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWTtcXG4gICAgICBjb250ZXh0ID0gY29udGV4dCB8fCAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSk7XFxuXFxuICAgICAgaWYgKCFjb250ZXh0KSB7XFxuICAgICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XFxuICAgICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSwgY29udGV4dCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChldmVudCkge1xcbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNpbicgPyBUcmlnZ2VyLkZPQ1VTIDogVHJpZ2dlci5IT1ZFUl0gPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJChjb250ZXh0LmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ2xhc3NOYW1lJDYuU0hPVykgfHwgY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSG92ZXJTdGF0ZS5TSE9XKSB7XFxuICAgICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSG92ZXJTdGF0ZS5TSE9XO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5fdGltZW91dCk7XFxuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhvdmVyU3RhdGUuU0hPVztcXG5cXG4gICAgICBpZiAoIWNvbnRleHQuY29uZmlnLmRlbGF5IHx8ICFjb250ZXh0LmNvbmZpZy5kZWxheS5zaG93KSB7XFxuICAgICAgICBjb250ZXh0LnNob3coKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhvdmVyU3RhdGUuU0hPVykge1xcbiAgICAgICAgICBjb250ZXh0LnNob3coKTtcXG4gICAgICAgIH1cXG4gICAgICB9LCBjb250ZXh0LmNvbmZpZy5kZWxheS5zaG93KTtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9sZWF2ZSA9IGZ1bmN0aW9uIF9sZWF2ZShldmVudCwgY29udGV4dCkge1xcbiAgICAgIHZhciBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWTtcXG4gICAgICBjb250ZXh0ID0gY29udGV4dCB8fCAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSk7XFxuXFxuICAgICAgaWYgKCFjb250ZXh0KSB7XFxuICAgICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XFxuICAgICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSwgY29udGV4dCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChldmVudCkge1xcbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVHJpZ2dlci5GT0NVUyA6IFRyaWdnZXIuSE9WRVJdID0gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xcbiAgICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIb3ZlclN0YXRlLk9VVDtcXG5cXG4gICAgICBpZiAoIWNvbnRleHQuY29uZmlnLmRlbGF5IHx8ICFjb250ZXh0LmNvbmZpZy5kZWxheS5oaWRlKSB7XFxuICAgICAgICBjb250ZXh0LmhpZGUoKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhvdmVyU3RhdGUuT1VUKSB7XFxuICAgICAgICAgIGNvbnRleHQuaGlkZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIGNvbnRleHQuY29uZmlnLmRlbGF5LmhpZGUpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2lzV2l0aEFjdGl2ZVRyaWdnZXIgPSBmdW5jdGlvbiBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcXG4gICAgICBmb3IgKHZhciB0cmlnZ2VyIGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpIHtcXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RyaWdnZXJdKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgICB2YXIgZGF0YUF0dHJpYnV0ZXMgPSAkKHRoaXMuZWxlbWVudCkuZGF0YSgpO1xcbiAgICAgIE9iamVjdC5rZXlzKGRhdGFBdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhQXR0cikge1xcbiAgICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5pbmRleE9mKGRhdGFBdHRyKSAhPT0gLTEpIHtcXG4gICAgICAgICAgZGVsZXRlIGRhdGFBdHRyaWJ1dGVzW2RhdGFBdHRyXTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICBjb25maWcgPSBfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LCB7fSwgZGF0YUF0dHJpYnV0ZXMsIHt9LCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XFxuICAgICAgICBjb25maWcuZGVsYXkgPSB7XFxuICAgICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcXG4gICAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50aXRsZSA9PT0gJ251bWJlcicpIHtcXG4gICAgICAgIGNvbmZpZy50aXRsZSA9IGNvbmZpZy50aXRsZS50b1N0cmluZygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgY29uZmlnLmNvbnRlbnQgPSBjb25maWcuY29udGVudC50b1N0cmluZygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FJDYsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XFxuXFxuICAgICAgaWYgKGNvbmZpZy5zYW5pdGl6ZSkge1xcbiAgICAgICAgY29uZmlnLnRlbXBsYXRlID0gc2FuaXRpemVIdG1sKGNvbmZpZy50ZW1wbGF0ZSwgY29uZmlnLndoaXRlTGlzdCwgY29uZmlnLnNhbml0aXplRm4pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gY29uZmlnO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2dldERlbGVnYXRlQ29uZmlnID0gZnVuY3Rpb24gX2dldERlbGVnYXRlQ29uZmlnKCkge1xcbiAgICAgIHZhciBjb25maWcgPSB7fTtcXG5cXG4gICAgICBpZiAodGhpcy5jb25maWcpIHtcXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbmZpZykge1xcbiAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2tleV0gIT09IHRoaXMuY29uZmlnW2tleV0pIHtcXG4gICAgICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuY29uZmlnW2tleV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9jbGVhblRpcENsYXNzID0gZnVuY3Rpb24gX2NsZWFuVGlwQ2xhc3MoKSB7XFxuICAgICAgdmFyICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcXG4gICAgICB2YXIgdGFiQ2xhc3MgPSAkdGlwLmF0dHIoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYKTtcXG5cXG4gICAgICBpZiAodGFiQ2xhc3MgIT09IG51bGwgJiYgdGFiQ2xhc3MubGVuZ3RoKSB7XFxuICAgICAgICAkdGlwLnJlbW92ZUNsYXNzKHRhYkNsYXNzLmpvaW4oJycpKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlID0gZnVuY3Rpb24gX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShwb3BwZXJEYXRhKSB7XFxuICAgICAgdmFyIHBvcHBlckluc3RhbmNlID0gcG9wcGVyRGF0YS5pbnN0YW5jZTtcXG4gICAgICB0aGlzLnRpcCA9IHBvcHBlckluc3RhbmNlLnBvcHBlcjtcXG5cXG4gICAgICB0aGlzLl9jbGVhblRpcENsYXNzKCk7XFxuXFxuICAgICAgdGhpcy5hZGRBdHRhY2htZW50Q2xhc3ModGhpcy5fZ2V0QXR0YWNobWVudChwb3BwZXJEYXRhLnBsYWNlbWVudCkpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2ZpeFRyYW5zaXRpb24gPSBmdW5jdGlvbiBfZml4VHJhbnNpdGlvbigpIHtcXG4gICAgICB2YXIgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KCk7XFxuICAgICAgdmFyIGluaXRDb25maWdBbmltYXRpb24gPSB0aGlzLmNvbmZpZy5hbmltYXRpb247XFxuXFxuICAgICAgaWYgKHRpcC5nZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JykgIT09IG51bGwpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgJCh0aXApLnJlbW92ZUNsYXNzKENsYXNzTmFtZSQ2LkZBREUpO1xcbiAgICAgIHRoaXMuY29uZmlnLmFuaW1hdGlvbiA9IGZhbHNlO1xcbiAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgIHRoaXMuc2hvdygpO1xcbiAgICAgIHRoaXMuY29uZmlnLmFuaW1hdGlvbiA9IGluaXRDb25maWdBbmltYXRpb247XFxuICAgIH0gLy8gU3RhdGljXFxuICAgIDtcXG5cXG4gICAgVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZJDYpO1xcblxcbiAgICAgICAgdmFyIF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWc7XFxuXFxuICAgICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghZGF0YSkge1xcbiAgICAgICAgICBkYXRhID0gbmV3IFRvb2x0aXAodGhpcywgX2NvbmZpZyk7XFxuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSQ2LCBkYXRhKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJObyBtZXRob2QgbmFtZWQgXFxcXFxcXCJcXFwiICsgY29uZmlnICsgXFxcIlxcXFxcXFwiXFxcIik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBudWxsLCBbe1xcbiAgICAgIGtleTogXFxcIlZFUlNJT05cXFwiLFxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIFZFUlNJT04kNjtcXG4gICAgICB9XFxuICAgIH0sIHtcXG4gICAgICBrZXk6IFxcXCJEZWZhdWx0XFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBEZWZhdWx0JDQ7XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiTkFNRVxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gTkFNRSQ2O1xcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcIkRBVEFfS0VZXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBEQVRBX0tFWSQ2O1xcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcIkV2ZW50XFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBFdmVudCQ2O1xcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcIkVWRU5UX0tFWVxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gRVZFTlRfS0VZJDY7XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiRGVmYXVsdFR5cGVcXFwiLFxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDQ7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBUb29sdGlwO1xcbiAgfSgpO1xcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIGpRdWVyeVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG5cXG4gICQuZm5bTkFNRSQ2XSA9IFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZTtcXG4gICQuZm5bTkFNRSQ2XS5Db25zdHJ1Y3RvciA9IFRvb2x0aXA7XFxuXFxuICAkLmZuW05BTUUkNl0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgJC5mbltOQU1FJDZdID0gSlFVRVJZX05PX0NPTkZMSUNUJDY7XFxuICAgIHJldHVybiBUb29sdGlwLl9qUXVlcnlJbnRlcmZhY2U7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIENvbnN0YW50c1xcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gIHZhciBOQU1FJDcgPSAncG9wb3Zlcic7XFxuICB2YXIgVkVSU0lPTiQ3ID0gJzQuNC4xJztcXG4gIHZhciBEQVRBX0tFWSQ3ID0gJ2JzLnBvcG92ZXInO1xcbiAgdmFyIEVWRU5UX0tFWSQ3ID0gXFxcIi5cXFwiICsgREFUQV9LRVkkNztcXG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QkNyA9ICQuZm5bTkFNRSQ3XTtcXG4gIHZhciBDTEFTU19QUkVGSVgkMSA9ICdicy1wb3BvdmVyJztcXG4gIHZhciBCU0NMU19QUkVGSVhfUkVHRVgkMSA9IG5ldyBSZWdFeHAoXFxcIihefFxcXFxcXFxccylcXFwiICsgQ0xBU1NfUFJFRklYJDEgKyBcXFwiXFxcXFxcXFxTK1xcXCIsICdnJyk7XFxuXFxuICB2YXIgRGVmYXVsdCQ1ID0gX29iamVjdFNwcmVhZDIoe30sIFRvb2x0aXAuRGVmYXVsdCwge1xcbiAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXFxuICAgIHRyaWdnZXI6ICdjbGljaycsXFxuICAgIGNvbnRlbnQ6ICcnLFxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XFxcInBvcG92ZXJcXFwiIHJvbGU9XFxcInRvb2x0aXBcXFwiPicgKyAnPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PicgKyAnPGgzIGNsYXNzPVxcXCJwb3BvdmVyLWhlYWRlclxcXCI+PC9oMz4nICsgJzxkaXYgY2xhc3M9XFxcInBvcG92ZXItYm9keVxcXCI+PC9kaXY+PC9kaXY+J1xcbiAgfSk7XFxuXFxuICB2YXIgRGVmYXVsdFR5cGUkNSA9IF9vYmplY3RTcHJlYWQyKHt9LCBUb29sdGlwLkRlZmF1bHRUeXBlLCB7XFxuICAgIGNvbnRlbnQ6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJ1xcbiAgfSk7XFxuXFxuICB2YXIgQ2xhc3NOYW1lJDcgPSB7XFxuICAgIEZBREU6ICdmYWRlJyxcXG4gICAgU0hPVzogJ3Nob3cnXFxuICB9O1xcbiAgdmFyIFNlbGVjdG9yJDcgPSB7XFxuICAgIFRJVExFOiAnLnBvcG92ZXItaGVhZGVyJyxcXG4gICAgQ09OVEVOVDogJy5wb3BvdmVyLWJvZHknXFxuICB9O1xcbiAgdmFyIEV2ZW50JDcgPSB7XFxuICAgIEhJREU6IFxcXCJoaWRlXFxcIiArIEVWRU5UX0tFWSQ3LFxcbiAgICBISURERU46IFxcXCJoaWRkZW5cXFwiICsgRVZFTlRfS0VZJDcsXFxuICAgIFNIT1c6IFxcXCJzaG93XFxcIiArIEVWRU5UX0tFWSQ3LFxcbiAgICBTSE9XTjogXFxcInNob3duXFxcIiArIEVWRU5UX0tFWSQ3LFxcbiAgICBJTlNFUlRFRDogXFxcImluc2VydGVkXFxcIiArIEVWRU5UX0tFWSQ3LFxcbiAgICBDTElDSzogXFxcImNsaWNrXFxcIiArIEVWRU5UX0tFWSQ3LFxcbiAgICBGT0NVU0lOOiBcXFwiZm9jdXNpblxcXCIgKyBFVkVOVF9LRVkkNyxcXG4gICAgRk9DVVNPVVQ6IFxcXCJmb2N1c291dFxcXCIgKyBFVkVOVF9LRVkkNyxcXG4gICAgTU9VU0VFTlRFUjogXFxcIm1vdXNlZW50ZXJcXFwiICsgRVZFTlRfS0VZJDcsXFxuICAgIE1PVVNFTEVBVkU6IFxcXCJtb3VzZWxlYXZlXFxcIiArIEVWRU5UX0tFWSQ3XFxuICB9O1xcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIENsYXNzIERlZmluaXRpb25cXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuICB2YXIgUG9wb3ZlciA9XFxuICAvKiNfX1BVUkVfXyovXFxuICBmdW5jdGlvbiAoX1Rvb2x0aXApIHtcXG4gICAgX2luaGVyaXRzTG9vc2UoUG9wb3ZlciwgX1Rvb2x0aXApO1xcblxcbiAgICBmdW5jdGlvbiBQb3BvdmVyKCkge1xcbiAgICAgIHJldHVybiBfVG9vbHRpcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XFxuICAgIH1cXG5cXG4gICAgdmFyIF9wcm90byA9IFBvcG92ZXIucHJvdG90eXBlO1xcblxcbiAgICAvLyBPdmVycmlkZXNcXG4gICAgX3Byb3RvLmlzV2l0aENvbnRlbnQgPSBmdW5jdGlvbiBpc1dpdGhDb250ZW50KCkge1xcbiAgICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5fZ2V0Q29udGVudCgpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uYWRkQXR0YWNobWVudENsYXNzID0gZnVuY3Rpb24gYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpIHtcXG4gICAgICAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhDTEFTU19QUkVGSVgkMSArIFxcXCItXFxcIiArIGF0dGFjaG1lbnQpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uZ2V0VGlwRWxlbWVudCA9IGZ1bmN0aW9uIGdldFRpcEVsZW1lbnQoKSB7XFxuICAgICAgdGhpcy50aXAgPSB0aGlzLnRpcCB8fCAkKHRoaXMuY29uZmlnLnRlbXBsYXRlKVswXTtcXG4gICAgICByZXR1cm4gdGhpcy50aXA7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5zZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudCgpIHtcXG4gICAgICB2YXIgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpOyAvLyBXZSB1c2UgYXBwZW5kIGZvciBodG1sIG9iamVjdHMgdG8gbWFpbnRhaW4ganMgZXZlbnRzXFxuXFxuICAgICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkdGlwLmZpbmQoU2VsZWN0b3IkNy5USVRMRSksIHRoaXMuZ2V0VGl0bGUoKSk7XFxuXFxuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9nZXRDb250ZW50KCk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBjb250ZW50ID0gY29udGVudC5jYWxsKHRoaXMuZWxlbWVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoJHRpcC5maW5kKFNlbGVjdG9yJDcuQ09OVEVOVCksIGNvbnRlbnQpO1xcbiAgICAgICR0aXAucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lJDcuRkFERSArIFxcXCIgXFxcIiArIENsYXNzTmFtZSQ3LlNIT1cpO1xcbiAgICB9IC8vIFByaXZhdGVcXG4gICAgO1xcblxcbiAgICBfcHJvdG8uX2dldENvbnRlbnQgPSBmdW5jdGlvbiBfZ2V0Q29udGVudCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb250ZW50JykgfHwgdGhpcy5jb25maWcuY29udGVudDtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9jbGVhblRpcENsYXNzID0gZnVuY3Rpb24gX2NsZWFuVGlwQ2xhc3MoKSB7XFxuICAgICAgdmFyICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTtcXG4gICAgICB2YXIgdGFiQ2xhc3MgPSAkdGlwLmF0dHIoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYJDEpO1xcblxcbiAgICAgIGlmICh0YWJDbGFzcyAhPT0gbnVsbCAmJiB0YWJDbGFzcy5sZW5ndGggPiAwKSB7XFxuICAgICAgICAkdGlwLnJlbW92ZUNsYXNzKHRhYkNsYXNzLmpvaW4oJycpKTtcXG4gICAgICB9XFxuICAgIH0gLy8gU3RhdGljXFxuICAgIDtcXG5cXG4gICAgUG9wb3Zlci5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZJDcpO1xcblxcbiAgICAgICAgdmFyIF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGw7XFxuXFxuICAgICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghZGF0YSkge1xcbiAgICAgICAgICBkYXRhID0gbmV3IFBvcG92ZXIodGhpcywgX2NvbmZpZyk7XFxuICAgICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSQ3LCBkYXRhKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJObyBtZXRob2QgbmFtZWQgXFxcXFxcXCJcXFwiICsgY29uZmlnICsgXFxcIlxcXFxcXFwiXFxcIik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIF9jcmVhdGVDbGFzcyhQb3BvdmVyLCBudWxsLCBbe1xcbiAgICAgIGtleTogXFxcIlZFUlNJT05cXFwiLFxcbiAgICAgIC8vIEdldHRlcnNcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBWRVJTSU9OJDc7XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiRGVmYXVsdFxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gRGVmYXVsdCQ1O1xcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcIk5BTUVcXFwiLFxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIE5BTUUkNztcXG4gICAgICB9XFxuICAgIH0sIHtcXG4gICAgICBrZXk6IFxcXCJEQVRBX0tFWVxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gREFUQV9LRVkkNztcXG4gICAgICB9XFxuICAgIH0sIHtcXG4gICAgICBrZXk6IFxcXCJFdmVudFxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gRXZlbnQkNztcXG4gICAgICB9XFxuICAgIH0sIHtcXG4gICAgICBrZXk6IFxcXCJFVkVOVF9LRVlcXFwiLFxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIEVWRU5UX0tFWSQ3O1xcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogXFxcIkRlZmF1bHRUeXBlXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ1O1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gUG9wb3ZlcjtcXG4gIH0oVG9vbHRpcCk7XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogalF1ZXJ5XFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcblxcbiAgJC5mbltOQU1FJDddID0gUG9wb3Zlci5falF1ZXJ5SW50ZXJmYWNlO1xcbiAgJC5mbltOQU1FJDddLkNvbnN0cnVjdG9yID0gUG9wb3ZlcjtcXG5cXG4gICQuZm5bTkFNRSQ3XS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAkLmZuW05BTUUkN10gPSBKUVVFUllfTk9fQ09ORkxJQ1QkNztcXG4gICAgcmV0dXJuIFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZTtcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQ29uc3RhbnRzXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgdmFyIE5BTUUkOCA9ICdzY3JvbGxzcHknO1xcbiAgdmFyIFZFUlNJT04kOCA9ICc0LjQuMSc7XFxuICB2YXIgREFUQV9LRVkkOCA9ICdicy5zY3JvbGxzcHknO1xcbiAgdmFyIEVWRU5UX0tFWSQ4ID0gXFxcIi5cXFwiICsgREFUQV9LRVkkODtcXG4gIHZhciBEQVRBX0FQSV9LRVkkNiA9ICcuZGF0YS1hcGknO1xcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCQ4ID0gJC5mbltOQU1FJDhdO1xcbiAgdmFyIERlZmF1bHQkNiA9IHtcXG4gICAgb2Zmc2V0OiAxMCxcXG4gICAgbWV0aG9kOiAnYXV0bycsXFxuICAgIHRhcmdldDogJydcXG4gIH07XFxuICB2YXIgRGVmYXVsdFR5cGUkNiA9IHtcXG4gICAgb2Zmc2V0OiAnbnVtYmVyJyxcXG4gICAgbWV0aG9kOiAnc3RyaW5nJyxcXG4gICAgdGFyZ2V0OiAnKHN0cmluZ3xlbGVtZW50KSdcXG4gIH07XFxuICB2YXIgRXZlbnQkOCA9IHtcXG4gICAgQUNUSVZBVEU6IFxcXCJhY3RpdmF0ZVxcXCIgKyBFVkVOVF9LRVkkOCxcXG4gICAgU0NST0xMOiBcXFwic2Nyb2xsXFxcIiArIEVWRU5UX0tFWSQ4LFxcbiAgICBMT0FEX0RBVEFfQVBJOiBcXFwibG9hZFxcXCIgKyBFVkVOVF9LRVkkOCArIERBVEFfQVBJX0tFWSQ2XFxuICB9O1xcbiAgdmFyIENsYXNzTmFtZSQ4ID0ge1xcbiAgICBEUk9QRE9XTl9JVEVNOiAnZHJvcGRvd24taXRlbScsXFxuICAgIERST1BET1dOX01FTlU6ICdkcm9wZG93bi1tZW51JyxcXG4gICAgQUNUSVZFOiAnYWN0aXZlJ1xcbiAgfTtcXG4gIHZhciBTZWxlY3RvciQ4ID0ge1xcbiAgICBEQVRBX1NQWTogJ1tkYXRhLXNweT1cXFwic2Nyb2xsXFxcIl0nLFxcbiAgICBBQ1RJVkU6ICcuYWN0aXZlJyxcXG4gICAgTkFWX0xJU1RfR1JPVVA6ICcubmF2LCAubGlzdC1ncm91cCcsXFxuICAgIE5BVl9MSU5LUzogJy5uYXYtbGluaycsXFxuICAgIE5BVl9JVEVNUzogJy5uYXYtaXRlbScsXFxuICAgIExJU1RfSVRFTVM6ICcubGlzdC1ncm91cC1pdGVtJyxcXG4gICAgRFJPUERPV046ICcuZHJvcGRvd24nLFxcbiAgICBEUk9QRE9XTl9JVEVNUzogJy5kcm9wZG93bi1pdGVtJyxcXG4gICAgRFJPUERPV05fVE9HR0xFOiAnLmRyb3Bkb3duLXRvZ2dsZSdcXG4gIH07XFxuICB2YXIgT2Zmc2V0TWV0aG9kID0ge1xcbiAgICBPRkZTRVQ6ICdvZmZzZXQnLFxcbiAgICBQT1NJVElPTjogJ3Bvc2l0aW9uJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBDbGFzcyBEZWZpbml0aW9uXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgdmFyIFNjcm9sbFNweSA9XFxuICAvKiNfX1BVUkVfXyovXFxuICBmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIFNjcm9sbFNweShlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBlbGVtZW50LnRhZ05hbWUgPT09ICdCT0RZJyA/IHdpbmRvdyA6IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgICAgdGhpcy5fc2VsZWN0b3IgPSB0aGlzLl9jb25maWcudGFyZ2V0ICsgXFxcIiBcXFwiICsgU2VsZWN0b3IkOC5OQVZfTElOS1MgKyBcXFwiLFxcXCIgKyAodGhpcy5fY29uZmlnLnRhcmdldCArIFxcXCIgXFxcIiArIFNlbGVjdG9yJDguTElTVF9JVEVNUyArIFxcXCIsXFxcIikgKyAodGhpcy5fY29uZmlnLnRhcmdldCArIFxcXCIgXFxcIiArIFNlbGVjdG9yJDguRFJPUERPV05fSVRFTVMpO1xcbiAgICAgIHRoaXMuX29mZnNldHMgPSBbXTtcXG4gICAgICB0aGlzLl90YXJnZXRzID0gW107XFxuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcXG4gICAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwO1xcbiAgICAgICQodGhpcy5fc2Nyb2xsRWxlbWVudCkub24oRXZlbnQkOC5TQ1JPTEwsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgcmV0dXJuIF90aGlzLl9wcm9jZXNzKGV2ZW50KTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLnJlZnJlc2goKTtcXG5cXG4gICAgICB0aGlzLl9wcm9jZXNzKCk7XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICB2YXIgX3Byb3RvID0gU2Nyb2xsU3B5LnByb3RvdHlwZTtcXG5cXG4gICAgLy8gUHVibGljXFxuICAgIF9wcm90by5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICB2YXIgYXV0b01ldGhvZCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHRoaXMuX3Njcm9sbEVsZW1lbnQud2luZG93ID8gT2Zmc2V0TWV0aG9kLk9GRlNFVCA6IE9mZnNldE1ldGhvZC5QT1NJVElPTjtcXG4gICAgICB2YXIgb2Zmc2V0TWV0aG9kID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gJ2F1dG8nID8gYXV0b01ldGhvZCA6IHRoaXMuX2NvbmZpZy5tZXRob2Q7XFxuICAgICAgdmFyIG9mZnNldEJhc2UgPSBvZmZzZXRNZXRob2QgPT09IE9mZnNldE1ldGhvZC5QT1NJVElPTiA/IHRoaXMuX2dldFNjcm9sbFRvcCgpIDogMDtcXG4gICAgICB0aGlzLl9vZmZzZXRzID0gW107XFxuICAgICAgdGhpcy5fdGFyZ2V0cyA9IFtdO1xcbiAgICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpO1xcbiAgICAgIHZhciB0YXJnZXRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuX3NlbGVjdG9yKSk7XFxuICAgICAgdGFyZ2V0cy5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgICAgIHZhciB0YXJnZXQ7XFxuICAgICAgICB2YXIgdGFyZ2V0U2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XFxuXFxuICAgICAgICBpZiAodGFyZ2V0U2VsZWN0b3IpIHtcXG4gICAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRTZWxlY3Rvcik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGFyZ2V0KSB7XFxuICAgICAgICAgIHZhciB0YXJnZXRCQ1IgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuICAgICAgICAgIGlmICh0YXJnZXRCQ1Iud2lkdGggfHwgdGFyZ2V0QkNSLmhlaWdodCkge1xcbiAgICAgICAgICAgIC8vIFRPRE8gKGZhdCk6IHJlbW92ZSBza2V0Y2ggcmVsaWFuY2Ugb24galF1ZXJ5IHBvc2l0aW9uL29mZnNldFxcbiAgICAgICAgICAgIHJldHVybiBbJCh0YXJnZXQpW29mZnNldE1ldGhvZF0oKS50b3AgKyBvZmZzZXRCYXNlLCB0YXJnZXRTZWxlY3Rvcl07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xcbiAgICAgICAgcmV0dXJuIGl0ZW07XFxuICAgICAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgICAgIF90aGlzMi5fb2Zmc2V0cy5wdXNoKGl0ZW1bMF0pO1xcblxcbiAgICAgICAgX3RoaXMyLl90YXJnZXRzLnB1c2goaXRlbVsxXSk7XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcXG4gICAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkkOCk7XFxuICAgICAgJCh0aGlzLl9zY3JvbGxFbGVtZW50KS5vZmYoRVZFTlRfS0VZJDgpO1xcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBudWxsO1xcbiAgICAgIHRoaXMuX2NvbmZpZyA9IG51bGw7XFxuICAgICAgdGhpcy5fc2VsZWN0b3IgPSBudWxsO1xcbiAgICAgIHRoaXMuX29mZnNldHMgPSBudWxsO1xcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBudWxsO1xcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XFxuICAgICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gbnVsbDtcXG4gICAgfSAvLyBQcml2YXRlXFxuICAgIDtcXG5cXG4gICAgX3Byb3RvLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xcbiAgICAgIGNvbmZpZyA9IF9vYmplY3RTcHJlYWQyKHt9LCBEZWZhdWx0JDYsIHt9LCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBjb25maWcudGFyZ2V0ICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgdmFyIGlkID0gJChjb25maWcudGFyZ2V0KS5hdHRyKCdpZCcpO1xcblxcbiAgICAgICAgaWYgKCFpZCkge1xcbiAgICAgICAgICBpZCA9IFV0aWwuZ2V0VUlEKE5BTUUkOCk7XFxuICAgICAgICAgICQoY29uZmlnLnRhcmdldCkuYXR0cignaWQnLCBpZCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb25maWcudGFyZ2V0ID0gXFxcIiNcXFwiICsgaWQ7XFxuICAgICAgfVxcblxcbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUkOCwgY29uZmlnLCBEZWZhdWx0VHlwZSQ2KTtcXG4gICAgICByZXR1cm4gY29uZmlnO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2dldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxUb3AoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcDtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsSGVpZ2h0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCk7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fZ2V0T2Zmc2V0SGVpZ2h0ID0gZnVuY3Rpb24gX2dldE9mZnNldEhlaWdodCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5fcHJvY2VzcyA9IGZ1bmN0aW9uIF9wcm9jZXNzKCkge1xcbiAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXQ7XFxuXFxuICAgICAgdmFyIHNjcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpO1xcblxcbiAgICAgIHZhciBtYXhTY3JvbGwgPSB0aGlzLl9jb25maWcub2Zmc2V0ICsgc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fZ2V0T2Zmc2V0SGVpZ2h0KCk7XFxuXFxuICAgICAgaWYgKHRoaXMuX3Njcm9sbEhlaWdodCAhPT0gc2Nyb2xsSGVpZ2h0KSB7XFxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV07XFxuXFxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0YXJnZXQpIHtcXG4gICAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCAmJiBzY3JvbGxUb3AgPCB0aGlzLl9vZmZzZXRzWzBdICYmIHRoaXMuX29mZnNldHNbMF0gPiAwKSB7XFxuICAgICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xcblxcbiAgICAgICAgdGhpcy5fY2xlYXIoKTtcXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIG9mZnNldExlbmd0aCA9IHRoaXMuX29mZnNldHMubGVuZ3RoO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSBvZmZzZXRMZW5ndGg7IGktLTspIHtcXG4gICAgICAgIHZhciBpc0FjdGl2ZVRhcmdldCA9IHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gdGhpcy5fdGFyZ2V0c1tpXSAmJiBzY3JvbGxUb3AgPj0gdGhpcy5fb2Zmc2V0c1tpXSAmJiAodHlwZW9mIHRoaXMuX29mZnNldHNbaSArIDFdID09PSAndW5kZWZpbmVkJyB8fCBzY3JvbGxUb3AgPCB0aGlzLl9vZmZzZXRzW2kgKyAxXSk7XFxuXFxuICAgICAgICBpZiAoaXNBY3RpdmVUYXJnZXQpIHtcXG4gICAgICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tpXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX2FjdGl2YXRlID0gZnVuY3Rpb24gX2FjdGl2YXRlKHRhcmdldCkge1xcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcXG5cXG4gICAgICB0aGlzLl9jbGVhcigpO1xcblxcbiAgICAgIHZhciBxdWVyaWVzID0gdGhpcy5fc2VsZWN0b3Iuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XFxuICAgICAgICByZXR1cm4gc2VsZWN0b3IgKyBcXFwiW2RhdGEtdGFyZ2V0PVxcXFxcXFwiXFxcIiArIHRhcmdldCArIFxcXCJcXFxcXFxcIl0sXFxcIiArIHNlbGVjdG9yICsgXFxcIltocmVmPVxcXFxcXFwiXFxcIiArIHRhcmdldCArIFxcXCJcXFxcXFxcIl1cXFwiO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHZhciAkbGluayA9ICQoW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJpZXMuam9pbignLCcpKSkpO1xcblxcbiAgICAgIGlmICgkbGluay5oYXNDbGFzcyhDbGFzc05hbWUkOC5EUk9QRE9XTl9JVEVNKSkge1xcbiAgICAgICAgJGxpbmsuY2xvc2VzdChTZWxlY3RvciQ4LkRST1BET1dOKS5maW5kKFNlbGVjdG9yJDguRFJPUERPV05fVE9HR0xFKS5hZGRDbGFzcyhDbGFzc05hbWUkOC5BQ1RJVkUpO1xcbiAgICAgICAgJGxpbmsuYWRkQ2xhc3MoQ2xhc3NOYW1lJDguQUNUSVZFKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rIGFzIGFjdGl2ZVxcbiAgICAgICAgJGxpbmsuYWRkQ2xhc3MoQ2xhc3NOYW1lJDguQUNUSVZFKTsgLy8gU2V0IHRyaWdnZXJlZCBsaW5rcyBwYXJlbnRzIGFzIGFjdGl2ZVxcbiAgICAgICAgLy8gV2l0aCBib3RoIDx1bD4gYW5kIDxuYXY+IG1hcmt1cCBhIHBhcmVudCBpcyB0aGUgcHJldmlvdXMgc2libGluZyBvZiBhbnkgbmF2IGFuY2VzdG9yXFxuXFxuICAgICAgICAkbGluay5wYXJlbnRzKFNlbGVjdG9yJDguTkFWX0xJU1RfR1JPVVApLnByZXYoU2VsZWN0b3IkOC5OQVZfTElOS1MgKyBcXFwiLCBcXFwiICsgU2VsZWN0b3IkOC5MSVNUX0lURU1TKS5hZGRDbGFzcyhDbGFzc05hbWUkOC5BQ1RJVkUpOyAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIHdoZW4gLm5hdi1saW5rIGlzIGluc2lkZSAubmF2LWl0ZW1cXG5cXG4gICAgICAgICRsaW5rLnBhcmVudHMoU2VsZWN0b3IkOC5OQVZfTElTVF9HUk9VUCkucHJldihTZWxlY3RvciQ4Lk5BVl9JVEVNUykuY2hpbGRyZW4oU2VsZWN0b3IkOC5OQVZfTElOS1MpLmFkZENsYXNzKENsYXNzTmFtZSQ4LkFDVElWRSk7XFxuICAgICAgfVxcblxcbiAgICAgICQodGhpcy5fc2Nyb2xsRWxlbWVudCkudHJpZ2dlcihFdmVudCQ4LkFDVElWQVRFLCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9jbGVhciA9IGZ1bmN0aW9uIF9jbGVhcigpIHtcXG4gICAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5fc2VsZWN0b3IpKS5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcXG4gICAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUkOC5BQ1RJVkUpO1xcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcXG4gICAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC5yZW1vdmUoQ2xhc3NOYW1lJDguQUNUSVZFKTtcXG4gICAgICB9KTtcXG4gICAgfSAvLyBTdGF0aWNcXG4gICAgO1xcblxcbiAgICBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSQ4KTtcXG5cXG4gICAgICAgIHZhciBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnO1xcblxcbiAgICAgICAgaWYgKCFkYXRhKSB7XFxuICAgICAgICAgIGRhdGEgPSBuZXcgU2Nyb2xsU3B5KHRoaXMsIF9jb25maWcpO1xcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVkkOCwgZGF0YSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiTm8gbWV0aG9kIG5hbWVkIFxcXFxcXFwiXFxcIiArIGNvbmZpZyArIFxcXCJcXFxcXFxcIlxcXCIpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBfY3JlYXRlQ2xhc3MoU2Nyb2xsU3B5LCBudWxsLCBbe1xcbiAgICAgIGtleTogXFxcIlZFUlNJT05cXFwiLFxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIFZFUlNJT04kODtcXG4gICAgICB9XFxuICAgIH0sIHtcXG4gICAgICBrZXk6IFxcXCJEZWZhdWx0XFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBEZWZhdWx0JDY7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBTY3JvbGxTcHk7XFxuICB9KCk7XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuXFxuICAkKHdpbmRvdykub24oRXZlbnQkOC5MT0FEX0RBVEFfQVBJLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzY3JvbGxTcHlzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yJDguREFUQV9TUFkpKTtcXG4gICAgdmFyIHNjcm9sbFNweXNMZW5ndGggPSBzY3JvbGxTcHlzLmxlbmd0aDtcXG5cXG4gICAgZm9yICh2YXIgaSA9IHNjcm9sbFNweXNMZW5ndGg7IGktLTspIHtcXG4gICAgICB2YXIgJHNweSA9ICQoc2Nyb2xsU3B5c1tpXSk7XFxuXFxuICAgICAgU2Nyb2xsU3B5Ll9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkc3B5LCAkc3B5LmRhdGEoKSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIGpRdWVyeVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gICQuZm5bTkFNRSQ4XSA9IFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlO1xcbiAgJC5mbltOQU1FJDhdLkNvbnN0cnVjdG9yID0gU2Nyb2xsU3B5O1xcblxcbiAgJC5mbltOQU1FJDhdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XFxuICAgICQuZm5bTkFNRSQ4XSA9IEpRVUVSWV9OT19DT05GTElDVCQ4O1xcbiAgICByZXR1cm4gU2Nyb2xsU3B5Ll9qUXVlcnlJbnRlcmZhY2U7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIENvbnN0YW50c1xcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gIHZhciBOQU1FJDkgPSAndGFiJztcXG4gIHZhciBWRVJTSU9OJDkgPSAnNC40LjEnO1xcbiAgdmFyIERBVEFfS0VZJDkgPSAnYnMudGFiJztcXG4gIHZhciBFVkVOVF9LRVkkOSA9IFxcXCIuXFxcIiArIERBVEFfS0VZJDk7XFxuICB2YXIgREFUQV9BUElfS0VZJDcgPSAnLmRhdGEtYXBpJztcXG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QkOSA9ICQuZm5bTkFNRSQ5XTtcXG4gIHZhciBFdmVudCQ5ID0ge1xcbiAgICBISURFOiBcXFwiaGlkZVxcXCIgKyBFVkVOVF9LRVkkOSxcXG4gICAgSElEREVOOiBcXFwiaGlkZGVuXFxcIiArIEVWRU5UX0tFWSQ5LFxcbiAgICBTSE9XOiBcXFwic2hvd1xcXCIgKyBFVkVOVF9LRVkkOSxcXG4gICAgU0hPV046IFxcXCJzaG93blxcXCIgKyBFVkVOVF9LRVkkOSxcXG4gICAgQ0xJQ0tfREFUQV9BUEk6IFxcXCJjbGlja1xcXCIgKyBFVkVOVF9LRVkkOSArIERBVEFfQVBJX0tFWSQ3XFxuICB9O1xcbiAgdmFyIENsYXNzTmFtZSQ5ID0ge1xcbiAgICBEUk9QRE9XTl9NRU5VOiAnZHJvcGRvd24tbWVudScsXFxuICAgIEFDVElWRTogJ2FjdGl2ZScsXFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxcbiAgICBGQURFOiAnZmFkZScsXFxuICAgIFNIT1c6ICdzaG93J1xcbiAgfTtcXG4gIHZhciBTZWxlY3RvciQ5ID0ge1xcbiAgICBEUk9QRE9XTjogJy5kcm9wZG93bicsXFxuICAgIE5BVl9MSVNUX0dST1VQOiAnLm5hdiwgLmxpc3QtZ3JvdXAnLFxcbiAgICBBQ1RJVkU6ICcuYWN0aXZlJyxcXG4gICAgQUNUSVZFX1VMOiAnPiBsaSA+IC5hY3RpdmUnLFxcbiAgICBEQVRBX1RPR0dMRTogJ1tkYXRhLXRvZ2dsZT1cXFwidGFiXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwicGlsbFxcXCJdLCBbZGF0YS10b2dnbGU9XFxcImxpc3RcXFwiXScsXFxuICAgIERST1BET1dOX1RPR0dMRTogJy5kcm9wZG93bi10b2dnbGUnLFxcbiAgICBEUk9QRE9XTl9BQ1RJVkVfQ0hJTEQ6ICc+IC5kcm9wZG93bi1tZW51IC5hY3RpdmUnXFxuICB9O1xcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIENsYXNzIERlZmluaXRpb25cXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuICB2YXIgVGFiID1cXG4gIC8qI19fUFVSRV9fKi9cXG4gIGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gVGFiKGVsZW1lbnQpIHtcXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHZhciBfcHJvdG8gPSBUYWIucHJvdG90eXBlO1xcblxcbiAgICAvLyBQdWJsaWNcXG4gICAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lJDkuQUNUSVZFKSB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZSQ5LkRJU0FCTEVEKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdGFyZ2V0O1xcbiAgICAgIHZhciBwcmV2aW91cztcXG4gICAgICB2YXIgbGlzdEVsZW1lbnQgPSAkKHRoaXMuX2VsZW1lbnQpLmNsb3Nlc3QoU2VsZWN0b3IkOS5OQVZfTElTVF9HUk9VUClbMF07XFxuICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICAgIGlmIChsaXN0RWxlbWVudCkge1xcbiAgICAgICAgdmFyIGl0ZW1TZWxlY3RvciA9IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnVUwnIHx8IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnT0wnID8gU2VsZWN0b3IkOS5BQ1RJVkVfVUwgOiBTZWxlY3RvciQ5LkFDVElWRTtcXG4gICAgICAgIHByZXZpb3VzID0gJC5tYWtlQXJyYXkoJChsaXN0RWxlbWVudCkuZmluZChpdGVtU2VsZWN0b3IpKTtcXG4gICAgICAgIHByZXZpb3VzID0gcHJldmlvdXNbcHJldmlvdXMubGVuZ3RoIC0gMV07XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBoaWRlRXZlbnQgPSAkLkV2ZW50KEV2ZW50JDkuSElERSwge1xcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxcbiAgICAgIH0pO1xcbiAgICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50JDkuU0hPVywge1xcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAocHJldmlvdXMpIHtcXG4gICAgICAgICQocHJldmlvdXMpLnRyaWdnZXIoaGlkZUV2ZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudCk7XFxuXFxuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHNlbGVjdG9yKSB7XFxuICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fZWxlbWVudCwgbGlzdEVsZW1lbnQpO1xcblxcbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xcbiAgICAgICAgdmFyIGhpZGRlbkV2ZW50ID0gJC5FdmVudChFdmVudCQ5LkhJRERFTiwge1xcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBfdGhpcy5fZWxlbWVudFxcbiAgICAgICAgfSk7XFxuICAgICAgICB2YXIgc2hvd25FdmVudCA9ICQuRXZlbnQoRXZlbnQkOS5TSE9XTiwge1xcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xcbiAgICAgICAgfSk7XFxuICAgICAgICAkKHByZXZpb3VzKS50cmlnZ2VyKGhpZGRlbkV2ZW50KTtcXG4gICAgICAgICQoX3RoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd25FdmVudCk7XFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAodGFyZ2V0KSB7XFxuICAgICAgICB0aGlzLl9hY3RpdmF0ZSh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlLCBjb21wbGV0ZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbXBsZXRlKCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XFxuICAgICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZJDkpO1xcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xcbiAgICB9IC8vIFByaXZhdGVcXG4gICAgO1xcblxcbiAgICBfcHJvdG8uX2FjdGl2YXRlID0gZnVuY3Rpb24gX2FjdGl2YXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcXG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICB2YXIgYWN0aXZlRWxlbWVudHMgPSBjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBjb250YWluZXIubm9kZU5hbWUgPT09ICdPTCcpID8gJChjb250YWluZXIpLmZpbmQoU2VsZWN0b3IkOS5BQ1RJVkVfVUwpIDogJChjb250YWluZXIpLmNoaWxkcmVuKFNlbGVjdG9yJDkuQUNUSVZFKTtcXG4gICAgICB2YXIgYWN0aXZlID0gYWN0aXZlRWxlbWVudHNbMF07XFxuICAgICAgdmFyIGlzVHJhbnNpdGlvbmluZyA9IGNhbGxiYWNrICYmIGFjdGl2ZSAmJiAkKGFjdGl2ZSkuaGFzQ2xhc3MoQ2xhc3NOYW1lJDkuRkFERSk7XFxuXFxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMyLl90cmFuc2l0aW9uQ29tcGxldGUoZWxlbWVudCwgYWN0aXZlLCBjYWxsYmFjayk7XFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAoYWN0aXZlICYmIGlzVHJhbnNpdGlvbmluZykge1xcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQoYWN0aXZlKTtcXG4gICAgICAgICQoYWN0aXZlKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkOS5TSE9XKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbXBsZXRlKCk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX3RyYW5zaXRpb25Db21wbGV0ZSA9IGZ1bmN0aW9uIF90cmFuc2l0aW9uQ29tcGxldGUoZWxlbWVudCwgYWN0aXZlLCBjYWxsYmFjaykge1xcbiAgICAgIGlmIChhY3RpdmUpIHtcXG4gICAgICAgICQoYWN0aXZlKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUkOS5BQ1RJVkUpO1xcbiAgICAgICAgdmFyIGRyb3Bkb3duQ2hpbGQgPSAkKGFjdGl2ZS5wYXJlbnROb2RlKS5maW5kKFNlbGVjdG9yJDkuRFJPUERPV05fQUNUSVZFX0NISUxEKVswXTtcXG5cXG4gICAgICAgIGlmIChkcm9wZG93bkNoaWxkKSB7XFxuICAgICAgICAgICQoZHJvcGRvd25DaGlsZCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lJDkuQUNUSVZFKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChhY3RpdmUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInKSB7XFxuICAgICAgICAgIGFjdGl2ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgICQoZWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lJDkuQUNUSVZFKTtcXG5cXG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIFV0aWwucmVmbG93KGVsZW1lbnQpO1xcblxcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUkOS5GQURFKSkge1xcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENsYXNzTmFtZSQ5LlNIT1cpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmICQoZWxlbWVudC5wYXJlbnROb2RlKS5oYXNDbGFzcyhDbGFzc05hbWUkOS5EUk9QRE9XTl9NRU5VKSkge1xcbiAgICAgICAgdmFyIGRyb3Bkb3duRWxlbWVudCA9ICQoZWxlbWVudCkuY2xvc2VzdChTZWxlY3RvciQ5LkRST1BET1dOKVswXTtcXG5cXG4gICAgICAgIGlmIChkcm9wZG93bkVsZW1lbnQpIHtcXG4gICAgICAgICAgdmFyIGRyb3Bkb3duVG9nZ2xlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZHJvcGRvd25FbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IkOS5EUk9QRE9XTl9UT0dHTEUpKTtcXG4gICAgICAgICAgJChkcm9wZG93blRvZ2dsZUxpc3QpLmFkZENsYXNzKENsYXNzTmFtZSQ5LkFDVElWRSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgIGNhbGxiYWNrKCk7XFxuICAgICAgfVxcbiAgICB9IC8vIFN0YXRpY1xcbiAgICA7XFxuXFxuICAgIFRhYi5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XFxuICAgICAgICB2YXIgZGF0YSA9ICR0aGlzLmRhdGEoREFUQV9LRVkkOSk7XFxuXFxuICAgICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgICAgZGF0YSA9IG5ldyBUYWIodGhpcyk7XFxuICAgICAgICAgICR0aGlzLmRhdGEoREFUQV9LRVkkOSwgZGF0YSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiTm8gbWV0aG9kIG5hbWVkIFxcXFxcXFwiXFxcIiArIGNvbmZpZyArIFxcXCJcXFxcXFxcIlxcXCIpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBfY3JlYXRlQ2xhc3MoVGFiLCBudWxsLCBbe1xcbiAgICAgIGtleTogXFxcIlZFUlNJT05cXFwiLFxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIFZFUlNJT04kOTtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIFRhYjtcXG4gIH0oKTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG5cXG4gICQoZG9jdW1lbnQpLm9uKEV2ZW50JDkuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yJDkuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICBUYWIuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICdzaG93Jyk7XFxuICB9KTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBqUXVlcnlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuICAkLmZuW05BTUUkOV0gPSBUYWIuX2pRdWVyeUludGVyZmFjZTtcXG4gICQuZm5bTkFNRSQ5XS5Db25zdHJ1Y3RvciA9IFRhYjtcXG5cXG4gICQuZm5bTkFNRSQ5XS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAkLmZuW05BTUUkOV0gPSBKUVVFUllfTk9fQ09ORkxJQ1QkOTtcXG4gICAgcmV0dXJuIFRhYi5falF1ZXJ5SW50ZXJmYWNlO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBDb25zdGFudHNcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuICB2YXIgTkFNRSRhID0gJ3RvYXN0JztcXG4gIHZhciBWRVJTSU9OJGEgPSAnNC40LjEnO1xcbiAgdmFyIERBVEFfS0VZJGEgPSAnYnMudG9hc3QnO1xcbiAgdmFyIEVWRU5UX0tFWSRhID0gXFxcIi5cXFwiICsgREFUQV9LRVkkYTtcXG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QkYSA9ICQuZm5bTkFNRSRhXTtcXG4gIHZhciBFdmVudCRhID0ge1xcbiAgICBDTElDS19ESVNNSVNTOiBcXFwiY2xpY2suZGlzbWlzc1xcXCIgKyBFVkVOVF9LRVkkYSxcXG4gICAgSElERTogXFxcImhpZGVcXFwiICsgRVZFTlRfS0VZJGEsXFxuICAgIEhJRERFTjogXFxcImhpZGRlblxcXCIgKyBFVkVOVF9LRVkkYSxcXG4gICAgU0hPVzogXFxcInNob3dcXFwiICsgRVZFTlRfS0VZJGEsXFxuICAgIFNIT1dOOiBcXFwic2hvd25cXFwiICsgRVZFTlRfS0VZJGFcXG4gIH07XFxuICB2YXIgQ2xhc3NOYW1lJGEgPSB7XFxuICAgIEZBREU6ICdmYWRlJyxcXG4gICAgSElERTogJ2hpZGUnLFxcbiAgICBTSE9XOiAnc2hvdycsXFxuICAgIFNIT1dJTkc6ICdzaG93aW5nJ1xcbiAgfTtcXG4gIHZhciBEZWZhdWx0VHlwZSQ3ID0ge1xcbiAgICBhbmltYXRpb246ICdib29sZWFuJyxcXG4gICAgYXV0b2hpZGU6ICdib29sZWFuJyxcXG4gICAgZGVsYXk6ICdudW1iZXInXFxuICB9O1xcbiAgdmFyIERlZmF1bHQkNyA9IHtcXG4gICAgYW5pbWF0aW9uOiB0cnVlLFxcbiAgICBhdXRvaGlkZTogdHJ1ZSxcXG4gICAgZGVsYXk6IDUwMFxcbiAgfTtcXG4gIHZhciBTZWxlY3RvciRhID0ge1xcbiAgICBEQVRBX0RJU01JU1M6ICdbZGF0YS1kaXNtaXNzPVxcXCJ0b2FzdFxcXCJdJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBDbGFzcyBEZWZpbml0aW9uXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgdmFyIFRvYXN0ID1cXG4gIC8qI19fUFVSRV9fKi9cXG4gIGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gVG9hc3QoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XFxuXFxuICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICB2YXIgX3Byb3RvID0gVG9hc3QucHJvdG90eXBlO1xcblxcbiAgICAvLyBQdWJsaWNcXG4gICAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdmFyIHNob3dFdmVudCA9ICQuRXZlbnQoRXZlbnQkYS5TSE9XKTtcXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KTtcXG5cXG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ2xhc3NOYW1lJGEuRkFERSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xcbiAgICAgICAgX3RoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDbGFzc05hbWUkYS5TSE9XSU5HKTtcXG5cXG4gICAgICAgIF90aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ2xhc3NOYW1lJGEuU0hPVyk7XFxuXFxuICAgICAgICAkKF90aGlzLl9lbGVtZW50KS50cmlnZ2VyKEV2ZW50JGEuU0hPV04pO1xcblxcbiAgICAgICAgaWYgKF90aGlzLl9jb25maWcuYXV0b2hpZGUpIHtcXG4gICAgICAgICAgX3RoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfdGhpcy5oaWRlKCk7XFxuICAgICAgICAgIH0sIF90aGlzLl9jb25maWcuZGVsYXkpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZSRhLkhJREUpO1xcblxcbiAgICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDbGFzc05hbWUkYS5TSE9XSU5HKTtcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XFxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29tcGxldGUoKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcXG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENsYXNzTmFtZSRhLlNIT1cpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBoaWRlRXZlbnQgPSAkLkV2ZW50KEV2ZW50JGEuSElERSk7XFxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKGhpZGVFdmVudCk7XFxuXFxuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9jbG9zZSgpO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xcblxcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUkYS5TSE9XKSkge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZSRhLlNIT1cpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFdmVudCRhLkNMSUNLX0RJU01JU1MpO1xcbiAgICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSRhKTtcXG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcXG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xcbiAgICB9IC8vIFByaXZhdGVcXG4gICAgO1xcblxcbiAgICBfcHJvdG8uX2dldENvbmZpZyA9IGZ1bmN0aW9uIF9nZXRDb25maWcoY29uZmlnKSB7XFxuICAgICAgY29uZmlnID0gX29iamVjdFNwcmVhZDIoe30sIERlZmF1bHQkNywge30sICQodGhpcy5fZWxlbWVudCkuZGF0YSgpLCB7fSwgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pO1xcbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUkYSwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcXG4gICAgICByZXR1cm4gY29uZmlnO1xcbiAgICB9O1xcblxcbiAgICBfcHJvdG8uX3NldExpc3RlbmVycyA9IGZ1bmN0aW9uIF9zZXRMaXN0ZW5lcnMoKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudCRhLkNMSUNLX0RJU01JU1MsIFNlbGVjdG9yJGEuREFUQV9ESVNNSVNTLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gX3RoaXMyLmhpZGUoKTtcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgX3Byb3RvLl9jbG9zZSA9IGZ1bmN0aW9uIF9jbG9zZSgpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG4gICAgICAgIF90aGlzMy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENsYXNzTmFtZSRhLkhJREUpO1xcblxcbiAgICAgICAgJChfdGhpczMuX2VsZW1lbnQpLnRyaWdnZXIoRXZlbnQkYS5ISURERU4pO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZSRhLlNIT1cpO1xcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XFxuICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcXG4gICAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb21wbGV0ZSgpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBTdGF0aWNcXG4gICAgO1xcblxcbiAgICBUb2FzdC5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyk7XFxuICAgICAgICB2YXIgZGF0YSA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkkYSk7XFxuXFxuICAgICAgICB2YXIgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZztcXG5cXG4gICAgICAgIGlmICghZGF0YSkge1xcbiAgICAgICAgICBkYXRhID0gbmV3IFRvYXN0KHRoaXMsIF9jb25maWcpO1xcbiAgICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZJGEsIGRhdGEpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIk5vIG1ldGhvZCBuYW1lZCBcXFxcXFxcIlxcXCIgKyBjb25maWcgKyBcXFwiXFxcXFxcXCJcXFwiKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIF9jcmVhdGVDbGFzcyhUb2FzdCwgbnVsbCwgW3tcXG4gICAgICBrZXk6IFxcXCJWRVJTSU9OXFxcIixcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBWRVJTSU9OJGE7XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiRGVmYXVsdFR5cGVcXFwiLFxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDc7XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiBcXFwiRGVmYXVsdFxcXCIsXFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gRGVmYXVsdCQ3O1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gVG9hc3Q7XFxuICB9KCk7XFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogalF1ZXJ5XFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcblxcbiAgJC5mbltOQU1FJGFdID0gVG9hc3QuX2pRdWVyeUludGVyZmFjZTtcXG4gICQuZm5bTkFNRSRhXS5Db25zdHJ1Y3RvciA9IFRvYXN0O1xcblxcbiAgJC5mbltOQU1FJGFdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XFxuICAgICQuZm5bTkFNRSRhXSA9IEpRVUVSWV9OT19DT05GTElDVCRhO1xcbiAgICByZXR1cm4gVG9hc3QuX2pRdWVyeUludGVyZmFjZTtcXG4gIH07XFxuXFxuICBleHBvcnRzLkFsZXJ0ID0gQWxlcnQ7XFxuICBleHBvcnRzLkJ1dHRvbiA9IEJ1dHRvbjtcXG4gIGV4cG9ydHMuQ2Fyb3VzZWwgPSBDYXJvdXNlbDtcXG4gIGV4cG9ydHMuQ29sbGFwc2UgPSBDb2xsYXBzZTtcXG4gIGV4cG9ydHMuRHJvcGRvd24gPSBEcm9wZG93bjtcXG4gIGV4cG9ydHMuTW9kYWwgPSBNb2RhbDtcXG4gIGV4cG9ydHMuUG9wb3ZlciA9IFBvcG92ZXI7XFxuICBleHBvcnRzLlNjcm9sbHNweSA9IFNjcm9sbFNweTtcXG4gIGV4cG9ydHMuVGFiID0gVGFiO1xcbiAgZXhwb3J0cy5Ub2FzdCA9IFRvYXN0O1xcbiAgZXhwb3J0cy5Ub29sdGlwID0gVG9vbHRpcDtcXG4gIGV4cG9ydHMuVXRpbCA9IFV0aWw7XFxuXFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xcblxcbn0pKSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vdHN0cmFwLmpzLm1hcFxcblwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzP2UzZDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZm9udC1hd2Vzb21lL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzcz80ZjFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(13))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci5qcz8xYjRhIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcY2xkcmpzXFxcXGRpc3RcXFxcY2xkci5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n")},function(module,exports){eval('module.exports = "/**\\n * CLDR JavaScript Library v0.5.1\\n * http://jquery.com/\\n *\\n * Copyright 2013 Rafael Xavier de Souza\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2019-01-21T13:43Z\\n */\\n/*!\\n * CLDR JavaScript Library v0.5.1 2019-01-21T13:43Z MIT license  Rafael Xavier\\n * http://git.io/h4lmVg\\n */\\n(function( root, factory ) {\\n\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\t\\t// AMD.\\n\\t\\tdefine( factory );\\n\\t} else if ( typeof module === \\"object\\" && typeof module.exports === \\"object\\" ) {\\n\\t\\t// Node. CommonJS.\\n\\t\\tmodule.exports = factory();\\n\\t} else {\\n\\t\\t// Global\\n\\t\\troot.Cldr = factory();\\n\\t}\\n\\n}( this, function() {\\n\\n\\n\\tvar arrayIsArray = Array.isArray || function( obj ) {\\n\\t\\treturn Object.prototype.toString.call( obj ) === \\"[object Array]\\";\\n\\t};\\n\\n\\n\\n\\n\\tvar pathNormalize = function( path, attributes ) {\\n\\t\\tif ( arrayIsArray( path ) ) {\\n\\t\\t\\tpath = path.join( \\"/\\" );\\n\\t\\t}\\n\\t\\tif ( typeof path !== \\"string\\" ) {\\n\\t\\t\\tthrow new Error( \\"invalid path \\\\\\"\\" + path + \\"\\\\\\"\\" );\\n\\t\\t}\\n\\t\\t// 1: Ignore leading slash `/`\\n\\t\\t// 2: Ignore leading `cldr/`\\n\\t\\tpath = path\\n\\t\\t\\t.replace( /^\\\\// , \\"\\" ) /* 1 */\\n\\t\\t\\t.replace( /^cldr\\\\// , \\"\\" ); /* 2 */\\n\\n\\t\\t// Replace {attribute}\'s\\n\\t\\tpath = path.replace( /{[a-zA-Z]+}/g, function( name ) {\\n\\t\\t\\tname = name.replace( /^{([^}]*)}$/, \\"$1\\" );\\n\\t\\t\\treturn attributes[ name ];\\n\\t\\t});\\n\\n\\t\\treturn path.split( \\"/\\" );\\n\\t};\\n\\n\\n\\n\\n\\tvar arraySome = function( array, callback ) {\\n\\t\\tvar i, length;\\n\\t\\tif ( array.some ) {\\n\\t\\t\\treturn array.some( callback );\\n\\t\\t}\\n\\t\\tfor ( i = 0, length = array.length; i < length; i++ ) {\\n\\t\\t\\tif ( callback( array[ i ], i, array ) ) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\n\\n\\n\\n\\t/**\\n\\t * Return the maximized language id as defined in\\n\\t * http://www.unicode.org/reports/tr35/#Likely_Subtags\\n\\t * 1. Canonicalize.\\n\\t * 1.1 Make sure the input locale is in canonical form: uses the right\\n\\t * separator, and has the right casing.\\n\\t * TODO Right casing? What df? It seems languages are lowercase, scripts are\\n\\t * Capitalized, territory is uppercase. I am leaving this as an exercise to\\n\\t * the user.\\n\\t *\\n\\t * 1.2 Replace any deprecated subtags with their canonical values using the\\n\\t * <alias> data in supplemental metadata. Use the first value in the\\n\\t * replacement list, if it exists. Language tag replacements may have multiple\\n\\t * parts, such as \\"sh\\"  \\"sr_Latn\\" or mo\\"  \\"ro_MD\\". In such a case, the\\n\\t * original script and/or region are retained if there is one. Thus\\n\\t * \\"sh_Arab_AQ\\"  \\"sr_Arab_AQ\\", not \\"sr_Latn_AQ\\".\\n\\t * TODO What <alias> data?\\n\\t *\\n\\t * 1.3 If the tag is grandfathered (see <variable id=\\"$grandfathered\\"\\n\\t * type=\\"choice\\"> in the supplemental data), then return it.\\n\\t * TODO grandfathered?\\n\\t *\\n\\t * 1.4 Remove the script code \'Zzzz\' and the region code \'ZZ\' if they occur.\\n\\t * 1.5 Get the components of the cleaned-up source tag (languages, scripts,\\n\\t * and regions), plus any variants and extensions.\\n\\t * 2. Lookup. Lookup each of the following in order, and stop on the first\\n\\t * match:\\n\\t * 2.1 languages_scripts_regions\\n\\t * 2.2 languages_regions\\n\\t * 2.3 languages_scripts\\n\\t * 2.4 languages\\n\\t * 2.5 und_scripts\\n\\t * 3. Return\\n\\t * 3.1 If there is no match, either return an error value, or the match for\\n\\t * \\"und\\" (in APIs where a valid language tag is required).\\n\\t * 3.2 Otherwise there is a match = languagem_scriptm_regionm\\n\\t * 3.3 Let xr = xs if xs is not empty, and xm otherwise.\\n\\t * 3.4 Return the language tag composed of languager _ scriptr _ regionr +\\n\\t * variants + extensions.\\n\\t *\\n\\t * @subtags [Array] normalized language id subtags tuple (see init.js).\\n\\t */\\n\\tvar coreLikelySubtags = function( Cldr, cldr, subtags, options ) {\\n\\t\\tvar match, matchFound,\\n\\t\\t\\tlanguage = subtags[ 0 ],\\n\\t\\t\\tscript = subtags[ 1 ],\\n\\t\\t\\tsep = Cldr.localeSep,\\n\\t\\t\\tterritory = subtags[ 2 ],\\n\\t\\t\\tvariants = subtags.slice( 3, 4 );\\n\\t\\toptions = options || {};\\n\\n\\t\\t// Skip if (language, script, territory) is not empty [3.3]\\n\\t\\tif ( language !== \\"und\\" && script !== \\"Zzzz\\" && territory !== \\"ZZ\\" ) {\\n\\t\\t\\treturn [ language, script, territory ].concat( variants );\\n\\t\\t}\\n\\n\\t\\t// Skip if no supplemental likelySubtags data is present\\n\\t\\tif ( typeof cldr.get( \\"supplemental/likelySubtags\\" ) === \\"undefined\\" ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// [2]\\n\\t\\tmatchFound = arraySome([\\n\\t\\t\\t[ language, script, territory ],\\n\\t\\t\\t[ language, territory ],\\n\\t\\t\\t[ language, script ],\\n\\t\\t\\t[ language ],\\n\\t\\t\\t[ \\"und\\", script ]\\n\\t\\t], function( test ) {\\n\\t\\t\\treturn match = !(/\\\\b(Zzzz|ZZ)\\\\b/).test( test.join( sep ) ) /* [1.4] */ && cldr.get( [ \\"supplemental/likelySubtags\\", test.join( sep ) ] );\\n\\t\\t});\\n\\n\\t\\t// [3]\\n\\t\\tif ( matchFound ) {\\n\\t\\t\\t// [3.2 .. 3.4]\\n\\t\\t\\tmatch = match.split( sep );\\n\\t\\t\\treturn [\\n\\t\\t\\t\\tlanguage !== \\"und\\" ? language : match[ 0 ],\\n\\t\\t\\t\\tscript !== \\"Zzzz\\" ? script : match[ 1 ],\\n\\t\\t\\t\\tterritory !== \\"ZZ\\" ? territory : match[ 2 ]\\n\\t\\t\\t].concat( variants );\\n\\t\\t} else if ( options.force ) {\\n\\t\\t\\t// [3.1.2]\\n\\t\\t\\treturn cldr.get( \\"supplemental/likelySubtags/und\\" ).split( sep );\\n\\t\\t} else {\\n\\t\\t\\t// [3.1.1]\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\t/**\\n\\t * Given a locale, remove any fields that Add Likely Subtags would add.\\n\\t * http://www.unicode.org/reports/tr35/#Likely_Subtags\\n\\t * 1. First get max = AddLikelySubtags(inputLocale). If an error is signaled,\\n\\t * return it.\\n\\t * 2. Remove the variants from max.\\n\\t * 3. Then for trial in {language, language _ region, language _ script}. If\\n\\t * AddLikelySubtags(trial) = max, then return trial + variants.\\n\\t * 4. If you do not get a match, return max + variants.\\n\\t * \\n\\t * @maxLanguageId [Array] maxLanguageId tuple (see init.js).\\n\\t */\\n\\tvar coreRemoveLikelySubtags = function( Cldr, cldr, maxLanguageId ) {\\n\\t\\tvar match, matchFound,\\n\\t\\t\\tlanguage = maxLanguageId[ 0 ],\\n\\t\\t\\tscript = maxLanguageId[ 1 ],\\n\\t\\t\\tterritory = maxLanguageId[ 2 ],\\n\\t\\t\\tvariants = maxLanguageId[ 3 ];\\n\\n\\t\\t// [3]\\n\\t\\tmatchFound = arraySome([\\n\\t\\t\\t[ [ language, \\"Zzzz\\", \\"ZZ\\" ], [ language ] ],\\n\\t\\t\\t[ [ language, \\"Zzzz\\", territory ], [ language, territory ] ],\\n\\t\\t\\t[ [ language, script, \\"ZZ\\" ], [ language, script ] ]\\n\\t\\t], function( test ) {\\n\\t\\t\\tvar result = coreLikelySubtags( Cldr, cldr, test[ 0 ] );\\n\\t\\t\\tmatch = test[ 1 ];\\n\\t\\t\\treturn result && result[ 0 ] === maxLanguageId[ 0 ] &&\\n\\t\\t\\t\\tresult[ 1 ] === maxLanguageId[ 1 ] &&\\n\\t\\t\\t\\tresult[ 2 ] === maxLanguageId[ 2 ];\\n\\t\\t});\\n\\n\\t\\tif ( matchFound ) {\\n\\t\\t\\tif ( variants ) {\\n\\t\\t\\t\\tmatch.push( variants );\\n\\t\\t\\t}\\n\\t\\t\\treturn match;\\n\\t\\t}\\n\\n\\t\\t// [4]\\n\\t\\treturn maxLanguageId;\\n\\t};\\n\\n\\n\\n\\n\\t/**\\n\\t * subtags( locale )\\n\\t *\\n\\t * @locale [String]\\n\\t */\\n\\tvar coreSubtags = function( locale ) {\\n\\t\\tvar aux, unicodeLanguageId,\\n\\t\\t\\tsubtags = [];\\n\\n\\t\\tlocale = locale.replace( /_/, \\"-\\" );\\n\\n\\t\\t// Unicode locale extensions.\\n\\t\\taux = locale.split( \\"-u-\\" );\\n\\t\\tif ( aux[ 1 ] ) {\\n\\t\\t\\taux[ 1 ] = aux[ 1 ].split( \\"-t-\\" );\\n\\t\\t\\tlocale = aux[ 0 ] + ( aux[ 1 ][ 1 ] ? \\"-t-\\" + aux[ 1 ][ 1 ] : \\"\\");\\n\\t\\t\\tsubtags[ 4 /* unicodeLocaleExtensions */ ] = aux[ 1 ][ 0 ];\\n\\t\\t}\\n\\n\\t\\t// TODO normalize transformed extensions. Currently, skipped.\\n\\t\\t// subtags[ x ] = locale.split( \\"-t-\\" )[ 1 ];\\n\\t\\tunicodeLanguageId = locale.split( \\"-t-\\" )[ 0 ];\\n\\n\\t\\t// unicode_language_id = \\"root\\"\\n\\t\\t//   | unicode_language_subtag         \\n\\t\\t//     (sep unicode_script_subtag)? \\n\\t\\t//     (sep unicode_region_subtag)?\\n\\t\\t//     (sep unicode_variant_subtag)* ;\\n\\t\\t//\\n\\t\\t// Although unicode_language_subtag = alpha{2,8}, I\'m using alpha{2,3}. Because, there\'s no language on CLDR lengthier than 3.\\n\\t\\taux = unicodeLanguageId.match( /^(([a-z]{2,3})(-([A-Z][a-z]{3}))?(-([A-Z]{2}|[0-9]{3}))?)((-([a-zA-Z0-9]{5,8}|[0-9][a-zA-Z0-9]{3}))*)$|^(root)$/ );\\n\\t\\tif ( aux === null ) {\\n\\t\\t\\treturn [ \\"und\\", \\"Zzzz\\", \\"ZZ\\" ];\\n\\t\\t}\\n\\t\\tsubtags[ 0 /* language */ ] = aux[ 10 ] /* root */ || aux[ 2 ] || \\"und\\";\\n\\t\\tsubtags[ 1 /* script */ ] = aux[ 4 ] || \\"Zzzz\\";\\n\\t\\tsubtags[ 2 /* territory */ ] = aux[ 6 ] || \\"ZZ\\";\\n\\t\\tif ( aux[ 7 ] && aux[ 7 ].length ) {\\n\\t\\t\\tsubtags[ 3 /* variant */ ] = aux[ 7 ].slice( 1 ) /* remove leading \\"-\\" */;\\n\\t\\t}\\n\\n\\t\\t// 0: language\\n\\t\\t// 1: script\\n\\t\\t// 2: territory (aka region)\\n\\t\\t// 3: variant\\n\\t\\t// 4: unicodeLocaleExtensions\\n\\t\\treturn subtags;\\n\\t};\\n\\n\\n\\n\\n\\tvar arrayForEach = function( array, callback ) {\\n\\t\\tvar i, length;\\n\\t\\tif ( array.forEach ) {\\n\\t\\t\\treturn array.forEach( callback );\\n\\t\\t}\\n\\t\\tfor ( i = 0, length = array.length; i < length; i++ ) {\\n\\t\\t\\tcallback( array[ i ], i, array );\\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\n\\t/**\\n\\t * bundleLookup( minLanguageId )\\n\\t *\\n\\t * @Cldr [Cldr class]\\n\\t *\\n\\t * @cldr [Cldr instance]\\n\\t *\\n\\t * @minLanguageId [String] requested languageId after applied remove likely subtags.\\n\\t */\\n\\tvar bundleLookup = function( Cldr, cldr, minLanguageId ) {\\n\\t\\tvar availableBundleMap = Cldr._availableBundleMap,\\n\\t\\t\\tavailableBundleMapQueue = Cldr._availableBundleMapQueue;\\n\\n\\t\\tif ( availableBundleMapQueue.length ) {\\n\\t\\t\\tarrayForEach( availableBundleMapQueue, function( bundle ) {\\n\\t\\t\\t\\tvar existing, maxBundle, minBundle, subtags;\\n\\t\\t\\t\\tsubtags = coreSubtags( bundle );\\n\\t\\t\\t\\tmaxBundle = coreLikelySubtags( Cldr, cldr, subtags );\\n\\t\\t\\t\\tminBundle = coreRemoveLikelySubtags( Cldr, cldr, maxBundle );\\n\\t\\t\\t\\tminBundle = minBundle.join( Cldr.localeSep );\\n\\t\\t\\t\\texisting = availableBundleMap[ minBundle ];\\n\\t\\t\\t\\tif ( existing && existing.length < bundle.length ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tavailableBundleMap[ minBundle ] = bundle;\\n\\t\\t\\t});\\n\\t\\t\\tCldr._availableBundleMapQueue = [];\\n\\t\\t}\\n\\n\\t\\treturn availableBundleMap[ minLanguageId ] || null;\\n\\t};\\n\\n\\n\\n\\n\\tvar objectKeys = function( object ) {\\n\\t\\tvar i,\\n\\t\\t\\tresult = [];\\n\\n\\t\\tif ( Object.keys ) {\\n\\t\\t\\treturn Object.keys( object );\\n\\t\\t}\\n\\n\\t\\tfor ( i in object ) {\\n\\t\\t\\tresult.push( i );\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t};\\n\\n\\n\\n\\n\\tvar createError = function( code, attributes ) {\\n\\t\\tvar error, message;\\n\\n\\t\\tmessage = code + ( attributes && JSON ? \\": \\" + JSON.stringify( attributes ) : \\"\\" );\\n\\t\\terror = new Error( message );\\n\\t\\terror.code = code;\\n\\n\\t\\t// extend( error, attributes );\\n\\t\\tarrayForEach( objectKeys( attributes ), function( attribute ) {\\n\\t\\t\\terror[ attribute ] = attributes[ attribute ];\\n\\t\\t});\\n\\n\\t\\treturn error;\\n\\t};\\n\\n\\n\\n\\n\\tvar validate = function( code, check, attributes ) {\\n\\t\\tif ( !check ) {\\n\\t\\t\\tthrow createError( code, attributes );\\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\n\\tvar validatePresence = function( value, name ) {\\n\\t\\tvalidate( \\"E_MISSING_PARAMETER\\", typeof value !== \\"undefined\\", {\\n\\t\\t\\tname: name\\n\\t\\t});\\n\\t};\\n\\n\\n\\n\\n\\tvar validateType = function( value, name, check, expected ) {\\n\\t\\tvalidate( \\"E_INVALID_PAR_TYPE\\", check, {\\n\\t\\t\\texpected: expected,\\n\\t\\t\\tname: name,\\n\\t\\t\\tvalue: value\\n\\t\\t});\\n\\t};\\n\\n\\n\\n\\n\\tvar validateTypePath = function( value, name ) {\\n\\t\\tvalidateType( value, name, typeof value === \\"string\\" || arrayIsArray( value ), \\"String or Array\\" );\\n\\t};\\n\\n\\n\\n\\n\\t/**\\n\\t * Function inspired by jQuery Core, but reduced to our use case.\\n\\t */\\n\\tvar isPlainObject = function( obj ) {\\n\\t\\treturn obj !== null && \\"\\" + obj === \\"[object Object]\\";\\n\\t};\\n\\n\\n\\n\\n\\tvar validateTypePlainObject = function( value, name ) {\\n\\t\\tvalidateType( value, name, typeof value === \\"undefined\\" || isPlainObject( value ), \\"Plain Object\\" );\\n\\t};\\n\\n\\n\\n\\n\\tvar validateTypeString = function( value, name ) {\\n\\t\\tvalidateType( value, name, typeof value === \\"string\\", \\"a string\\" );\\n\\t};\\n\\n\\n\\n\\n\\t// @path: normalized path\\n\\tvar resourceGet = function( data, path ) {\\n\\t\\tvar i,\\n\\t\\t\\tnode = data,\\n\\t\\t\\tlength = path.length;\\n\\n\\t\\tfor ( i = 0; i < length - 1; i++ ) {\\n\\t\\t\\tnode = node[ path[ i ] ];\\n\\t\\t\\tif ( !node ) {\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn node[ path[ i ] ];\\n\\t};\\n\\n\\n\\n\\n\\t/**\\n\\t * setAvailableBundles( Cldr, json )\\n\\t *\\n\\t * @Cldr [Cldr class]\\n\\t *\\n\\t * @json resolved/unresolved cldr data.\\n\\t *\\n\\t * Set available bundles queue based on passed json CLDR data. Considers a bundle as any String at /main/{bundle}.\\n\\t */\\n\\tvar coreSetAvailableBundles = function( Cldr, json ) {\\n\\t\\tvar bundle,\\n\\t\\t\\tavailableBundleMapQueue = Cldr._availableBundleMapQueue,\\n\\t\\t\\tmain = resourceGet( json, [ \\"main\\" ] );\\n\\n\\t\\tif ( main ) {\\n\\t\\t\\tfor ( bundle in main ) {\\n\\t\\t\\t\\tif ( main.hasOwnProperty( bundle ) && bundle !== \\"root\\" &&\\n\\t\\t\\t\\t\\t\\t\\tavailableBundleMapQueue.indexOf( bundle ) === -1 ) {\\n\\t\\t\\t\\t\\tavailableBundleMapQueue.push( bundle );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\n\\n\\tvar alwaysArray = function( somethingOrArray ) {\\n\\t\\treturn arrayIsArray( somethingOrArray ) ?  somethingOrArray : [ somethingOrArray ];\\n\\t};\\n\\n\\n\\tvar jsonMerge = (function() {\\n\\n\\t// Returns new deeply merged JSON.\\n\\t//\\n\\t// Eg.\\n\\t// merge( { a: { b: 1, c: 2 } }, { a: { b: 3, d: 4 } } )\\n\\t// -> { a: { b: 3, c: 2, d: 4 } }\\n\\t//\\n\\t// @arguments JSON\'s\\n\\t// \\n\\tvar merge = function() {\\n\\t\\tvar destination = {},\\n\\t\\t\\tsources = [].slice.call( arguments, 0 );\\n\\t\\tarrayForEach( sources, function( source ) {\\n\\t\\t\\tvar prop;\\n\\t\\t\\tfor ( prop in source ) {\\n\\t\\t\\t\\tif ( prop in destination && typeof destination[ prop ] === \\"object\\" && !arrayIsArray( destination[ prop ] ) ) {\\n\\n\\t\\t\\t\\t\\t// Merge Objects\\n\\t\\t\\t\\t\\tdestination[ prop ] = merge( destination[ prop ], source[ prop ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// Set new values\\n\\t\\t\\t\\t\\tdestination[ prop ] = source[ prop ];\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn destination;\\n\\t};\\n\\n\\treturn merge;\\n\\n}());\\n\\n\\n\\t/**\\n\\t * load( Cldr, source, jsons )\\n\\t *\\n\\t * @Cldr [Cldr class]\\n\\t *\\n\\t * @source [Object]\\n\\t *\\n\\t * @jsons [arguments]\\n\\t */\\n\\tvar coreLoad = function( Cldr, source, jsons ) {\\n\\t\\tvar i, j, json;\\n\\n\\t\\tvalidatePresence( jsons[ 0 ], \\"json\\" );\\n\\n\\t\\t// Support arbitrary parameters, e.g., `Cldr.load({...}, {...})`.\\n\\t\\tfor ( i = 0; i < jsons.length; i++ ) {\\n\\n\\t\\t\\t// Support array parameters, e.g., `Cldr.load([{...}, {...}])`.\\n\\t\\t\\tjson = alwaysArray( jsons[ i ] );\\n\\n\\t\\t\\tfor ( j = 0; j < json.length; j++ ) {\\n\\t\\t\\t\\tvalidateTypePlainObject( json[ j ], \\"json\\" );\\n\\t\\t\\t\\tsource = jsonMerge( source, json[ j ] );\\n\\t\\t\\t\\tcoreSetAvailableBundles( Cldr, json[ j ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn source;\\n\\t};\\n\\n\\n\\n\\tvar itemGetResolved = function( Cldr, path, attributes ) {\\n\\t\\t// Resolve path\\n\\t\\tvar normalizedPath = pathNormalize( path, attributes );\\n\\n\\t\\treturn resourceGet( Cldr._resolved, normalizedPath );\\n\\t};\\n\\n\\n\\n\\n\\t/**\\n\\t * new Cldr()\\n\\t */\\n\\tvar Cldr = function( locale ) {\\n\\t\\tthis.init( locale );\\n\\t};\\n\\n\\t// Build optimization hack to avoid duplicating functions across modules.\\n\\tCldr._alwaysArray = alwaysArray;\\n\\tCldr._coreLoad = coreLoad;\\n\\tCldr._createError = createError;\\n\\tCldr._itemGetResolved = itemGetResolved;\\n\\tCldr._jsonMerge = jsonMerge;\\n\\tCldr._pathNormalize = pathNormalize;\\n\\tCldr._resourceGet = resourceGet;\\n\\tCldr._validatePresence = validatePresence;\\n\\tCldr._validateType = validateType;\\n\\tCldr._validateTypePath = validateTypePath;\\n\\tCldr._validateTypePlainObject = validateTypePlainObject;\\n\\n\\tCldr._availableBundleMap = {};\\n\\tCldr._availableBundleMapQueue = [];\\n\\tCldr._resolved = {};\\n\\n\\t// Allow user to override locale separator \\"-\\" (default) | \\"_\\". According to http://www.unicode.org/reports/tr35/#Unicode_language_identifier, both \\"-\\" and \\"_\\" are valid locale separators (eg. \\"en_GB\\", \\"en-GB\\"). According to http://unicode.org/cldr/trac/ticket/6786 its usage must be consistent throughout the data set.\\n\\tCldr.localeSep = \\"-\\";\\n\\n\\t/**\\n\\t * Cldr.load( json [, json, ...] )\\n\\t *\\n\\t * @json [JSON] CLDR data or [Array] Array of @json\'s.\\n\\t *\\n\\t * Load resolved cldr data.\\n\\t */\\n\\tCldr.load = function() {\\n\\t\\tCldr._resolved = coreLoad( Cldr, Cldr._resolved, arguments );\\n\\t};\\n\\n\\t/**\\n\\t * .init() automatically run on instantiation/construction.\\n\\t */\\n\\tCldr.prototype.init = function( locale ) {\\n\\t\\tvar attributes, language, maxLanguageId, minLanguageId, script, subtags, territory, unicodeLocaleExtensions, variant,\\n\\t\\t\\tsep = Cldr.localeSep,\\n\\t\\t\\tunicodeLocaleExtensionsRaw = \\"\\";\\n\\n\\t\\tvalidatePresence( locale, \\"locale\\" );\\n\\t\\tvalidateTypeString( locale, \\"locale\\" );\\n\\n\\t\\tsubtags = coreSubtags( locale );\\n\\n\\t\\tif ( subtags.length === 5 ) {\\n\\t\\t\\tunicodeLocaleExtensions = subtags.pop();\\n\\t\\t\\tunicodeLocaleExtensionsRaw = sep + \\"u\\" + sep + unicodeLocaleExtensions;\\n\\t\\t\\t// Remove trailing null when there is unicodeLocaleExtensions but no variants.\\n\\t\\t\\tif ( !subtags[ 3 ] ) {\\n\\t\\t\\t\\tsubtags.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvariant = subtags[ 3 ];\\n\\n\\t\\t// Normalize locale code.\\n\\t\\t// Get (or deduce) the \\"triple subtags\\": language, territory (also aliased as region), and script subtags.\\n\\t\\t// Get the variant subtags (calendar, collation, currency, etc).\\n\\t\\t// refs:\\n\\t\\t// - http://www.unicode.org/reports/tr35/#Field_Definitions\\n\\t\\t// - http://www.unicode.org/reports/tr35/#Language_and_Locale_IDs\\n\\t\\t// - http://www.unicode.org/reports/tr35/#Unicode_locale_identifier\\n\\n\\t\\t// When a locale id does not specify a language, or territory (region), or script, they are obtained by Likely Subtags.\\n\\t\\tmaxLanguageId = coreLikelySubtags( Cldr, this, subtags, { force: true } ) || subtags;\\n\\t\\tlanguage = maxLanguageId[ 0 ];\\n\\t\\tscript = maxLanguageId[ 1 ];\\n\\t\\tterritory = maxLanguageId[ 2 ];\\n\\n\\t\\tminLanguageId = coreRemoveLikelySubtags( Cldr, this, maxLanguageId ).join( sep );\\n\\n\\t\\t// Set attributes\\n\\t\\tthis.attributes = attributes = {\\n\\t\\t\\tbundle: bundleLookup( Cldr, this, minLanguageId ),\\n\\n\\t\\t\\t// Unicode Language Id\\n\\t\\t\\tminLanguageId: minLanguageId + unicodeLocaleExtensionsRaw,\\n\\t\\t\\tmaxLanguageId: maxLanguageId.join( sep ) + unicodeLocaleExtensionsRaw,\\n\\n\\t\\t\\t// Unicode Language Id Subtabs\\n\\t\\t\\tlanguage: language,\\n\\t\\t\\tscript: script,\\n\\t\\t\\tterritory: territory,\\n\\t\\t\\tregion: territory, /* alias */\\n\\t\\t\\tvariant: variant\\n\\t\\t};\\n\\n\\t\\t// Unicode locale extensions.\\n\\t\\tunicodeLocaleExtensions && ( \\"-\\" + unicodeLocaleExtensions ).replace( /-[a-z]{3,8}|(-[a-z]{2})-([a-z]{3,8})/g, function( attribute, key, type ) {\\n\\n\\t\\t\\tif ( key ) {\\n\\n\\t\\t\\t\\t// Extension is in the `keyword` form.\\n\\t\\t\\t\\tattributes[ \\"u\\" + key ] = type;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Extension is in the `attribute` form.\\n\\t\\t\\t\\tattributes[ \\"u\\" + attribute ] = true;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tthis.locale = locale;\\n\\t};\\n\\n\\t/**\\n\\t * .get()\\n\\t */\\n\\tCldr.prototype.get = function( path ) {\\n\\n\\t\\tvalidatePresence( path, \\"path\\" );\\n\\t\\tvalidateTypePath( path, \\"path\\" );\\n\\n\\t\\treturn itemGetResolved( Cldr, path, this.attributes );\\n\\t};\\n\\n\\t/**\\n\\t * .main()\\n\\t */\\n\\tCldr.prototype.main = function( path ) {\\n\\t\\tvalidatePresence( path, \\"path\\" );\\n\\t\\tvalidateTypePath( path, \\"path\\" );\\n\\n\\t\\tvalidate( \\"E_MISSING_BUNDLE\\", this.attributes.bundle !== null, {\\n\\t\\t\\tlocale: this.locale\\n\\t\\t});\\n\\n\\t\\tpath = alwaysArray( path );\\n\\t\\treturn this.get( [ \\"main/{bundle}\\" ].concat( path ) );\\n\\t};\\n\\n\\treturn Cldr;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci5qcz8xMDEzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKipcXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC41LjFcXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cXG4gKlxcbiAqIENvcHlyaWdodCAyMDEzIFJhZmFlbCBYYXZpZXIgZGUgU291emFcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDE5LTAxLTIxVDEzOjQzWlxcbiAqL1xcbi8qIVxcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjUuMSAyMDE5LTAxLTIxVDEzOjQzWiBNSVQgbGljZW5zZSDCqSBSYWZhZWwgWGF2aWVyXFxuICogaHR0cDovL2dpdC5pby9oNGxtVmdcXG4gKi9cXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XFxuXFxuXFx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQgKSB7XFxuXFx0XFx0Ly8gQU1ELlxcblxcdFxcdGRlZmluZSggZmFjdG9yeSApO1xcblxcdH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFx0XFx0Ly8gTm9kZS4gQ29tbW9uSlMuXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHQvLyBHbG9iYWxcXG5cXHRcXHRyb290LkNsZHIgPSBmYWN0b3J5KCk7XFxuXFx0fVxcblxcbn0oIHRoaXMsIGZ1bmN0aW9uKCkge1xcblxcblxcblxcdHZhciBhcnJheUlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKCBvYmogKSB7XFxuXFx0XFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggb2JqICkgPT09IFxcXCJbb2JqZWN0IEFycmF5XVxcXCI7XFxuXFx0fTtcXG5cXG5cXG5cXG5cXG5cXHR2YXIgcGF0aE5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCBwYXRoLCBhdHRyaWJ1dGVzICkge1xcblxcdFxcdGlmICggYXJyYXlJc0FycmF5KCBwYXRoICkgKSB7XFxuXFx0XFx0XFx0cGF0aCA9IHBhdGguam9pbiggXFxcIi9cXFwiICk7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggdHlwZW9mIHBhdGggIT09IFxcXCJzdHJpbmdcXFwiICkge1xcblxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggXFxcImludmFsaWQgcGF0aCBcXFxcXFxcIlxcXCIgKyBwYXRoICsgXFxcIlxcXFxcXFwiXFxcIiApO1xcblxcdFxcdH1cXG5cXHRcXHQvLyAxOiBJZ25vcmUgbGVhZGluZyBzbGFzaCBgL2BcXG5cXHRcXHQvLyAyOiBJZ25vcmUgbGVhZGluZyBgY2xkci9gXFxuXFx0XFx0cGF0aCA9IHBhdGhcXG5cXHRcXHRcXHQucmVwbGFjZSggL15cXFxcLy8gLCBcXFwiXFxcIiApIC8qIDEgKi9cXG5cXHRcXHRcXHQucmVwbGFjZSggL15jbGRyXFxcXC8vICwgXFxcIlxcXCIgKTsgLyogMiAqL1xcblxcblxcdFxcdC8vIFJlcGxhY2Uge2F0dHJpYnV0ZX0nc1xcblxcdFxcdHBhdGggPSBwYXRoLnJlcGxhY2UoIC97W2EtekEtWl0rfS9nLCBmdW5jdGlvbiggbmFtZSApIHtcXG5cXHRcXHRcXHRuYW1lID0gbmFtZS5yZXBsYWNlKCAvXnsoW159XSopfSQvLCBcXFwiJDFcXFwiICk7XFxuXFx0XFx0XFx0cmV0dXJuIGF0dHJpYnV0ZXNbIG5hbWUgXTtcXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHRyZXR1cm4gcGF0aC5zcGxpdCggXFxcIi9cXFwiICk7XFxuXFx0fTtcXG5cXG5cXG5cXG5cXG5cXHR2YXIgYXJyYXlTb21lID0gZnVuY3Rpb24oIGFycmF5LCBjYWxsYmFjayApIHtcXG5cXHRcXHR2YXIgaSwgbGVuZ3RoO1xcblxcdFxcdGlmICggYXJyYXkuc29tZSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXkuc29tZSggY2FsbGJhY2sgKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yICggaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrICkge1xcblxcdFxcdFxcdGlmICggY2FsbGJhY2soIGFycmF5WyBpIF0sIGksIGFycmF5ICkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fTtcXG5cXG5cXG5cXG5cXG5cXHQvKipcXG5cXHQgKiBSZXR1cm4gdGhlIG1heGltaXplZCBsYW5ndWFnZSBpZCBhcyBkZWZpbmVkIGluXFxuXFx0ICogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvI0xpa2VseV9TdWJ0YWdzXFxuXFx0ICogMS4gQ2Fub25pY2FsaXplLlxcblxcdCAqIDEuMSBNYWtlIHN1cmUgdGhlIGlucHV0IGxvY2FsZSBpcyBpbiBjYW5vbmljYWwgZm9ybTogdXNlcyB0aGUgcmlnaHRcXG5cXHQgKiBzZXBhcmF0b3IsIGFuZCBoYXMgdGhlIHJpZ2h0IGNhc2luZy5cXG5cXHQgKiBUT0RPIFJpZ2h0IGNhc2luZz8gV2hhdCBkZj8gSXQgc2VlbXMgbGFuZ3VhZ2VzIGFyZSBsb3dlcmNhc2UsIHNjcmlwdHMgYXJlXFxuXFx0ICogQ2FwaXRhbGl6ZWQsIHRlcnJpdG9yeSBpcyB1cHBlcmNhc2UuIEkgYW0gbGVhdmluZyB0aGlzIGFzIGFuIGV4ZXJjaXNlIHRvXFxuXFx0ICogdGhlIHVzZXIuXFxuXFx0ICpcXG5cXHQgKiAxLjIgUmVwbGFjZSBhbnkgZGVwcmVjYXRlZCBzdWJ0YWdzIHdpdGggdGhlaXIgY2Fub25pY2FsIHZhbHVlcyB1c2luZyB0aGVcXG5cXHQgKiA8YWxpYXM+IGRhdGEgaW4gc3VwcGxlbWVudGFsIG1ldGFkYXRhLiBVc2UgdGhlIGZpcnN0IHZhbHVlIGluIHRoZVxcblxcdCAqIHJlcGxhY2VtZW50IGxpc3QsIGlmIGl0IGV4aXN0cy4gTGFuZ3VhZ2UgdGFnIHJlcGxhY2VtZW50cyBtYXkgaGF2ZSBtdWx0aXBsZVxcblxcdCAqIHBhcnRzLCBzdWNoIGFzIFxcXCJzaFxcXCIg4p6eIFxcXCJzcl9MYXRuXFxcIiBvciBtb1xcXCIg4p6eIFxcXCJyb19NRFxcXCIuIEluIHN1Y2ggYSBjYXNlLCB0aGVcXG5cXHQgKiBvcmlnaW5hbCBzY3JpcHQgYW5kL29yIHJlZ2lvbiBhcmUgcmV0YWluZWQgaWYgdGhlcmUgaXMgb25lLiBUaHVzXFxuXFx0ICogXFxcInNoX0FyYWJfQVFcXFwiIOKeniBcXFwic3JfQXJhYl9BUVxcXCIsIG5vdCBcXFwic3JfTGF0bl9BUVxcXCIuXFxuXFx0ICogVE9ETyBXaGF0IDxhbGlhcz4gZGF0YT9cXG5cXHQgKlxcblxcdCAqIDEuMyBJZiB0aGUgdGFnIGlzIGdyYW5kZmF0aGVyZWQgKHNlZSA8dmFyaWFibGUgaWQ9XFxcIiRncmFuZGZhdGhlcmVkXFxcIlxcblxcdCAqIHR5cGU9XFxcImNob2ljZVxcXCI+IGluIHRoZSBzdXBwbGVtZW50YWwgZGF0YSksIHRoZW4gcmV0dXJuIGl0LlxcblxcdCAqIFRPRE8gZ3JhbmRmYXRoZXJlZD9cXG5cXHQgKlxcblxcdCAqIDEuNCBSZW1vdmUgdGhlIHNjcmlwdCBjb2RlICdaenp6JyBhbmQgdGhlIHJlZ2lvbiBjb2RlICdaWicgaWYgdGhleSBvY2N1ci5cXG5cXHQgKiAxLjUgR2V0IHRoZSBjb21wb25lbnRzIG9mIHRoZSBjbGVhbmVkLXVwIHNvdXJjZSB0YWcgKGxhbmd1YWdlcywgc2NyaXB0cyxcXG5cXHQgKiBhbmQgcmVnaW9ucyksIHBsdXMgYW55IHZhcmlhbnRzIGFuZCBleHRlbnNpb25zLlxcblxcdCAqIDIuIExvb2t1cC4gTG9va3VwIGVhY2ggb2YgdGhlIGZvbGxvd2luZyBpbiBvcmRlciwgYW5kIHN0b3Agb24gdGhlIGZpcnN0XFxuXFx0ICogbWF0Y2g6XFxuXFx0ICogMi4xIGxhbmd1YWdlc19zY3JpcHRzX3JlZ2lvbnNcXG5cXHQgKiAyLjIgbGFuZ3VhZ2VzX3JlZ2lvbnNcXG5cXHQgKiAyLjMgbGFuZ3VhZ2VzX3NjcmlwdHNcXG5cXHQgKiAyLjQgbGFuZ3VhZ2VzXFxuXFx0ICogMi41IHVuZF9zY3JpcHRzXFxuXFx0ICogMy4gUmV0dXJuXFxuXFx0ICogMy4xIElmIHRoZXJlIGlzIG5vIG1hdGNoLCBlaXRoZXIgcmV0dXJuIGFuIGVycm9yIHZhbHVlLCBvciB0aGUgbWF0Y2ggZm9yXFxuXFx0ICogXFxcInVuZFxcXCIgKGluIEFQSXMgd2hlcmUgYSB2YWxpZCBsYW5ndWFnZSB0YWcgaXMgcmVxdWlyZWQpLlxcblxcdCAqIDMuMiBPdGhlcndpc2UgdGhlcmUgaXMgYSBtYXRjaCA9IGxhbmd1YWdlbV9zY3JpcHRtX3JlZ2lvbm1cXG5cXHQgKiAzLjMgTGV0IHhyID0geHMgaWYgeHMgaXMgbm90IGVtcHR5LCBhbmQgeG0gb3RoZXJ3aXNlLlxcblxcdCAqIDMuNCBSZXR1cm4gdGhlIGxhbmd1YWdlIHRhZyBjb21wb3NlZCBvZiBsYW5ndWFnZXIgXyBzY3JpcHRyIF8gcmVnaW9uciArXFxuXFx0ICogdmFyaWFudHMgKyBleHRlbnNpb25zLlxcblxcdCAqXFxuXFx0ICogQHN1YnRhZ3MgW0FycmF5XSBub3JtYWxpemVkIGxhbmd1YWdlIGlkIHN1YnRhZ3MgdHVwbGUgKHNlZSBpbml0LmpzKS5cXG5cXHQgKi9cXG5cXHR2YXIgY29yZUxpa2VseVN1YnRhZ3MgPSBmdW5jdGlvbiggQ2xkciwgY2xkciwgc3VidGFncywgb3B0aW9ucyApIHtcXG5cXHRcXHR2YXIgbWF0Y2gsIG1hdGNoRm91bmQsXFxuXFx0XFx0XFx0bGFuZ3VhZ2UgPSBzdWJ0YWdzWyAwIF0sXFxuXFx0XFx0XFx0c2NyaXB0ID0gc3VidGFnc1sgMSBdLFxcblxcdFxcdFxcdHNlcCA9IENsZHIubG9jYWxlU2VwLFxcblxcdFxcdFxcdHRlcnJpdG9yeSA9IHN1YnRhZ3NbIDIgXSxcXG5cXHRcXHRcXHR2YXJpYW50cyA9IHN1YnRhZ3Muc2xpY2UoIDMsIDQgKTtcXG5cXHRcXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG5cXHRcXHQvLyBTa2lwIGlmIChsYW5ndWFnZSwgc2NyaXB0LCB0ZXJyaXRvcnkpIGlzIG5vdCBlbXB0eSBbMy4zXVxcblxcdFxcdGlmICggbGFuZ3VhZ2UgIT09IFxcXCJ1bmRcXFwiICYmIHNjcmlwdCAhPT0gXFxcIlp6enpcXFwiICYmIHRlcnJpdG9yeSAhPT0gXFxcIlpaXFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gWyBsYW5ndWFnZSwgc2NyaXB0LCB0ZXJyaXRvcnkgXS5jb25jYXQoIHZhcmlhbnRzICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNraXAgaWYgbm8gc3VwcGxlbWVudGFsIGxpa2VseVN1YnRhZ3MgZGF0YSBpcyBwcmVzZW50XFxuXFx0XFx0aWYgKCB0eXBlb2YgY2xkci5nZXQoIFxcXCJzdXBwbGVtZW50YWwvbGlrZWx5U3VidGFnc1xcXCIgKSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBbMl1cXG5cXHRcXHRtYXRjaEZvdW5kID0gYXJyYXlTb21lKFtcXG5cXHRcXHRcXHRbIGxhbmd1YWdlLCBzY3JpcHQsIHRlcnJpdG9yeSBdLFxcblxcdFxcdFxcdFsgbGFuZ3VhZ2UsIHRlcnJpdG9yeSBdLFxcblxcdFxcdFxcdFsgbGFuZ3VhZ2UsIHNjcmlwdCBdLFxcblxcdFxcdFxcdFsgbGFuZ3VhZ2UgXSxcXG5cXHRcXHRcXHRbIFxcXCJ1bmRcXFwiLCBzY3JpcHQgXVxcblxcdFxcdF0sIGZ1bmN0aW9uKCB0ZXN0ICkge1xcblxcdFxcdFxcdHJldHVybiBtYXRjaCA9ICEoL1xcXFxiKFp6enp8WlopXFxcXGIvKS50ZXN0KCB0ZXN0LmpvaW4oIHNlcCApICkgLyogWzEuNF0gKi8gJiYgY2xkci5nZXQoIFsgXFxcInN1cHBsZW1lbnRhbC9saWtlbHlTdWJ0YWdzXFxcIiwgdGVzdC5qb2luKCBzZXAgKSBdICk7XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0Ly8gWzNdXFxuXFx0XFx0aWYgKCBtYXRjaEZvdW5kICkge1xcblxcdFxcdFxcdC8vIFszLjIgLi4gMy40XVxcblxcdFxcdFxcdG1hdGNoID0gbWF0Y2guc3BsaXQoIHNlcCApO1xcblxcdFxcdFxcdHJldHVybiBbXFxuXFx0XFx0XFx0XFx0bGFuZ3VhZ2UgIT09IFxcXCJ1bmRcXFwiID8gbGFuZ3VhZ2UgOiBtYXRjaFsgMCBdLFxcblxcdFxcdFxcdFxcdHNjcmlwdCAhPT0gXFxcIlp6enpcXFwiID8gc2NyaXB0IDogbWF0Y2hbIDEgXSxcXG5cXHRcXHRcXHRcXHR0ZXJyaXRvcnkgIT09IFxcXCJaWlxcXCIgPyB0ZXJyaXRvcnkgOiBtYXRjaFsgMiBdXFxuXFx0XFx0XFx0XS5jb25jYXQoIHZhcmlhbnRzICk7XFxuXFx0XFx0fSBlbHNlIGlmICggb3B0aW9ucy5mb3JjZSApIHtcXG5cXHRcXHRcXHQvLyBbMy4xLjJdXFxuXFx0XFx0XFx0cmV0dXJuIGNsZHIuZ2V0KCBcXFwic3VwcGxlbWVudGFsL2xpa2VseVN1YnRhZ3MvdW5kXFxcIiApLnNwbGl0KCBzZXAgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdC8vIFszLjEuMV1cXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFxuXFxuXFx0LyoqXFxuXFx0ICogR2l2ZW4gYSBsb2NhbGUsIHJlbW92ZSBhbnkgZmllbGRzIHRoYXQgQWRkIExpa2VseSBTdWJ0YWdzIHdvdWxkIGFkZC5cXG5cXHQgKiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jTGlrZWx5X1N1YnRhZ3NcXG5cXHQgKiAxLiBGaXJzdCBnZXQgbWF4ID0gQWRkTGlrZWx5U3VidGFncyhpbnB1dExvY2FsZSkuIElmIGFuIGVycm9yIGlzIHNpZ25hbGVkLFxcblxcdCAqIHJldHVybiBpdC5cXG5cXHQgKiAyLiBSZW1vdmUgdGhlIHZhcmlhbnRzIGZyb20gbWF4LlxcblxcdCAqIDMuIFRoZW4gZm9yIHRyaWFsIGluIHtsYW5ndWFnZSwgbGFuZ3VhZ2UgXyByZWdpb24sIGxhbmd1YWdlIF8gc2NyaXB0fS4gSWZcXG5cXHQgKiBBZGRMaWtlbHlTdWJ0YWdzKHRyaWFsKSA9IG1heCwgdGhlbiByZXR1cm4gdHJpYWwgKyB2YXJpYW50cy5cXG5cXHQgKiA0LiBJZiB5b3UgZG8gbm90IGdldCBhIG1hdGNoLCByZXR1cm4gbWF4ICsgdmFyaWFudHMuXFxuXFx0ICogXFxuXFx0ICogQG1heExhbmd1YWdlSWQgW0FycmF5XSBtYXhMYW5ndWFnZUlkIHR1cGxlIChzZWUgaW5pdC5qcykuXFxuXFx0ICovXFxuXFx0dmFyIGNvcmVSZW1vdmVMaWtlbHlTdWJ0YWdzID0gZnVuY3Rpb24oIENsZHIsIGNsZHIsIG1heExhbmd1YWdlSWQgKSB7XFxuXFx0XFx0dmFyIG1hdGNoLCBtYXRjaEZvdW5kLFxcblxcdFxcdFxcdGxhbmd1YWdlID0gbWF4TGFuZ3VhZ2VJZFsgMCBdLFxcblxcdFxcdFxcdHNjcmlwdCA9IG1heExhbmd1YWdlSWRbIDEgXSxcXG5cXHRcXHRcXHR0ZXJyaXRvcnkgPSBtYXhMYW5ndWFnZUlkWyAyIF0sXFxuXFx0XFx0XFx0dmFyaWFudHMgPSBtYXhMYW5ndWFnZUlkWyAzIF07XFxuXFxuXFx0XFx0Ly8gWzNdXFxuXFx0XFx0bWF0Y2hGb3VuZCA9IGFycmF5U29tZShbXFxuXFx0XFx0XFx0WyBbIGxhbmd1YWdlLCBcXFwiWnp6elxcXCIsIFxcXCJaWlxcXCIgXSwgWyBsYW5ndWFnZSBdIF0sXFxuXFx0XFx0XFx0WyBbIGxhbmd1YWdlLCBcXFwiWnp6elxcXCIsIHRlcnJpdG9yeSBdLCBbIGxhbmd1YWdlLCB0ZXJyaXRvcnkgXSBdLFxcblxcdFxcdFxcdFsgWyBsYW5ndWFnZSwgc2NyaXB0LCBcXFwiWlpcXFwiIF0sIFsgbGFuZ3VhZ2UsIHNjcmlwdCBdIF1cXG5cXHRcXHRdLCBmdW5jdGlvbiggdGVzdCApIHtcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gY29yZUxpa2VseVN1YnRhZ3MoIENsZHIsIGNsZHIsIHRlc3RbIDAgXSApO1xcblxcdFxcdFxcdG1hdGNoID0gdGVzdFsgMSBdO1xcblxcdFxcdFxcdHJldHVybiByZXN1bHQgJiYgcmVzdWx0WyAwIF0gPT09IG1heExhbmd1YWdlSWRbIDAgXSAmJlxcblxcdFxcdFxcdFxcdHJlc3VsdFsgMSBdID09PSBtYXhMYW5ndWFnZUlkWyAxIF0gJiZcXG5cXHRcXHRcXHRcXHRyZXN1bHRbIDIgXSA9PT0gbWF4TGFuZ3VhZ2VJZFsgMiBdO1xcblxcdFxcdH0pO1xcblxcblxcdFxcdGlmICggbWF0Y2hGb3VuZCApIHtcXG5cXHRcXHRcXHRpZiAoIHZhcmlhbnRzICkge1xcblxcdFxcdFxcdFxcdG1hdGNoLnB1c2goIHZhcmlhbnRzICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtYXRjaDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gWzRdXFxuXFx0XFx0cmV0dXJuIG1heExhbmd1YWdlSWQ7XFxuXFx0fTtcXG5cXG5cXG5cXG5cXG5cXHQvKipcXG5cXHQgKiBzdWJ0YWdzKCBsb2NhbGUgKVxcblxcdCAqXFxuXFx0ICogQGxvY2FsZSBbU3RyaW5nXVxcblxcdCAqL1xcblxcdHZhciBjb3JlU3VidGFncyA9IGZ1bmN0aW9uKCBsb2NhbGUgKSB7XFxuXFx0XFx0dmFyIGF1eCwgdW5pY29kZUxhbmd1YWdlSWQsXFxuXFx0XFx0XFx0c3VidGFncyA9IFtdO1xcblxcblxcdFxcdGxvY2FsZSA9IGxvY2FsZS5yZXBsYWNlKCAvXy8sIFxcXCItXFxcIiApO1xcblxcblxcdFxcdC8vIFVuaWNvZGUgbG9jYWxlIGV4dGVuc2lvbnMuXFxuXFx0XFx0YXV4ID0gbG9jYWxlLnNwbGl0KCBcXFwiLXUtXFxcIiApO1xcblxcdFxcdGlmICggYXV4WyAxIF0gKSB7XFxuXFx0XFx0XFx0YXV4WyAxIF0gPSBhdXhbIDEgXS5zcGxpdCggXFxcIi10LVxcXCIgKTtcXG5cXHRcXHRcXHRsb2NhbGUgPSBhdXhbIDAgXSArICggYXV4WyAxIF1bIDEgXSA/IFxcXCItdC1cXFwiICsgYXV4WyAxIF1bIDEgXSA6IFxcXCJcXFwiKTtcXG5cXHRcXHRcXHRzdWJ0YWdzWyA0IC8qIHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zICovIF0gPSBhdXhbIDEgXVsgMCBdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBUT0RPIG5vcm1hbGl6ZSB0cmFuc2Zvcm1lZCBleHRlbnNpb25zLiBDdXJyZW50bHksIHNraXBwZWQuXFxuXFx0XFx0Ly8gc3VidGFnc1sgeCBdID0gbG9jYWxlLnNwbGl0KCBcXFwiLXQtXFxcIiApWyAxIF07XFxuXFx0XFx0dW5pY29kZUxhbmd1YWdlSWQgPSBsb2NhbGUuc3BsaXQoIFxcXCItdC1cXFwiIClbIDAgXTtcXG5cXG5cXHRcXHQvLyB1bmljb2RlX2xhbmd1YWdlX2lkID0gXFxcInJvb3RcXFwiXFxuXFx0XFx0Ly8gICB8IHVuaWNvZGVfbGFuZ3VhZ2Vfc3VidGFnICAgICAgICAgXFxuXFx0XFx0Ly8gICAgIChzZXAgdW5pY29kZV9zY3JpcHRfc3VidGFnKT8gXFxuXFx0XFx0Ly8gICAgIChzZXAgdW5pY29kZV9yZWdpb25fc3VidGFnKT9cXG5cXHRcXHQvLyAgICAgKHNlcCB1bmljb2RlX3ZhcmlhbnRfc3VidGFnKSogO1xcblxcdFxcdC8vXFxuXFx0XFx0Ly8gQWx0aG91Z2ggdW5pY29kZV9sYW5ndWFnZV9zdWJ0YWcgPSBhbHBoYXsyLDh9LCBJJ20gdXNpbmcgYWxwaGF7MiwzfS4gQmVjYXVzZSwgdGhlcmUncyBubyBsYW5ndWFnZSBvbiBDTERSIGxlbmd0aGllciB0aGFuIDMuXFxuXFx0XFx0YXV4ID0gdW5pY29kZUxhbmd1YWdlSWQubWF0Y2goIC9eKChbYS16XXsyLDN9KSgtKFtBLVpdW2Etel17M30pKT8oLShbQS1aXXsyfXxbMC05XXszfSkpPykoKC0oW2EtekEtWjAtOV17NSw4fXxbMC05XVthLXpBLVowLTldezN9KSkqKSR8Xihyb290KSQvICk7XFxuXFx0XFx0aWYgKCBhdXggPT09IG51bGwgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIFsgXFxcInVuZFxcXCIsIFxcXCJaenp6XFxcIiwgXFxcIlpaXFxcIiBdO1xcblxcdFxcdH1cXG5cXHRcXHRzdWJ0YWdzWyAwIC8qIGxhbmd1YWdlICovIF0gPSBhdXhbIDEwIF0gLyogcm9vdCAqLyB8fCBhdXhbIDIgXSB8fCBcXFwidW5kXFxcIjtcXG5cXHRcXHRzdWJ0YWdzWyAxIC8qIHNjcmlwdCAqLyBdID0gYXV4WyA0IF0gfHwgXFxcIlp6enpcXFwiO1xcblxcdFxcdHN1YnRhZ3NbIDIgLyogdGVycml0b3J5ICovIF0gPSBhdXhbIDYgXSB8fCBcXFwiWlpcXFwiO1xcblxcdFxcdGlmICggYXV4WyA3IF0gJiYgYXV4WyA3IF0ubGVuZ3RoICkge1xcblxcdFxcdFxcdHN1YnRhZ3NbIDMgLyogdmFyaWFudCAqLyBdID0gYXV4WyA3IF0uc2xpY2UoIDEgKSAvKiByZW1vdmUgbGVhZGluZyBcXFwiLVxcXCIgKi87XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIDA6IGxhbmd1YWdlXFxuXFx0XFx0Ly8gMTogc2NyaXB0XFxuXFx0XFx0Ly8gMjogdGVycml0b3J5IChha2EgcmVnaW9uKVxcblxcdFxcdC8vIDM6IHZhcmlhbnRcXG5cXHRcXHQvLyA0OiB1bmljb2RlTG9jYWxlRXh0ZW5zaW9uc1xcblxcdFxcdHJldHVybiBzdWJ0YWdzO1xcblxcdH07XFxuXFxuXFxuXFxuXFxuXFx0dmFyIGFycmF5Rm9yRWFjaCA9IGZ1bmN0aW9uKCBhcnJheSwgY2FsbGJhY2sgKSB7XFxuXFx0XFx0dmFyIGksIGxlbmd0aDtcXG5cXHRcXHRpZiAoIGFycmF5LmZvckVhY2ggKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5LmZvckVhY2goIGNhbGxiYWNrICk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAoIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyApIHtcXG5cXHRcXHRcXHRjYWxsYmFjayggYXJyYXlbIGkgXSwgaSwgYXJyYXkgKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXG5cXG5cXG5cXHQvKipcXG5cXHQgKiBidW5kbGVMb29rdXAoIG1pbkxhbmd1YWdlSWQgKVxcblxcdCAqXFxuXFx0ICogQENsZHIgW0NsZHIgY2xhc3NdXFxuXFx0ICpcXG5cXHQgKiBAY2xkciBbQ2xkciBpbnN0YW5jZV1cXG5cXHQgKlxcblxcdCAqIEBtaW5MYW5ndWFnZUlkIFtTdHJpbmddIHJlcXVlc3RlZCBsYW5ndWFnZUlkIGFmdGVyIGFwcGxpZWQgcmVtb3ZlIGxpa2VseSBzdWJ0YWdzLlxcblxcdCAqL1xcblxcdHZhciBidW5kbGVMb29rdXAgPSBmdW5jdGlvbiggQ2xkciwgY2xkciwgbWluTGFuZ3VhZ2VJZCApIHtcXG5cXHRcXHR2YXIgYXZhaWxhYmxlQnVuZGxlTWFwID0gQ2xkci5fYXZhaWxhYmxlQnVuZGxlTWFwLFxcblxcdFxcdFxcdGF2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlID0gQ2xkci5fYXZhaWxhYmxlQnVuZGxlTWFwUXVldWU7XFxuXFxuXFx0XFx0aWYgKCBhdmFpbGFibGVCdW5kbGVNYXBRdWV1ZS5sZW5ndGggKSB7XFxuXFx0XFx0XFx0YXJyYXlGb3JFYWNoKCBhdmFpbGFibGVCdW5kbGVNYXBRdWV1ZSwgZnVuY3Rpb24oIGJ1bmRsZSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgZXhpc3RpbmcsIG1heEJ1bmRsZSwgbWluQnVuZGxlLCBzdWJ0YWdzO1xcblxcdFxcdFxcdFxcdHN1YnRhZ3MgPSBjb3JlU3VidGFncyggYnVuZGxlICk7XFxuXFx0XFx0XFx0XFx0bWF4QnVuZGxlID0gY29yZUxpa2VseVN1YnRhZ3MoIENsZHIsIGNsZHIsIHN1YnRhZ3MgKTtcXG5cXHRcXHRcXHRcXHRtaW5CdW5kbGUgPSBjb3JlUmVtb3ZlTGlrZWx5U3VidGFncyggQ2xkciwgY2xkciwgbWF4QnVuZGxlICk7XFxuXFx0XFx0XFx0XFx0bWluQnVuZGxlID0gbWluQnVuZGxlLmpvaW4oIENsZHIubG9jYWxlU2VwICk7XFxuXFx0XFx0XFx0XFx0ZXhpc3RpbmcgPSBhdmFpbGFibGVCdW5kbGVNYXBbIG1pbkJ1bmRsZSBdO1xcblxcdFxcdFxcdFxcdGlmICggZXhpc3RpbmcgJiYgZXhpc3RpbmcubGVuZ3RoIDwgYnVuZGxlLmxlbmd0aCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGF2YWlsYWJsZUJ1bmRsZU1hcFsgbWluQnVuZGxlIF0gPSBidW5kbGU7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0Q2xkci5fYXZhaWxhYmxlQnVuZGxlTWFwUXVldWUgPSBbXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGF2YWlsYWJsZUJ1bmRsZU1hcFsgbWluTGFuZ3VhZ2VJZCBdIHx8IG51bGw7XFxuXFx0fTtcXG5cXG5cXG5cXG5cXG5cXHR2YXIgb2JqZWN0S2V5cyA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XFxuXFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0cmVzdWx0ID0gW107XFxuXFxuXFx0XFx0aWYgKCBPYmplY3Qua2V5cyApIHtcXG5cXHRcXHRcXHRyZXR1cm4gT2JqZWN0LmtleXMoIG9iamVjdCApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmb3IgKCBpIGluIG9iamVjdCApIHtcXG5cXHRcXHRcXHRyZXN1bHQucHVzaCggaSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcdH07XFxuXFxuXFxuXFxuXFxuXFx0dmFyIGNyZWF0ZUVycm9yID0gZnVuY3Rpb24oIGNvZGUsIGF0dHJpYnV0ZXMgKSB7XFxuXFx0XFx0dmFyIGVycm9yLCBtZXNzYWdlO1xcblxcblxcdFxcdG1lc3NhZ2UgPSBjb2RlICsgKCBhdHRyaWJ1dGVzICYmIEpTT04gPyBcXFwiOiBcXFwiICsgSlNPTi5zdHJpbmdpZnkoIGF0dHJpYnV0ZXMgKSA6IFxcXCJcXFwiICk7XFxuXFx0XFx0ZXJyb3IgPSBuZXcgRXJyb3IoIG1lc3NhZ2UgKTtcXG5cXHRcXHRlcnJvci5jb2RlID0gY29kZTtcXG5cXG5cXHRcXHQvLyBleHRlbmQoIGVycm9yLCBhdHRyaWJ1dGVzICk7XFxuXFx0XFx0YXJyYXlGb3JFYWNoKCBvYmplY3RLZXlzKCBhdHRyaWJ1dGVzICksIGZ1bmN0aW9uKCBhdHRyaWJ1dGUgKSB7XFxuXFx0XFx0XFx0ZXJyb3JbIGF0dHJpYnV0ZSBdID0gYXR0cmlidXRlc1sgYXR0cmlidXRlIF07XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0cmV0dXJuIGVycm9yO1xcblxcdH07XFxuXFxuXFxuXFxuXFxuXFx0dmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oIGNvZGUsIGNoZWNrLCBhdHRyaWJ1dGVzICkge1xcblxcdFxcdGlmICggIWNoZWNrICkge1xcblxcdFxcdFxcdHRocm93IGNyZWF0ZUVycm9yKCBjb2RlLCBhdHRyaWJ1dGVzICk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFxuXFxuXFxuXFx0dmFyIHZhbGlkYXRlUHJlc2VuY2UgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XFxuXFx0XFx0dmFsaWRhdGUoIFxcXCJFX01JU1NJTkdfUEFSQU1FVEVSXFxcIiwgdHlwZW9mIHZhbHVlICE9PSBcXFwidW5kZWZpbmVkXFxcIiwge1xcblxcdFxcdFxcdG5hbWU6IG5hbWVcXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcblxcblxcblxcblxcdHZhciB2YWxpZGF0ZVR5cGUgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUsIGNoZWNrLCBleHBlY3RlZCApIHtcXG5cXHRcXHR2YWxpZGF0ZSggXFxcIkVfSU5WQUxJRF9QQVJfVFlQRVxcXCIsIGNoZWNrLCB7XFxuXFx0XFx0XFx0ZXhwZWN0ZWQ6IGV4cGVjdGVkLFxcblxcdFxcdFxcdG5hbWU6IG5hbWUsXFxuXFx0XFx0XFx0dmFsdWU6IHZhbHVlXFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXG5cXG5cXG5cXG5cXHR2YXIgdmFsaWRhdGVUeXBlUGF0aCA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcXG5cXHRcXHR2YWxpZGF0ZVR5cGUoIHZhbHVlLCBuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiIHx8IGFycmF5SXNBcnJheSggdmFsdWUgKSwgXFxcIlN0cmluZyBvciBBcnJheVxcXCIgKTtcXG5cXHR9O1xcblxcblxcblxcblxcblxcdC8qKlxcblxcdCAqIEZ1bmN0aW9uIGluc3BpcmVkIGJ5IGpRdWVyeSBDb3JlLCBidXQgcmVkdWNlZCB0byBvdXIgdXNlIGNhc2UuXFxuXFx0ICovXFxuXFx0dmFyIGlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiggb2JqICkge1xcblxcdFxcdHJldHVybiBvYmogIT09IG51bGwgJiYgXFxcIlxcXCIgKyBvYmogPT09IFxcXCJbb2JqZWN0IE9iamVjdF1cXFwiO1xcblxcdH07XFxuXFxuXFxuXFxuXFxuXFx0dmFyIHZhbGlkYXRlVHlwZVBsYWluT2JqZWN0ID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xcblxcdFxcdHZhbGlkYXRlVHlwZSggdmFsdWUsIG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgaXNQbGFpbk9iamVjdCggdmFsdWUgKSwgXFxcIlBsYWluIE9iamVjdFxcXCIgKTtcXG5cXHR9O1xcblxcblxcblxcblxcblxcdHZhciB2YWxpZGF0ZVR5cGVTdHJpbmcgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XFxuXFx0XFx0dmFsaWRhdGVUeXBlKCB2YWx1ZSwgbmFtZSwgdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiwgXFxcImEgc3RyaW5nXFxcIiApO1xcblxcdH07XFxuXFxuXFxuXFxuXFxuXFx0Ly8gQHBhdGg6IG5vcm1hbGl6ZWQgcGF0aFxcblxcdHZhciByZXNvdXJjZUdldCA9IGZ1bmN0aW9uKCBkYXRhLCBwYXRoICkge1xcblxcdFxcdHZhciBpLFxcblxcdFxcdFxcdG5vZGUgPSBkYXRhLFxcblxcdFxcdFxcdGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xcblxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrICkge1xcblxcdFxcdFxcdG5vZGUgPSBub2RlWyBwYXRoWyBpIF0gXTtcXG5cXHRcXHRcXHRpZiAoICFub2RlICkge1xcblxcdFxcdFxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gbm9kZVsgcGF0aFsgaSBdIF07XFxuXFx0fTtcXG5cXG5cXG5cXG5cXG5cXHQvKipcXG5cXHQgKiBzZXRBdmFpbGFibGVCdW5kbGVzKCBDbGRyLCBqc29uIClcXG5cXHQgKlxcblxcdCAqIEBDbGRyIFtDbGRyIGNsYXNzXVxcblxcdCAqXFxuXFx0ICogQGpzb24gcmVzb2x2ZWQvdW5yZXNvbHZlZCBjbGRyIGRhdGEuXFxuXFx0ICpcXG5cXHQgKiBTZXQgYXZhaWxhYmxlIGJ1bmRsZXMgcXVldWUgYmFzZWQgb24gcGFzc2VkIGpzb24gQ0xEUiBkYXRhLiBDb25zaWRlcnMgYSBidW5kbGUgYXMgYW55IFN0cmluZyBhdCAvbWFpbi97YnVuZGxlfS5cXG5cXHQgKi9cXG5cXHR2YXIgY29yZVNldEF2YWlsYWJsZUJ1bmRsZXMgPSBmdW5jdGlvbiggQ2xkciwganNvbiApIHtcXG5cXHRcXHR2YXIgYnVuZGxlLFxcblxcdFxcdFxcdGF2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlID0gQ2xkci5fYXZhaWxhYmxlQnVuZGxlTWFwUXVldWUsXFxuXFx0XFx0XFx0bWFpbiA9IHJlc291cmNlR2V0KCBqc29uLCBbIFxcXCJtYWluXFxcIiBdICk7XFxuXFxuXFx0XFx0aWYgKCBtYWluICkge1xcblxcdFxcdFxcdGZvciAoIGJ1bmRsZSBpbiBtYWluICkge1xcblxcdFxcdFxcdFxcdGlmICggbWFpbi5oYXNPd25Qcm9wZXJ0eSggYnVuZGxlICkgJiYgYnVuZGxlICE9PSBcXFwicm9vdFxcXCIgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhdmFpbGFibGVCdW5kbGVNYXBRdWV1ZS5pbmRleE9mKCBidW5kbGUgKSA9PT0gLTEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0YXZhaWxhYmxlQnVuZGxlTWFwUXVldWUucHVzaCggYnVuZGxlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXG5cXG5cXHR2YXIgYWx3YXlzQXJyYXkgPSBmdW5jdGlvbiggc29tZXRoaW5nT3JBcnJheSApIHtcXG5cXHRcXHRyZXR1cm4gYXJyYXlJc0FycmF5KCBzb21ldGhpbmdPckFycmF5ICkgPyAgc29tZXRoaW5nT3JBcnJheSA6IFsgc29tZXRoaW5nT3JBcnJheSBdO1xcblxcdH07XFxuXFxuXFxuXFx0dmFyIGpzb25NZXJnZSA9IChmdW5jdGlvbigpIHtcXG5cXG5cXHQvLyBSZXR1cm5zIG5ldyBkZWVwbHkgbWVyZ2VkIEpTT04uXFxuXFx0Ly9cXG5cXHQvLyBFZy5cXG5cXHQvLyBtZXJnZSggeyBhOiB7IGI6IDEsIGM6IDIgfSB9LCB7IGE6IHsgYjogMywgZDogNCB9IH0gKVxcblxcdC8vIC0+IHsgYTogeyBiOiAzLCBjOiAyLCBkOiA0IH0gfVxcblxcdC8vXFxuXFx0Ly8gQGFyZ3VtZW50cyBKU09OJ3NcXG5cXHQvLyBcXG5cXHR2YXIgbWVyZ2UgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZGVzdGluYXRpb24gPSB7fSxcXG5cXHRcXHRcXHRzb3VyY2VzID0gW10uc2xpY2UuY2FsbCggYXJndW1lbnRzLCAwICk7XFxuXFx0XFx0YXJyYXlGb3JFYWNoKCBzb3VyY2VzLCBmdW5jdGlvbiggc291cmNlICkge1xcblxcdFxcdFxcdHZhciBwcm9wO1xcblxcdFxcdFxcdGZvciAoIHByb3AgaW4gc291cmNlICkge1xcblxcdFxcdFxcdFxcdGlmICggcHJvcCBpbiBkZXN0aW5hdGlvbiAmJiB0eXBlb2YgZGVzdGluYXRpb25bIHByb3AgXSA9PT0gXFxcIm9iamVjdFxcXCIgJiYgIWFycmF5SXNBcnJheSggZGVzdGluYXRpb25bIHByb3AgXSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE1lcmdlIE9iamVjdHNcXG5cXHRcXHRcXHRcXHRcXHRkZXN0aW5hdGlvblsgcHJvcCBdID0gbWVyZ2UoIGRlc3RpbmF0aW9uWyBwcm9wIF0sIHNvdXJjZVsgcHJvcCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTZXQgbmV3IHZhbHVlc1xcblxcdFxcdFxcdFxcdFxcdGRlc3RpbmF0aW9uWyBwcm9wIF0gPSBzb3VyY2VbIHByb3AgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdFxcdHJldHVybiBkZXN0aW5hdGlvbjtcXG5cXHR9O1xcblxcblxcdHJldHVybiBtZXJnZTtcXG5cXG59KCkpO1xcblxcblxcblxcdC8qKlxcblxcdCAqIGxvYWQoIENsZHIsIHNvdXJjZSwganNvbnMgKVxcblxcdCAqXFxuXFx0ICogQENsZHIgW0NsZHIgY2xhc3NdXFxuXFx0ICpcXG5cXHQgKiBAc291cmNlIFtPYmplY3RdXFxuXFx0ICpcXG5cXHQgKiBAanNvbnMgW2FyZ3VtZW50c11cXG5cXHQgKi9cXG5cXHR2YXIgY29yZUxvYWQgPSBmdW5jdGlvbiggQ2xkciwgc291cmNlLCBqc29ucyApIHtcXG5cXHRcXHR2YXIgaSwgaiwganNvbjtcXG5cXG5cXHRcXHR2YWxpZGF0ZVByZXNlbmNlKCBqc29uc1sgMCBdLCBcXFwianNvblxcXCIgKTtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0IGFyYml0cmFyeSBwYXJhbWV0ZXJzLCBlLmcuLCBgQ2xkci5sb2FkKHsuLi59LCB7Li4ufSlgLlxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKysgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydCBhcnJheSBwYXJhbWV0ZXJzLCBlLmcuLCBgQ2xkci5sb2FkKFt7Li4ufSwgey4uLn1dKWAuXFxuXFx0XFx0XFx0anNvbiA9IGFsd2F5c0FycmF5KCBqc29uc1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPCBqc29uLmxlbmd0aDsgaisrICkge1xcblxcdFxcdFxcdFxcdHZhbGlkYXRlVHlwZVBsYWluT2JqZWN0KCBqc29uWyBqIF0sIFxcXCJqc29uXFxcIiApO1xcblxcdFxcdFxcdFxcdHNvdXJjZSA9IGpzb25NZXJnZSggc291cmNlLCBqc29uWyBqIF0gKTtcXG5cXHRcXHRcXHRcXHRjb3JlU2V0QXZhaWxhYmxlQnVuZGxlcyggQ2xkciwganNvblsgaiBdICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gc291cmNlO1xcblxcdH07XFxuXFxuXFxuXFxuXFx0dmFyIGl0ZW1HZXRSZXNvbHZlZCA9IGZ1bmN0aW9uKCBDbGRyLCBwYXRoLCBhdHRyaWJ1dGVzICkge1xcblxcdFxcdC8vIFJlc29sdmUgcGF0aFxcblxcdFxcdHZhciBub3JtYWxpemVkUGF0aCA9IHBhdGhOb3JtYWxpemUoIHBhdGgsIGF0dHJpYnV0ZXMgKTtcXG5cXG5cXHRcXHRyZXR1cm4gcmVzb3VyY2VHZXQoIENsZHIuX3Jlc29sdmVkLCBub3JtYWxpemVkUGF0aCApO1xcblxcdH07XFxuXFxuXFxuXFxuXFxuXFx0LyoqXFxuXFx0ICogbmV3IENsZHIoKVxcblxcdCAqL1xcblxcdHZhciBDbGRyID0gZnVuY3Rpb24oIGxvY2FsZSApIHtcXG5cXHRcXHR0aGlzLmluaXQoIGxvY2FsZSApO1xcblxcdH07XFxuXFxuXFx0Ly8gQnVpbGQgb3B0aW1pemF0aW9uIGhhY2sgdG8gYXZvaWQgZHVwbGljYXRpbmcgZnVuY3Rpb25zIGFjcm9zcyBtb2R1bGVzLlxcblxcdENsZHIuX2Fsd2F5c0FycmF5ID0gYWx3YXlzQXJyYXk7XFxuXFx0Q2xkci5fY29yZUxvYWQgPSBjb3JlTG9hZDtcXG5cXHRDbGRyLl9jcmVhdGVFcnJvciA9IGNyZWF0ZUVycm9yO1xcblxcdENsZHIuX2l0ZW1HZXRSZXNvbHZlZCA9IGl0ZW1HZXRSZXNvbHZlZDtcXG5cXHRDbGRyLl9qc29uTWVyZ2UgPSBqc29uTWVyZ2U7XFxuXFx0Q2xkci5fcGF0aE5vcm1hbGl6ZSA9IHBhdGhOb3JtYWxpemU7XFxuXFx0Q2xkci5fcmVzb3VyY2VHZXQgPSByZXNvdXJjZUdldDtcXG5cXHRDbGRyLl92YWxpZGF0ZVByZXNlbmNlID0gdmFsaWRhdGVQcmVzZW5jZTtcXG5cXHRDbGRyLl92YWxpZGF0ZVR5cGUgPSB2YWxpZGF0ZVR5cGU7XFxuXFx0Q2xkci5fdmFsaWRhdGVUeXBlUGF0aCA9IHZhbGlkYXRlVHlwZVBhdGg7XFxuXFx0Q2xkci5fdmFsaWRhdGVUeXBlUGxhaW5PYmplY3QgPSB2YWxpZGF0ZVR5cGVQbGFpbk9iamVjdDtcXG5cXG5cXHRDbGRyLl9hdmFpbGFibGVCdW5kbGVNYXAgPSB7fTtcXG5cXHRDbGRyLl9hdmFpbGFibGVCdW5kbGVNYXBRdWV1ZSA9IFtdO1xcblxcdENsZHIuX3Jlc29sdmVkID0ge307XFxuXFxuXFx0Ly8gQWxsb3cgdXNlciB0byBvdmVycmlkZSBsb2NhbGUgc2VwYXJhdG9yIFxcXCItXFxcIiAoZGVmYXVsdCkgfCBcXFwiX1xcXCIuIEFjY29yZGluZyB0byBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jVW5pY29kZV9sYW5ndWFnZV9pZGVudGlmaWVyLCBib3RoIFxcXCItXFxcIiBhbmQgXFxcIl9cXFwiIGFyZSB2YWxpZCBsb2NhbGUgc2VwYXJhdG9ycyAoZWcuIFxcXCJlbl9HQlxcXCIsIFxcXCJlbi1HQlxcXCIpLiBBY2NvcmRpbmcgdG8gaHR0cDovL3VuaWNvZGUub3JnL2NsZHIvdHJhYy90aWNrZXQvNjc4NiBpdHMgdXNhZ2UgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgdGhlIGRhdGEgc2V0LlxcblxcdENsZHIubG9jYWxlU2VwID0gXFxcIi1cXFwiO1xcblxcblxcdC8qKlxcblxcdCAqIENsZHIubG9hZCgganNvbiBbLCBqc29uLCAuLi5dIClcXG5cXHQgKlxcblxcdCAqIEBqc29uIFtKU09OXSBDTERSIGRhdGEgb3IgW0FycmF5XSBBcnJheSBvZiBAanNvbidzLlxcblxcdCAqXFxuXFx0ICogTG9hZCByZXNvbHZlZCBjbGRyIGRhdGEuXFxuXFx0ICovXFxuXFx0Q2xkci5sb2FkID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0Q2xkci5fcmVzb2x2ZWQgPSBjb3JlTG9hZCggQ2xkciwgQ2xkci5fcmVzb2x2ZWQsIGFyZ3VtZW50cyApO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogLmluaXQoKSBhdXRvbWF0aWNhbGx5IHJ1biBvbiBpbnN0YW50aWF0aW9uL2NvbnN0cnVjdGlvbi5cXG5cXHQgKi9cXG5cXHRDbGRyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oIGxvY2FsZSApIHtcXG5cXHRcXHR2YXIgYXR0cmlidXRlcywgbGFuZ3VhZ2UsIG1heExhbmd1YWdlSWQsIG1pbkxhbmd1YWdlSWQsIHNjcmlwdCwgc3VidGFncywgdGVycml0b3J5LCB1bmljb2RlTG9jYWxlRXh0ZW5zaW9ucywgdmFyaWFudCxcXG5cXHRcXHRcXHRzZXAgPSBDbGRyLmxvY2FsZVNlcCxcXG5cXHRcXHRcXHR1bmljb2RlTG9jYWxlRXh0ZW5zaW9uc1JhdyA9IFxcXCJcXFwiO1xcblxcblxcdFxcdHZhbGlkYXRlUHJlc2VuY2UoIGxvY2FsZSwgXFxcImxvY2FsZVxcXCIgKTtcXG5cXHRcXHR2YWxpZGF0ZVR5cGVTdHJpbmcoIGxvY2FsZSwgXFxcImxvY2FsZVxcXCIgKTtcXG5cXG5cXHRcXHRzdWJ0YWdzID0gY29yZVN1YnRhZ3MoIGxvY2FsZSApO1xcblxcblxcdFxcdGlmICggc3VidGFncy5sZW5ndGggPT09IDUgKSB7XFxuXFx0XFx0XFx0dW5pY29kZUxvY2FsZUV4dGVuc2lvbnMgPSBzdWJ0YWdzLnBvcCgpO1xcblxcdFxcdFxcdHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zUmF3ID0gc2VwICsgXFxcInVcXFwiICsgc2VwICsgdW5pY29kZUxvY2FsZUV4dGVuc2lvbnM7XFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIHRyYWlsaW5nIG51bGwgd2hlbiB0aGVyZSBpcyB1bmljb2RlTG9jYWxlRXh0ZW5zaW9ucyBidXQgbm8gdmFyaWFudHMuXFxuXFx0XFx0XFx0aWYgKCAhc3VidGFnc1sgMyBdICkge1xcblxcdFxcdFxcdFxcdHN1YnRhZ3MucG9wKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHR2YXJpYW50ID0gc3VidGFnc1sgMyBdO1xcblxcblxcdFxcdC8vIE5vcm1hbGl6ZSBsb2NhbGUgY29kZS5cXG5cXHRcXHQvLyBHZXQgKG9yIGRlZHVjZSkgdGhlIFxcXCJ0cmlwbGUgc3VidGFnc1xcXCI6IGxhbmd1YWdlLCB0ZXJyaXRvcnkgKGFsc28gYWxpYXNlZCBhcyByZWdpb24pLCBhbmQgc2NyaXB0IHN1YnRhZ3MuXFxuXFx0XFx0Ly8gR2V0IHRoZSB2YXJpYW50IHN1YnRhZ3MgKGNhbGVuZGFyLCBjb2xsYXRpb24sIGN1cnJlbmN5LCBldGMpLlxcblxcdFxcdC8vIHJlZnM6XFxuXFx0XFx0Ly8gLSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jRmllbGRfRGVmaW5pdGlvbnNcXG5cXHRcXHQvLyAtIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyNMYW5ndWFnZV9hbmRfTG9jYWxlX0lEc1xcblxcdFxcdC8vIC0gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvI1VuaWNvZGVfbG9jYWxlX2lkZW50aWZpZXJcXG5cXG5cXHRcXHQvLyBXaGVuIGEgbG9jYWxlIGlkIGRvZXMgbm90IHNwZWNpZnkgYSBsYW5ndWFnZSwgb3IgdGVycml0b3J5IChyZWdpb24pLCBvciBzY3JpcHQsIHRoZXkgYXJlIG9idGFpbmVkIGJ5IExpa2VseSBTdWJ0YWdzLlxcblxcdFxcdG1heExhbmd1YWdlSWQgPSBjb3JlTGlrZWx5U3VidGFncyggQ2xkciwgdGhpcywgc3VidGFncywgeyBmb3JjZTogdHJ1ZSB9ICkgfHwgc3VidGFncztcXG5cXHRcXHRsYW5ndWFnZSA9IG1heExhbmd1YWdlSWRbIDAgXTtcXG5cXHRcXHRzY3JpcHQgPSBtYXhMYW5ndWFnZUlkWyAxIF07XFxuXFx0XFx0dGVycml0b3J5ID0gbWF4TGFuZ3VhZ2VJZFsgMiBdO1xcblxcblxcdFxcdG1pbkxhbmd1YWdlSWQgPSBjb3JlUmVtb3ZlTGlrZWx5U3VidGFncyggQ2xkciwgdGhpcywgbWF4TGFuZ3VhZ2VJZCApLmpvaW4oIHNlcCApO1xcblxcblxcdFxcdC8vIFNldCBhdHRyaWJ1dGVzXFxuXFx0XFx0dGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyA9IHtcXG5cXHRcXHRcXHRidW5kbGU6IGJ1bmRsZUxvb2t1cCggQ2xkciwgdGhpcywgbWluTGFuZ3VhZ2VJZCApLFxcblxcblxcdFxcdFxcdC8vIFVuaWNvZGUgTGFuZ3VhZ2UgSWRcXG5cXHRcXHRcXHRtaW5MYW5ndWFnZUlkOiBtaW5MYW5ndWFnZUlkICsgdW5pY29kZUxvY2FsZUV4dGVuc2lvbnNSYXcsXFxuXFx0XFx0XFx0bWF4TGFuZ3VhZ2VJZDogbWF4TGFuZ3VhZ2VJZC5qb2luKCBzZXAgKSArIHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zUmF3LFxcblxcblxcdFxcdFxcdC8vIFVuaWNvZGUgTGFuZ3VhZ2UgSWQgU3VidGFic1xcblxcdFxcdFxcdGxhbmd1YWdlOiBsYW5ndWFnZSxcXG5cXHRcXHRcXHRzY3JpcHQ6IHNjcmlwdCxcXG5cXHRcXHRcXHR0ZXJyaXRvcnk6IHRlcnJpdG9yeSxcXG5cXHRcXHRcXHRyZWdpb246IHRlcnJpdG9yeSwgLyogYWxpYXMgKi9cXG5cXHRcXHRcXHR2YXJpYW50OiB2YXJpYW50XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBVbmljb2RlIGxvY2FsZSBleHRlbnNpb25zLlxcblxcdFxcdHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zICYmICggXFxcIi1cXFwiICsgdW5pY29kZUxvY2FsZUV4dGVuc2lvbnMgKS5yZXBsYWNlKCAvLVthLXpdezMsOH18KC1bYS16XXsyfSktKFthLXpdezMsOH0pL2csIGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIGtleSwgdHlwZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGtleSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFeHRlbnNpb24gaXMgaW4gdGhlIGBrZXl3b3JkYCBmb3JtLlxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZXNbIFxcXCJ1XFxcIiArIGtleSBdID0gdHlwZTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIEV4dGVuc2lvbiBpcyBpbiB0aGUgYGF0dHJpYnV0ZWAgZm9ybS5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVzWyBcXFwidVxcXCIgKyBhdHRyaWJ1dGUgXSA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdHRoaXMubG9jYWxlID0gbG9jYWxlO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogLmdldCgpXFxuXFx0ICovXFxuXFx0Q2xkci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oIHBhdGggKSB7XFxuXFxuXFx0XFx0dmFsaWRhdGVQcmVzZW5jZSggcGF0aCwgXFxcInBhdGhcXFwiICk7XFxuXFx0XFx0dmFsaWRhdGVUeXBlUGF0aCggcGF0aCwgXFxcInBhdGhcXFwiICk7XFxuXFxuXFx0XFx0cmV0dXJuIGl0ZW1HZXRSZXNvbHZlZCggQ2xkciwgcGF0aCwgdGhpcy5hdHRyaWJ1dGVzICk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiAubWFpbigpXFxuXFx0ICovXFxuXFx0Q2xkci5wcm90b3R5cGUubWFpbiA9IGZ1bmN0aW9uKCBwYXRoICkge1xcblxcdFxcdHZhbGlkYXRlUHJlc2VuY2UoIHBhdGgsIFxcXCJwYXRoXFxcIiApO1xcblxcdFxcdHZhbGlkYXRlVHlwZVBhdGgoIHBhdGgsIFxcXCJwYXRoXFxcIiApO1xcblxcblxcdFxcdHZhbGlkYXRlKCBcXFwiRV9NSVNTSU5HX0JVTkRMRVxcXCIsIHRoaXMuYXR0cmlidXRlcy5idW5kbGUgIT09IG51bGwsIHtcXG5cXHRcXHRcXHRsb2NhbGU6IHRoaXMubG9jYWxlXFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0cGF0aCA9IGFsd2F5c0FycmF5KCBwYXRoICk7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZ2V0KCBbIFxcXCJtYWluL3tidW5kbGV9XFxcIiBdLmNvbmNhdCggcGF0aCApICk7XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gQ2xkcjtcXG5cXG5cXG5cXG5cXG59KSk7XFxuXCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(15))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci9ldmVudC5qcz9lYTYzIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcY2xkcmpzXFxcXGRpc3RcXFxcY2xkclxcXFxldmVudC5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n")},function(module,exports){eval('module.exports = "/**\\n * CLDR JavaScript Library v0.5.1\\n * http://jquery.com/\\n *\\n * Copyright 2013 Rafael Xavier de Souza\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2019-01-21T13:43Z\\n */\\n/*!\\n * CLDR JavaScript Library v0.5.1 2019-01-21T13:43Z MIT license  Rafael Xavier\\n * http://git.io/h4lmVg\\n */\\n(function( factory ) {\\n\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\t\\t// AMD.\\n\\t\\tdefine( [ \\"../cldr\\" ], factory );\\n\\t} else if ( typeof module === \\"object\\" && typeof module.exports === \\"object\\" ) {\\n\\t\\t// Node. CommonJS.\\n\\t\\tmodule.exports = factory( require( \\"../cldr\\" ) );\\n\\t} else {\\n\\t\\t// Global\\n\\t\\tfactory( Cldr );\\n\\t}\\n\\n}(function( Cldr ) {\\n\\n\\t// Build optimization hack to avoid duplicating functions across modules.\\n\\tvar pathNormalize = Cldr._pathNormalize,\\n\\t\\tvalidatePresence = Cldr._validatePresence,\\n\\t\\tvalidateType = Cldr._validateType;\\n\\n/*!\\n * EventEmitter v4.2.7 - git.io/ee\\n * Oliver Caldwell\\n * MIT license\\n * @preserve\\n */\\n\\nvar EventEmitter;\\n/* jshint ignore:start */\\nEventEmitter = (function () {\\n\\n\\n\\t/**\\n\\t * Class for managing events.\\n\\t * Can be extended to provide event functionality in other classes.\\n\\t *\\n\\t * @class EventEmitter Manages event registering and emitting.\\n\\t */\\n\\tfunction EventEmitter() {}\\n\\n\\t// Shortcuts to improve speed and size\\n\\tvar proto = EventEmitter.prototype;\\n\\tvar exports = {};\\n\\t\\n\\n\\t/**\\n\\t * Finds the index of the listener for the event in it\'s storage array.\\n\\t *\\n\\t * @param {Function[]} listeners Array of listeners to search through.\\n\\t * @param {Function} listener Method to look for.\\n\\t * @return {Number} Index of the specified listener, -1 if not found\\n\\t * @api private\\n\\t */\\n\\tfunction indexOfListener(listeners, listener) {\\n\\t\\tvar i = listeners.length;\\n\\t\\twhile (i--) {\\n\\t\\t\\tif (listeners[i].listener === listener) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n\\n\\t/**\\n\\t * Alias a method while keeping the context correct, to allow for overwriting of target method.\\n\\t *\\n\\t * @param {String} name The name of the target method.\\n\\t * @return {Function} The aliased method\\n\\t * @api private\\n\\t */\\n\\tfunction alias(name) {\\n\\t\\treturn function aliasClosure() {\\n\\t\\t\\treturn this[name].apply(this, arguments);\\n\\t\\t};\\n\\t}\\n\\n\\t/**\\n\\t * Returns the listener array for the specified event.\\n\\t * Will initialise the event object and listener arrays if required.\\n\\t * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\\n\\t * Each property in the object response is an array of listener functions.\\n\\t *\\n\\t * @param {String|RegExp} evt Name of the event to return the listeners from.\\n\\t * @return {Function[]|Object} All listener functions for the event.\\n\\t */\\n\\tproto.getListeners = function getListeners(evt) {\\n\\t\\tvar events = this._getEvents();\\n\\t\\tvar response;\\n\\t\\tvar key;\\n\\n\\t\\t// Return a concatenated array of all matching events if\\n\\t\\t// the selector is a regular expression.\\n\\t\\tif (evt instanceof RegExp) {\\n\\t\\t\\tresponse = {};\\n\\t\\t\\tfor (key in events) {\\n\\t\\t\\t\\tif (events.hasOwnProperty(key) && evt.test(key)) {\\n\\t\\t\\t\\t\\tresponse[key] = events[key];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tresponse = events[evt] || (events[evt] = []);\\n\\t\\t}\\n\\n\\t\\treturn response;\\n\\t};\\n\\n\\t/**\\n\\t * Takes a list of listener objects and flattens it into a list of listener functions.\\n\\t *\\n\\t * @param {Object[]} listeners Raw listener objects.\\n\\t * @return {Function[]} Just the listener functions.\\n\\t */\\n\\tproto.flattenListeners = function flattenListeners(listeners) {\\n\\t\\tvar flatListeners = [];\\n\\t\\tvar i;\\n\\n\\t\\tfor (i = 0; i < listeners.length; i += 1) {\\n\\t\\t\\tflatListeners.push(listeners[i].listener);\\n\\t\\t}\\n\\n\\t\\treturn flatListeners;\\n\\t};\\n\\n\\t/**\\n\\t * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\\n\\t *\\n\\t * @param {String|RegExp} evt Name of the event to return the listeners from.\\n\\t * @return {Object} All listener functions for an event in an object.\\n\\t */\\n\\tproto.getListenersAsObject = function getListenersAsObject(evt) {\\n\\t\\tvar listeners = this.getListeners(evt);\\n\\t\\tvar response;\\n\\n\\t\\tif (listeners instanceof Array) {\\n\\t\\t\\tresponse = {};\\n\\t\\t\\tresponse[evt] = listeners;\\n\\t\\t}\\n\\n\\t\\treturn response || listeners;\\n\\t};\\n\\n\\t/**\\n\\t * Adds a listener function to the specified event.\\n\\t * The listener will not be added if it is a duplicate.\\n\\t * If the listener returns true then it will be removed after it is called.\\n\\t * If you pass a regular expression as the event name then the listener will be added to all events that match it.\\n\\t *\\n\\t * @param {String|RegExp} evt Name of the event to attach the listener to.\\n\\t * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.addListener = function addListener(evt, listener) {\\n\\t\\tvar listeners = this.getListenersAsObject(evt);\\n\\t\\tvar listenerIsWrapped = typeof listener === \'object\';\\n\\t\\tvar key;\\n\\n\\t\\tfor (key in listeners) {\\n\\t\\t\\tif (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\\n\\t\\t\\t\\tlisteners[key].push(listenerIsWrapped ? listener : {\\n\\t\\t\\t\\t\\tlistener: listener,\\n\\t\\t\\t\\t\\tonce: false\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n\\t * Alias of addListener\\n\\t */\\n\\tproto.on = alias(\'addListener\');\\n\\n\\t/**\\n\\t * Semi-alias of addListener. It will add a listener that will be\\n\\t * automatically removed after it\'s first execution.\\n\\t *\\n\\t * @param {String|RegExp} evt Name of the event to attach the listener to.\\n\\t * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.addOnceListener = function addOnceListener(evt, listener) {\\n\\t\\treturn this.addListener(evt, {\\n\\t\\t\\tlistener: listener,\\n\\t\\t\\tonce: true\\n\\t\\t});\\n\\t};\\n\\n\\t/**\\n\\t * Alias of addOnceListener.\\n\\t */\\n\\tproto.once = alias(\'addOnceListener\');\\n\\n\\t/**\\n\\t * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don\'t do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\\n\\t * You need to tell it what event names should be matched by a regex.\\n\\t *\\n\\t * @param {String} evt Name of the event to create.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.defineEvent = function defineEvent(evt) {\\n\\t\\tthis.getListeners(evt);\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n\\t * Uses defineEvent to define multiple events.\\n\\t *\\n\\t * @param {String[]} evts An array of event names to define.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.defineEvents = function defineEvents(evts) {\\n\\t\\tfor (var i = 0; i < evts.length; i += 1) {\\n\\t\\t\\tthis.defineEvent(evts[i]);\\n\\t\\t}\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n\\t * Removes a listener function from the specified event.\\n\\t * When passed a regular expression as the event name, it will remove the listener from all events that match it.\\n\\t *\\n\\t * @param {String|RegExp} evt Name of the event to remove the listener from.\\n\\t * @param {Function} listener Method to remove from the event.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.removeListener = function removeListener(evt, listener) {\\n\\t\\tvar listeners = this.getListenersAsObject(evt);\\n\\t\\tvar index;\\n\\t\\tvar key;\\n\\n\\t\\tfor (key in listeners) {\\n\\t\\t\\tif (listeners.hasOwnProperty(key)) {\\n\\t\\t\\t\\tindex = indexOfListener(listeners[key], listener);\\n\\n\\t\\t\\t\\tif (index !== -1) {\\n\\t\\t\\t\\t\\tlisteners[key].splice(index, 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n\\t * Alias of removeListener\\n\\t */\\n\\tproto.off = alias(\'removeListener\');\\n\\n\\t/**\\n\\t * Adds listeners in bulk using the manipulateListeners method.\\n\\t * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\\n\\t * You can also pass it a regular expression to add the array of listeners to all events that match it.\\n\\t * Yeah, this function does quite a bit. That\'s probably a bad thing.\\n\\t *\\n\\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\\n\\t * @param {Function[]} [listeners] An optional array of listener functions to add.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.addListeners = function addListeners(evt, listeners) {\\n\\t\\t// Pass through to manipulateListeners\\n\\t\\treturn this.manipulateListeners(false, evt, listeners);\\n\\t};\\n\\n\\t/**\\n\\t * Removes listeners in bulk using the manipulateListeners method.\\n\\t * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\\n\\t * You can also pass it an event name and an array of listeners to be removed.\\n\\t * You can also pass it a regular expression to remove the listeners from all events that match it.\\n\\t *\\n\\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\\n\\t * @param {Function[]} [listeners] An optional array of listener functions to remove.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.removeListeners = function removeListeners(evt, listeners) {\\n\\t\\t// Pass through to manipulateListeners\\n\\t\\treturn this.manipulateListeners(true, evt, listeners);\\n\\t};\\n\\n\\t/**\\n\\t * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\\n\\t * The first argument will determine if the listeners are removed (true) or added (false).\\n\\t * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\\n\\t * You can also pass it an event name and an array of listeners to be added/removed.\\n\\t * You can also pass it a regular expression to manipulate the listeners of all events that match it.\\n\\t *\\n\\t * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\\n\\t * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\\n\\t * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\\n\\t\\tvar i;\\n\\t\\tvar value;\\n\\t\\tvar single = remove ? this.removeListener : this.addListener;\\n\\t\\tvar multiple = remove ? this.removeListeners : this.addListeners;\\n\\n\\t\\t// If evt is an object then pass each of it\'s properties to this method\\n\\t\\tif (typeof evt === \'object\' && !(evt instanceof RegExp)) {\\n\\t\\t\\tfor (i in evt) {\\n\\t\\t\\t\\tif (evt.hasOwnProperty(i) && (value = evt[i])) {\\n\\t\\t\\t\\t\\t// Pass the single listener straight through to the singular method\\n\\t\\t\\t\\t\\tif (typeof value === \'function\') {\\n\\t\\t\\t\\t\\t\\tsingle.call(this, i, value);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t// Otherwise pass back to the multiple function\\n\\t\\t\\t\\t\\t\\tmultiple.call(this, i, value);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// So evt must be a string\\n\\t\\t\\t// And listeners must be an array of listeners\\n\\t\\t\\t// Loop over it and pass each one to the multiple method\\n\\t\\t\\ti = listeners.length;\\n\\t\\t\\twhile (i--) {\\n\\t\\t\\t\\tsingle.call(this, evt, listeners[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n\\t * Removes all listeners from a specified event.\\n\\t * If you do not specify an event then all listeners will be removed.\\n\\t * That means every event will be emptied.\\n\\t * You can also pass a regex to remove all events that match it.\\n\\t *\\n\\t * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.removeEvent = function removeEvent(evt) {\\n\\t\\tvar type = typeof evt;\\n\\t\\tvar events = this._getEvents();\\n\\t\\tvar key;\\n\\n\\t\\t// Remove different things depending on the state of evt\\n\\t\\tif (type === \'string\') {\\n\\t\\t\\t// Remove all listeners for the specified event\\n\\t\\t\\tdelete events[evt];\\n\\t\\t}\\n\\t\\telse if (evt instanceof RegExp) {\\n\\t\\t\\t// Remove all events matching the regex.\\n\\t\\t\\tfor (key in events) {\\n\\t\\t\\t\\tif (events.hasOwnProperty(key) && evt.test(key)) {\\n\\t\\t\\t\\t\\tdelete events[key];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// Remove all listeners in all events\\n\\t\\t\\tdelete this._events;\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n\\t * Alias of removeEvent.\\n\\t *\\n\\t * Added to mirror the node API.\\n\\t */\\n\\tproto.removeAllListeners = alias(\'removeEvent\');\\n\\n\\t/**\\n\\t * Emits an event of your choice.\\n\\t * When emitted, every listener attached to that event will be executed.\\n\\t * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\\n\\t * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\\n\\t * So they will not arrive within the array on the other side, they will be separate.\\n\\t * You can also pass a regular expression to emit to all events that match it.\\n\\t *\\n\\t * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\\n\\t * @param {Array} [args] Optional array of arguments to be passed to each listener.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.emitEvent = function emitEvent(evt, args) {\\n\\t\\tvar listeners = this.getListenersAsObject(evt);\\n\\t\\tvar listener;\\n\\t\\tvar i;\\n\\t\\tvar key;\\n\\t\\tvar response;\\n\\n\\t\\tfor (key in listeners) {\\n\\t\\t\\tif (listeners.hasOwnProperty(key)) {\\n\\t\\t\\t\\ti = listeners[key].length;\\n\\n\\t\\t\\t\\twhile (i--) {\\n\\t\\t\\t\\t\\t// If the listener returns true then it shall be removed from the event\\n\\t\\t\\t\\t\\t// The function is executed either with a basic call or an apply if there is an args array\\n\\t\\t\\t\\t\\tlistener = listeners[key][i];\\n\\n\\t\\t\\t\\t\\tif (listener.once === true) {\\n\\t\\t\\t\\t\\t\\tthis.removeListener(evt, listener.listener);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tresponse = listener.listener.apply(this, args || []);\\n\\n\\t\\t\\t\\t\\tif (response === this._getOnceReturnValue()) {\\n\\t\\t\\t\\t\\t\\tthis.removeListener(evt, listener.listener);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n\\t * Alias of emitEvent\\n\\t */\\n\\tproto.trigger = alias(\'emitEvent\');\\n\\n\\t/**\\n\\t * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\\n\\t * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\\n\\t *\\n\\t * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\\n\\t * @param {...*} Optional additional arguments to be passed to each listener.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.emit = function emit(evt) {\\n\\t\\tvar args = Array.prototype.slice.call(arguments, 1);\\n\\t\\treturn this.emitEvent(evt, args);\\n\\t};\\n\\n\\t/**\\n\\t * Sets the current value to check against when executing listeners. If a\\n\\t * listeners return value matches the one set here then it will be removed\\n\\t * after execution. This value defaults to true.\\n\\t *\\n\\t * @param {*} value The new value to check for when executing listeners.\\n\\t * @return {Object} Current instance of EventEmitter for chaining.\\n\\t */\\n\\tproto.setOnceReturnValue = function setOnceReturnValue(value) {\\n\\t\\tthis._onceReturnValue = value;\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n\\t * Fetches the current value to check against when executing listeners. If\\n\\t * the listeners return value matches this one then it should be removed\\n\\t * automatically. It will return true by default.\\n\\t *\\n\\t * @return {*|Boolean} The current value to check for or the default, true.\\n\\t * @api private\\n\\t */\\n\\tproto._getOnceReturnValue = function _getOnceReturnValue() {\\n\\t\\tif (this.hasOwnProperty(\'_onceReturnValue\')) {\\n\\t\\t\\treturn this._onceReturnValue;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Fetches the events object and creates one if required.\\n\\t *\\n\\t * @return {Object} The events storage object.\\n\\t * @api private\\n\\t */\\n\\tproto._getEvents = function _getEvents() {\\n\\t\\treturn this._events || (this._events = {});\\n\\t};\\n\\n\\t/**\\n\\t * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.\\n\\t *\\n\\t * @return {Function} Non conflicting EventEmitter class.\\n\\t */\\n\\tEventEmitter.noConflict = function noConflict() {\\n\\t\\texports.EventEmitter = originalGlobalValue;\\n\\t\\treturn EventEmitter;\\n\\t};\\n\\n\\treturn EventEmitter;\\n}());\\n/* jshint ignore:end */\\n\\n\\n\\n\\tvar validateTypeFunction = function( value, name ) {\\n\\t\\tvalidateType( value, name, typeof value === \\"undefined\\" || typeof value === \\"function\\", \\"Function\\" );\\n\\t};\\n\\n\\n\\n\\n\\tvar superGet, superInit,\\n\\t\\tglobalEe = new EventEmitter();\\n\\n\\tfunction validateTypeEvent( value, name ) {\\n\\t\\tvalidateType( value, name, typeof value === \\"string\\" || value instanceof RegExp, \\"String or RegExp\\" );\\n\\t}\\n\\n\\tfunction validateThenCall( method, self ) {\\n\\t\\treturn function( event, listener ) {\\n\\t\\t\\tvalidatePresence( event, \\"event\\" );\\n\\t\\t\\tvalidateTypeEvent( event, \\"event\\" );\\n\\n\\t\\t\\tvalidatePresence( listener, \\"listener\\" );\\n\\t\\t\\tvalidateTypeFunction( listener, \\"listener\\" );\\n\\n\\t\\t\\treturn self[ method ].apply( self, arguments );\\n\\t\\t};\\n\\t}\\n\\n\\tfunction off( self ) {\\n\\t\\treturn validateThenCall( \\"off\\", self );\\n\\t}\\n\\n\\tfunction on( self ) {\\n\\t\\treturn validateThenCall( \\"on\\", self );\\n\\t}\\n\\n\\tfunction once( self ) {\\n\\t\\treturn validateThenCall( \\"once\\", self );\\n\\t}\\n\\n\\tCldr.off = off( globalEe );\\n\\tCldr.on = on( globalEe );\\n\\tCldr.once = once( globalEe );\\n\\n\\t/**\\n\\t * Overload Cldr.prototype.init().\\n\\t */\\n\\tsuperInit = Cldr.prototype.init;\\n\\tCldr.prototype.init = function() {\\n\\t\\tvar ee;\\n\\t\\tthis.ee = ee = new EventEmitter();\\n\\t\\tthis.off = off( ee );\\n\\t\\tthis.on = on( ee );\\n\\t\\tthis.once = once( ee );\\n\\t\\tsuperInit.apply( this, arguments );\\n\\t};\\n\\n\\t/**\\n\\t * getOverload is encapsulated, because of cldr/unresolved. If it\'s loaded\\n\\t * after cldr/event (and note it overwrites .get), it can trigger this\\n\\t * overload again.\\n\\t */\\n\\tfunction getOverload() {\\n\\n\\t\\t/**\\n\\t\\t * Overload Cldr.prototype.get().\\n\\t\\t */\\n\\t\\tsuperGet = Cldr.prototype.get;\\n\\t\\tCldr.prototype.get = function( path ) {\\n\\t\\t\\tvar value = superGet.apply( this, arguments );\\n\\t\\t\\tpath = pathNormalize( path, this.attributes ).join( \\"/\\" );\\n\\t\\t\\tglobalEe.trigger( \\"get\\", [ path, value ] );\\n\\t\\t\\tthis.ee.trigger( \\"get\\", [ path, value ] );\\n\\t\\t\\treturn value;\\n\\t\\t};\\n\\t}\\n\\n\\tCldr._eventInit = getOverload;\\n\\tgetOverload();\\n\\n\\treturn Cldr;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci9ldmVudC5qcz9lOWIxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKipcXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC41LjFcXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cXG4gKlxcbiAqIENvcHlyaWdodCAyMDEzIFJhZmFlbCBYYXZpZXIgZGUgU291emFcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDE5LTAxLTIxVDEzOjQzWlxcbiAqL1xcbi8qIVxcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjUuMSAyMDE5LTAxLTIxVDEzOjQzWiBNSVQgbGljZW5zZSDCqSBSYWZhZWwgWGF2aWVyXFxuICogaHR0cDovL2dpdC5pby9oNGxtVmdcXG4gKi9cXG4oZnVuY3Rpb24oIGZhY3RvcnkgKSB7XFxuXFxuXFx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQgKSB7XFxuXFx0XFx0Ly8gQU1ELlxcblxcdFxcdGRlZmluZSggWyBcXFwiLi4vY2xkclxcXCIgXSwgZmFjdG9yeSApO1xcblxcdH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFx0XFx0Ly8gTm9kZS4gQ29tbW9uSlMuXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcXFwiLi4vY2xkclxcXCIgKSApO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0Ly8gR2xvYmFsXFxuXFx0XFx0ZmFjdG9yeSggQ2xkciApO1xcblxcdH1cXG5cXG59KGZ1bmN0aW9uKCBDbGRyICkge1xcblxcblxcdC8vIEJ1aWxkIG9wdGltaXphdGlvbiBoYWNrIHRvIGF2b2lkIGR1cGxpY2F0aW5nIGZ1bmN0aW9ucyBhY3Jvc3MgbW9kdWxlcy5cXG5cXHR2YXIgcGF0aE5vcm1hbGl6ZSA9IENsZHIuX3BhdGhOb3JtYWxpemUsXFxuXFx0XFx0dmFsaWRhdGVQcmVzZW5jZSA9IENsZHIuX3ZhbGlkYXRlUHJlc2VuY2UsXFxuXFx0XFx0dmFsaWRhdGVUeXBlID0gQ2xkci5fdmFsaWRhdGVUeXBlO1xcblxcbi8qIVxcbiAqIEV2ZW50RW1pdHRlciB2NC4yLjcgLSBnaXQuaW8vZWVcXG4gKiBPbGl2ZXIgQ2FsZHdlbGxcXG4gKiBNSVQgbGljZW5zZVxcbiAqIEBwcmVzZXJ2ZVxcbiAqL1xcblxcbnZhciBFdmVudEVtaXR0ZXI7XFxuLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xcbkV2ZW50RW1pdHRlciA9IChmdW5jdGlvbiAoKSB7XFxuXFxuXFxuXFx0LyoqXFxuXFx0ICogQ2xhc3MgZm9yIG1hbmFnaW5nIGV2ZW50cy5cXG5cXHQgKiBDYW4gYmUgZXh0ZW5kZWQgdG8gcHJvdmlkZSBldmVudCBmdW5jdGlvbmFsaXR5IGluIG90aGVyIGNsYXNzZXMuXFxuXFx0ICpcXG5cXHQgKiBAY2xhc3MgRXZlbnRFbWl0dGVyIE1hbmFnZXMgZXZlbnQgcmVnaXN0ZXJpbmcgYW5kIGVtaXR0aW5nLlxcblxcdCAqL1xcblxcdGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHt9XFxuXFxuXFx0Ly8gU2hvcnRjdXRzIHRvIGltcHJvdmUgc3BlZWQgYW5kIHNpemVcXG5cXHR2YXIgcHJvdG8gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlO1xcblxcdHZhciBleHBvcnRzID0ge307XFxuXFx0XFxuXFxuXFx0LyoqXFxuXFx0ICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50IGluIGl0J3Mgc3RvcmFnZSBhcnJheS5cXG5cXHQgKlxcblxcdCAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycyB0byBzZWFyY2ggdGhyb3VnaC5cXG5cXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gbG9vayBmb3IuXFxuXFx0ICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyLCAtMSBpZiBub3QgZm91bmRcXG5cXHQgKiBAYXBpIHByaXZhdGVcXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lcikge1xcblxcdFxcdHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aDtcXG5cXHRcXHR3aGlsZSAoaS0tKSB7XFxuXFx0XFx0XFx0aWYgKGxpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiAtMTtcXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQWxpYXMgYSBtZXRob2Qgd2hpbGUga2VlcGluZyB0aGUgY29udGV4dCBjb3JyZWN0LCB0byBhbGxvdyBmb3Igb3ZlcndyaXRpbmcgb2YgdGFyZ2V0IG1ldGhvZC5cXG5cXHQgKlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgbWV0aG9kLlxcblxcdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgYWxpYXNlZCBtZXRob2RcXG5cXHQgKiBAYXBpIHByaXZhdGVcXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBhbGlhcyhuYW1lKSB7XFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGFsaWFzQ2xvc3VyZSgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpc1tuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIFJldHVybnMgdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxcblxcdCAqIFdpbGwgaW5pdGlhbGlzZSB0aGUgZXZlbnQgb2JqZWN0IGFuZCBsaXN0ZW5lciBhcnJheXMgaWYgcmVxdWlyZWQuXFxuXFx0ICogV2lsbCByZXR1cm4gYW4gb2JqZWN0IGlmIHlvdSB1c2UgYSByZWdleCBzZWFyY2guIFRoZSBvYmplY3QgY29udGFpbnMga2V5cyBmb3IgZWFjaCBtYXRjaGVkIGV2ZW50LiBTbyAvYmFbcnpdLyBtaWdodCByZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYmFyIGFuZCBiYXouIEJ1dCBvbmx5IGlmIHlvdSBoYXZlIGVpdGhlciBkZWZpbmVkIHRoZW0gd2l0aCBkZWZpbmVFdmVudCBvciBhZGRlZCBzb21lIGxpc3RlbmVycyB0byB0aGVtLlxcblxcdCAqIEVhY2ggcHJvcGVydHkgaW4gdGhlIG9iamVjdCByZXNwb25zZSBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXFxuXFx0ICpcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxcblxcdCAqIEByZXR1cm4ge0Z1bmN0aW9uW118T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgZXZlbnQuXFxuXFx0ICovXFxuXFx0cHJvdG8uZ2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzKGV2dCkge1xcblxcdFxcdHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcXG5cXHRcXHR2YXIgcmVzcG9uc2U7XFxuXFx0XFx0dmFyIGtleTtcXG5cXG5cXHRcXHQvLyBSZXR1cm4gYSBjb25jYXRlbmF0ZWQgYXJyYXkgb2YgYWxsIG1hdGNoaW5nIGV2ZW50cyBpZlxcblxcdFxcdC8vIHRoZSBzZWxlY3RvciBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cXG5cXHRcXHRpZiAoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XFxuXFx0XFx0XFx0cmVzcG9uc2UgPSB7fTtcXG5cXHRcXHRcXHRmb3IgKGtleSBpbiBldmVudHMpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xcblxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlW2tleV0gPSBldmVudHNba2V5XTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRyZXNwb25zZSA9IGV2ZW50c1tldnRdIHx8IChldmVudHNbZXZ0XSA9IFtdKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHJlc3BvbnNlO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogVGFrZXMgYSBsaXN0IG9mIGxpc3RlbmVyIG9iamVjdHMgYW5kIGZsYXR0ZW5zIGl0IGludG8gYSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucy5cXG5cXHQgKlxcblxcdCAqIEBwYXJhbSB7T2JqZWN0W119IGxpc3RlbmVycyBSYXcgbGlzdGVuZXIgb2JqZWN0cy5cXG5cXHQgKiBAcmV0dXJuIHtGdW5jdGlvbltdfSBKdXN0IHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMuXFxuXFx0ICovXFxuXFx0cHJvdG8uZmxhdHRlbkxpc3RlbmVycyA9IGZ1bmN0aW9uIGZsYXR0ZW5MaXN0ZW5lcnMobGlzdGVuZXJzKSB7XFxuXFx0XFx0dmFyIGZsYXRMaXN0ZW5lcnMgPSBbXTtcXG5cXHRcXHR2YXIgaTtcXG5cXG5cXHRcXHRmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XFxuXFx0XFx0XFx0ZmxhdExpc3RlbmVycy5wdXNoKGxpc3RlbmVyc1tpXS5saXN0ZW5lcik7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBmbGF0TGlzdGVuZXJzO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRmV0Y2hlcyB0aGUgcmVxdWVzdGVkIGxpc3RlbmVycyB2aWEgZ2V0TGlzdGVuZXJzIGJ1dCB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHJlc3VsdHMgaW5zaWRlIGFuIG9iamVjdC4gVGhpcyBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSBidXQgb3RoZXJzIG1heSBmaW5kIGl0IHVzZWZ1bC5cXG5cXHQgKlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJldHVybiB0aGUgbGlzdGVuZXJzIGZyb20uXFxuXFx0ICogQHJldHVybiB7T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciBhbiBldmVudCBpbiBhbiBvYmplY3QuXFxuXFx0ICovXFxuXFx0cHJvdG8uZ2V0TGlzdGVuZXJzQXNPYmplY3QgPSBmdW5jdGlvbiBnZXRMaXN0ZW5lcnNBc09iamVjdChldnQpIHtcXG5cXHRcXHR2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcXG5cXHRcXHR2YXIgcmVzcG9uc2U7XFxuXFxuXFx0XFx0aWYgKGxpc3RlbmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XFxuXFx0XFx0XFx0cmVzcG9uc2UgPSB7fTtcXG5cXHRcXHRcXHRyZXNwb25zZVtldnRdID0gbGlzdGVuZXJzO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcmVzcG9uc2UgfHwgbGlzdGVuZXJzO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQWRkcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQuXFxuXFx0ICogVGhlIGxpc3RlbmVyIHdpbGwgbm90IGJlIGFkZGVkIGlmIGl0IGlzIGEgZHVwbGljYXRlLlxcblxcdCAqIElmIHRoZSBsaXN0ZW5lciByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgaXQgaXMgY2FsbGVkLlxcblxcdCAqIElmIHlvdSBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lIHRoZW4gdGhlIGxpc3RlbmVyIHdpbGwgYmUgYWRkZWQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxcblxcdCAqXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciB0by5cXG5cXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cXG5cXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cXG5cXHQgKi9cXG5cXHRwcm90by5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcXG5cXHRcXHR2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xcblxcdFxcdHZhciBsaXN0ZW5lcklzV3JhcHBlZCA9IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCc7XFxuXFx0XFx0dmFyIGtleTtcXG5cXG5cXHRcXHRmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcXG5cXHRcXHRcXHRpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgaW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyc1trZXldLCBsaXN0ZW5lcikgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0bGlzdGVuZXJzW2tleV0ucHVzaChsaXN0ZW5lcklzV3JhcHBlZCA/IGxpc3RlbmVyIDoge1xcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyOiBsaXN0ZW5lcixcXG5cXHRcXHRcXHRcXHRcXHRvbmNlOiBmYWxzZVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBBbGlhcyBvZiBhZGRMaXN0ZW5lclxcblxcdCAqL1xcblxcdHByb3RvLm9uID0gYWxpYXMoJ2FkZExpc3RlbmVyJyk7XFxuXFxuXFx0LyoqXFxuXFx0ICogU2VtaS1hbGlhcyBvZiBhZGRMaXN0ZW5lci4gSXQgd2lsbCBhZGQgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmVcXG5cXHQgKiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgYWZ0ZXIgaXQncyBmaXJzdCBleGVjdXRpb24uXFxuXFx0ICpcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvLlxcblxcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxcblxcdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxcblxcdCAqL1xcblxcdHByb3RvLmFkZE9uY2VMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZE9uY2VMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZXZ0LCB7XFxuXFx0XFx0XFx0bGlzdGVuZXI6IGxpc3RlbmVyLFxcblxcdFxcdFxcdG9uY2U6IHRydWVcXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEFsaWFzIG9mIGFkZE9uY2VMaXN0ZW5lci5cXG5cXHQgKi9cXG5cXHRwcm90by5vbmNlID0gYWxpYXMoJ2FkZE9uY2VMaXN0ZW5lcicpO1xcblxcblxcdC8qKlxcblxcdCAqIERlZmluZXMgYW4gZXZlbnQgbmFtZS4gVGhpcyBpcyByZXF1aXJlZCBpZiB5b3Ugd2FudCB0byB1c2UgYSByZWdleCB0byBhZGQgYSBsaXN0ZW5lciB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gSWYgeW91IGRvbid0IGRvIHRoaXMgdGhlbiBob3cgZG8geW91IGV4cGVjdCBpdCB0byBrbm93IHdoYXQgZXZlbnQgdG8gYWRkIHRvPyBTaG91bGQgaXQganVzdCBhZGQgdG8gZXZlcnkgcG9zc2libGUgbWF0Y2ggZm9yIGEgcmVnZXg/IE5vLiBUaGF0IGlzIHNjYXJ5IGFuZCBiYWQuXFxuXFx0ICogWW91IG5lZWQgdG8gdGVsbCBpdCB3aGF0IGV2ZW50IG5hbWVzIHNob3VsZCBiZSBtYXRjaGVkIGJ5IGEgcmVnZXguXFxuXFx0ICpcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cXG5cXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cXG5cXHQgKi9cXG5cXHRwcm90by5kZWZpbmVFdmVudCA9IGZ1bmN0aW9uIGRlZmluZUV2ZW50KGV2dCkge1xcblxcdFxcdHRoaXMuZ2V0TGlzdGVuZXJzKGV2dCk7XFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBVc2VzIGRlZmluZUV2ZW50IHRvIGRlZmluZSBtdWx0aXBsZSBldmVudHMuXFxuXFx0ICpcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ1tdfSBldnRzIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRvIGRlZmluZS5cXG5cXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cXG5cXHQgKi9cXG5cXHRwcm90by5kZWZpbmVFdmVudHMgPSBmdW5jdGlvbiBkZWZpbmVFdmVudHMoZXZ0cykge1xcblxcdFxcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkgKz0gMSkge1xcblxcdFxcdFxcdHRoaXMuZGVmaW5lRXZlbnQoZXZ0c1tpXSk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZ1bmN0aW9uIGZyb20gdGhlIHNwZWNpZmllZCBldmVudC5cXG5cXHQgKiBXaGVuIHBhc3NlZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyB0aGUgZXZlbnQgbmFtZSwgaXQgd2lsbCByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxcblxcdCAqXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tLlxcblxcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byByZW1vdmUgZnJvbSB0aGUgZXZlbnQuXFxuXFx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXFxuXFx0ICovXFxuXFx0cHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XFxuXFx0XFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcXG5cXHRcXHR2YXIgaW5kZXg7XFxuXFx0XFx0dmFyIGtleTtcXG5cXG5cXHRcXHRmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcXG5cXHRcXHRcXHRpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcXG5cXHRcXHRcXHRcXHRpbmRleCA9IGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpO1xcblxcblxcdFxcdFxcdFxcdGlmIChpbmRleCAhPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lcnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQWxpYXMgb2YgcmVtb3ZlTGlzdGVuZXJcXG5cXHQgKi9cXG5cXHRwcm90by5vZmYgPSBhbGlhcygncmVtb3ZlTGlzdGVuZXInKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBBZGRzIGxpc3RlbmVycyBpbiBidWxrIHVzaW5nIHRoZSBtYW5pcHVsYXRlTGlzdGVuZXJzIG1ldGhvZC5cXG5cXHQgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB5b3UgY2FuIGFkZCB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQuXFxuXFx0ICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gYWRkIHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxcblxcdCAqIFllYWgsIHRoaXMgZnVuY3Rpb24gZG9lcyBxdWl0ZSBhIGJpdC4gVGhhdCdzIHByb2JhYmx5IGEgYmFkIHRoaW5nLlxcblxcdCAqXFxuXFx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZCB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cXG5cXHQgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQuXFxuXFx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXFxuXFx0ICovXFxuXFx0cHJvdG8uYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGV2dCwgbGlzdGVuZXJzKSB7XFxuXFx0XFx0Ly8gUGFzcyB0aHJvdWdoIHRvIG1hbmlwdWxhdGVMaXN0ZW5lcnNcXG5cXHRcXHRyZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKGZhbHNlLCBldnQsIGxpc3RlbmVycyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZW1vdmVzIGxpc3RlbmVycyBpbiBidWxrIHVzaW5nIHRoZSBtYW5pcHVsYXRlTGlzdGVuZXJzIG1ldGhvZC5cXG5cXHQgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB5b3UgY2FuIHJlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuXFxuXFx0ICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIHJlbW92ZWQuXFxuXFx0ICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgZnJvbSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXFxuXFx0ICpcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXFxuXFx0ICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gcmVtb3ZlLlxcblxcdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxcblxcdCAqL1xcblxcdHByb3RvLnJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycyhldnQsIGxpc3RlbmVycykge1xcblxcdFxcdC8vIFBhc3MgdGhyb3VnaCB0byBtYW5pcHVsYXRlTGlzdGVuZXJzXFxuXFx0XFx0cmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyh0cnVlLCBldnQsIGxpc3RlbmVycyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBFZGl0cyBsaXN0ZW5lcnMgaW4gYnVsay4gVGhlIGFkZExpc3RlbmVycyBhbmQgcmVtb3ZlTGlzdGVuZXJzIG1ldGhvZHMgYm90aCB1c2UgdGhpcyB0byBkbyB0aGVpciBqb2IuIFlvdSBzaG91bGQgcmVhbGx5IHVzZSB0aG9zZSBpbnN0ZWFkLCB0aGlzIGlzIGEgbGl0dGxlIGxvd2VyIGxldmVsLlxcblxcdCAqIFRoZSBmaXJzdCBhcmd1bWVudCB3aWxsIGRldGVybWluZSBpZiB0aGUgbGlzdGVuZXJzIGFyZSByZW1vdmVkICh0cnVlKSBvciBhZGRlZCAoZmFsc2UpLlxcblxcdCAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHlvdSBjYW4gYWRkL3JlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuXFxuXFx0ICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIGFkZGVkL3JlbW92ZWQuXFxuXFx0ICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWFuaXB1bGF0ZSB0aGUgbGlzdGVuZXJzIG9mIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cXG5cXHQgKlxcblxcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlIFRydWUgaWYgeW91IHdhbnQgdG8gcmVtb3ZlIGxpc3RlbmVycywgZmFsc2UgaWYgeW91IHdhbnQgdG8gYWRkLlxcblxcdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byBhZGQvcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXFxuXFx0ICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gYWRkL3JlbW92ZS5cXG5cXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cXG5cXHQgKi9cXG5cXHRwcm90by5tYW5pcHVsYXRlTGlzdGVuZXJzID0gZnVuY3Rpb24gbWFuaXB1bGF0ZUxpc3RlbmVycyhyZW1vdmUsIGV2dCwgbGlzdGVuZXJzKSB7XFxuXFx0XFx0dmFyIGk7XFxuXFx0XFx0dmFyIHZhbHVlO1xcblxcdFxcdHZhciBzaW5nbGUgPSByZW1vdmUgPyB0aGlzLnJlbW92ZUxpc3RlbmVyIDogdGhpcy5hZGRMaXN0ZW5lcjtcXG5cXHRcXHR2YXIgbXVsdGlwbGUgPSByZW1vdmUgPyB0aGlzLnJlbW92ZUxpc3RlbmVycyA6IHRoaXMuYWRkTGlzdGVuZXJzO1xcblxcblxcdFxcdC8vIElmIGV2dCBpcyBhbiBvYmplY3QgdGhlbiBwYXNzIGVhY2ggb2YgaXQncyBwcm9wZXJ0aWVzIHRvIHRoaXMgbWV0aG9kXFxuXFx0XFx0aWYgKHR5cGVvZiBldnQgPT09ICdvYmplY3QnICYmICEoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSkge1xcblxcdFxcdFxcdGZvciAoaSBpbiBldnQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZXZ0Lmhhc093blByb3BlcnR5KGkpICYmICh2YWx1ZSA9IGV2dFtpXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBQYXNzIHRoZSBzaW5nbGUgbGlzdGVuZXIgc3RyYWlnaHQgdGhyb3VnaCB0byB0aGUgc2luZ3VsYXIgbWV0aG9kXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNpbmdsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHBhc3MgYmFjayB0byB0aGUgbXVsdGlwbGUgZnVuY3Rpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHRtdWx0aXBsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0Ly8gU28gZXZ0IG11c3QgYmUgYSBzdHJpbmdcXG5cXHRcXHRcXHQvLyBBbmQgbGlzdGVuZXJzIG11c3QgYmUgYW4gYXJyYXkgb2YgbGlzdGVuZXJzXFxuXFx0XFx0XFx0Ly8gTG9vcCBvdmVyIGl0IGFuZCBwYXNzIGVhY2ggb25lIHRvIHRoZSBtdWx0aXBsZSBtZXRob2RcXG5cXHRcXHRcXHRpID0gbGlzdGVuZXJzLmxlbmd0aDtcXG5cXHRcXHRcXHR3aGlsZSAoaS0tKSB7XFxuXFx0XFx0XFx0XFx0c2luZ2xlLmNhbGwodGhpcywgZXZ0LCBsaXN0ZW5lcnNbaV0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZnJvbSBhIHNwZWNpZmllZCBldmVudC5cXG5cXHQgKiBJZiB5b3UgZG8gbm90IHNwZWNpZnkgYW4gZXZlbnQgdGhlbiBhbGwgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZC5cXG5cXHQgKiBUaGF0IG1lYW5zIGV2ZXJ5IGV2ZW50IHdpbGwgYmUgZW1wdGllZC5cXG5cXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBhIHJlZ2V4IHRvIHJlbW92ZSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXFxuXFx0ICpcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IFtldnRdIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvci4gV2lsbCByZW1vdmUgZnJvbSBldmVyeSBldmVudCBpZiBub3QgcGFzc2VkLlxcblxcdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxcblxcdCAqL1xcblxcdHByb3RvLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZXZ0KSB7XFxuXFx0XFx0dmFyIHR5cGUgPSB0eXBlb2YgZXZ0O1xcblxcdFxcdHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcXG5cXHRcXHR2YXIga2V5O1xcblxcblxcdFxcdC8vIFJlbW92ZSBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgc3RhdGUgb2YgZXZ0XFxuXFx0XFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRcXG5cXHRcXHRcXHRkZWxldGUgZXZlbnRzW2V2dF07XFxuXFx0XFx0fVxcblxcdFxcdGVsc2UgaWYgKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xcblxcdFxcdFxcdC8vIFJlbW92ZSBhbGwgZXZlbnRzIG1hdGNoaW5nIHRoZSByZWdleC5cXG5cXHRcXHRcXHRmb3IgKGtleSBpbiBldmVudHMpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBldmVudHNba2V5XTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHQvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBpbiBhbGwgZXZlbnRzXFxuXFx0XFx0XFx0ZGVsZXRlIHRoaXMuX2V2ZW50cztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBBbGlhcyBvZiByZW1vdmVFdmVudC5cXG5cXHQgKlxcblxcdCAqIEFkZGVkIHRvIG1pcnJvciB0aGUgbm9kZSBBUEkuXFxuXFx0ICovXFxuXFx0cHJvdG8ucmVtb3ZlQWxsTGlzdGVuZXJzID0gYWxpYXMoJ3JlbW92ZUV2ZW50Jyk7XFxuXFxuXFx0LyoqXFxuXFx0ICogRW1pdHMgYW4gZXZlbnQgb2YgeW91ciBjaG9pY2UuXFxuXFx0ICogV2hlbiBlbWl0dGVkLCBldmVyeSBsaXN0ZW5lciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50IHdpbGwgYmUgZXhlY3V0ZWQuXFxuXFx0ICogSWYgeW91IHBhc3MgdGhlIG9wdGlvbmFsIGFyZ3VtZW50IGFycmF5IHRoZW4gdGhvc2UgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIHRvIGV2ZXJ5IGxpc3RlbmVyIHVwb24gZXhlY3V0aW9uLlxcblxcdCAqIEJlY2F1c2UgaXQgdXNlcyBgYXBwbHlgLCB5b3VyIGFycmF5IG9mIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCBhcyBpZiB5b3Ugd3JvdGUgdGhlbSBvdXQgc2VwYXJhdGVseS5cXG5cXHQgKiBTbyB0aGV5IHdpbGwgbm90IGFycml2ZSB3aXRoaW4gdGhlIGFycmF5IG9uIHRoZSBvdGhlciBzaWRlLCB0aGV5IHdpbGwgYmUgc2VwYXJhdGUuXFxuXFx0ICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXFxuXFx0ICpcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXFxuXFx0ICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIE9wdGlvbmFsIGFycmF5IG9mIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cXG5cXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cXG5cXHQgKi9cXG5cXHRwcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiBlbWl0RXZlbnQoZXZ0LCBhcmdzKSB7XFxuXFx0XFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcXG5cXHRcXHR2YXIgbGlzdGVuZXI7XFxuXFx0XFx0dmFyIGk7XFxuXFx0XFx0dmFyIGtleTtcXG5cXHRcXHR2YXIgcmVzcG9uc2U7XFxuXFxuXFx0XFx0Zm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XFxuXFx0XFx0XFx0aWYgKGxpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuXFx0XFx0XFx0XFx0aSA9IGxpc3RlbmVyc1trZXldLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHR3aGlsZSAoaS0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlIGxpc3RlbmVyIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHNoYWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZXZlbnRcXG5cXHRcXHRcXHRcXHRcXHQvLyBUaGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZWl0aGVyIHdpdGggYSBiYXNpYyBjYWxsIG9yIGFuIGFwcGx5IGlmIHRoZXJlIGlzIGFuIGFyZ3MgYXJyYXlcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lciA9IGxpc3RlbmVyc1trZXldW2ldO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChsaXN0ZW5lci5vbmNlID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5yZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyLmxpc3RlbmVyKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBsaXN0ZW5lci5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzIHx8IFtdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAocmVzcG9uc2UgPT09IHRoaXMuX2dldE9uY2VSZXR1cm5WYWx1ZSgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5yZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyLmxpc3RlbmVyKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBBbGlhcyBvZiBlbWl0RXZlbnRcXG5cXHQgKi9cXG5cXHRwcm90by50cmlnZ2VyID0gYWxpYXMoJ2VtaXRFdmVudCcpO1xcblxcblxcdC8qKlxcblxcdCAqIFN1YnRseSBkaWZmZXJlbnQgZnJvbSBlbWl0RXZlbnQgaW4gdGhhdCBpdCB3aWxsIHBhc3MgaXRzIGFyZ3VtZW50cyBvbiB0byB0aGUgbGlzdGVuZXJzLCBhcyBvcHBvc2VkIHRvIHRha2luZyBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyBvbi5cXG5cXHQgKiBBcyB3aXRoIGVtaXRFdmVudCwgeW91IGNhbiBwYXNzIGEgcmVnZXggaW4gcGxhY2Ugb2YgdGhlIGV2ZW50IG5hbWUgdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXFxuXFx0ICpcXG5cXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXFxuXFx0ICogQHBhcmFtIHsuLi4qfSBPcHRpb25hbCBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cXG5cXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cXG5cXHQgKi9cXG5cXHRwcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcXG5cXHRcXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZW1pdEV2ZW50KGV2dCwgYXJncyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTZXRzIHRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGFnYWluc3Qgd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLiBJZiBhXFxuXFx0ICogbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZSBvbmUgc2V0IGhlcmUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWRcXG5cXHQgKiBhZnRlciBleGVjdXRpb24uIFRoaXMgdmFsdWUgZGVmYXVsdHMgdG8gdHJ1ZS5cXG5cXHQgKlxcblxcdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBjaGVjayBmb3Igd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLlxcblxcdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxcblxcdCAqL1xcblxcdHByb3RvLnNldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uIHNldE9uY2VSZXR1cm5WYWx1ZSh2YWx1ZSkge1xcblxcdFxcdHRoaXMuX29uY2VSZXR1cm5WYWx1ZSA9IHZhbHVlO1xcblxcdFxcdHJldHVybiB0aGlzO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRmV0Y2hlcyB0aGUgY3VycmVudCB2YWx1ZSB0byBjaGVjayBhZ2FpbnN0IHdoZW4gZXhlY3V0aW5nIGxpc3RlbmVycy4gSWZcXG5cXHQgKiB0aGUgbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoaXMgb25lIHRoZW4gaXQgc2hvdWxkIGJlIHJlbW92ZWRcXG5cXHQgKiBhdXRvbWF0aWNhbGx5LiBJdCB3aWxsIHJldHVybiB0cnVlIGJ5IGRlZmF1bHQuXFxuXFx0ICpcXG5cXHQgKiBAcmV0dXJuIHsqfEJvb2xlYW59IFRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGZvciBvciB0aGUgZGVmYXVsdCwgdHJ1ZS5cXG5cXHQgKiBAYXBpIHByaXZhdGVcXG5cXHQgKi9cXG5cXHRwcm90by5fZ2V0T25jZVJldHVyblZhbHVlID0gZnVuY3Rpb24gX2dldE9uY2VSZXR1cm5WYWx1ZSgpIHtcXG5cXHRcXHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnX29uY2VSZXR1cm5WYWx1ZScpKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX29uY2VSZXR1cm5WYWx1ZTtcXG5cXHRcXHR9XFxuXFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogRmV0Y2hlcyB0aGUgZXZlbnRzIG9iamVjdCBhbmQgY3JlYXRlcyBvbmUgaWYgcmVxdWlyZWQuXFxuXFx0ICpcXG5cXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBldmVudHMgc3RvcmFnZSBvYmplY3QuXFxuXFx0ICogQGFwaSBwcml2YXRlXFxuXFx0ICovXFxuXFx0cHJvdG8uX2dldEV2ZW50cyA9IGZ1bmN0aW9uIF9nZXRFdmVudHMoKSB7XFxuXFx0XFx0cmV0dXJuIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogUmV2ZXJ0cyB0aGUgZ2xvYmFsIHtAbGluayBFdmVudEVtaXR0ZXJ9IHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIHZlcnNpb24uXFxuXFx0ICpcXG5cXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gTm9uIGNvbmZsaWN0aW5nIEV2ZW50RW1pdHRlciBjbGFzcy5cXG5cXHQgKi9cXG5cXHRFdmVudEVtaXR0ZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XFxuXFx0XFx0ZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBvcmlnaW5hbEdsb2JhbFZhbHVlO1xcblxcdFxcdHJldHVybiBFdmVudEVtaXR0ZXI7XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gRXZlbnRFbWl0dGVyO1xcbn0oKSk7XFxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cXG5cXG5cXG5cXG5cXHR2YXIgdmFsaWRhdGVUeXBlRnVuY3Rpb24gPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XFxuXFx0XFx0dmFsaWRhdGVUeXBlKCB2YWx1ZSwgbmFtZSwgdHlwZW9mIHZhbHVlID09PSBcXFwidW5kZWZpbmVkXFxcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFxcXCJmdW5jdGlvblxcXCIsIFxcXCJGdW5jdGlvblxcXCIgKTtcXG5cXHR9O1xcblxcblxcblxcblxcblxcdHZhciBzdXBlckdldCwgc3VwZXJJbml0LFxcblxcdFxcdGdsb2JhbEVlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xcblxcblxcdGZ1bmN0aW9uIHZhbGlkYXRlVHlwZUV2ZW50KCB2YWx1ZSwgbmFtZSApIHtcXG5cXHRcXHR2YWxpZGF0ZVR5cGUoIHZhbHVlLCBuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwLCBcXFwiU3RyaW5nIG9yIFJlZ0V4cFxcXCIgKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gdmFsaWRhdGVUaGVuQ2FsbCggbWV0aG9kLCBzZWxmICkge1xcblxcdFxcdHJldHVybiBmdW5jdGlvbiggZXZlbnQsIGxpc3RlbmVyICkge1xcblxcdFxcdFxcdHZhbGlkYXRlUHJlc2VuY2UoIGV2ZW50LCBcXFwiZXZlbnRcXFwiICk7XFxuXFx0XFx0XFx0dmFsaWRhdGVUeXBlRXZlbnQoIGV2ZW50LCBcXFwiZXZlbnRcXFwiICk7XFxuXFxuXFx0XFx0XFx0dmFsaWRhdGVQcmVzZW5jZSggbGlzdGVuZXIsIFxcXCJsaXN0ZW5lclxcXCIgKTtcXG5cXHRcXHRcXHR2YWxpZGF0ZVR5cGVGdW5jdGlvbiggbGlzdGVuZXIsIFxcXCJsaXN0ZW5lclxcXCIgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gc2VsZlsgbWV0aG9kIF0uYXBwbHkoIHNlbGYsIGFyZ3VtZW50cyApO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIG9mZiggc2VsZiApIHtcXG5cXHRcXHRyZXR1cm4gdmFsaWRhdGVUaGVuQ2FsbCggXFxcIm9mZlxcXCIsIHNlbGYgKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gb24oIHNlbGYgKSB7XFxuXFx0XFx0cmV0dXJuIHZhbGlkYXRlVGhlbkNhbGwoIFxcXCJvblxcXCIsIHNlbGYgKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gb25jZSggc2VsZiApIHtcXG5cXHRcXHRyZXR1cm4gdmFsaWRhdGVUaGVuQ2FsbCggXFxcIm9uY2VcXFwiLCBzZWxmICk7XFxuXFx0fVxcblxcblxcdENsZHIub2ZmID0gb2ZmKCBnbG9iYWxFZSApO1xcblxcdENsZHIub24gPSBvbiggZ2xvYmFsRWUgKTtcXG5cXHRDbGRyLm9uY2UgPSBvbmNlKCBnbG9iYWxFZSApO1xcblxcblxcdC8qKlxcblxcdCAqIE92ZXJsb2FkIENsZHIucHJvdG90eXBlLmluaXQoKS5cXG5cXHQgKi9cXG5cXHRzdXBlckluaXQgPSBDbGRyLnByb3RvdHlwZS5pbml0O1xcblxcdENsZHIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgZWU7XFxuXFx0XFx0dGhpcy5lZSA9IGVlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xcblxcdFxcdHRoaXMub2ZmID0gb2ZmKCBlZSApO1xcblxcdFxcdHRoaXMub24gPSBvbiggZWUgKTtcXG5cXHRcXHR0aGlzLm9uY2UgPSBvbmNlKCBlZSApO1xcblxcdFxcdHN1cGVySW5pdC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBnZXRPdmVybG9hZCBpcyBlbmNhcHN1bGF0ZWQsIGJlY2F1c2Ugb2YgY2xkci91bnJlc29sdmVkLiBJZiBpdCdzIGxvYWRlZFxcblxcdCAqIGFmdGVyIGNsZHIvZXZlbnQgKGFuZCBub3RlIGl0IG92ZXJ3cml0ZXMgLmdldCksIGl0IGNhbiB0cmlnZ2VyIHRoaXNcXG5cXHQgKiBvdmVybG9hZCBhZ2Fpbi5cXG5cXHQgKi9cXG5cXHRmdW5jdGlvbiBnZXRPdmVybG9hZCgpIHtcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBPdmVybG9hZCBDbGRyLnByb3RvdHlwZS5nZXQoKS5cXG5cXHRcXHQgKi9cXG5cXHRcXHRzdXBlckdldCA9IENsZHIucHJvdG90eXBlLmdldDtcXG5cXHRcXHRDbGRyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiggcGF0aCApIHtcXG5cXHRcXHRcXHR2YXIgdmFsdWUgPSBzdXBlckdldC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0XFx0cGF0aCA9IHBhdGhOb3JtYWxpemUoIHBhdGgsIHRoaXMuYXR0cmlidXRlcyApLmpvaW4oIFxcXCIvXFxcIiApO1xcblxcdFxcdFxcdGdsb2JhbEVlLnRyaWdnZXIoIFxcXCJnZXRcXFwiLCBbIHBhdGgsIHZhbHVlIF0gKTtcXG5cXHRcXHRcXHR0aGlzLmVlLnRyaWdnZXIoIFxcXCJnZXRcXFwiLCBbIHBhdGgsIHZhbHVlIF0gKTtcXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0Q2xkci5fZXZlbnRJbml0ID0gZ2V0T3ZlcmxvYWQ7XFxuXFx0Z2V0T3ZlcmxvYWQoKTtcXG5cXG5cXHRyZXR1cm4gQ2xkcjtcXG5cXG5cXG5cXG5cXG59KSk7XFxuXCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(17))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci9zdXBwbGVtZW50YWwuanM/MGI3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXGNsZHJqc1xcXFxkaXN0XFxcXGNsZHJcXFxcc3VwcGxlbWVudGFsLmpzXCIpKSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n")},function(module,exports){eval('module.exports = "/**\\n * CLDR JavaScript Library v0.5.1\\n * http://jquery.com/\\n *\\n * Copyright 2013 Rafael Xavier de Souza\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2019-01-21T13:43Z\\n */\\n/*!\\n * CLDR JavaScript Library v0.5.1 2019-01-21T13:43Z MIT license  Rafael Xavier\\n * http://git.io/h4lmVg\\n */\\n(function( factory ) {\\n\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\t\\t// AMD.\\n\\t\\tdefine( [ \\"../cldr\\" ], factory );\\n\\t} else if ( typeof module === \\"object\\" && typeof module.exports === \\"object\\" ) {\\n\\t\\t// Node. CommonJS.\\n\\t\\tmodule.exports = factory( require( \\"../cldr\\" ) );\\n\\t} else {\\n\\t\\t// Global\\n\\t\\tfactory( Cldr );\\n\\t}\\n\\n}(function( Cldr ) {\\n\\n\\t// Build optimization hack to avoid duplicating functions across modules.\\n\\tvar alwaysArray = Cldr._alwaysArray;\\n\\n\\n\\n\\tvar supplementalMain = function( cldr ) {\\n\\n\\t\\tvar prepend, supplemental;\\n\\t\\t\\n\\t\\tprepend = function( prepend ) {\\n\\t\\t\\treturn function( path ) {\\n\\t\\t\\t\\tpath = alwaysArray( path );\\n\\t\\t\\t\\treturn cldr.get( [ prepend ].concat( path ) );\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\tsupplemental = prepend( \\"supplemental\\" );\\n\\n\\t\\t// Week Data\\n\\t\\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Week_Data\\n\\t\\tsupplemental.weekData = prepend( \\"supplemental/weekData\\" );\\n\\n\\t\\tsupplemental.weekData.firstDay = function() {\\n\\t\\t\\treturn cldr.get( \\"supplemental/weekData/firstDay/{territory}\\" ) ||\\n\\t\\t\\t\\tcldr.get( \\"supplemental/weekData/firstDay/001\\" );\\n\\t\\t};\\n\\n\\t\\tsupplemental.weekData.minDays = function() {\\n\\t\\t\\tvar minDays = cldr.get( \\"supplemental/weekData/minDays/{territory}\\" ) ||\\n\\t\\t\\t\\tcldr.get( \\"supplemental/weekData/minDays/001\\" );\\n\\t\\t\\treturn parseInt( minDays, 10 );\\n\\t\\t};\\n\\n\\t\\t// Time Data\\n\\t\\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\\n\\t\\tsupplemental.timeData = prepend( \\"supplemental/timeData\\" );\\n\\n\\t\\tsupplemental.timeData.allowed = function() {\\n\\t\\t\\treturn cldr.get( \\"supplemental/timeData/{territory}/_allowed\\" ) ||\\n\\t\\t\\t\\tcldr.get( \\"supplemental/timeData/001/_allowed\\" );\\n\\t\\t};\\n\\n\\t\\tsupplemental.timeData.preferred = function() {\\n\\t\\t\\treturn cldr.get( \\"supplemental/timeData/{territory}/_preferred\\" ) ||\\n\\t\\t\\t\\tcldr.get( \\"supplemental/timeData/001/_preferred\\" );\\n\\t\\t};\\n\\n\\t\\treturn supplemental;\\n\\n\\t};\\n\\n\\n\\n\\n\\tvar initSuper = Cldr.prototype.init;\\n\\n\\t/**\\n\\t * .init() automatically ran on construction.\\n\\t *\\n\\t * Overload .init().\\n\\t */\\n\\tCldr.prototype.init = function() {\\n\\t\\tinitSuper.apply( this, arguments );\\n\\t\\tthis.supplemental = supplementalMain( this );\\n\\t};\\n\\n\\treturn Cldr;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci9zdXBwbGVtZW50YWwuanM/NzIzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqXFxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNS4xXFxuICogaHR0cDovL2pxdWVyeS5jb20vXFxuICpcXG4gKiBDb3B5cmlnaHQgMjAxMyBSYWZhZWwgWGF2aWVyIGRlIFNvdXphXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAqXFxuICogRGF0ZTogMjAxOS0wMS0yMVQxMzo0M1pcXG4gKi9cXG4vKiFcXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC41LjEgMjAxOS0wMS0yMVQxMzo0M1ogTUlUIGxpY2Vuc2UgwqkgUmFmYWVsIFhhdmllclxcbiAqIGh0dHA6Ly9naXQuaW8vaDRsbVZnXFxuICovXFxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xcblxcblxcdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBkZWZpbmUuYW1kICkge1xcblxcdFxcdC8vIEFNRC5cXG5cXHRcXHRkZWZpbmUoIFsgXFxcIi4uL2NsZHJcXFwiIF0sIGZhY3RvcnkgKTtcXG5cXHR9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09PSBcXFwib2JqZWN0XFxcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcdFxcdC8vIE5vZGUuIENvbW1vbkpTLlxcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXFxcIi4uL2NsZHJcXFwiICkgKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdC8vIEdsb2JhbFxcblxcdFxcdGZhY3RvcnkoIENsZHIgKTtcXG5cXHR9XFxuXFxufShmdW5jdGlvbiggQ2xkciApIHtcXG5cXG5cXHQvLyBCdWlsZCBvcHRpbWl6YXRpb24gaGFjayB0byBhdm9pZCBkdXBsaWNhdGluZyBmdW5jdGlvbnMgYWNyb3NzIG1vZHVsZXMuXFxuXFx0dmFyIGFsd2F5c0FycmF5ID0gQ2xkci5fYWx3YXlzQXJyYXk7XFxuXFxuXFxuXFxuXFx0dmFyIHN1cHBsZW1lbnRhbE1haW4gPSBmdW5jdGlvbiggY2xkciApIHtcXG5cXG5cXHRcXHR2YXIgcHJlcGVuZCwgc3VwcGxlbWVudGFsO1xcblxcdFxcdFxcblxcdFxcdHByZXBlbmQgPSBmdW5jdGlvbiggcHJlcGVuZCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24oIHBhdGggKSB7XFxuXFx0XFx0XFx0XFx0cGF0aCA9IGFsd2F5c0FycmF5KCBwYXRoICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsZHIuZ2V0KCBbIHByZXBlbmQgXS5jb25jYXQoIHBhdGggKSApO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRzdXBwbGVtZW50YWwgPSBwcmVwZW5kKCBcXFwic3VwcGxlbWVudGFsXFxcIiApO1xcblxcblxcdFxcdC8vIFdlZWsgRGF0YVxcblxcdFxcdC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNXZWVrX0RhdGFcXG5cXHRcXHRzdXBwbGVtZW50YWwud2Vla0RhdGEgPSBwcmVwZW5kKCBcXFwic3VwcGxlbWVudGFsL3dlZWtEYXRhXFxcIiApO1xcblxcblxcdFxcdHN1cHBsZW1lbnRhbC53ZWVrRGF0YS5maXJzdERheSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJldHVybiBjbGRyLmdldCggXFxcInN1cHBsZW1lbnRhbC93ZWVrRGF0YS9maXJzdERheS97dGVycml0b3J5fVxcXCIgKSB8fFxcblxcdFxcdFxcdFxcdGNsZHIuZ2V0KCBcXFwic3VwcGxlbWVudGFsL3dlZWtEYXRhL2ZpcnN0RGF5LzAwMVxcXCIgKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHN1cHBsZW1lbnRhbC53ZWVrRGF0YS5taW5EYXlzID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIG1pbkRheXMgPSBjbGRyLmdldCggXFxcInN1cHBsZW1lbnRhbC93ZWVrRGF0YS9taW5EYXlzL3t0ZXJyaXRvcnl9XFxcIiApIHx8XFxuXFx0XFx0XFx0XFx0Y2xkci5nZXQoIFxcXCJzdXBwbGVtZW50YWwvd2Vla0RhdGEvbWluRGF5cy8wMDFcXFwiICk7XFxuXFx0XFx0XFx0cmV0dXJuIHBhcnNlSW50KCBtaW5EYXlzLCAxMCApO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gVGltZSBEYXRhXFxuXFx0XFx0Ly8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI1RpbWVfRGF0YVxcblxcdFxcdHN1cHBsZW1lbnRhbC50aW1lRGF0YSA9IHByZXBlbmQoIFxcXCJzdXBwbGVtZW50YWwvdGltZURhdGFcXFwiICk7XFxuXFxuXFx0XFx0c3VwcGxlbWVudGFsLnRpbWVEYXRhLmFsbG93ZWQgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gY2xkci5nZXQoIFxcXCJzdXBwbGVtZW50YWwvdGltZURhdGEve3RlcnJpdG9yeX0vX2FsbG93ZWRcXFwiICkgfHxcXG5cXHRcXHRcXHRcXHRjbGRyLmdldCggXFxcInN1cHBsZW1lbnRhbC90aW1lRGF0YS8wMDEvX2FsbG93ZWRcXFwiICk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRzdXBwbGVtZW50YWwudGltZURhdGEucHJlZmVycmVkID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGNsZHIuZ2V0KCBcXFwic3VwcGxlbWVudGFsL3RpbWVEYXRhL3t0ZXJyaXRvcnl9L19wcmVmZXJyZWRcXFwiICkgfHxcXG5cXHRcXHRcXHRcXHRjbGRyLmdldCggXFxcInN1cHBsZW1lbnRhbC90aW1lRGF0YS8wMDEvX3ByZWZlcnJlZFxcXCIgKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHJldHVybiBzdXBwbGVtZW50YWw7XFxuXFxuXFx0fTtcXG5cXG5cXG5cXG5cXG5cXHR2YXIgaW5pdFN1cGVyID0gQ2xkci5wcm90b3R5cGUuaW5pdDtcXG5cXG5cXHQvKipcXG5cXHQgKiAuaW5pdCgpIGF1dG9tYXRpY2FsbHkgcmFuIG9uIGNvbnN0cnVjdGlvbi5cXG5cXHQgKlxcblxcdCAqIE92ZXJsb2FkIC5pbml0KCkuXFxuXFx0ICovXFxuXFx0Q2xkci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdGluaXRTdXBlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XFxuXFx0XFx0dGhpcy5zdXBwbGVtZW50YWwgPSBzdXBwbGVtZW50YWxNYWluKCB0aGlzICk7XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gQ2xkcjtcXG5cXG5cXG5cXG5cXG59KSk7XFxuXCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(19))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci91bnJlc29sdmVkLmpzPzgyNjEiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHNjcmlwdC1sb2FkZXJcXFxcYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxyYXctbG9hZGVyXFxcXGluZGV4LmpzIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxjbGRyanNcXFxcZGlzdFxcXFxjbGRyXFxcXHVucmVzb2x2ZWQuanNcIikpIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n")},function(module,exports){eval('module.exports = "/**\\n * CLDR JavaScript Library v0.5.1\\n * http://jquery.com/\\n *\\n * Copyright 2013 Rafael Xavier de Souza\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2019-01-21T13:43Z\\n */\\n/*!\\n * CLDR JavaScript Library v0.5.1 2019-01-21T13:43Z MIT license  Rafael Xavier\\n * http://git.io/h4lmVg\\n */\\n(function( factory ) {\\n\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\t\\t// AMD.\\n\\t\\tdefine( [ \\"../cldr\\" ], factory );\\n\\t} else if ( typeof module === \\"object\\" && typeof module.exports === \\"object\\" ) {\\n\\t\\t// Node. CommonJS.\\n\\t\\tmodule.exports = factory( require( \\"../cldr\\" ) );\\n\\t} else {\\n\\t\\t// Global\\n\\t\\tfactory( Cldr );\\n\\t}\\n\\n}(function( Cldr ) {\\n\\n\\t// Build optimization hack to avoid duplicating functions across modules.\\n\\tvar coreLoad = Cldr._coreLoad;\\n\\tvar jsonMerge = Cldr._jsonMerge;\\n\\tvar pathNormalize = Cldr._pathNormalize;\\n\\tvar resourceGet = Cldr._resourceGet;\\n\\tvar validatePresence = Cldr._validatePresence;\\n\\tvar validateTypePath = Cldr._validateTypePath;\\n\\n\\n\\n\\tvar bundleParentLookup = function( Cldr, locale ) {\\n\\t\\tvar normalizedPath, parent;\\n\\n\\t\\tif ( locale === \\"root\\" ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// First, try to find parent on supplemental data.\\n\\t\\tnormalizedPath = pathNormalize( [ \\"supplemental/parentLocales/parentLocale\\", locale ] );\\n\\t\\tparent = resourceGet( Cldr._resolved, normalizedPath ) || resourceGet( Cldr._raw, normalizedPath );\\n\\t\\tif ( parent ) {\\n\\t\\t\\treturn parent;\\n\\t\\t}\\n\\n\\t\\t// Or truncate locale.\\n\\t\\tparent = locale.substr( 0, locale.lastIndexOf( Cldr.localeSep ) );\\n\\t\\tif ( !parent ) {\\n\\t\\t\\treturn \\"root\\";\\n\\t\\t}\\n\\n\\t\\treturn parent;\\n\\t};\\n\\n\\n\\n\\n\\t// @path: normalized path\\n\\tvar resourceSet = function( data, path, value ) {\\n\\t\\tvar i,\\n\\t\\t\\tnode = data,\\n\\t\\t\\tlength = path.length;\\n\\n\\t\\tfor ( i = 0; i < length - 1; i++ ) {\\n\\t\\t\\tif ( !node[ path[ i ] ] ) {\\n\\t\\t\\t\\tnode[ path[ i ] ] = {};\\n\\t\\t\\t}\\n\\t\\t\\tnode = node[ path[ i ] ];\\n\\t\\t}\\n\\t\\tnode[ path[ i ] ] = value;\\n\\t};\\n\\n\\n\\tvar itemLookup = (function() {\\n\\n\\tvar lookup;\\n\\n\\tlookup = function( Cldr, locale, path, attributes, childLocale ) {\\n\\t\\tvar normalizedPath, parent, value;\\n\\n\\t\\t// 1: Finish recursion\\n\\t\\t// 2: Avoid infinite loop\\n\\t\\tif ( typeof locale === \\"undefined\\" /* 1 */ || locale === childLocale /* 2 */ ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Resolve path\\n\\t\\tnormalizedPath = pathNormalize( path, attributes );\\n\\n\\t\\t// Check resolved (cached) data first\\n\\t\\t// 1: Due to #16, never use the cached resolved non-leaf nodes. It may not\\n\\t\\t//    represent its leafs in its entirety.\\n\\t\\tvalue = resourceGet( Cldr._resolved, normalizedPath );\\n\\t\\tif ( value !== undefined && typeof value !== \\"object\\" /* 1 */ ) {\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\t// Check raw data\\n\\t\\tvalue = resourceGet( Cldr._raw, normalizedPath );\\n\\n\\t\\tif ( value === undefined ) {\\n\\t\\t\\t// Or, lookup at parent locale\\n\\t\\t\\tparent = bundleParentLookup( Cldr, locale );\\n\\t\\t\\tvalue = lookup( Cldr, parent, path, jsonMerge( attributes, { bundle: parent }), locale );\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\t// Set resolved (cached)\\n\\t\\t\\tresourceSet( Cldr._resolved, normalizedPath, value );\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t};\\n\\n\\treturn lookup;\\n\\n}());\\n\\n\\n\\tCldr._raw = {};\\n\\n\\t/**\\n\\t * Cldr.load( json [, json, ...] )\\n\\t *\\n\\t * @json [JSON] CLDR data or [Array] Array of @json\'s.\\n\\t *\\n\\t * Load resolved or unresolved cldr data.\\n\\t * Overwrite Cldr.load().\\n\\t */\\n\\tCldr.load = function() {\\n\\t\\tCldr._raw = coreLoad( Cldr, Cldr._raw, arguments );\\n\\t};\\n\\n\\t/**\\n\\t * Overwrite Cldr.prototype.get().\\n\\t */\\n\\tCldr.prototype.get = function( path ) {\\n\\t\\tvalidatePresence( path, \\"path\\" );\\n\\t\\tvalidateTypePath( path, \\"path\\" );\\n\\n\\t\\t// 1: use bundle as locale on item lookup for simplification purposes, because no other extended subtag is used anyway on bundle parent lookup.\\n\\t\\t// 2: during init(), this method is called, but bundle is yet not defined. Use \\"\\" as a workaround in this very specific scenario.\\n\\t\\treturn itemLookup( Cldr, this.attributes && this.attributes.bundle /* 1 */ || \\"\\" /* 2 */, path, this.attributes );\\n\\t};\\n\\n\\t// In case cldr/unresolved is loaded after cldr/event, we trigger its overloads again. Because, .get is overwritten in here.\\n\\tif ( Cldr._eventInit ) {\\n\\t\\tCldr._eventInit();\\n\\t}\\n\\n\\treturn Cldr;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci91bnJlc29sdmVkLmpzP2FmYTciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qKlxcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjUuMVxcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xcbiAqXFxuICogQ29weXJpZ2h0IDIwMTMgUmFmYWVsIFhhdmllciBkZSBTb3V6YVxcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIERhdGU6IDIwMTktMDEtMjFUMTM6NDNaXFxuICovXFxuLyohXFxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNS4xIDIwMTktMDEtMjFUMTM6NDNaIE1JVCBsaWNlbnNlIMKpIFJhZmFlbCBYYXZpZXJcXG4gKiBodHRwOi8vZ2l0LmlvL2g0bG1WZ1xcbiAqL1xcbihmdW5jdGlvbiggZmFjdG9yeSApIHtcXG5cXG5cXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZGVmaW5lLmFtZCApIHtcXG5cXHRcXHQvLyBBTUQuXFxuXFx0XFx0ZGVmaW5lKCBbIFxcXCIuLi9jbGRyXFxcIiBdLCBmYWN0b3J5ICk7XFxuXFx0fSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXHRcXHQvLyBOb2RlLiBDb21tb25KUy5cXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFxcXCIuLi9jbGRyXFxcIiApICk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHQvLyBHbG9iYWxcXG5cXHRcXHRmYWN0b3J5KCBDbGRyICk7XFxuXFx0fVxcblxcbn0oZnVuY3Rpb24oIENsZHIgKSB7XFxuXFxuXFx0Ly8gQnVpbGQgb3B0aW1pemF0aW9uIGhhY2sgdG8gYXZvaWQgZHVwbGljYXRpbmcgZnVuY3Rpb25zIGFjcm9zcyBtb2R1bGVzLlxcblxcdHZhciBjb3JlTG9hZCA9IENsZHIuX2NvcmVMb2FkO1xcblxcdHZhciBqc29uTWVyZ2UgPSBDbGRyLl9qc29uTWVyZ2U7XFxuXFx0dmFyIHBhdGhOb3JtYWxpemUgPSBDbGRyLl9wYXRoTm9ybWFsaXplO1xcblxcdHZhciByZXNvdXJjZUdldCA9IENsZHIuX3Jlc291cmNlR2V0O1xcblxcdHZhciB2YWxpZGF0ZVByZXNlbmNlID0gQ2xkci5fdmFsaWRhdGVQcmVzZW5jZTtcXG5cXHR2YXIgdmFsaWRhdGVUeXBlUGF0aCA9IENsZHIuX3ZhbGlkYXRlVHlwZVBhdGg7XFxuXFxuXFxuXFxuXFx0dmFyIGJ1bmRsZVBhcmVudExvb2t1cCA9IGZ1bmN0aW9uKCBDbGRyLCBsb2NhbGUgKSB7XFxuXFx0XFx0dmFyIG5vcm1hbGl6ZWRQYXRoLCBwYXJlbnQ7XFxuXFxuXFx0XFx0aWYgKCBsb2NhbGUgPT09IFxcXCJyb290XFxcIiApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEZpcnN0LCB0cnkgdG8gZmluZCBwYXJlbnQgb24gc3VwcGxlbWVudGFsIGRhdGEuXFxuXFx0XFx0bm9ybWFsaXplZFBhdGggPSBwYXRoTm9ybWFsaXplKCBbIFxcXCJzdXBwbGVtZW50YWwvcGFyZW50TG9jYWxlcy9wYXJlbnRMb2NhbGVcXFwiLCBsb2NhbGUgXSApO1xcblxcdFxcdHBhcmVudCA9IHJlc291cmNlR2V0KCBDbGRyLl9yZXNvbHZlZCwgbm9ybWFsaXplZFBhdGggKSB8fCByZXNvdXJjZUdldCggQ2xkci5fcmF3LCBub3JtYWxpemVkUGF0aCApO1xcblxcdFxcdGlmICggcGFyZW50ICkge1xcblxcdFxcdFxcdHJldHVybiBwYXJlbnQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIE9yIHRydW5jYXRlIGxvY2FsZS5cXG5cXHRcXHRwYXJlbnQgPSBsb2NhbGUuc3Vic3RyKCAwLCBsb2NhbGUubGFzdEluZGV4T2YoIENsZHIubG9jYWxlU2VwICkgKTtcXG5cXHRcXHRpZiAoICFwYXJlbnQgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIFxcXCJyb290XFxcIjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHBhcmVudDtcXG5cXHR9O1xcblxcblxcblxcblxcblxcdC8vIEBwYXRoOiBub3JtYWxpemVkIHBhdGhcXG5cXHR2YXIgcmVzb3VyY2VTZXQgPSBmdW5jdGlvbiggZGF0YSwgcGF0aCwgdmFsdWUgKSB7XFxuXFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0bm9kZSA9IGRhdGEsXFxuXFx0XFx0XFx0bGVuZ3RoID0gcGF0aC5sZW5ndGg7XFxuXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKysgKSB7XFxuXFx0XFx0XFx0aWYgKCAhbm9kZVsgcGF0aFsgaSBdIF0gKSB7XFxuXFx0XFx0XFx0XFx0bm9kZVsgcGF0aFsgaSBdIF0gPSB7fTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bm9kZSA9IG5vZGVbIHBhdGhbIGkgXSBdO1xcblxcdFxcdH1cXG5cXHRcXHRub2RlWyBwYXRoWyBpIF0gXSA9IHZhbHVlO1xcblxcdH07XFxuXFxuXFxuXFx0dmFyIGl0ZW1Mb29rdXAgPSAoZnVuY3Rpb24oKSB7XFxuXFxuXFx0dmFyIGxvb2t1cDtcXG5cXG5cXHRsb29rdXAgPSBmdW5jdGlvbiggQ2xkciwgbG9jYWxlLCBwYXRoLCBhdHRyaWJ1dGVzLCBjaGlsZExvY2FsZSApIHtcXG5cXHRcXHR2YXIgbm9ybWFsaXplZFBhdGgsIHBhcmVudCwgdmFsdWU7XFxuXFxuXFx0XFx0Ly8gMTogRmluaXNoIHJlY3Vyc2lvblxcblxcdFxcdC8vIDI6IEF2b2lkIGluZmluaXRlIGxvb3BcXG5cXHRcXHRpZiAoIHR5cGVvZiBsb2NhbGUgPT09IFxcXCJ1bmRlZmluZWRcXFwiIC8qIDEgKi8gfHwgbG9jYWxlID09PSBjaGlsZExvY2FsZSAvKiAyICovICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmVzb2x2ZSBwYXRoXFxuXFx0XFx0bm9ybWFsaXplZFBhdGggPSBwYXRoTm9ybWFsaXplKCBwYXRoLCBhdHRyaWJ1dGVzICk7XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgcmVzb2x2ZWQgKGNhY2hlZCkgZGF0YSBmaXJzdFxcblxcdFxcdC8vIDE6IER1ZSB0byAjMTYsIG5ldmVyIHVzZSB0aGUgY2FjaGVkIHJlc29sdmVkIG5vbi1sZWFmIG5vZGVzLiBJdCBtYXkgbm90XFxuXFx0XFx0Ly8gICAgcmVwcmVzZW50IGl0cyBsZWFmcyBpbiBpdHMgZW50aXJldHkuXFxuXFx0XFx0dmFsdWUgPSByZXNvdXJjZUdldCggQ2xkci5fcmVzb2x2ZWQsIG5vcm1hbGl6ZWRQYXRoICk7XFxuXFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gXFxcIm9iamVjdFxcXCIgLyogMSAqLyApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENoZWNrIHJhdyBkYXRhXFxuXFx0XFx0dmFsdWUgPSByZXNvdXJjZUdldCggQ2xkci5fcmF3LCBub3JtYWxpemVkUGF0aCApO1xcblxcblxcdFxcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHQvLyBPciwgbG9va3VwIGF0IHBhcmVudCBsb2NhbGVcXG5cXHRcXHRcXHRwYXJlbnQgPSBidW5kbGVQYXJlbnRMb29rdXAoIENsZHIsIGxvY2FsZSApO1xcblxcdFxcdFxcdHZhbHVlID0gbG9va3VwKCBDbGRyLCBwYXJlbnQsIHBhdGgsIGpzb25NZXJnZSggYXR0cmlidXRlcywgeyBidW5kbGU6IHBhcmVudCB9KSwgbG9jYWxlICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHQvLyBTZXQgcmVzb2x2ZWQgKGNhY2hlZClcXG5cXHRcXHRcXHRyZXNvdXJjZVNldCggQ2xkci5fcmVzb2x2ZWQsIG5vcm1hbGl6ZWRQYXRoLCB2YWx1ZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gbG9va3VwO1xcblxcbn0oKSk7XFxuXFxuXFxuXFx0Q2xkci5fcmF3ID0ge307XFxuXFxuXFx0LyoqXFxuXFx0ICogQ2xkci5sb2FkKCBqc29uIFssIGpzb24sIC4uLl0gKVxcblxcdCAqXFxuXFx0ICogQGpzb24gW0pTT05dIENMRFIgZGF0YSBvciBbQXJyYXldIEFycmF5IG9mIEBqc29uJ3MuXFxuXFx0ICpcXG5cXHQgKiBMb2FkIHJlc29sdmVkIG9yIHVucmVzb2x2ZWQgY2xkciBkYXRhLlxcblxcdCAqIE92ZXJ3cml0ZSBDbGRyLmxvYWQoKS5cXG5cXHQgKi9cXG5cXHRDbGRyLmxvYWQgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRDbGRyLl9yYXcgPSBjb3JlTG9hZCggQ2xkciwgQ2xkci5fcmF3LCBhcmd1bWVudHMgKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIE92ZXJ3cml0ZSBDbGRyLnByb3RvdHlwZS5nZXQoKS5cXG5cXHQgKi9cXG5cXHRDbGRyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiggcGF0aCApIHtcXG5cXHRcXHR2YWxpZGF0ZVByZXNlbmNlKCBwYXRoLCBcXFwicGF0aFxcXCIgKTtcXG5cXHRcXHR2YWxpZGF0ZVR5cGVQYXRoKCBwYXRoLCBcXFwicGF0aFxcXCIgKTtcXG5cXG5cXHRcXHQvLyAxOiB1c2UgYnVuZGxlIGFzIGxvY2FsZSBvbiBpdGVtIGxvb2t1cCBmb3Igc2ltcGxpZmljYXRpb24gcHVycG9zZXMsIGJlY2F1c2Ugbm8gb3RoZXIgZXh0ZW5kZWQgc3VidGFnIGlzIHVzZWQgYW55d2F5IG9uIGJ1bmRsZSBwYXJlbnQgbG9va3VwLlxcblxcdFxcdC8vIDI6IGR1cmluZyBpbml0KCksIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgYnV0IGJ1bmRsZSBpcyB5ZXQgbm90IGRlZmluZWQuIFVzZSBcXFwiXFxcIiBhcyBhIHdvcmthcm91bmQgaW4gdGhpcyB2ZXJ5IHNwZWNpZmljIHNjZW5hcmlvLlxcblxcdFxcdHJldHVybiBpdGVtTG9va3VwKCBDbGRyLCB0aGlzLmF0dHJpYnV0ZXMgJiYgdGhpcy5hdHRyaWJ1dGVzLmJ1bmRsZSAvKiAxICovIHx8IFxcXCJcXFwiIC8qIDIgKi8sIHBhdGgsIHRoaXMuYXR0cmlidXRlcyApO1xcblxcdH07XFxuXFxuXFx0Ly8gSW4gY2FzZSBjbGRyL3VucmVzb2x2ZWQgaXMgbG9hZGVkIGFmdGVyIGNsZHIvZXZlbnQsIHdlIHRyaWdnZXIgaXRzIG92ZXJsb2FkcyBhZ2Fpbi4gQmVjYXVzZSwgLmdldCBpcyBvdmVyd3JpdHRlbiBpbiBoZXJlLlxcblxcdGlmICggQ2xkci5fZXZlbnRJbml0ICkge1xcblxcdFxcdENsZHIuX2V2ZW50SW5pdCgpO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gQ2xkcjtcXG5cXG5cXG5cXG5cXG59KSk7XFxuXCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(21))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplLmpzP2JhZTIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHNjcmlwdC1sb2FkZXJcXFxcYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxyYXctbG9hZGVyXFxcXGluZGV4LmpzIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxnbG9iYWxpemVcXFxcZGlzdFxcXFxnbG9iYWxpemUuanNcIikpIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n")},function(module,exports){eval('module.exports = "/**\\n * Globalize v1.5.0\\n *\\n * http://github.com/jquery/globalize\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2020-03-25T12:19Z\\n */\\n/*!\\n * Globalize v1.5.0 2020-03-25T12:19Z Released under the MIT license\\n * http://git.io/TrdQbw\\n */\\n(function( root, factory ) {\\n\\n\\t// UMD returnExports\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\n\\t\\t// AMD\\n\\t\\tdefine([\\n\\t\\t\\t\\"cldr\\",\\n\\t\\t\\t\\"cldr/event\\"\\n\\t\\t], factory );\\n\\t} else if ( typeof exports === \\"object\\" ) {\\n\\n\\t\\t// Node, CommonJS\\n\\t\\tmodule.exports = factory( require( \\"cldrjs\\" ) );\\n\\t} else {\\n\\n\\t\\t// Global\\n\\t\\troot.Globalize = factory( root.Cldr );\\n\\t}\\n}( this, function( Cldr ) {\\n\\n\\n/**\\n * A toString method that outputs meaningful values for objects or arrays and\\n * still performs as fast as a plain string in case variable is string, or as\\n * fast as `\\"\\" + number` in case variable is a number.\\n * Ref: http://jsperf.com/my-stringify\\n */\\nvar toString = function( variable ) {\\n\\treturn typeof variable === \\"string\\" ? variable : ( typeof variable === \\"number\\" ? \\"\\" +\\n\\t\\tvariable : JSON.stringify( variable ) );\\n};\\n\\n\\n\\n\\n/**\\n * formatMessage( message, data )\\n *\\n * @message [String] A message with optional {vars} to be replaced.\\n *\\n * @data [Array or JSON] Object with replacing-variables content.\\n *\\n * Return the formatted message. For example:\\n *\\n * - formatMessage( \\"{0} second\\", [ 1 ] ); // 1 second\\n *\\n * - formatMessage( \\"{0}/{1}\\", [\\"m\\", \\"s\\"] ); // m/s\\n *\\n * - formatMessage( \\"{name} <{email}>\\", {\\n *     name: \\"Foo\\",\\n *     email: \\"bar@baz.qux\\"\\n *   }); // Foo <bar@baz.qux>\\n */\\nvar formatMessage = function( message, data ) {\\n\\n\\t// Replace {attribute}\'s\\n\\tmessage = message.replace( /{[0-9a-zA-Z-_. ]+}/g, function( name ) {\\n\\t\\tname = name.replace( /^{([^}]*)}$/, \\"$1\\" );\\n\\t\\treturn toString( data[ name ] );\\n\\t});\\n\\n\\treturn message;\\n};\\n\\n\\n\\n\\nvar objectExtend = function() {\\n\\tvar destination = arguments[ 0 ],\\n\\t\\tsources = [].slice.call( arguments, 1 );\\n\\n\\tsources.forEach(function( source ) {\\n\\t\\tvar prop;\\n\\t\\tfor ( prop in source ) {\\n\\t\\t\\tdestination[ prop ] = source[ prop ];\\n\\t\\t}\\n\\t});\\n\\n\\treturn destination;\\n};\\n\\n\\n\\n\\nvar createError = function( code, message, attributes ) {\\n\\tvar error;\\n\\n\\tmessage = code + ( message ? \\": \\" + formatMessage( message, attributes ) : \\"\\" );\\n\\terror = new Error( message );\\n\\terror.code = code;\\n\\n\\tobjectExtend( error, attributes );\\n\\n\\treturn error;\\n};\\n\\n\\n\\n\\n/**\\n * Pushes part to parts array, concat two consecutive parts of the same type.\\n */\\nvar partsPush = function( parts, type, value ) {\\n\\n\\t\\t// Concat two consecutive parts of same type\\n\\t\\tif ( parts.length && parts[ parts.length - 1 ].type === type ) {\\n\\t\\t\\tparts[ parts.length - 1 ].value += value;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tparts.push( { type: type, value: value } );\\n};\\n\\n\\n\\n\\n/**\\n * formatMessage( message, data )\\n *\\n * @message [String] A message with optional {vars} to be replaced.\\n *\\n * @data [Array or JSON] Object with replacing-variables content.\\n *\\n * Return the formatted message. For example:\\n *\\n * - formatMessage( \\"{0} second\\", [ 1 ] );\\n * > [{type: \\"variable\\", value: \\"1\\", name: \\"0\\"}, {type: \\"literal\\", value: \\" second\\"}]\\n *\\n * - formatMessage( \\"{0}/{1}\\", [\\"m\\", \\"s\\"] );\\n * > [\\n *     { type: \\"variable\\", value: \\"m\\", name: \\"0\\" },\\n *     { type: \\"literal\\", value: \\" /\\" },\\n *     { type: \\"variable\\", value: \\"s\\", name: \\"1\\" }\\n *   ]\\n */\\nvar formatMessageToParts = function( message, data ) {\\n\\n\\tvar lastOffset = 0,\\n\\t\\tparts = [];\\n\\n\\t// Create parts.\\n\\tmessage.replace( /{[0-9a-zA-Z-_. ]+}/g, function( nameIncludingBrackets, offset ) {\\n\\t\\tvar name = nameIncludingBrackets.slice( 1, -1 );\\n\\t\\tpartsPush( parts, \\"literal\\", message.slice( lastOffset, offset ));\\n\\t\\tpartsPush( parts, \\"variable\\", data[ name ] );\\n\\t\\tparts[ parts.length - 1 ].name = name;\\n\\t\\tlastOffset += offset + nameIncludingBrackets.length;\\n\\t});\\n\\n\\t// Skip empty ones such as `{ type: \'literal\', value: \'\' }`.\\n\\treturn parts.filter(function( part ) {\\n\\t\\treturn part.value !== \\"\\";\\n\\t});\\n};\\n\\n\\n\\n\\n/**\\n * Returns joined parts values.\\n */\\nvar partsJoin = function( parts ) {\\n\\treturn parts.map( function( part ) {\\n\\t\\treturn part.value;\\n\\t}).join( \\"\\" );\\n};\\n\\n\\n\\n\\nvar runtimeStringify = function( args ) {\\n\\treturn JSON.stringify( args, function( key, value ) {\\n\\t\\tif ( value && value.runtimeKey ) {\\n\\t\\t\\treturn value.runtimeKey;\\n\\t\\t}\\n\\t\\treturn value;\\n\\t} );\\n};\\n\\n\\n\\n\\n// Based on http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\\nvar stringHash = function( str ) {\\n\\treturn [].reduce.call( str, function( hash, i ) {\\n\\t\\tvar chr = i.charCodeAt( 0 );\\n\\t\\thash = ( ( hash << 5 ) - hash ) + chr;\\n\\t\\treturn hash | 0;\\n\\t}, 0 );\\n};\\n\\n\\n\\n\\nvar runtimeKey = function( fnName, locale, args, argsStr ) {\\n\\tvar hash;\\n\\targsStr = argsStr || runtimeStringify( args );\\n\\thash = stringHash( fnName + locale + argsStr );\\n\\treturn hash > 0 ? \\"a\\" + hash : \\"b\\" + Math.abs( hash );\\n};\\n\\n\\n\\n\\nvar functionName = function( fn ) {\\n\\tif ( fn.name !== undefined ) {\\n\\t\\treturn fn.name;\\n\\t}\\n\\n\\t// fn.name is not supported by IE.\\n\\tvar matches = /^function\\\\s+([\\\\w\\\\$]+)\\\\s*\\\\(/.exec( fn.toString() );\\n\\n\\tif ( matches && matches.length > 0 ) {\\n\\t\\treturn matches[ 1 ];\\n\\t}\\n};\\n\\n\\n\\n\\nvar runtimeBind = function( args, cldr, fn, runtimeArgs ) {\\n\\n\\tvar argsStr = runtimeStringify( args ),\\n\\t\\tfnName = functionName( fn ),\\n\\t\\tlocale = cldr.locale;\\n\\n\\t// If name of the function is not available, this is most likely due to uglification,\\n\\t// which most likely means we are in production, and runtimeBind here is not necessary.\\n\\tif ( !fnName ) {\\n\\t\\treturn fn;\\n\\t}\\n\\n\\tfn.runtimeKey = runtimeKey( fnName, locale, null, argsStr );\\n\\n\\tfn.generatorString = function() {\\n\\t\\treturn \\"Globalize(\\\\\\"\\" + locale + \\"\\\\\\").\\" + fnName + \\"(\\" + argsStr.slice( 1, -1 ) + \\")\\";\\n\\t};\\n\\n\\tfn.runtimeArgs = runtimeArgs;\\n\\n\\treturn fn;\\n};\\n\\n\\n\\n\\nvar validate = function( code, message, check, attributes ) {\\n\\tif ( !check ) {\\n\\t\\tthrow createError( code, message, attributes );\\n\\t}\\n};\\n\\n\\n\\n\\nvar alwaysArray = function( stringOrArray ) {\\n\\treturn Array.isArray( stringOrArray ) ? stringOrArray : stringOrArray ? [ stringOrArray ] : [];\\n};\\n\\n\\n\\n\\nvar validateCldr = function( path, value, options ) {\\n\\tvar skipBoolean;\\n\\toptions = options || {};\\n\\n\\tskipBoolean = alwaysArray( options.skip ).some(function( pathRe ) {\\n\\t\\treturn pathRe.test( path );\\n\\t});\\n\\n\\tvalidate( \\"E_MISSING_CLDR\\", \\"Missing required CLDR content `{path}`.\\", value || skipBoolean, {\\n\\t\\tpath: path\\n\\t});\\n};\\n\\n\\n\\n\\nvar validateDefaultLocale = function( value ) {\\n\\tvalidate( \\"E_DEFAULT_LOCALE_NOT_DEFINED\\", \\"Default locale has not been defined.\\",\\n\\t\\tvalue !== undefined, {} );\\n};\\n\\n\\n\\n\\nvar validateParameterPresence = function( value, name ) {\\n\\tvalidate( \\"E_MISSING_PARAMETER\\", \\"Missing required parameter `{name}`.\\",\\n\\t\\tvalue !== undefined, { name: name });\\n};\\n\\n\\n\\n\\n/**\\n * range( value, name, minimum, maximum )\\n *\\n * @value [Number].\\n *\\n * @name [String] name of variable.\\n *\\n * @minimum [Number]. The lowest valid value, inclusive.\\n *\\n * @maximum [Number]. The greatest valid value, inclusive.\\n */\\nvar validateParameterRange = function( value, name, minimum, maximum ) {\\n\\tvalidate(\\n\\t\\t\\"E_PAR_OUT_OF_RANGE\\",\\n\\t\\t\\"Parameter `{name}` has value `{value}` out of range [{minimum}, {maximum}].\\",\\n\\t\\tvalue === undefined || value >= minimum && value <= maximum,\\n\\t\\t{\\n\\t\\t\\tmaximum: maximum,\\n\\t\\t\\tminimum: minimum,\\n\\t\\t\\tname: name,\\n\\t\\t\\tvalue: value\\n\\t\\t}\\n\\t);\\n};\\n\\n\\n\\n\\nvar validateParameterType = function( value, name, check, expected ) {\\n\\tvalidate(\\n\\t\\t\\"E_INVALID_PAR_TYPE\\",\\n\\t\\t\\"Invalid `{name}` parameter ({value}). {expected} expected.\\",\\n\\t\\tcheck,\\n\\t\\t{\\n\\t\\t\\texpected: expected,\\n\\t\\t\\tname: name,\\n\\t\\t\\tvalue: value\\n\\t\\t}\\n\\t);\\n};\\n\\n\\n\\n\\nvar validateParameterTypeLocale = function( value, name ) {\\n\\tvalidateParameterType(\\n\\t\\tvalue,\\n\\t\\tname,\\n\\t\\tvalue === undefined || typeof value === \\"string\\" || value instanceof Cldr,\\n\\t\\t\\"String or Cldr instance\\"\\n\\t);\\n};\\n\\n\\n\\n\\n/**\\n * Function inspired by jQuery Core, but reduced to our use case.\\n */\\nvar isPlainObject = function( obj ) {\\n\\treturn obj !== null && \\"\\" + obj === \\"[object Object]\\";\\n};\\n\\n\\n\\n\\nvar validateParameterTypePlainObject = function( value, name ) {\\n\\tvalidateParameterType(\\n\\t\\tvalue,\\n\\t\\tname,\\n\\t\\tvalue === undefined || isPlainObject( value ),\\n\\t\\t\\"Plain Object\\"\\n\\t);\\n};\\n\\n\\n\\n\\nvar alwaysCldr = function( localeOrCldr ) {\\n\\treturn localeOrCldr instanceof Cldr ? localeOrCldr : new Cldr( localeOrCldr );\\n};\\n\\n\\n\\n\\n// ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions\\nvar regexpEscape = function( string ) {\\n\\treturn string.replace( /([.*+?^=!:${}()|\\\\[\\\\]\\\\/\\\\\\\\])/g, \\"\\\\\\\\$1\\" );\\n};\\n\\n\\n\\n\\nvar stringPad = function( str, count, right ) {\\n\\tvar length;\\n\\tif ( typeof str !== \\"string\\" ) {\\n\\t\\tstr = String( str );\\n\\t}\\n\\tfor ( length = str.length; length < count; length += 1 ) {\\n\\t\\tstr = ( right ? ( str + \\"0\\" ) : ( \\"0\\" + str ) );\\n\\t}\\n\\treturn str;\\n};\\n\\n\\n\\n\\nfunction validateLikelySubtags( cldr ) {\\n\\tcldr.once( \\"get\\", validateCldr );\\n\\tcldr.get( \\"supplemental/likelySubtags\\" );\\n}\\n\\n/**\\n * [new] Globalize( locale|cldr )\\n *\\n * @locale [String]\\n *\\n * @cldr [Cldr instance]\\n *\\n * Create a Globalize instance.\\n */\\nfunction Globalize( locale ) {\\n\\tif ( !( this instanceof Globalize ) ) {\\n\\t\\treturn new Globalize( locale );\\n\\t}\\n\\n\\tvalidateParameterPresence( locale, \\"locale\\" );\\n\\tvalidateParameterTypeLocale( locale, \\"locale\\" );\\n\\n\\tthis.cldr = alwaysCldr( locale );\\n\\n\\tvalidateLikelySubtags( this.cldr );\\n}\\n\\n/**\\n * Globalize.load( json, ... )\\n *\\n * @json [JSON]\\n *\\n * Load resolved or unresolved cldr data.\\n * Somewhat equivalent to previous Globalize.addCultureInfo(...).\\n */\\nGlobalize.load = function() {\\n\\n\\t// validations are delegated to Cldr.load().\\n\\tCldr.load.apply( Cldr, arguments );\\n};\\n\\n/**\\n * Globalize.locale( [locale|cldr] )\\n *\\n * @locale [String]\\n *\\n * @cldr [Cldr instance]\\n *\\n * Set default Cldr instance if locale or cldr argument is passed.\\n *\\n * Return the default Cldr instance.\\n */\\nGlobalize.locale = function( locale ) {\\n\\tvalidateParameterTypeLocale( locale, \\"locale\\" );\\n\\n\\tif ( arguments.length ) {\\n\\t\\tthis.cldr = alwaysCldr( locale );\\n\\t\\tvalidateLikelySubtags( this.cldr );\\n\\t}\\n\\treturn this.cldr;\\n};\\n\\n/**\\n * Optimization to avoid duplicating some internal functions across modules.\\n */\\nGlobalize._alwaysArray = alwaysArray;\\nGlobalize._createError = createError;\\nGlobalize._formatMessage = formatMessage;\\nGlobalize._formatMessageToParts = formatMessageToParts;\\nGlobalize._isPlainObject = isPlainObject;\\nGlobalize._objectExtend = objectExtend;\\nGlobalize._partsJoin = partsJoin;\\nGlobalize._partsPush = partsPush;\\nGlobalize._regexpEscape = regexpEscape;\\nGlobalize._runtimeBind = runtimeBind;\\nGlobalize._stringPad = stringPad;\\nGlobalize._validate = validate;\\nGlobalize._validateCldr = validateCldr;\\nGlobalize._validateDefaultLocale = validateDefaultLocale;\\nGlobalize._validateParameterPresence = validateParameterPresence;\\nGlobalize._validateParameterRange = validateParameterRange;\\nGlobalize._validateParameterTypePlainObject = validateParameterTypePlainObject;\\nGlobalize._validateParameterType = validateParameterType;\\n\\nreturn Globalize;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplLmpzPzkyYzUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qKlxcbiAqIEdsb2JhbGl6ZSB2MS41LjBcXG4gKlxcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcXG4gKlxcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAqXFxuICogRGF0ZTogMjAyMC0wMy0yNVQxMjoxOVpcXG4gKi9cXG4vKiFcXG4gKiBHbG9iYWxpemUgdjEuNS4wIDIwMjAtMDMtMjVUMTI6MTlaIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHA6Ly9naXQuaW8vVHJkUWJ3XFxuICovXFxuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xcblxcblxcdC8vIFVNRCByZXR1cm5FeHBvcnRzXFxuXFx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQgKSB7XFxuXFxuXFx0XFx0Ly8gQU1EXFxuXFx0XFx0ZGVmaW5lKFtcXG5cXHRcXHRcXHRcXFwiY2xkclxcXCIsXFxuXFx0XFx0XFx0XFxcImNsZHIvZXZlbnRcXFwiXFxuXFx0XFx0XSwgZmFjdG9yeSApO1xcblxcdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHQvLyBOb2RlLCBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXFxcImNsZHJqc1xcXCIgKSApO1xcblxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0Ly8gR2xvYmFsXFxuXFx0XFx0cm9vdC5HbG9iYWxpemUgPSBmYWN0b3J5KCByb290LkNsZHIgKTtcXG5cXHR9XFxufSggdGhpcywgZnVuY3Rpb24oIENsZHIgKSB7XFxuXFxuXFxuLyoqXFxuICogQSB0b1N0cmluZyBtZXRob2QgdGhhdCBvdXRwdXRzIG1lYW5pbmdmdWwgdmFsdWVzIGZvciBvYmplY3RzIG9yIGFycmF5cyBhbmRcXG4gKiBzdGlsbCBwZXJmb3JtcyBhcyBmYXN0IGFzIGEgcGxhaW4gc3RyaW5nIGluIGNhc2UgdmFyaWFibGUgaXMgc3RyaW5nLCBvciBhc1xcbiAqIGZhc3QgYXMgYFxcXCJcXFwiICsgbnVtYmVyYCBpbiBjYXNlIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxcbiAqIFJlZjogaHR0cDovL2pzcGVyZi5jb20vbXktc3RyaW5naWZ5XFxuICovXFxudmFyIHRvU3RyaW5nID0gZnVuY3Rpb24oIHZhcmlhYmxlICkge1xcblxcdHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT09IFxcXCJzdHJpbmdcXFwiID8gdmFyaWFibGUgOiAoIHR5cGVvZiB2YXJpYWJsZSA9PT0gXFxcIm51bWJlclxcXCIgPyBcXFwiXFxcIiArXFxuXFx0XFx0dmFyaWFibGUgOiBKU09OLnN0cmluZ2lmeSggdmFyaWFibGUgKSApO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogZm9ybWF0TWVzc2FnZSggbWVzc2FnZSwgZGF0YSApXFxuICpcXG4gKiBAbWVzc2FnZSBbU3RyaW5nXSBBIG1lc3NhZ2Ugd2l0aCBvcHRpb25hbCB7dmFyc30gdG8gYmUgcmVwbGFjZWQuXFxuICpcXG4gKiBAZGF0YSBbQXJyYXkgb3IgSlNPTl0gT2JqZWN0IHdpdGggcmVwbGFjaW5nLXZhcmlhYmxlcyBjb250ZW50LlxcbiAqXFxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgbWVzc2FnZS4gRm9yIGV4YW1wbGU6XFxuICpcXG4gKiAtIGZvcm1hdE1lc3NhZ2UoIFxcXCJ7MH0gc2Vjb25kXFxcIiwgWyAxIF0gKTsgLy8gMSBzZWNvbmRcXG4gKlxcbiAqIC0gZm9ybWF0TWVzc2FnZSggXFxcInswfS97MX1cXFwiLCBbXFxcIm1cXFwiLCBcXFwic1xcXCJdICk7IC8vIG0vc1xcbiAqXFxuICogLSBmb3JtYXRNZXNzYWdlKCBcXFwie25hbWV9IDx7ZW1haWx9PlxcXCIsIHtcXG4gKiAgICAgbmFtZTogXFxcIkZvb1xcXCIsXFxuICogICAgIGVtYWlsOiBcXFwiYmFyQGJhei5xdXhcXFwiXFxuICogICB9KTsgLy8gRm9vIDxiYXJAYmF6LnF1eD5cXG4gKi9cXG52YXIgZm9ybWF0TWVzc2FnZSA9IGZ1bmN0aW9uKCBtZXNzYWdlLCBkYXRhICkge1xcblxcblxcdC8vIFJlcGxhY2Uge2F0dHJpYnV0ZX0nc1xcblxcdG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoIC97WzAtOWEtekEtWi1fLiBdK30vZywgZnVuY3Rpb24oIG5hbWUgKSB7XFxuXFx0XFx0bmFtZSA9IG5hbWUucmVwbGFjZSggL157KFtefV0qKX0kLywgXFxcIiQxXFxcIiApO1xcblxcdFxcdHJldHVybiB0b1N0cmluZyggZGF0YVsgbmFtZSBdICk7XFxuXFx0fSk7XFxuXFxuXFx0cmV0dXJuIG1lc3NhZ2U7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgb2JqZWN0RXh0ZW5kID0gZnVuY3Rpb24oKSB7XFxuXFx0dmFyIGRlc3RpbmF0aW9uID0gYXJndW1lbnRzWyAwIF0sXFxuXFx0XFx0c291cmNlcyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xcblxcblxcdHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiggc291cmNlICkge1xcblxcdFxcdHZhciBwcm9wO1xcblxcdFxcdGZvciAoIHByb3AgaW4gc291cmNlICkge1xcblxcdFxcdFxcdGRlc3RpbmF0aW9uWyBwcm9wIF0gPSBzb3VyY2VbIHByb3AgXTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0cmV0dXJuIGRlc3RpbmF0aW9uO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIGNyZWF0ZUVycm9yID0gZnVuY3Rpb24oIGNvZGUsIG1lc3NhZ2UsIGF0dHJpYnV0ZXMgKSB7XFxuXFx0dmFyIGVycm9yO1xcblxcblxcdG1lc3NhZ2UgPSBjb2RlICsgKCBtZXNzYWdlID8gXFxcIjogXFxcIiArIGZvcm1hdE1lc3NhZ2UoIG1lc3NhZ2UsIGF0dHJpYnV0ZXMgKSA6IFxcXCJcXFwiICk7XFxuXFx0ZXJyb3IgPSBuZXcgRXJyb3IoIG1lc3NhZ2UgKTtcXG5cXHRlcnJvci5jb2RlID0gY29kZTtcXG5cXG5cXHRvYmplY3RFeHRlbmQoIGVycm9yLCBhdHRyaWJ1dGVzICk7XFxuXFxuXFx0cmV0dXJuIGVycm9yO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogUHVzaGVzIHBhcnQgdG8gcGFydHMgYXJyYXksIGNvbmNhdCB0d28gY29uc2VjdXRpdmUgcGFydHMgb2YgdGhlIHNhbWUgdHlwZS5cXG4gKi9cXG52YXIgcGFydHNQdXNoID0gZnVuY3Rpb24oIHBhcnRzLCB0eXBlLCB2YWx1ZSApIHtcXG5cXG5cXHRcXHQvLyBDb25jYXQgdHdvIGNvbnNlY3V0aXZlIHBhcnRzIG9mIHNhbWUgdHlwZVxcblxcdFxcdGlmICggcGFydHMubGVuZ3RoICYmIHBhcnRzWyBwYXJ0cy5sZW5ndGggLSAxIF0udHlwZSA9PT0gdHlwZSApIHtcXG5cXHRcXHRcXHRwYXJ0c1sgcGFydHMubGVuZ3RoIC0gMSBdLnZhbHVlICs9IHZhbHVlO1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cGFydHMucHVzaCggeyB0eXBlOiB0eXBlLCB2YWx1ZTogdmFsdWUgfSApO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogZm9ybWF0TWVzc2FnZSggbWVzc2FnZSwgZGF0YSApXFxuICpcXG4gKiBAbWVzc2FnZSBbU3RyaW5nXSBBIG1lc3NhZ2Ugd2l0aCBvcHRpb25hbCB7dmFyc30gdG8gYmUgcmVwbGFjZWQuXFxuICpcXG4gKiBAZGF0YSBbQXJyYXkgb3IgSlNPTl0gT2JqZWN0IHdpdGggcmVwbGFjaW5nLXZhcmlhYmxlcyBjb250ZW50LlxcbiAqXFxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgbWVzc2FnZS4gRm9yIGV4YW1wbGU6XFxuICpcXG4gKiAtIGZvcm1hdE1lc3NhZ2UoIFxcXCJ7MH0gc2Vjb25kXFxcIiwgWyAxIF0gKTtcXG4gKiA+IFt7dHlwZTogXFxcInZhcmlhYmxlXFxcIiwgdmFsdWU6IFxcXCIxXFxcIiwgbmFtZTogXFxcIjBcXFwifSwge3R5cGU6IFxcXCJsaXRlcmFsXFxcIiwgdmFsdWU6IFxcXCIgc2Vjb25kXFxcIn1dXFxuICpcXG4gKiAtIGZvcm1hdE1lc3NhZ2UoIFxcXCJ7MH0vezF9XFxcIiwgW1xcXCJtXFxcIiwgXFxcInNcXFwiXSApO1xcbiAqID4gW1xcbiAqICAgICB7IHR5cGU6IFxcXCJ2YXJpYWJsZVxcXCIsIHZhbHVlOiBcXFwibVxcXCIsIG5hbWU6IFxcXCIwXFxcIiB9LFxcbiAqICAgICB7IHR5cGU6IFxcXCJsaXRlcmFsXFxcIiwgdmFsdWU6IFxcXCIgL1xcXCIgfSxcXG4gKiAgICAgeyB0eXBlOiBcXFwidmFyaWFibGVcXFwiLCB2YWx1ZTogXFxcInNcXFwiLCBuYW1lOiBcXFwiMVxcXCIgfVxcbiAqICAgXVxcbiAqL1xcbnZhciBmb3JtYXRNZXNzYWdlVG9QYXJ0cyA9IGZ1bmN0aW9uKCBtZXNzYWdlLCBkYXRhICkge1xcblxcblxcdHZhciBsYXN0T2Zmc2V0ID0gMCxcXG5cXHRcXHRwYXJ0cyA9IFtdO1xcblxcblxcdC8vIENyZWF0ZSBwYXJ0cy5cXG5cXHRtZXNzYWdlLnJlcGxhY2UoIC97WzAtOWEtekEtWi1fLiBdK30vZywgZnVuY3Rpb24oIG5hbWVJbmNsdWRpbmdCcmFja2V0cywgb2Zmc2V0ICkge1xcblxcdFxcdHZhciBuYW1lID0gbmFtZUluY2x1ZGluZ0JyYWNrZXRzLnNsaWNlKCAxLCAtMSApO1xcblxcdFxcdHBhcnRzUHVzaCggcGFydHMsIFxcXCJsaXRlcmFsXFxcIiwgbWVzc2FnZS5zbGljZSggbGFzdE9mZnNldCwgb2Zmc2V0ICkpO1xcblxcdFxcdHBhcnRzUHVzaCggcGFydHMsIFxcXCJ2YXJpYWJsZVxcXCIsIGRhdGFbIG5hbWUgXSApO1xcblxcdFxcdHBhcnRzWyBwYXJ0cy5sZW5ndGggLSAxIF0ubmFtZSA9IG5hbWU7XFxuXFx0XFx0bGFzdE9mZnNldCArPSBvZmZzZXQgKyBuYW1lSW5jbHVkaW5nQnJhY2tldHMubGVuZ3RoO1xcblxcdH0pO1xcblxcblxcdC8vIFNraXAgZW1wdHkgb25lcyBzdWNoIGFzIGB7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6ICcnIH1gLlxcblxcdHJldHVybiBwYXJ0cy5maWx0ZXIoZnVuY3Rpb24oIHBhcnQgKSB7XFxuXFx0XFx0cmV0dXJuIHBhcnQudmFsdWUgIT09IFxcXCJcXFwiO1xcblxcdH0pO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogUmV0dXJucyBqb2luZWQgcGFydHMgdmFsdWVzLlxcbiAqL1xcbnZhciBwYXJ0c0pvaW4gPSBmdW5jdGlvbiggcGFydHMgKSB7XFxuXFx0cmV0dXJuIHBhcnRzLm1hcCggZnVuY3Rpb24oIHBhcnQgKSB7XFxuXFx0XFx0cmV0dXJuIHBhcnQudmFsdWU7XFxuXFx0fSkuam9pbiggXFxcIlxcXCIgKTtcXG59O1xcblxcblxcblxcblxcbnZhciBydW50aW1lU3RyaW5naWZ5ID0gZnVuY3Rpb24oIGFyZ3MgKSB7XFxuXFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KCBhcmdzLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcXG5cXHRcXHRpZiAoIHZhbHVlICYmIHZhbHVlLnJ1bnRpbWVLZXkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlLnJ1bnRpbWVLZXk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHR9ICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc2MTY0NjEvZ2VuZXJhdGUtYS1oYXNoLWZyb20tc3RyaW5nLWluLWphdmFzY3JpcHQtanF1ZXJ5XFxudmFyIHN0cmluZ0hhc2ggPSBmdW5jdGlvbiggc3RyICkge1xcblxcdHJldHVybiBbXS5yZWR1Y2UuY2FsbCggc3RyLCBmdW5jdGlvbiggaGFzaCwgaSApIHtcXG5cXHRcXHR2YXIgY2hyID0gaS5jaGFyQ29kZUF0KCAwICk7XFxuXFx0XFx0aGFzaCA9ICggKCBoYXNoIDw8IDUgKSAtIGhhc2ggKSArIGNocjtcXG5cXHRcXHRyZXR1cm4gaGFzaCB8IDA7XFxuXFx0fSwgMCApO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIHJ1bnRpbWVLZXkgPSBmdW5jdGlvbiggZm5OYW1lLCBsb2NhbGUsIGFyZ3MsIGFyZ3NTdHIgKSB7XFxuXFx0dmFyIGhhc2g7XFxuXFx0YXJnc1N0ciA9IGFyZ3NTdHIgfHwgcnVudGltZVN0cmluZ2lmeSggYXJncyApO1xcblxcdGhhc2ggPSBzdHJpbmdIYXNoKCBmbk5hbWUgKyBsb2NhbGUgKyBhcmdzU3RyICk7XFxuXFx0cmV0dXJuIGhhc2ggPiAwID8gXFxcImFcXFwiICsgaGFzaCA6IFxcXCJiXFxcIiArIE1hdGguYWJzKCBoYXNoICk7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb24oIGZuICkge1xcblxcdGlmICggZm4ubmFtZSAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdHJldHVybiBmbi5uYW1lO1xcblxcdH1cXG5cXG5cXHQvLyBmbi5uYW1lIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUuXFxuXFx0dmFyIG1hdGNoZXMgPSAvXmZ1bmN0aW9uXFxcXHMrKFtcXFxcd1xcXFwkXSspXFxcXHMqXFxcXCgvLmV4ZWMoIGZuLnRvU3RyaW5nKCkgKTtcXG5cXG5cXHRpZiAoIG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAwICkge1xcblxcdFxcdHJldHVybiBtYXRjaGVzWyAxIF07XFxuXFx0fVxcbn07XFxuXFxuXFxuXFxuXFxudmFyIHJ1bnRpbWVCaW5kID0gZnVuY3Rpb24oIGFyZ3MsIGNsZHIsIGZuLCBydW50aW1lQXJncyApIHtcXG5cXG5cXHR2YXIgYXJnc1N0ciA9IHJ1bnRpbWVTdHJpbmdpZnkoIGFyZ3MgKSxcXG5cXHRcXHRmbk5hbWUgPSBmdW5jdGlvbk5hbWUoIGZuICksXFxuXFx0XFx0bG9jYWxlID0gY2xkci5sb2NhbGU7XFxuXFxuXFx0Ly8gSWYgbmFtZSBvZiB0aGUgZnVuY3Rpb24gaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBpcyBtb3N0IGxpa2VseSBkdWUgdG8gdWdsaWZpY2F0aW9uLFxcblxcdC8vIHdoaWNoIG1vc3QgbGlrZWx5IG1lYW5zIHdlIGFyZSBpbiBwcm9kdWN0aW9uLCBhbmQgcnVudGltZUJpbmQgaGVyZSBpcyBub3QgbmVjZXNzYXJ5LlxcblxcdGlmICggIWZuTmFtZSApIHtcXG5cXHRcXHRyZXR1cm4gZm47XFxuXFx0fVxcblxcblxcdGZuLnJ1bnRpbWVLZXkgPSBydW50aW1lS2V5KCBmbk5hbWUsIGxvY2FsZSwgbnVsbCwgYXJnc1N0ciApO1xcblxcblxcdGZuLmdlbmVyYXRvclN0cmluZyA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBcXFwiR2xvYmFsaXplKFxcXFxcXFwiXFxcIiArIGxvY2FsZSArIFxcXCJcXFxcXFxcIikuXFxcIiArIGZuTmFtZSArIFxcXCIoXFxcIiArIGFyZ3NTdHIuc2xpY2UoIDEsIC0xICkgKyBcXFwiKVxcXCI7XFxuXFx0fTtcXG5cXG5cXHRmbi5ydW50aW1lQXJncyA9IHJ1bnRpbWVBcmdzO1xcblxcblxcdHJldHVybiBmbjtcXG59O1xcblxcblxcblxcblxcbnZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKCBjb2RlLCBtZXNzYWdlLCBjaGVjaywgYXR0cmlidXRlcyApIHtcXG5cXHRpZiAoICFjaGVjayApIHtcXG5cXHRcXHR0aHJvdyBjcmVhdGVFcnJvciggY29kZSwgbWVzc2FnZSwgYXR0cmlidXRlcyApO1xcblxcdH1cXG59O1xcblxcblxcblxcblxcbnZhciBhbHdheXNBcnJheSA9IGZ1bmN0aW9uKCBzdHJpbmdPckFycmF5ICkge1xcblxcdHJldHVybiBBcnJheS5pc0FycmF5KCBzdHJpbmdPckFycmF5ICkgPyBzdHJpbmdPckFycmF5IDogc3RyaW5nT3JBcnJheSA/IFsgc3RyaW5nT3JBcnJheSBdIDogW107XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgdmFsaWRhdGVDbGRyID0gZnVuY3Rpb24oIHBhdGgsIHZhbHVlLCBvcHRpb25zICkge1xcblxcdHZhciBza2lwQm9vbGVhbjtcXG5cXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG5cXHRza2lwQm9vbGVhbiA9IGFsd2F5c0FycmF5KCBvcHRpb25zLnNraXAgKS5zb21lKGZ1bmN0aW9uKCBwYXRoUmUgKSB7XFxuXFx0XFx0cmV0dXJuIHBhdGhSZS50ZXN0KCBwYXRoICk7XFxuXFx0fSk7XFxuXFxuXFx0dmFsaWRhdGUoIFxcXCJFX01JU1NJTkdfQ0xEUlxcXCIsIFxcXCJNaXNzaW5nIHJlcXVpcmVkIENMRFIgY29udGVudCBge3BhdGh9YC5cXFwiLCB2YWx1ZSB8fCBza2lwQm9vbGVhbiwge1xcblxcdFxcdHBhdGg6IHBhdGhcXG5cXHR9KTtcXG59O1xcblxcblxcblxcblxcbnZhciB2YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0dmFsaWRhdGUoIFxcXCJFX0RFRkFVTFRfTE9DQUxFX05PVF9ERUZJTkVEXFxcIiwgXFxcIkRlZmF1bHQgbG9jYWxlIGhhcyBub3QgYmVlbiBkZWZpbmVkLlxcXCIsXFxuXFx0XFx0dmFsdWUgIT09IHVuZGVmaW5lZCwge30gKTtcXG59O1xcblxcblxcblxcblxcbnZhciB2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xcblxcdHZhbGlkYXRlKCBcXFwiRV9NSVNTSU5HX1BBUkFNRVRFUlxcXCIsIFxcXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciBge25hbWV9YC5cXFwiLFxcblxcdFxcdHZhbHVlICE9PSB1bmRlZmluZWQsIHsgbmFtZTogbmFtZSB9KTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIHJhbmdlKCB2YWx1ZSwgbmFtZSwgbWluaW11bSwgbWF4aW11bSApXFxuICpcXG4gKiBAdmFsdWUgW051bWJlcl0uXFxuICpcXG4gKiBAbmFtZSBbU3RyaW5nXSBuYW1lIG9mIHZhcmlhYmxlLlxcbiAqXFxuICogQG1pbmltdW0gW051bWJlcl0uIFRoZSBsb3dlc3QgdmFsaWQgdmFsdWUsIGluY2x1c2l2ZS5cXG4gKlxcbiAqIEBtYXhpbXVtIFtOdW1iZXJdLiBUaGUgZ3JlYXRlc3QgdmFsaWQgdmFsdWUsIGluY2x1c2l2ZS5cXG4gKi9cXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSwgbWluaW11bSwgbWF4aW11bSApIHtcXG5cXHR2YWxpZGF0ZShcXG5cXHRcXHRcXFwiRV9QQVJfT1VUX09GX1JBTkdFXFxcIixcXG5cXHRcXHRcXFwiUGFyYW1ldGVyIGB7bmFtZX1gIGhhcyB2YWx1ZSBge3ZhbHVlfWAgb3V0IG9mIHJhbmdlIFt7bWluaW11bX0sIHttYXhpbXVtfV0uXFxcIixcXG5cXHRcXHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID49IG1pbmltdW0gJiYgdmFsdWUgPD0gbWF4aW11bSxcXG5cXHRcXHR7XFxuXFx0XFx0XFx0bWF4aW11bTogbWF4aW11bSxcXG5cXHRcXHRcXHRtaW5pbXVtOiBtaW5pbXVtLFxcblxcdFxcdFxcdG5hbWU6IG5hbWUsXFxuXFx0XFx0XFx0dmFsdWU6IHZhbHVlXFxuXFx0XFx0fVxcblxcdCk7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lLCBjaGVjaywgZXhwZWN0ZWQgKSB7XFxuXFx0dmFsaWRhdGUoXFxuXFx0XFx0XFxcIkVfSU5WQUxJRF9QQVJfVFlQRVxcXCIsXFxuXFx0XFx0XFxcIkludmFsaWQgYHtuYW1lfWAgcGFyYW1ldGVyICh7dmFsdWV9KS4ge2V4cGVjdGVkfSBleHBlY3RlZC5cXFwiLFxcblxcdFxcdGNoZWNrLFxcblxcdFxcdHtcXG5cXHRcXHRcXHRleHBlY3RlZDogZXhwZWN0ZWQsXFxuXFx0XFx0XFx0bmFtZTogbmFtZSxcXG5cXHRcXHRcXHR2YWx1ZTogdmFsdWVcXG5cXHRcXHR9XFxuXFx0KTtcXG59O1xcblxcblxcblxcblxcbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVMb2NhbGUgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKFxcblxcdFxcdHZhbHVlLFxcblxcdFxcdG5hbWUsXFxuXFx0XFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiIHx8IHZhbHVlIGluc3RhbmNlb2YgQ2xkcixcXG5cXHRcXHRcXFwiU3RyaW5nIG9yIENsZHIgaW5zdGFuY2VcXFwiXFxuXFx0KTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIEZ1bmN0aW9uIGluc3BpcmVkIGJ5IGpRdWVyeSBDb3JlLCBidXQgcmVkdWNlZCB0byBvdXIgdXNlIGNhc2UuXFxuICovXFxudmFyIGlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiggb2JqICkge1xcblxcdHJldHVybiBvYmogIT09IG51bGwgJiYgXFxcIlxcXCIgKyBvYmogPT09IFxcXCJbb2JqZWN0IE9iamVjdF1cXFwiO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZShcXG5cXHRcXHR2YWx1ZSxcXG5cXHRcXHRuYW1lLFxcblxcdFxcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgaXNQbGFpbk9iamVjdCggdmFsdWUgKSxcXG5cXHRcXHRcXFwiUGxhaW4gT2JqZWN0XFxcIlxcblxcdCk7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgYWx3YXlzQ2xkciA9IGZ1bmN0aW9uKCBsb2NhbGVPckNsZHIgKSB7XFxuXFx0cmV0dXJuIGxvY2FsZU9yQ2xkciBpbnN0YW5jZW9mIENsZHIgPyBsb2NhbGVPckNsZHIgOiBuZXcgQ2xkciggbG9jYWxlT3JDbGRyICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vLyByZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9ucz9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRkd1aWRlJTJGUmVndWxhcl9FeHByZXNzaW9uc1xcbnZhciByZWdleHBFc2NhcGUgPSBmdW5jdGlvbiggc3RyaW5nICkge1xcblxcdHJldHVybiBzdHJpbmcucmVwbGFjZSggLyhbLiorP149IToke30oKXxcXFxcW1xcXFxdXFxcXC9cXFxcXFxcXF0pL2csIFxcXCJcXFxcXFxcXCQxXFxcIiApO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIHN0cmluZ1BhZCA9IGZ1bmN0aW9uKCBzdHIsIGNvdW50LCByaWdodCApIHtcXG5cXHR2YXIgbGVuZ3RoO1xcblxcdGlmICggdHlwZW9mIHN0ciAhPT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0c3RyID0gU3RyaW5nKCBzdHIgKTtcXG5cXHR9XFxuXFx0Zm9yICggbGVuZ3RoID0gc3RyLmxlbmd0aDsgbGVuZ3RoIDwgY291bnQ7IGxlbmd0aCArPSAxICkge1xcblxcdFxcdHN0ciA9ICggcmlnaHQgPyAoIHN0ciArIFxcXCIwXFxcIiApIDogKCBcXFwiMFxcXCIgKyBzdHIgKSApO1xcblxcdH1cXG5cXHRyZXR1cm4gc3RyO1xcbn07XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gdmFsaWRhdGVMaWtlbHlTdWJ0YWdzKCBjbGRyICkge1xcblxcdGNsZHIub25jZSggXFxcImdldFxcXCIsIHZhbGlkYXRlQ2xkciApO1xcblxcdGNsZHIuZ2V0KCBcXFwic3VwcGxlbWVudGFsL2xpa2VseVN1YnRhZ3NcXFwiICk7XFxufVxcblxcbi8qKlxcbiAqIFtuZXddIEdsb2JhbGl6ZSggbG9jYWxlfGNsZHIgKVxcbiAqXFxuICogQGxvY2FsZSBbU3RyaW5nXVxcbiAqXFxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdXFxuICpcXG4gKiBDcmVhdGUgYSBHbG9iYWxpemUgaW5zdGFuY2UuXFxuICovXFxuZnVuY3Rpb24gR2xvYmFsaXplKCBsb2NhbGUgKSB7XFxuXFx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgR2xvYmFsaXplICkgKSB7XFxuXFx0XFx0cmV0dXJuIG5ldyBHbG9iYWxpemUoIGxvY2FsZSApO1xcblxcdH1cXG5cXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCBsb2NhbGUsIFxcXCJsb2NhbGVcXFwiICk7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTG9jYWxlKCBsb2NhbGUsIFxcXCJsb2NhbGVcXFwiICk7XFxuXFxuXFx0dGhpcy5jbGRyID0gYWx3YXlzQ2xkciggbG9jYWxlICk7XFxuXFxuXFx0dmFsaWRhdGVMaWtlbHlTdWJ0YWdzKCB0aGlzLmNsZHIgKTtcXG59XFxuXFxuLyoqXFxuICogR2xvYmFsaXplLmxvYWQoIGpzb24sIC4uLiApXFxuICpcXG4gKiBAanNvbiBbSlNPTl1cXG4gKlxcbiAqIExvYWQgcmVzb2x2ZWQgb3IgdW5yZXNvbHZlZCBjbGRyIGRhdGEuXFxuICogU29tZXdoYXQgZXF1aXZhbGVudCB0byBwcmV2aW91cyBHbG9iYWxpemUuYWRkQ3VsdHVyZUluZm8oLi4uKS5cXG4gKi9cXG5HbG9iYWxpemUubG9hZCA9IGZ1bmN0aW9uKCkge1xcblxcblxcdC8vIHZhbGlkYXRpb25zIGFyZSBkZWxlZ2F0ZWQgdG8gQ2xkci5sb2FkKCkuXFxuXFx0Q2xkci5sb2FkLmFwcGx5KCBDbGRyLCBhcmd1bWVudHMgKTtcXG59O1xcblxcbi8qKlxcbiAqIEdsb2JhbGl6ZS5sb2NhbGUoIFtsb2NhbGV8Y2xkcl0gKVxcbiAqXFxuICogQGxvY2FsZSBbU3RyaW5nXVxcbiAqXFxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdXFxuICpcXG4gKiBTZXQgZGVmYXVsdCBDbGRyIGluc3RhbmNlIGlmIGxvY2FsZSBvciBjbGRyIGFyZ3VtZW50IGlzIHBhc3NlZC5cXG4gKlxcbiAqIFJldHVybiB0aGUgZGVmYXVsdCBDbGRyIGluc3RhbmNlLlxcbiAqL1xcbkdsb2JhbGl6ZS5sb2NhbGUgPSBmdW5jdGlvbiggbG9jYWxlICkge1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZUxvY2FsZSggbG9jYWxlLCBcXFwibG9jYWxlXFxcIiApO1xcblxcblxcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcXG5cXHRcXHR0aGlzLmNsZHIgPSBhbHdheXNDbGRyKCBsb2NhbGUgKTtcXG5cXHRcXHR2YWxpZGF0ZUxpa2VseVN1YnRhZ3MoIHRoaXMuY2xkciApO1xcblxcdH1cXG5cXHRyZXR1cm4gdGhpcy5jbGRyO1xcbn07XFxuXFxuLyoqXFxuICogT3B0aW1pemF0aW9uIHRvIGF2b2lkIGR1cGxpY2F0aW5nIHNvbWUgaW50ZXJuYWwgZnVuY3Rpb25zIGFjcm9zcyBtb2R1bGVzLlxcbiAqL1xcbkdsb2JhbGl6ZS5fYWx3YXlzQXJyYXkgPSBhbHdheXNBcnJheTtcXG5HbG9iYWxpemUuX2NyZWF0ZUVycm9yID0gY3JlYXRlRXJyb3I7XFxuR2xvYmFsaXplLl9mb3JtYXRNZXNzYWdlID0gZm9ybWF0TWVzc2FnZTtcXG5HbG9iYWxpemUuX2Zvcm1hdE1lc3NhZ2VUb1BhcnRzID0gZm9ybWF0TWVzc2FnZVRvUGFydHM7XFxuR2xvYmFsaXplLl9pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcXG5HbG9iYWxpemUuX29iamVjdEV4dGVuZCA9IG9iamVjdEV4dGVuZDtcXG5HbG9iYWxpemUuX3BhcnRzSm9pbiA9IHBhcnRzSm9pbjtcXG5HbG9iYWxpemUuX3BhcnRzUHVzaCA9IHBhcnRzUHVzaDtcXG5HbG9iYWxpemUuX3JlZ2V4cEVzY2FwZSA9IHJlZ2V4cEVzY2FwZTtcXG5HbG9iYWxpemUuX3J1bnRpbWVCaW5kID0gcnVudGltZUJpbmQ7XFxuR2xvYmFsaXplLl9zdHJpbmdQYWQgPSBzdHJpbmdQYWQ7XFxuR2xvYmFsaXplLl92YWxpZGF0ZSA9IHZhbGlkYXRlO1xcbkdsb2JhbGl6ZS5fdmFsaWRhdGVDbGRyID0gdmFsaWRhdGVDbGRyO1xcbkdsb2JhbGl6ZS5fdmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gdmFsaWRhdGVEZWZhdWx0TG9jYWxlO1xcbkdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2U7XFxuR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclJhbmdlID0gdmFsaWRhdGVQYXJhbWV0ZXJSYW5nZTtcXG5HbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3Q7XFxuR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGUgPSB2YWxpZGF0ZVBhcmFtZXRlclR5cGU7XFxuXFxucmV0dXJuIEdsb2JhbGl6ZTtcXG5cXG5cXG5cXG5cXG59KSk7XFxuXCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL251bWJlci5qcz8xZDRlIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcZ2xvYmFsaXplXFxcXGRpc3RcXFxcZ2xvYmFsaXplXFxcXG51bWJlci5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n")},function(module,exports){eval('module.exports = "/**\\n * Globalize v1.5.0\\n *\\n * http://github.com/jquery/globalize\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2020-03-25T12:19Z\\n */\\n/*!\\n * Globalize v1.5.0 2020-03-25T12:19Z Released under the MIT license\\n * http://git.io/TrdQbw\\n */\\n(function( root, factory ) {\\n\\n\\t// UMD returnExports\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\n\\t\\t// AMD\\n\\t\\tdefine([\\n\\t\\t\\t\\"cldr\\",\\n\\t\\t\\t\\"../globalize\\",\\n\\t\\t\\t\\"cldr/event\\",\\n\\t\\t\\t\\"cldr/supplemental\\"\\n\\t\\t], factory );\\n\\t} else if ( typeof exports === \\"object\\" ) {\\n\\n\\t\\t// Node, CommonJS\\n\\t\\tmodule.exports = factory( require( \\"cldrjs\\" ), require( \\"../globalize\\" ) );\\n\\t} else {\\n\\n\\t\\t// Global\\n\\t\\tfactory( root.Cldr, root.Globalize );\\n\\t}\\n}(this, function( Cldr, Globalize ) {\\n\\nvar createError = Globalize._createError,\\n\\tpartsJoin = Globalize._partsJoin,\\n\\tpartsPush = Globalize._partsPush,\\n\\tregexpEscape = Globalize._regexpEscape,\\n\\truntimeBind = Globalize._runtimeBind,\\n\\tstringPad = Globalize._stringPad,\\n\\tvalidateCldr = Globalize._validateCldr,\\n\\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\\n\\tvalidateParameterPresence = Globalize._validateParameterPresence,\\n\\tvalidateParameterRange = Globalize._validateParameterRange,\\n\\tvalidateParameterType = Globalize._validateParameterType,\\n\\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\\n\\n\\nvar createErrorUnsupportedFeature = function( feature ) {\\n\\treturn createError( \\"E_UNSUPPORTED\\", \\"Unsupported {feature}.\\", {\\n\\t\\tfeature: feature\\n\\t});\\n};\\n\\n\\n\\n\\nvar validateParameterTypeNumber = function( value, name ) {\\n\\tvalidateParameterType(\\n\\t\\tvalue,\\n\\t\\tname,\\n\\t\\tvalue === undefined || typeof value === \\"number\\",\\n\\t\\t\\"Number\\"\\n\\t);\\n};\\n\\n\\n\\n\\nvar validateParameterTypeString = function( value, name ) {\\n\\tvalidateParameterType(\\n\\t\\tvalue,\\n\\t\\tname,\\n\\t\\tvalue === undefined || typeof value === \\"string\\",\\n\\t\\t\\"a string\\"\\n\\t);\\n};\\n\\n\\n\\n\\nvar numberFormatterFn = function( numberToPartsFormatter ) {\\n\\treturn function numberFormatter( value ) {\\n\\t\\treturn partsJoin( numberToPartsFormatter( value ));\\n\\t};\\n};\\n\\n\\n\\n\\n/**\\n * NumberingSystem( cldr )\\n *\\n * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems\\n * - http://cldr.unicode.org/index/bcp47-extension\\n * - http://www.unicode.org/reports/tr35/#u_Extension\\n */\\nvar numberNumberingSystem = function( cldr ) {\\n\\tvar nu = cldr.attributes[ \\"u-nu\\" ];\\n\\n\\tif ( nu ) {\\n\\t\\tif ( nu === \\"traditio\\" ) {\\n\\t\\t\\tnu = \\"traditional\\";\\n\\t\\t}\\n\\t\\tif ( [ \\"native\\", \\"traditional\\", \\"finance\\" ].indexOf( nu ) !== -1 ) {\\n\\n\\t\\t\\t// Unicode locale extension `u-nu` is set using either (native, traditional or\\n\\t\\t\\t// finance). So, lookup the respective locale\'s numberingSystem and return it.\\n\\t\\t\\treturn cldr.main([ \\"numbers/otherNumberingSystems\\", nu ]);\\n\\t\\t}\\n\\n\\t\\t// Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.\\n\\t\\treturn nu;\\n\\t}\\n\\n\\t// Return the default numberingSystem.\\n\\treturn cldr.main( \\"numbers/defaultNumberingSystem\\" );\\n};\\n\\n\\n\\n\\n/**\\n * Compact( name, cldr )\\n *\\n * @compactType [String] Compact mode, `short` or `long`.\\n *\\n * @cldr [Cldr instance].\\n *\\n * Return the localized compact map for the given compact mode.\\n */\\nvar numberCompact = function( compactType, cldr ) {\\n\\tvar maxExponent = 0;\\n\\n\\tvar object = cldr.main([\\n\\t\\t\\"numbers/decimalFormats-numberSystem-\\" + numberNumberingSystem( cldr ),\\n\\t\\tcompactType,\\n\\t\\t\\"decimalFormat\\"\\n\\t]);\\n\\n\\tobject = Object.keys( object ).reduce(function( newObject, compactKey ) {\\n\\t\\tvar numberExponent = compactKey.split( \\"0\\" ).length - 1;\\n\\t\\tvar pluralForm = compactKey.split( \\"-\\" )[ 2 ];\\n\\t\\tnewObject[ numberExponent ] = newObject[ numberExponent ] || {};\\n\\t\\tnewObject[ numberExponent ][ pluralForm ] = object[ compactKey ];\\n\\t\\tmaxExponent = Math.max( numberExponent, maxExponent );\\n\\t\\treturn newObject;\\n\\t}, {});\\n\\n\\tobject.maxExponent = maxExponent;\\n\\n\\treturn object;\\n};\\n\\n\\n\\n\\n/**\\n * nuMap( cldr )\\n *\\n * @cldr [Cldr instance].\\n *\\n * Return digits map if numbering system is different than `latn`.\\n */\\nvar numberNumberingSystemDigitsMap = function( cldr ) {\\n\\tvar aux,\\n\\t\\tnu = numberNumberingSystem( cldr );\\n\\n\\tif ( nu === \\"latn\\" ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\taux = cldr.supplemental([ \\"numberingSystems\\", nu ]);\\n\\n\\tif ( aux._type !== \\"numeric\\" ) {\\n\\t\\tthrow createErrorUnsupportedFeature( \\"`\\" + aux._type + \\"` numbering system\\" );\\n\\t}\\n\\n\\treturn aux._digits;\\n};\\n\\n\\n\\n\\n/**\\n * EBNF representation:\\n *\\n * number_pattern_re =        prefix?\\n *                            padding?\\n *                            (integer_fraction_pattern | significant_pattern)\\n *                            scientific_notation?\\n *                            suffix?\\n *\\n * prefix =                   non_number_stuff\\n *\\n * padding =                  \\"*\\" regexp(.)\\n *\\n * integer_fraction_pattern = integer_pattern\\n *                            fraction_pattern?\\n *\\n * integer_pattern =          regexp([#,]*[0,]*0+)\\n *\\n * fraction_pattern =         \\".\\" regexp(0*[0-9]*#*)\\n *\\n * significant_pattern =      regexp([#,]*@+#*)\\n *\\n * scientific_notation =      regexp(E\\\\+?0+)\\n *\\n * suffix =                   non_number_stuff\\n *\\n * non_number_stuff =         regexp((\'[^\']+\'|\'\'|[^*#@0,.E])*)\\n *\\n *\\n * Regexp groups:\\n *\\n *  0: number_pattern_re\\n *  1: prefix\\n *  2: -\\n *  3: -\\n *  4: padding\\n *  5: (integer_fraction_pattern | significant_pattern)\\n *  6: integer_fraction_pattern\\n *  7: integer_pattern\\n *  8: fraction_pattern\\n *  9: significant_pattern\\n * 10: scientific_notation\\n * 11: suffix\\n * 12: -\\n */\\nvar numberPatternRe = ( /^((\'([^\']|\'\')*\'|[^*#@0,.E])*)(\\\\*.)?((([#,]*[0,]*0+)(\\\\.0*[0-9]*#*)?)|([#,]*@+#*))(E\\\\+?0+)?((\'[^\']+\'|\'\'|[^*#@0,.E])*)$/ );\\n\\n\\n\\n\\n/**\\n * format( number, pattern )\\n *\\n * @number [Number].\\n *\\n * @pattern [String] raw pattern for numbers.\\n *\\n * Return the formatted number.\\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\\n */\\nvar numberPatternProperties = function( pattern ) {\\n\\tvar aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern,\\n\\t\\tmaximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,\\n\\t\\tminimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize,\\n\\t\\troundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;\\n\\n\\tpattern = pattern.match( numberPatternRe );\\n\\tif ( !pattern ) {\\n\\t\\tthrow new Error( \\"Invalid pattern: \\" + pattern );\\n\\t}\\n\\n\\tprefix = pattern[ 1 ];\\n\\tpadding = pattern[ 4 ];\\n\\tintegerFractionOrSignificantPattern = pattern[ 5 ];\\n\\tsignificantPattern = pattern[ 9 ];\\n\\tscientificNotation = pattern[ 10 ];\\n\\tsuffix = pattern[ 11 ];\\n\\n\\t// Significant digit format\\n\\tif ( significantPattern ) {\\n\\t\\tsignificantPattern.replace( /(@+)(#*)/, function( match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch ) {\\n\\t\\t\\tminimumSignificantDigits = minimumSignificantDigitsMatch.length;\\n\\t\\t\\tmaximumSignificantDigits = minimumSignificantDigits +\\n\\t\\t\\t\\tmaximumSignificantDigitsMatch.length;\\n\\t\\t});\\n\\n\\t// Integer and fractional format\\n\\t} else {\\n\\t\\tfractionPattern = pattern[ 8 ];\\n\\t\\tintegerPattern = pattern[ 7 ];\\n\\n\\t\\tif ( fractionPattern ) {\\n\\n\\t\\t\\t// Minimum fraction digits, and rounding.\\n\\t\\t\\tfractionPattern.replace( /[0-9]+/, function( match ) {\\n\\t\\t\\t\\tminimumFractionDigits = match;\\n\\t\\t\\t});\\n\\t\\t\\tif ( minimumFractionDigits ) {\\n\\t\\t\\t\\troundIncrement = +( \\"0.\\" + minimumFractionDigits );\\n\\t\\t\\t\\tminimumFractionDigits = minimumFractionDigits.length;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tminimumFractionDigits = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Maximum fraction digits\\n\\t\\t\\t// 1: ignore decimal character\\n\\t\\t\\tmaximumFractionDigits = fractionPattern.length - 1 /* 1 */;\\n\\t\\t} else {\\n\\t\\t\\tminimumFractionDigits = 0;\\n\\t\\t\\tmaximumFractionDigits = 0;\\n\\t\\t}\\n\\n\\t\\t// Minimum integer digits\\n\\t\\tintegerPattern.replace( /0+$/, function( match ) {\\n\\t\\t\\tminimumIntegerDigits = match.length;\\n\\t\\t});\\n\\t}\\n\\n\\t// Scientific notation\\n\\tif ( scientificNotation ) {\\n\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\tfeature: \\"scientific notation (not implemented)\\"\\n\\t\\t});\\n\\t}\\n\\n\\t// Padding\\n\\tif ( padding ) {\\n\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\tfeature: \\"padding (not implemented)\\"\\n\\t\\t});\\n\\t}\\n\\n\\t// Grouping\\n\\tif ( ( aux1 = integerFractionOrSignificantPattern.lastIndexOf( \\",\\" ) ) !== -1 ) {\\n\\n\\t\\t// Primary grouping size is the interval between the last group separator and the end of\\n\\t\\t// the integer (or the end of the significant pattern).\\n\\t\\taux2 = integerFractionOrSignificantPattern.split( \\".\\" )[ 0 ];\\n\\t\\tprimaryGroupingSize = aux2.length - aux1 - 1;\\n\\n\\t\\t// Secondary grouping size is the interval between the last two group separators.\\n\\t\\tif ( ( aux2 = integerFractionOrSignificantPattern.lastIndexOf( \\",\\", aux1 - 1 ) ) !== -1 ) {\\n\\t\\t\\tsecondaryGroupingSize = aux1 - 1 - aux2;\\n\\t\\t}\\n\\t}\\n\\n\\t// Return:\\n\\t//  0: @prefix String\\n\\t//  1: @padding Array [ <character>, <count> ] TODO\\n\\t//  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer\\n\\t//        digits to be used. Numbers will be padded with leading zeroes if necessary.\\n\\t//  3: @minimumFractionDigits and\\n\\t//  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and\\n\\t//        maximum fraction digits to be used. Numbers will be rounded or padded with trailing\\n\\t//        zeroes if necessary.\\n\\t//  5: @minimumSignificantDigits and\\n\\t//  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and\\n\\t//        maximum fraction digits to be shown. Either none or both of these properties are\\n\\t//        present; if they are, they override minimum and maximum integer and fraction digits\\n\\t//         the formatter uses however many integer and fraction digits are required to display\\n\\t//        the specified number of significant digits.\\n\\t//  7: @roundIncrement Decimal round increment or null\\n\\t//  8: @primaryGroupingSize\\n\\t//  9: @secondaryGroupingSize\\n\\t// 10: @suffix String\\n\\treturn [\\n\\t\\tprefix,\\n\\t\\tpadding,\\n\\t\\tminimumIntegerDigits,\\n\\t\\tminimumFractionDigits,\\n\\t\\tmaximumFractionDigits,\\n\\t\\tminimumSignificantDigits,\\n\\t\\tmaximumSignificantDigits,\\n\\t\\troundIncrement,\\n\\t\\tprimaryGroupingSize,\\n\\t\\tsecondaryGroupingSize,\\n\\t\\tsuffix\\n\\t];\\n};\\n\\n\\n\\n\\n/**\\n * Symbol( name, cldr )\\n *\\n * @name [String] Symbol name.\\n *\\n * @cldr [Cldr instance].\\n *\\n * Return the localized symbol given its name.\\n */\\nvar numberSymbol = function( name, cldr ) {\\n\\treturn cldr.main([\\n\\t\\t\\"numbers/symbols-numberSystem-\\" + numberNumberingSystem( cldr ),\\n\\t\\tname\\n\\t]);\\n};\\n\\n\\n\\n\\nvar numberSymbolName = {\\n\\t\\".\\": \\"decimal\\",\\n\\t\\",\\": \\"group\\",\\n\\t\\"%\\": \\"percentSign\\",\\n\\t\\"+\\": \\"plusSign\\",\\n\\t\\"-\\": \\"minusSign\\",\\n\\t\\"E\\": \\"exponential\\",\\n\\t\\"\\\\u2030\\": \\"perMille\\"\\n};\\n\\n\\n\\n\\n/**\\n * symbolMap( cldr )\\n *\\n * @cldr [Cldr instance].\\n *\\n * Return the (localized symbol, pattern symbol) key value pair, eg. {\\n *   \\".\\": \\"\\",\\n *   \\",\\": \\"\\",\\n *   \\"%\\": \\"\\",\\n *   ...\\n * };\\n */\\nvar numberSymbolMap = function( cldr ) {\\n\\tvar symbol,\\n\\t\\tsymbolMap = {};\\n\\n\\tfor ( symbol in numberSymbolName ) {\\n\\t\\tsymbolMap[ symbol ] = numberSymbol( numberSymbolName[ symbol ], cldr );\\n\\t}\\n\\n\\treturn symbolMap;\\n};\\n\\n\\n\\n\\nvar numberTruncate = function( value ) {\\n\\tif ( isNaN( value ) ) {\\n\\t\\treturn NaN;\\n\\t}\\n\\treturn Math[ value < 0 ? \\"ceil\\" : \\"floor\\" ]( value );\\n};\\n\\n\\n\\n\\n/**\\n * round( method )\\n *\\n * @method [String] with either \\"round\\", \\"ceil\\", \\"floor\\", or \\"truncate\\".\\n *\\n * Return function( value, incrementOrExp ):\\n *\\n *   @value [Number] eg. 123.45.\\n *\\n *   @incrementOrExp [Number] optional, eg. 0.1; or\\n *     [Object] Either { increment: <value> } or { exponent: <value> }\\n *\\n *   Return the rounded number, eg:\\n *   - round( \\"round\\" )( 123.45 ): 123;\\n *   - round( \\"ceil\\" )( 123.45 ): 124;\\n *   - round( \\"floor\\" )( 123.45 ): 123;\\n *   - round( \\"truncate\\" )( 123.45 ): 123;\\n *   - round( \\"round\\" )( 123.45, 0.1 ): 123.5;\\n *   - round( \\"round\\" )( 123.45, 10 ): 120;\\n *\\n *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\\n *   Ref: #376\\n */\\nvar numberRound = function( method ) {\\n\\tmethod = method || \\"round\\";\\n\\tmethod = method === \\"truncate\\" ? numberTruncate : Math[ method ];\\n\\n\\treturn function( value, incrementOrExp ) {\\n\\t\\tvar exp, increment;\\n\\n\\t\\tvalue = +value;\\n\\n\\t\\t// If the value is not a number, return NaN.\\n\\t\\tif ( isNaN( value ) ) {\\n\\t\\t\\treturn NaN;\\n\\t\\t}\\n\\n\\t\\t// Exponent given.\\n\\t\\tif ( typeof incrementOrExp === \\"object\\" && incrementOrExp.exponent ) {\\n\\t\\t\\texp = +incrementOrExp.exponent;\\n\\t\\t\\tincrement = 1;\\n\\n\\t\\t\\tif ( exp === 0 ) {\\n\\t\\t\\t\\treturn method( value );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If the exp is not an integer, return NaN.\\n\\t\\t\\tif ( !( typeof exp === \\"number\\" && exp % 1 === 0 ) ) {\\n\\t\\t\\t\\treturn NaN;\\n\\t\\t\\t}\\n\\n\\t\\t// Increment given.\\n\\t\\t} else {\\n\\t\\t\\tincrement = +incrementOrExp || 1;\\n\\n\\t\\t\\tif ( increment === 1 ) {\\n\\t\\t\\t\\treturn method( value );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If the increment is not a number, return NaN.\\n\\t\\t\\tif ( isNaN( increment ) ) {\\n\\t\\t\\t\\treturn NaN;\\n\\t\\t\\t}\\n\\n\\t\\t\\tincrement = increment.toExponential().split( \\"e\\" );\\n\\t\\t\\texp = +increment[ 1 ];\\n\\t\\t\\tincrement = +increment[ 0 ];\\n\\t\\t}\\n\\n\\t\\t// Shift & Round\\n\\t\\tvalue = value.toString().split( \\"e\\" );\\n\\t\\tvalue[ 0 ] = +value[ 0 ] / increment;\\n\\t\\tvalue[ 1 ] = value[ 1 ] ? ( +value[ 1 ] - exp ) : -exp;\\n\\t\\tvalue = method( +( value[ 0 ] + \\"e\\" + value[ 1 ] ) );\\n\\n\\t\\t// Shift back\\n\\t\\tvalue = value.toString().split( \\"e\\" );\\n\\t\\tvalue[ 0 ] = +value[ 0 ] * increment;\\n\\t\\tvalue[ 1 ] = value[ 1 ] ? ( +value[ 1 ] + exp ) : exp;\\n\\t\\treturn +( value[ 0 ] + \\"e\\" + value[ 1 ] );\\n\\t};\\n};\\n\\n\\n\\n\\n/**\\n * formatProperties( pattern, cldr [, options] )\\n *\\n * @pattern [String] raw pattern for numbers.\\n *\\n * @cldr [Cldr instance].\\n *\\n * @options [Object]:\\n * - minimumIntegerDigits [Number]\\n * - minimumFractionDigits, maximumFractionDigits [Number]\\n * - minimumSignificantDigits, maximumSignificantDigits [Number]\\n * - round [String] \\"ceil\\", \\"floor\\", \\"round\\" (default), or \\"truncate\\".\\n * - useGrouping [Boolean] default true.\\n *\\n * Return the processed properties that will be used in number/format.\\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\\n */\\nvar numberFormatProperties = function( pattern, cldr, options ) {\\n\\tvar negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern,\\n\\t\\troundFn, properties;\\n\\n\\tfunction getOptions( attribute, propertyIndex ) {\\n\\t\\tif ( attribute in options ) {\\n\\t\\t\\tproperties[ propertyIndex ] = options[ attribute ];\\n\\t\\t}\\n\\t}\\n\\n\\toptions = options || {};\\n\\tpattern = pattern.split( \\";\\" );\\n\\n\\tpositivePattern = pattern[ 0 ];\\n\\n\\tnegativePattern = pattern[ 1 ] || \\"-\\" + positivePattern;\\n\\tnegativeProperties = numberPatternProperties( negativePattern );\\n\\tnegativePrefix = negativeProperties[ 0 ];\\n\\tnegativeSuffix = negativeProperties[ 10 ];\\n\\n\\t// Have runtime code to refer to numberRound() instead of including it explicitly.\\n\\troundFn = numberRound( options.round );\\n\\troundFn.generatorString = function() {\\n\\t\\treturn \\"numberRound(\\" + ( options.round ? \\"\\\\\\"\\" + options.round + \\"\\\\\\"\\" : \\"\\" ) + \\")\\";\\n\\t};\\n\\n\\tproperties = numberPatternProperties( positivePattern ).concat([\\n\\t\\tpositivePattern,\\n\\t\\tnegativePrefix + positivePattern + negativeSuffix,\\n\\t\\tnegativePrefix,\\n\\t\\tnegativeSuffix,\\n\\t\\troundFn,\\n\\t\\tnumberSymbol( \\"infinity\\", cldr ),\\n\\t\\tnumberSymbol( \\"nan\\", cldr ),\\n\\t\\tnumberSymbolMap( cldr ),\\n\\t\\tnumberNumberingSystemDigitsMap( cldr )\\n\\t]);\\n\\n\\tif ( options.compact ) {\\n\\n\\t\\t// The compact digits number pattern is always `0+`, so override the following properties.\\n\\t\\t// Note: minimumIntegerDigits would actually range from `0` to `000` based on the scale of\\n\\t\\t// the value to be formatted, though we\'re always using 1 as a simplification, because the\\n\\t\\t// number won\'t be zero-padded since we chose the right format based on the scale, i.e.,\\n\\t\\t// we\'d never see something like `003M` anyway.\\n\\t\\tproperties[ 2 ] = 1; // minimumIntegerDigits\\n\\t\\tproperties[ 3 ] = 0; // minimumFractionDigits\\n\\t\\tproperties[ 4 ] = 0; // maximumFractionDigits\\n\\t\\tproperties[ 5 ] = // minimumSignificantDigits &\\n\\t\\t\\tproperties[ 6 ] = undefined ; // maximumSignificantDigits\\n\\n\\t\\tproperties[20] = numberCompact( options.compact, cldr );\\n\\t}\\n\\n\\tgetOptions( \\"minimumIntegerDigits\\", 2 );\\n\\tgetOptions( \\"minimumFractionDigits\\", 3 );\\n\\tgetOptions( \\"maximumFractionDigits\\", 4 );\\n\\tgetOptions( \\"minimumSignificantDigits\\", 5 );\\n\\tgetOptions( \\"maximumSignificantDigits\\", 6 );\\n\\n\\t// Grouping separators\\n\\tif ( options.useGrouping === false ) {\\n\\t\\tproperties[ 8 ] = null;\\n\\t}\\n\\n\\t// Normalize number of digits if only one of either minimumFractionDigits or\\n\\t// maximumFractionDigits is passed in as an option\\n\\tif ( \\"minimumFractionDigits\\" in options && !( \\"maximumFractionDigits\\" in options ) ) {\\n\\n\\t\\t// maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );\\n\\t\\tproperties[ 4 ] = Math.max( properties[ 3 ], properties[ 4 ] );\\n\\t} else if ( !( \\"minimumFractionDigits\\" in options ) &&\\n\\t\\t\\t\\"maximumFractionDigits\\" in options ) {\\n\\n\\t\\t// minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );\\n\\t\\tproperties[ 3 ] = Math.min( properties[ 3 ], properties[ 4 ] );\\n\\t}\\n\\n\\t// Return:\\n\\t// 0-10: see number/pattern-properties.\\n\\t// 11: @positivePattern [String] Positive pattern.\\n\\t// 12: @negativePattern [String] Negative pattern.\\n\\t// 13: @negativePrefix [String] Negative prefix.\\n\\t// 14: @negativeSuffix [String] Negative suffix.\\n\\t// 15: @round [Function] Round function.\\n\\t// 16: @infinitySymbol [String] Infinity symbol.\\n\\t// 17: @nanSymbol [String] NaN symbol.\\n\\t// 18: @symbolMap [Object] A bunch of other symbols.\\n\\t// 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.\\n\\t// 20: @compactMap [Object] Map of per-digit-count format patterns for specified compact mode.\\n\\treturn properties;\\n};\\n\\n\\n\\n\\n/**\\n * Generated by:\\n *\\n * var regenerate = require( \\"regenerate\\" );\\n * var formatSymbols = require( * \\"unicode-8.0.0/General_Category/Format/symbols\\" );\\n * regenerate().add( formatSymbols ).toString();\\n *\\n * https://github.com/mathiasbynens/regenerate\\n * https://github.com/mathiasbynens/unicode-8.0.0\\n */\\nvar regexpCfG = /[\\\\xAD\\\\u0600-\\\\u0605\\\\u061C\\\\u06DD\\\\u070F\\\\u180E\\\\u200B-\\\\u200F\\\\u202A-\\\\u202E\\\\u2060-\\\\u2064\\\\u2066-\\\\u206F\\\\uFEFF\\\\uFFF9-\\\\uFFFB]|\\\\uD804\\\\uDCBD|\\\\uD82F[\\\\uDCA0-\\\\uDCA3]|\\\\uD834[\\\\uDD73-\\\\uDD7A]|\\\\uDB40[\\\\uDC01\\\\uDC20-\\\\uDC7F]/g;\\n\\n\\n\\n\\n/**\\n * Generated by:\\n *\\n * var regenerate = require( \\"regenerate\\" );\\n * var dashSymbols = require( * \\"unicode-8.0.0/General_Category/Dash_Punctuation/symbols\\" );\\n * regenerate().add( dashSymbols ).toString();\\n *\\n * https://github.com/mathiasbynens/regenerate\\n * https://github.com/mathiasbynens/unicode-8.0.0\\n *\\n * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.\\n */\\nvar regexpDashG = /[\\\\-\\\\u058A\\\\u05BE\\\\u1400\\\\u1806\\\\u2010-\\\\u2015\\\\u2E17\\\\u2E1A\\\\u2E3A\\\\u2E3B\\\\u2E40\\\\u301C\\\\u3030\\\\u30A0\\\\uFE31\\\\uFE32\\\\uFE58\\\\uFE63\\\\uFF0D\\\\u2212]/g;\\n\\n\\n\\n\\n/**\\n * Generated by:\\n *\\n * var regenerate = require( \\"regenerate\\" );\\n * var spaceSeparatorSymbols = require( \\"unicode-8.0.0/General_Category/Space_Separator/symbols\\" );\\n * regenerate().add( spaceSeparatorSymbols ).toString();\\n *\\n * https://github.com/mathiasbynens/regenerate\\n * https://github.com/mathiasbynens/unicode-8.0.0\\n */\\nvar regexpZsG = /[ \\\\xA0\\\\u1680\\\\u2000-\\\\u200A\\\\u202F\\\\u205F\\\\u3000]/g;\\n\\n\\n\\n\\n/**\\n * Loose Matching:\\n * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI\\n *   formatting.\\n * - Map all characters in [:Zs:] to U+0020 SPACE;\\n * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;\\n */\\nvar looseMatching = function( value ) {\\n\\treturn value\\n\\t\\t.replace( regexpCfG, \\"\\" )\\n\\t\\t.replace( regexpDashG, \\"-\\" )\\n\\t\\t.replace( regexpZsG, \\" \\" );\\n};\\n\\n\\n\\n\\n/**\\n * parse( value, properties )\\n *\\n * @value [String].\\n *\\n * @properties [Object] Parser properties is a reduced pre-processed cldr\\n * data set returned by numberParserProperties().\\n *\\n * Return the parsed Number (including Infinity) or NaN when value is invalid.\\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\\n */\\nvar numberParse = function( value, properties ) {\\n\\tvar grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix,\\n\\t\\tsuffix, tokenizer, valid;\\n\\n\\t// Grammar:\\n\\t// - Value <=           NaN | PositiveNumber | NegativeNumber\\n\\t// - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix\\n\\t// - NegativeNumber <=  NegativePrefix NumberOrInf\\n\\t// - NumberOrInf <=     Number | Inf\\n\\tgrammar = [\\n\\t\\t[ \\"nan\\" ],\\n\\t\\t[ \\"prefix\\", \\"infinity\\", \\"suffix\\" ],\\n\\t\\t[ \\"prefix\\", \\"number\\", \\"suffix\\" ],\\n\\t\\t[ \\"negativePrefix\\", \\"infinity\\", \\"negativeSuffix\\" ],\\n\\t\\t[ \\"negativePrefix\\", \\"number\\", \\"negativeSuffix\\" ]\\n\\t];\\n\\n\\tinvertedSymbolMap = properties[ 0 ];\\n\\tinvertedNuDigitsMap = properties[ 1 ] || {};\\n\\ttokenizer = properties[ 2 ];\\n\\n\\tvalue = looseMatching( value );\\n\\n\\tfunction parse( type ) {\\n\\t\\treturn function( lexeme ) {\\n\\n\\t\\t\\t// Reverse localized symbols and numbering system.\\n\\t\\t\\tlexeme = lexeme.split( \\"\\" ).map(function( character ) {\\n\\t\\t\\t\\treturn invertedSymbolMap[ character ] ||\\n\\t\\t\\t\\t\\tinvertedNuDigitsMap[ character ] ||\\n\\t\\t\\t\\t\\tcharacter;\\n\\t\\t\\t}).join( \\"\\" );\\n\\n\\t\\t\\tswitch ( type ) {\\n\\t\\t\\t\\tcase \\"infinity\\":\\n\\t\\t\\t\\t\\tnumber = Infinity;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase \\"nan\\":\\n\\t\\t\\t\\t\\tnumber = NaN;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase \\"number\\":\\n\\n\\t\\t\\t\\t\\t// Remove grouping separators.\\n\\t\\t\\t\\t\\tlexeme = lexeme.replace( /,/g, \\"\\" );\\n\\n\\t\\t\\t\\t\\tnumber = +lexeme;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase \\"prefix\\":\\n\\t\\t\\t\\tcase \\"negativePrefix\\":\\n\\t\\t\\t\\t\\tprefix = lexeme;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase \\"suffix\\":\\n\\t\\t\\t\\t\\tsuffix = lexeme;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase \\"negativeSuffix\\":\\n\\t\\t\\t\\t\\tsuffix = lexeme;\\n\\t\\t\\t\\t\\tnegative = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t// This should never be reached.\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tthrow new Error( \\"Internal error\\" );\\n\\t\\t\\t}\\n\\t\\t\\treturn \\"\\";\\n\\t\\t};\\n\\t}\\n\\n\\tfunction tokenizeNParse( _value, grammar ) {\\n\\t\\treturn grammar.some(function( statement ) {\\n\\t\\t\\tvar value = _value;\\n\\n\\t\\t\\t// The whole grammar statement should be used (i.e., .every() return true) and value be\\n\\t\\t\\t// entirely consumed (i.e., !value.length).\\n\\t\\t\\treturn statement.every(function( type ) {\\n\\t\\t\\t\\tif ( value.match( tokenizer[ type ] ) === null ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Consume and parse it.\\n\\t\\t\\t\\tvalue = value.replace( tokenizer[ type ], parse( type ) );\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}) && !value.length;\\n\\t\\t});\\n\\t}\\n\\n\\tvalid = tokenizeNParse( value, grammar );\\n\\n\\t// NaN\\n\\tif ( !valid || isNaN( number ) ) {\\n\\t\\treturn NaN;\\n\\t}\\n\\n\\tprefixNSuffix = \\"\\" + prefix + suffix;\\n\\n\\t// Percent\\n\\tif ( prefixNSuffix.indexOf( \\"%\\" ) !== -1 ) {\\n\\t\\tnumber /= 100;\\n\\n\\t// Per mille\\n\\t} else if ( prefixNSuffix.indexOf( \\"\\\\u2030\\" ) !== -1 ) {\\n\\t\\tnumber /= 1000;\\n\\t}\\n\\n\\t// Negative number\\n\\tif ( negative ) {\\n\\t\\tnumber *= -1;\\n\\t}\\n\\n\\treturn number;\\n};\\n\\n\\n\\n\\nvar numberParserFn = function( properties ) {\\n\\treturn function numberParser( value ) {\\n\\t\\tvalidateParameterPresence( value, \\"value\\" );\\n\\t\\tvalidateParameterTypeString( value, \\"value\\" );\\n\\n\\t\\treturn numberParse( value, properties );\\n\\t};\\n\\n};\\n\\n\\n\\n\\n/**\\n * symbolMap( cldr )\\n *\\n * @cldr [Cldr instance].\\n *\\n * Return the (localized symbol, pattern symbol) key value pair, eg. {\\n *   \\"\\": \\".\\",\\n *   \\"\\": \\",\\",\\n *   \\"\\": \\"%\\",\\n *   ...\\n * };\\n */\\nvar numberSymbolInvertedMap = function( cldr ) {\\n\\tvar symbol,\\n\\t\\tsymbolMap = {};\\n\\n\\tfor ( symbol in numberSymbolName ) {\\n\\t\\tsymbolMap[ numberSymbol( numberSymbolName[ symbol ], cldr ) ] = symbol;\\n\\t}\\n\\n\\treturn symbolMap;\\n};\\n\\n\\n\\n\\n/**\\n * objectMap( object, fn)\\n *\\n * - object\\n *\\n * - fn( pair ) => pair\\n */\\nvar objectMap = function( object, fn ) {\\n\\treturn Object.keys( object ).map(function( key ) {\\n\\t\\treturn fn([ key, object[ key ] ]);\\n\\t}).reduce(function( object, pair ) {\\n\\t\\tobject[ pair[ 0 ] ] = pair[ 1 ];\\n\\t\\treturn object;\\n\\t}, {});\\n};\\n\\n\\n\\n\\n/**\\n * removeLiteralQuotes( string )\\n *\\n * Return:\\n * - `\'` if input string is `\'\'`.\\n * - `o\'clock` if input string is `\'o\'\'clock\'`.\\n * - `foo` if input string is `foo`, i.e., return the same value in case it isn\'t a single-quoted\\n *   string.\\n */\\nvar removeLiteralQuotes = function( string ) {\\n\\tif ( string[ 0 ] + string[ string.length - 1 ] !== \\"\'\'\\" ) {\\n\\t\\treturn string;\\n\\t}\\n\\tif ( string === \\"\'\'\\" ) {\\n\\t\\treturn \\"\'\\";\\n\\t}\\n\\treturn string.replace( /\'\'/g, \\"\'\\" ).slice( 1, -1 );\\n};\\n\\n\\n\\n\\n/**\\n * parseProperties( pattern, cldr )\\n *\\n * @pattern [String] raw pattern for numbers.\\n *\\n * @cldr [Cldr instance].\\n *\\n * Return parser properties, used to feed parser function.\\n *\\n * TODO:\\n * - Scientific_notation;\\n * - Padding;\\n */\\nvar numberParseProperties = function( pattern, cldr, options ) {\\n\\tvar aux, decimalSymbolRe, digitsRe, groupingSeparatorRe, infinitySymbol, invertedNuDigitsMap,\\n\\t\\tinvertedSymbolMap, maximumFractionDigits, maximumSignificantDigits,\\n\\t\\tminimumSignificantDigits, nanSymbol, negativePrefix, negativeSuffix, nuDigitsMap,\\n\\t\\tnumberTokenizer, prefix, primaryGroupingSize, secondaryGroupingSize, suffix, symbolMap,\\n\\t\\tformatProperties = numberFormatProperties( pattern, cldr, options );\\n\\n\\tprefix = looseMatching( formatProperties[ 0 ] );\\n\\tmaximumFractionDigits = formatProperties[ 4 ];\\n\\tminimumSignificantDigits = formatProperties[ 5 ];\\n\\tmaximumSignificantDigits = formatProperties[ 6 ];\\n\\tprimaryGroupingSize = formatProperties[ 8 ];\\n\\tsecondaryGroupingSize = formatProperties[ 9 ];\\n\\tsuffix = looseMatching( formatProperties[ 10 ] );\\n\\tnegativePrefix = looseMatching( formatProperties[ 13 ] );\\n\\tnegativeSuffix = looseMatching( formatProperties[ 14 ] );\\n\\tinfinitySymbol = looseMatching( formatProperties[ 16 ] );\\n\\tnanSymbol = looseMatching( formatProperties[ 17 ] );\\n\\tsymbolMap = objectMap( formatProperties[ 18 ], function( pair ) {\\n\\t\\treturn [ pair[ 0 ], looseMatching( pair[ 1 ] ) ];\\n\\t});\\n\\tnuDigitsMap = formatProperties[ 19 ];\\n\\n\\tinvertedSymbolMap = objectMap( numberSymbolInvertedMap( cldr ), function( pair ) {\\n\\t\\treturn [ looseMatching( pair[ 0 ] ), pair[ 1 ] ];\\n\\t});\\n\\n\\tdigitsRe = nuDigitsMap ? \\"[\\" + nuDigitsMap + \\"]\\" : \\"\\\\\\\\d\\";\\n\\tgroupingSeparatorRe = regexpEscape( symbolMap[ \\",\\" ] );\\n\\tdecimalSymbolRe = regexpEscape( symbolMap[ \\".\\" ] );\\n\\n\\tif ( nuDigitsMap ) {\\n\\t\\tinvertedNuDigitsMap = nuDigitsMap.split( \\"\\" ).reduce(function( object, localizedDigit, i ) {\\n\\t\\t\\tobject[ localizedDigit ] = String( i );\\n\\t\\t\\treturn object;\\n\\t\\t}, {} );\\n\\t}\\n\\n\\taux = [ prefix, suffix, negativePrefix, negativeSuffix ].map(function( value ) {\\n\\t\\treturn value.replace( /(\'([^\']|\'\')+\'|\'\')|./g, function( character, literal ) {\\n\\n\\t\\t\\t// Literals\\n\\t\\t\\tif ( literal ) {\\n\\t\\t\\t\\treturn removeLiteralQuotes( literal );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Symbols\\n\\t\\t\\tcharacter = character.replace( /[\\\\-+E%\\\\u2030]/, function( symbol ) {\\n\\t\\t\\t\\treturn symbolMap[ symbol ];\\n\\t\\t\\t});\\n\\n\\t\\t\\treturn character;\\n\\t\\t});\\n\\t});\\n\\n\\tprefix = aux[ 0 ];\\n\\tsuffix = aux[ 1 ];\\n\\tnegativePrefix = aux[ 2 ];\\n\\tnegativeSuffix = aux[ 3 ];\\n\\n\\t// Number\\n\\t//\\n\\t// number_re =                       integer fraction?\\n\\t//\\n\\t// integer =                         digits | digits_using_grouping_separators\\n\\t//\\n\\t// fraction =                        regexp((.\\\\d+)?)\\n\\t//\\n\\t// digits =                          regexp(\\\\d+)\\n\\t//\\n\\t// digits_w_grouping_separators =    digits_w_1_grouping_separators |\\n\\t//                                   digits_w_2_grouping_separators\\n\\t//\\n\\t// digits_w_1_grouping_separators =  regexp(\\\\d{1,3}(,\\\\d{3})+)\\n\\t//\\n\\t// digits_w_2_grouping_separators =  regexp(\\\\d{1,2}((,\\\\d{2})*(,\\\\d{3})))\\n\\n\\t// Integer part\\n\\tnumberTokenizer = digitsRe + \\"+\\";\\n\\n\\t// Grouping separators\\n\\tif ( primaryGroupingSize ) {\\n\\t\\tif ( secondaryGroupingSize ) {\\n\\t\\t\\taux = digitsRe + \\"{1,\\" + secondaryGroupingSize + \\"}((\\" + groupingSeparatorRe +\\n\\t\\t\\t\\tdigitsRe + \\"{\\" + secondaryGroupingSize + \\"})*(\\" + groupingSeparatorRe +\\n\\t\\t\\t\\tdigitsRe + \\"{\\" + primaryGroupingSize + \\"}))\\";\\n\\t\\t} else {\\n\\t\\t\\taux = digitsRe + \\"{1,\\" + primaryGroupingSize + \\"}(\\" + groupingSeparatorRe +\\n\\t\\t\\t\\tdigitsRe + \\"{\\" + primaryGroupingSize + \\"})+\\";\\n\\t\\t}\\n\\t\\tnumberTokenizer = \\"(\\" + aux + \\"|\\" + numberTokenizer + \\")\\";\\n\\t}\\n\\n\\t// Fraction part? Only included if 1 or 2.\\n\\t// 1: Using significant digit format.\\n\\t// 2: Using integer and fractional format && it has a maximumFractionDigits.\\n\\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) || /* 1 */\\n\\t\\t\\t\\tmaximumFractionDigits /* 2 */ ) {\\n\\n\\t\\t// 1: Handle trailing decimal separator, e.g., `\\"1.\\" => `1``.\\n\\t\\taux = decimalSymbolRe + digitsRe + \\"+\\";\\n\\t\\tnumberTokenizer = numberTokenizer + \\"(\\" + aux + \\"|\\" + decimalSymbolRe /* 1 */ + \\")?\\" +\\n\\n\\t\\t\\t// Handle non-padded decimals, e.g., `\\".12\\"` => `0.12` by making the integer part\\n\\t\\t\\t// optional.\\n\\t\\t\\t\\"|(\\" + numberTokenizer + \\")?\\" + aux;\\n\\n\\t\\tnumberTokenizer = \\"(\\" + numberTokenizer + \\")\\";\\n\\t}\\n\\n\\t// 0: @invertedSymbolMap [Object] Inverted symbol map.\\n\\t// 1: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than\\n\\t//    `latn`.\\n\\t// 2: @tokenizer [Object] Tokenizer map, used by parser to consume input.\\n\\treturn [\\n\\t\\tinvertedSymbolMap,\\n\\t\\tinvertedNuDigitsMap,\\n\\t\\t{\\n\\t\\t\\tinfinity: new RegExp( \\"^\\" + regexpEscape( infinitySymbol ) ),\\n\\t\\t\\tnan:  new RegExp( \\"^\\" + regexpEscape( nanSymbol ) ),\\n\\t\\t\\tnegativePrefix: new RegExp( \\"^\\" + regexpEscape( negativePrefix ) ),\\n\\t\\t\\tnegativeSuffix: new RegExp( \\"^\\" + regexpEscape( negativeSuffix ) ),\\n\\t\\t\\tnumber: new RegExp( \\"^\\" + numberTokenizer ),\\n\\t\\t\\tprefix: new RegExp( \\"^\\" + regexpEscape( prefix ) ),\\n\\t\\t\\tsuffix: new RegExp( \\"^\\" + regexpEscape( suffix ) )\\n\\t\\t}\\n\\t];\\n\\n};\\n\\n\\n\\n\\n/**\\n * Pattern( style )\\n *\\n * @style [String] \\"decimal\\" (default) or \\"percent\\".\\n *\\n * @cldr [Cldr instance].\\n */\\nvar numberPattern = function( style, cldr ) {\\n\\tif ( style !== \\"decimal\\" && style !== \\"percent\\" ) {\\n\\t\\tthrow new Error( \\"Invalid style\\" );\\n\\t}\\n\\n\\treturn cldr.main([\\n\\t\\t\\"numbers\\",\\n\\t\\tstyle + \\"Formats-numberSystem-\\" + numberNumberingSystem( cldr ),\\n\\t\\t\\"standard\\"\\n\\t]);\\n};\\n\\n\\n\\n\\n/**\\n * EBNF representation:\\n *\\n * compact_pattern_re =       prefix?\\n *                            number_pattern_re\\n *                            suffix?\\n *\\n * number_pattern_re =        0+\\n *\\n * Regexp groups:\\n *\\n *  0: compact_pattern_re\\n *  1: prefix\\n *  2: number_pattern_re (the number pattern to use in compact mode)\\n *  3: suffix\\n */\\nvar numberCompactPatternRe = ( /^([^0]*)(0+)([^0]*)$/ );\\n\\n\\n\\n\\n/**\\n * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )\\n *\\n * @number [Number].\\n *\\n * @primaryGroupingSize [Number]\\n *\\n * @secondaryGroupingSize [Number]\\n *\\n * Return the formatted number with group separator.\\n */\\nvar numberFormatGroupingSeparator = function( number, primaryGroupingSize, secondaryGroupingSize ) {\\n\\tvar index,\\n\\t\\tcurrentGroupingSize = primaryGroupingSize,\\n\\t\\tret = \\"\\",\\n\\t\\tsep = \\",\\",\\n\\t\\tswitchToSecondary = secondaryGroupingSize ? true : false;\\n\\n\\tnumber = String( number ).split( \\".\\" );\\n\\tindex = number[ 0 ].length;\\n\\n\\twhile ( index > currentGroupingSize ) {\\n\\t\\tret = number[ 0 ].slice( index - currentGroupingSize, index ) +\\n\\t\\t\\t( ret.length ? sep : \\"\\" ) + ret;\\n\\t\\tindex -= currentGroupingSize;\\n\\t\\tif ( switchToSecondary ) {\\n\\t\\t\\tcurrentGroupingSize = secondaryGroupingSize;\\n\\t\\t\\tswitchToSecondary = false;\\n\\t\\t}\\n\\t}\\n\\n\\tnumber[ 0 ] = number[ 0 ].slice( 0, index ) + ( ret.length ? sep : \\"\\" ) + ret;\\n\\treturn number.join( \\".\\" );\\n};\\n\\n\\n\\n\\n/**\\n * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,\\n * maximumFractionDigits, round, roundIncrement )\\n *\\n * @number [Number]\\n *\\n * @minimumIntegerDigits [Number]\\n *\\n * @minimumFractionDigits [Number]\\n *\\n * @maximumFractionDigits [Number]\\n *\\n * @round [Function]\\n *\\n * @roundIncrement [Function]\\n *\\n * Return the formatted integer and fraction digits.\\n */\\nvar numberFormatIntegerFractionDigits = function( number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round,\\n\\troundIncrement ) {\\n\\n\\t// Fraction\\n\\tif ( maximumFractionDigits ) {\\n\\n\\t\\t// Rounding\\n\\t\\tif ( roundIncrement ) {\\n\\t\\t\\tnumber = round( number, roundIncrement );\\n\\n\\t\\t// Maximum fraction digits\\n\\t\\t} else {\\n\\t\\t\\tnumber = round( number, { exponent: -maximumFractionDigits } );\\n\\t\\t}\\n\\n\\t} else {\\n\\t\\tnumber = round( number );\\n\\t}\\n\\n\\tnumber = String( number );\\n\\n\\t// Maximum integer digits (post string phase)\\n\\tif ( maximumFractionDigits && /e-/.test( number ) ) {\\n\\n\\t\\t// Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are\\n\\t\\t// displayed using plain digits instead of scientific notation.\\n\\t\\t// 1: Remove leading decimal zeros.\\n\\t\\t// 2: Remove leading decimal separator.\\n\\t\\t// Note: String() is still preferred so it doesn\'t mess up with a number precision\\n\\t\\t// unnecessarily, e.g., (123456789.123).toFixed(10) === \\"123456789.1229999959\\",\\n\\t\\t// String(123456789.123) === \\"123456789.123\\".\\n\\t\\tnumber = ( +number ).toFixed( maximumFractionDigits )\\n\\t\\t\\t.replace( /0+$/, \\"\\" ) /* 1 */\\n\\t\\t\\t.replace( /\\\\.$/, \\"\\" ) /* 2 */;\\n\\t}\\n\\n\\t// Minimum fraction digits (post string phase)\\n\\tif ( minimumFractionDigits ) {\\n\\t\\tnumber = number.split( \\".\\" );\\n\\t\\tnumber[ 1 ] = stringPad( number[ 1 ] || \\"\\", minimumFractionDigits, true );\\n\\t\\tnumber = number.join( \\".\\" );\\n\\t}\\n\\n\\t// Minimum integer digits\\n\\tif ( minimumIntegerDigits ) {\\n\\t\\tnumber = number.split( \\".\\" );\\n\\t\\tnumber[ 0 ] = stringPad( number[ 0 ], minimumIntegerDigits );\\n\\t\\tnumber = number.join( \\".\\" );\\n\\t}\\n\\n\\treturn number;\\n};\\n\\n\\n\\n\\n/**\\n * toPrecision( number, precision, round )\\n *\\n * @number (Number)\\n *\\n * @precision (Number) significant figures precision (not decimal precision).\\n *\\n * @round (Function)\\n *\\n * Return number.toPrecision( precision ) using the given round function.\\n */\\nvar numberToPrecision = function( number, precision, round ) {\\n\\tvar roundOrder;\\n\\n\\tif ( number === 0 ) {  // Fix #706\\n\\t\\treturn number;\\n\\t}\\n\\n\\troundOrder = Math.ceil( Math.log( Math.abs( number ) ) / Math.log( 10 ) );\\n\\troundOrder -= precision;\\n\\n\\treturn round( number, { exponent: roundOrder } );\\n};\\n\\n\\n\\n\\n/**\\n * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )\\n *\\n * @number [Number]\\n *\\n * @minimumSignificantDigits [Number]\\n *\\n * @maximumSignificantDigits [Number]\\n *\\n * @round [Function]\\n *\\n * Return the formatted significant digits number.\\n */\\nvar numberFormatSignificantDigits = function( number, minimumSignificantDigits, maximumSignificantDigits, round ) {\\n\\tvar atMinimum, atMaximum;\\n\\n\\t// Sanity check.\\n\\tif ( minimumSignificantDigits > maximumSignificantDigits ) {\\n\\t\\tmaximumSignificantDigits = minimumSignificantDigits;\\n\\t}\\n\\n\\tatMinimum = numberToPrecision( number, minimumSignificantDigits, round );\\n\\tatMaximum = numberToPrecision( number, maximumSignificantDigits, round );\\n\\n\\t// Use atMaximum only if it has more significant digits than atMinimum.\\n\\tnumber = +atMinimum === +atMaximum ? atMinimum : atMaximum;\\n\\n\\t// Expand integer numbers, eg. 123e5 to 12300.\\n\\tnumber = ( +number ).toString( 10 );\\n\\n\\tif ( ( /e/ ).test( number ) ) {\\n\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\tfeature: \\"integers out of (1e21, 1e-7)\\"\\n\\t\\t});\\n\\t}\\n\\n\\t// Add trailing zeros if necessary.\\n\\tif ( minimumSignificantDigits - number.replace( /^0+|\\\\./g, \\"\\" ).length > 0 ) {\\n\\t\\tnumber = number.split( \\".\\" );\\n\\t\\tnumber[ 1 ] = stringPad( number[ 1 ] || \\"\\", minimumSignificantDigits - number[ 0 ].replace( /^0+/, \\"\\" ).length, true );\\n\\t\\tnumber = number.join( \\".\\" );\\n\\t}\\n\\n\\treturn number;\\n};\\n\\n\\n\\n\\n/**\\n * format( number, properties )\\n *\\n * @number [Number].\\n *\\n * @properties [Object] Output of number/format-properties.\\n *\\n * Return the formatted number.\\n * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html\\n */\\nvar numberFormat = function( number, properties, pluralGenerator ) {\\n\\tvar aux, compactMap, infinitySymbol, maximumFractionDigits, maximumSignificantDigits,\\n\\t\\tminimumFractionDigits, minimumIntegerDigits, minimumSignificantDigits, nanSymbol,\\n\\t\\tnuDigitsMap, padding, prefix, primaryGroupingSize, pattern, round, roundIncrement,\\n\\t\\tsecondaryGroupingSize, stringToParts, suffix, symbolMap;\\n\\n\\tpadding = properties[ 1 ];\\n\\tminimumIntegerDigits = properties[ 2 ];\\n\\tminimumFractionDigits = properties[ 3 ];\\n\\tmaximumFractionDigits = properties[ 4 ];\\n\\tminimumSignificantDigits = properties[ 5 ];\\n\\tmaximumSignificantDigits = properties[ 6 ];\\n\\troundIncrement = properties[ 7 ];\\n\\tprimaryGroupingSize = properties[ 8 ];\\n\\tsecondaryGroupingSize = properties[ 9 ];\\n\\tround = properties[ 15 ];\\n\\tinfinitySymbol = properties[ 16 ];\\n\\tnanSymbol = properties[ 17 ];\\n\\tsymbolMap = properties[ 18 ];\\n\\tnuDigitsMap = properties[ 19 ];\\n\\tcompactMap = properties[ 20 ];\\n\\n\\t// NaN\\n\\tif ( isNaN( number ) ) {\\n\\t\\treturn [ { type: \\"nan\\", value: nanSymbol } ];\\n\\t}\\n\\n\\tif ( number < 0 ) {\\n\\t\\tpattern = properties[ 12 ];\\n\\t\\tprefix = properties[ 13 ];\\n\\t\\tsuffix = properties[ 14 ];\\n\\t} else {\\n\\t\\tpattern = properties[ 11 ];\\n\\t\\tprefix = properties[ 0 ];\\n\\t\\tsuffix = properties[ 10 ];\\n\\t}\\n\\n\\t// For prefix, suffix, and number parts.\\n\\tstringToParts = function( string ) {\\n\\t\\tvar numberType = \\"integer\\",\\n\\t\\t\\tparts = [];\\n\\n\\t\\t// TODO Move the tokenization of all parts that don\'t depend on number into\\n\\t\\t// format-properties.\\n\\t\\tstring.replace( /(\'([^\']|\'\')+\'|\'\')|./g, function( character, literal ) {\\n\\n\\t\\t\\t// Literals\\n\\t\\t\\tif ( literal ) {\\n\\t\\t\\t\\tpartsPush( parts, \\"literal\\", removeLiteralQuotes( literal ) );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Currency symbol\\n\\t\\t\\tif ( character === \\"\\\\u00A4\\" ) {\\n\\t\\t\\t\\tpartsPush( parts, \\"currency\\", character );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Symbols\\n\\t\\t\\tcharacter = character.replace( /[.,\\\\-+E%\\\\u2030]/, function( symbol ) {\\n\\t\\t\\t\\tif ( symbol === \\".\\" ) {\\n\\t\\t\\t\\t\\tnumberType = \\"fraction\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpartsPush( parts, numberSymbolName[symbol], symbolMap[ symbol ] );\\n\\n\\t\\t\\t\\t// \\"Erase\\" handled character.\\n\\t\\t\\t\\treturn \\"\\";\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Number\\n\\t\\t\\tcharacter = character.replace( /[0-9]/, function( digit ) {\\n\\n\\t\\t\\t\\t// Numbering system\\n\\t\\t\\t\\tif ( nuDigitsMap ) {\\n\\t\\t\\t\\t\\tdigit = nuDigitsMap[ +digit ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpartsPush( parts, numberType, digit );\\n\\n\\t\\t\\t\\t// \\"Erase\\" handled character.\\n\\t\\t\\t\\treturn \\"\\";\\n\\t\\t\\t});\\n\\n\\t\\t\\t// Etc\\n\\t\\t\\tcharacter.replace( /./, function( etc ) {\\n\\t\\t\\t\\tpartsPush( parts, \\"literal\\", etc );\\n\\t\\t\\t});\\n\\t\\t});\\n\\t\\treturn parts;\\n\\t};\\n\\n\\tprefix = stringToParts( prefix );\\n\\tsuffix = stringToParts( suffix );\\n\\n\\t// Infinity\\n\\tif ( !isFinite( number ) ) {\\n\\t\\treturn prefix.concat(\\n\\t\\t\\t{ type: \\"infinity\\", value: infinitySymbol },\\n\\t\\t\\tsuffix\\n\\t\\t);\\n\\t}\\n\\n\\t// Percent\\n\\tif ( pattern.indexOf( \\"%\\" ) !== -1 ) {\\n\\t\\tnumber *= 100;\\n\\n\\t// Per mille\\n\\t} else if ( pattern.indexOf( \\"\\\\u2030\\" ) !== -1 ) {\\n\\t\\tnumber *= 1000;\\n\\t}\\n\\n\\tvar compactPattern, compactDigits, compactProperties, divisor, numberExponent, pluralForm;\\n\\n\\t// Compact mode: initial number digit processing\\n\\tif ( compactMap ) {\\n\\t\\tnumberExponent = Math.abs( Math.floor( number ) ).toString().length - 1;\\n\\t\\tnumberExponent = Math.min( numberExponent, compactMap.maxExponent );\\n\\n\\t\\t// Use default plural form to perform initial decimal shift\\n\\t\\tif ( numberExponent >= 3 ) {\\n\\t\\t\\tcompactPattern = compactMap[ numberExponent ] && compactMap[ numberExponent ].other;\\n\\t\\t}\\n\\n\\t\\tif ( compactPattern === \\"0\\" ) {\\n\\t\\t\\tcompactPattern = null;\\n\\t\\t} else if ( compactPattern ) {\\n\\t\\t\\tcompactDigits = compactPattern.split( \\"0\\" ).length - 1;\\n\\t\\t\\tdivisor = numberExponent - ( compactDigits - 1 );\\n\\t\\t\\tnumber = number / Math.pow( 10, divisor );\\n\\t\\t}\\n\\t}\\n\\n\\t// Significant digit format\\n\\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {\\n\\t\\tnumber = numberFormatSignificantDigits( number, minimumSignificantDigits,\\n\\t\\t\\tmaximumSignificantDigits, round );\\n\\n\\t// Integer and fractional format\\n\\t} else {\\n\\t\\tnumber = numberFormatIntegerFractionDigits( number, minimumIntegerDigits,\\n\\t\\t\\tminimumFractionDigits, maximumFractionDigits, round, roundIncrement );\\n\\t}\\n\\n\\t// Compact mode: apply formatting\\n\\tif ( compactMap && compactPattern ) {\\n\\n\\t\\t// Get plural form after possible roundings\\n\\t\\tpluralForm = pluralGenerator ? pluralGenerator( +number ) : \\"other\\";\\n\\n\\t\\tcompactPattern = compactMap[ numberExponent ][ pluralForm ] || compactPattern;\\n\\t\\tcompactProperties = compactPattern.match( numberCompactPatternRe );\\n\\n\\t\\t// TODO Move the tokenization of all parts that don\'t depend on number into\\n\\t\\t// format-properties.\\n\\t\\taux = function( string ) {\\n\\t\\t\\tvar parts = [];\\n\\t\\t\\tstring.replace( /(\\\\s+)|([^\\\\s0]+)/g, function( garbage, space, compact ) {\\n\\n\\t\\t\\t\\t// Literals\\n\\t\\t\\t\\tif ( space ) {\\n\\t\\t\\t\\t\\tpartsPush( parts, \\"literal\\", space );\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Compact value\\n\\t\\t\\t\\tif ( compact ) {\\n\\t\\t\\t\\t\\tpartsPush( parts, \\"compact\\", compact );\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn parts;\\n\\t\\t};\\n\\n\\t\\t// update prefix/suffix with compact prefix/suffix\\n\\t\\tprefix = prefix.concat( aux( compactProperties[ 1 ] ) );\\n\\t\\tsuffix = aux( compactProperties[ 3 ] ).concat( suffix );\\n\\t}\\n\\n\\t// Remove the possible number minus sign\\n\\tnumber = number.replace( /^-/, \\"\\" );\\n\\n\\t// Grouping separators\\n\\tif ( primaryGroupingSize ) {\\n\\t\\tnumber = numberFormatGroupingSeparator( number, primaryGroupingSize,\\n\\t\\t\\tsecondaryGroupingSize );\\n\\t}\\n\\n\\t// Scientific notation\\n\\t// TODO implement here\\n\\n\\t// Padding/\'([^\']|\'\')+\'|\'\'|[.,\\\\-+E%\\\\u2030]/g\\n\\t// TODO implement here\\n\\n\\treturn prefix.concat(\\n\\t\\tstringToParts( number ),\\n\\t\\tsuffix\\n\\t);\\n};\\n\\n\\n\\n\\nvar numberToPartsFormatterFn = function( properties, pluralGenerator ) {\\n\\treturn function numberToPartsFormatter( value ) {\\n\\t\\tvalidateParameterPresence( value, \\"value\\" );\\n\\t\\tvalidateParameterTypeNumber( value, \\"value\\" );\\n\\n\\t\\treturn numberFormat( value, properties, pluralGenerator );\\n\\t};\\n};\\n\\n\\n\\n\\nfunction validateDigits( properties ) {\\n\\tvar minimumIntegerDigits = properties[ 2 ],\\n\\t\\tminimumFractionDigits = properties[ 3 ],\\n\\t\\tmaximumFractionDigits = properties[ 4 ],\\n\\t\\tminimumSignificantDigits = properties[ 5 ],\\n\\t\\tmaximumSignificantDigits = properties[ 6 ];\\n\\n\\t// Validate significant digit format properties\\n\\tif ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {\\n\\t\\tvalidateParameterRange( minimumSignificantDigits, \\"minimumSignificantDigits\\", 1, 21 );\\n\\t\\tvalidateParameterRange( maximumSignificantDigits, \\"maximumSignificantDigits\\",\\n\\t\\t\\tminimumSignificantDigits, 21 );\\n\\n\\t} else if ( !isNaN( minimumSignificantDigits ) || !isNaN( maximumSignificantDigits ) ) {\\n\\t\\tthrow new Error( \\"Neither or both the minimum and maximum significant digits must be \\" +\\n\\t\\t\\t\\"present\\" );\\n\\n\\t// Validate integer and fractional format\\n\\t} else {\\n\\t\\tvalidateParameterRange( minimumIntegerDigits, \\"minimumIntegerDigits\\", 1, 21 );\\n\\t\\tvalidateParameterRange( minimumFractionDigits, \\"minimumFractionDigits\\", 0, 20 );\\n\\t\\tvalidateParameterRange( maximumFractionDigits, \\"maximumFractionDigits\\",\\n\\t\\t\\tminimumFractionDigits, 20 );\\n\\t}\\n}\\n\\n/**\\n * .numberFormatter( [options] )\\n *\\n * @options [Object]:\\n * - style: [String] \\"decimal\\" (default) or \\"percent\\".\\n * - see also number/format options.\\n *\\n * Return a function that formats a number according to the given options and default/instance\\n * locale.\\n */\\nGlobalize.numberFormatter =\\nGlobalize.prototype.numberFormatter = function( options ) {\\n\\tvar args, numberToPartsFormatter, returnFn;\\n\\n\\tvalidateParameterTypePlainObject( options, \\"options\\" );\\n\\n\\toptions = options || {};\\n\\targs = [ options ];\\n\\n\\tnumberToPartsFormatter = this.numberToPartsFormatter( options );\\n\\treturnFn = numberFormatterFn( numberToPartsFormatter );\\n\\truntimeBind( args, this.cldr, returnFn, [ numberToPartsFormatter ] );\\n\\n\\treturn returnFn;\\n};\\n\\n/**\\n * .numberToPartsFormatter( [options] )\\n *\\n * @options [Object]:\\n * - style: [String] \\"symbol\\" (default), \\"accounting\\", \\"code\\" or \\"name\\".\\n * - see also number/format options.\\n *\\n * Return a function that formats a number to parts according to the given options and\\n * default/instance locale.\\n */\\nGlobalize.numberToPartsFormatter =\\nGlobalize.prototype.numberToPartsFormatter = function( options ) {\\n\\tvar args, cldr, fnArgs, pattern, properties, returnFn;\\n\\n\\tvalidateParameterTypePlainObject( options, \\"options\\" );\\n\\n\\toptions = options || {};\\n\\tcldr = this.cldr;\\n\\n\\targs = [ options ];\\n\\n\\tvalidateDefaultLocale( cldr );\\n\\n\\tcldr.on( \\"get\\", validateCldr );\\n\\ttry {\\n\\t\\tif ( options.raw ) {\\n\\t\\t\\tpattern = options.raw;\\n\\t\\t} else {\\n\\t\\t\\tpattern = numberPattern( options.style || \\"decimal\\", cldr );\\n\\t\\t}\\n\\n\\t\\tproperties = numberFormatProperties( pattern, cldr, options );\\n\\t\\tfnArgs = [ properties ];\\n\\t} finally {\\n\\t\\tcldr.off( \\"get\\", validateCldr );\\n\\t}\\n\\n\\tvalidateDigits( properties );\\n\\n\\tif ( options.compact ) {\\n\\t\\tfnArgs.push( this.pluralGenerator() );\\n\\t}\\n\\treturnFn = numberToPartsFormatterFn.apply( null, fnArgs );\\n\\truntimeBind( args, cldr, returnFn, fnArgs );\\n\\n\\treturn returnFn;\\n};\\n\\n/**\\n * .numberParser( [options] )\\n *\\n * @options [Object]:\\n * - style: [String] \\"decimal\\" (default) or \\"percent\\".\\n *\\n * Return the number parser according to the default/instance locale.\\n */\\nGlobalize.numberParser =\\nGlobalize.prototype.numberParser = function( options ) {\\n\\tvar args, cldr, pattern, properties, returnFn;\\n\\n\\tvalidateParameterTypePlainObject( options, \\"options\\" );\\n\\n\\toptions = options || {};\\n\\tcldr = this.cldr;\\n\\n\\targs = [ options ];\\n\\n\\tvalidateDefaultLocale( cldr );\\n\\tif ( options.compact ) {\\n\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\tfeature: \\"compact number parsing (not implemented)\\"\\n\\t\\t});\\n\\t}\\n\\n\\tcldr.on( \\"get\\", validateCldr );\\n\\n\\tif ( options.raw ) {\\n\\t\\tpattern = options.raw;\\n\\t} else {\\n\\t\\tpattern = numberPattern( options.style || \\"decimal\\", cldr );\\n\\t}\\n\\n\\tproperties = numberParseProperties( pattern, cldr, options );\\n\\n\\tcldr.off( \\"get\\", validateCldr );\\n\\n\\treturnFn = numberParserFn( properties );\\n\\n\\truntimeBind( args, cldr, returnFn, [ properties ] );\\n\\n\\treturn returnFn;\\n};\\n\\n/**\\n * .formatNumber( value [, options] )\\n *\\n * @value [Number] number to be formatted.\\n *\\n * @options [Object]: see number/format-properties.\\n *\\n * Format a number according to the given options and default/instance locale.\\n */\\nGlobalize.formatNumber =\\nGlobalize.prototype.formatNumber = function( value, options ) {\\n\\tvalidateParameterPresence( value, \\"value\\" );\\n\\tvalidateParameterTypeNumber( value, \\"value\\" );\\n\\n\\treturn this.numberFormatter( options )( value );\\n};\\n\\n/**\\n * .formatNumberToParts( value [, options] )\\n *\\n * @value [Number] number to be formatted.\\n *\\n * @options [Object]: see number/format-properties.\\n *\\n * Format a number to pars according to the given options and default/instance locale.\\n */\\nGlobalize.formatNumberToParts =\\nGlobalize.prototype.formatNumberToParts = function( value, options ) {\\n\\tvalidateParameterPresence( value, \\"value\\" );\\n\\tvalidateParameterTypeNumber( value, \\"value\\" );\\n\\n\\treturn this.numberToPartsFormatter( options )( value );\\n};\\n\\n/**\\n * .parseNumber( value [, options] )\\n *\\n * @value [String]\\n *\\n * @options [Object]: See numberParser().\\n *\\n * Return the parsed Number (including Infinity) or NaN when value is invalid.\\n */\\nGlobalize.parseNumber =\\nGlobalize.prototype.parseNumber = function( value, options ) {\\n\\tvalidateParameterPresence( value, \\"value\\" );\\n\\tvalidateParameterTypeString( value, \\"value\\" );\\n\\n\\treturn this.numberParser( options )( value );\\n};\\n\\n/**\\n * Optimization to avoid duplicating some internal functions across modules.\\n */\\nGlobalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;\\nGlobalize._numberNumberingSystem = numberNumberingSystem;\\nGlobalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;\\nGlobalize._numberPattern = numberPattern;\\nGlobalize._numberSymbol = numberSymbol;\\nGlobalize._looseMatching = looseMatching;\\nGlobalize._removeLiteralQuotes = removeLiteralQuotes;\\nGlobalize._stringPad = stringPad;\\nGlobalize._validateParameterTypeNumber = validateParameterTypeNumber;\\nGlobalize._validateParameterTypeString = validateParameterTypeString;\\n\\nreturn Globalize;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL251bWJlci5qcz83YTc0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKipcXG4gKiBHbG9iYWxpemUgdjEuNS4wXFxuICpcXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXFxuICpcXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIERhdGU6IDIwMjAtMDMtMjVUMTI6MTlaXFxuICovXFxuLyohXFxuICogR2xvYmFsaXplIHYxLjUuMCAyMDIwLTAzLTI1VDEyOjE5WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xcbiAqL1xcbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcXG5cXG5cXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xcblxcdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBkZWZpbmUuYW1kICkge1xcblxcblxcdFxcdC8vIEFNRFxcblxcdFxcdGRlZmluZShbXFxuXFx0XFx0XFx0XFxcImNsZHJcXFwiLFxcblxcdFxcdFxcdFxcXCIuLi9nbG9iYWxpemVcXFwiLFxcblxcdFxcdFxcdFxcXCJjbGRyL2V2ZW50XFxcIixcXG5cXHRcXHRcXHRcXFwiY2xkci9zdXBwbGVtZW50YWxcXFwiXFxuXFx0XFx0XSwgZmFjdG9yeSApO1xcblxcdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHQvLyBOb2RlLCBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXFxcImNsZHJqc1xcXCIgKSwgcmVxdWlyZSggXFxcIi4uL2dsb2JhbGl6ZVxcXCIgKSApO1xcblxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0Ly8gR2xvYmFsXFxuXFx0XFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xcblxcdH1cXG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XFxuXFxudmFyIGNyZWF0ZUVycm9yID0gR2xvYmFsaXplLl9jcmVhdGVFcnJvcixcXG5cXHRwYXJ0c0pvaW4gPSBHbG9iYWxpemUuX3BhcnRzSm9pbixcXG5cXHRwYXJ0c1B1c2ggPSBHbG9iYWxpemUuX3BhcnRzUHVzaCxcXG5cXHRyZWdleHBFc2NhcGUgPSBHbG9iYWxpemUuX3JlZ2V4cEVzY2FwZSxcXG5cXHRydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXFxuXFx0c3RyaW5nUGFkID0gR2xvYmFsaXplLl9zdHJpbmdQYWQsXFxuXFx0dmFsaWRhdGVDbGRyID0gR2xvYmFsaXplLl92YWxpZGF0ZUNsZHIsXFxuXFx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gR2xvYmFsaXplLl92YWxpZGF0ZURlZmF1bHRMb2NhbGUsXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSxcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclJhbmdlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclJhbmdlLFxcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlLFxcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdDtcXG5cXG5cXG52YXIgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUgPSBmdW5jdGlvbiggZmVhdHVyZSApIHtcXG5cXHRyZXR1cm4gY3JlYXRlRXJyb3IoIFxcXCJFX1VOU1VQUE9SVEVEXFxcIiwgXFxcIlVuc3VwcG9ydGVkIHtmZWF0dXJlfS5cXFwiLCB7XFxuXFx0XFx0ZmVhdHVyZTogZmVhdHVyZVxcblxcdH0pO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXFxuXFx0XFx0dmFsdWUsXFxuXFx0XFx0bmFtZSxcXG5cXHRcXHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXFxcIm51bWJlclxcXCIsXFxuXFx0XFx0XFxcIk51bWJlclxcXCJcXG5cXHQpO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXFxuXFx0XFx0dmFsdWUsXFxuXFx0XFx0bmFtZSxcXG5cXHRcXHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIsXFxuXFx0XFx0XFxcImEgc3RyaW5nXFxcIlxcblxcdCk7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgbnVtYmVyRm9ybWF0dGVyRm4gPSBmdW5jdGlvbiggbnVtYmVyVG9QYXJ0c0Zvcm1hdHRlciApIHtcXG5cXHRyZXR1cm4gZnVuY3Rpb24gbnVtYmVyRm9ybWF0dGVyKCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gcGFydHNKb2luKCBudW1iZXJUb1BhcnRzRm9ybWF0dGVyKCB2YWx1ZSApKTtcXG5cXHR9O1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogTnVtYmVyaW5nU3lzdGVtKCBjbGRyIClcXG4gKlxcbiAqIC0gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1udW1iZXJzLmh0bWwjb3RoZXJOdW1iZXJpbmdTeXN0ZW1zXFxuICogLSBodHRwOi8vY2xkci51bmljb2RlLm9yZy9pbmRleC9iY3A0Ny1leHRlbnNpb25cXG4gKiAtIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyN1X0V4dGVuc2lvblxcbiAqL1xcbnZhciBudW1iZXJOdW1iZXJpbmdTeXN0ZW0gPSBmdW5jdGlvbiggY2xkciApIHtcXG5cXHR2YXIgbnUgPSBjbGRyLmF0dHJpYnV0ZXNbIFxcXCJ1LW51XFxcIiBdO1xcblxcblxcdGlmICggbnUgKSB7XFxuXFx0XFx0aWYgKCBudSA9PT0gXFxcInRyYWRpdGlvXFxcIiApIHtcXG5cXHRcXHRcXHRudSA9IFxcXCJ0cmFkaXRpb25hbFxcXCI7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggWyBcXFwibmF0aXZlXFxcIiwgXFxcInRyYWRpdGlvbmFsXFxcIiwgXFxcImZpbmFuY2VcXFwiIF0uaW5kZXhPZiggbnUgKSAhPT0gLTEgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gVW5pY29kZSBsb2NhbGUgZXh0ZW5zaW9uIGB1LW51YCBpcyBzZXQgdXNpbmcgZWl0aGVyIChuYXRpdmUsIHRyYWRpdGlvbmFsIG9yXFxuXFx0XFx0XFx0Ly8gZmluYW5jZSkuIFNvLCBsb29rdXAgdGhlIHJlc3BlY3RpdmUgbG9jYWxlJ3MgbnVtYmVyaW5nU3lzdGVtIGFuZCByZXR1cm4gaXQuXFxuXFx0XFx0XFx0cmV0dXJuIGNsZHIubWFpbihbIFxcXCJudW1iZXJzL290aGVyTnVtYmVyaW5nU3lzdGVtc1xcXCIsIG51IF0pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBVbmljb2RlIGxvY2FsZSBleHRlbnNpb24gYHUtbnVgIGlzIHNldCB3aXRoIGFuIGV4cGxpY2l0IG51bWJlcmluZ1N5c3RlbS4gUmV0dXJuIGl0LlxcblxcdFxcdHJldHVybiBudTtcXG5cXHR9XFxuXFxuXFx0Ly8gUmV0dXJuIHRoZSBkZWZhdWx0IG51bWJlcmluZ1N5c3RlbS5cXG5cXHRyZXR1cm4gY2xkci5tYWluKCBcXFwibnVtYmVycy9kZWZhdWx0TnVtYmVyaW5nU3lzdGVtXFxcIiApO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogQ29tcGFjdCggbmFtZSwgY2xkciApXFxuICpcXG4gKiBAY29tcGFjdFR5cGUgW1N0cmluZ10gQ29tcGFjdCBtb2RlLCBgc2hvcnRgIG9yIGBsb25nYC5cXG4gKlxcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cXG4gKlxcbiAqIFJldHVybiB0aGUgbG9jYWxpemVkIGNvbXBhY3QgbWFwIGZvciB0aGUgZ2l2ZW4gY29tcGFjdCBtb2RlLlxcbiAqL1xcbnZhciBudW1iZXJDb21wYWN0ID0gZnVuY3Rpb24oIGNvbXBhY3RUeXBlLCBjbGRyICkge1xcblxcdHZhciBtYXhFeHBvbmVudCA9IDA7XFxuXFxuXFx0dmFyIG9iamVjdCA9IGNsZHIubWFpbihbXFxuXFx0XFx0XFxcIm51bWJlcnMvZGVjaW1hbEZvcm1hdHMtbnVtYmVyU3lzdGVtLVxcXCIgKyBudW1iZXJOdW1iZXJpbmdTeXN0ZW0oIGNsZHIgKSxcXG5cXHRcXHRjb21wYWN0VHlwZSxcXG5cXHRcXHRcXFwiZGVjaW1hbEZvcm1hdFxcXCJcXG5cXHRdKTtcXG5cXG5cXHRvYmplY3QgPSBPYmplY3Qua2V5cyggb2JqZWN0ICkucmVkdWNlKGZ1bmN0aW9uKCBuZXdPYmplY3QsIGNvbXBhY3RLZXkgKSB7XFxuXFx0XFx0dmFyIG51bWJlckV4cG9uZW50ID0gY29tcGFjdEtleS5zcGxpdCggXFxcIjBcXFwiICkubGVuZ3RoIC0gMTtcXG5cXHRcXHR2YXIgcGx1cmFsRm9ybSA9IGNvbXBhY3RLZXkuc3BsaXQoIFxcXCItXFxcIiApWyAyIF07XFxuXFx0XFx0bmV3T2JqZWN0WyBudW1iZXJFeHBvbmVudCBdID0gbmV3T2JqZWN0WyBudW1iZXJFeHBvbmVudCBdIHx8IHt9O1xcblxcdFxcdG5ld09iamVjdFsgbnVtYmVyRXhwb25lbnQgXVsgcGx1cmFsRm9ybSBdID0gb2JqZWN0WyBjb21wYWN0S2V5IF07XFxuXFx0XFx0bWF4RXhwb25lbnQgPSBNYXRoLm1heCggbnVtYmVyRXhwb25lbnQsIG1heEV4cG9uZW50ICk7XFxuXFx0XFx0cmV0dXJuIG5ld09iamVjdDtcXG5cXHR9LCB7fSk7XFxuXFxuXFx0b2JqZWN0Lm1heEV4cG9uZW50ID0gbWF4RXhwb25lbnQ7XFxuXFxuXFx0cmV0dXJuIG9iamVjdDtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIG51TWFwKCBjbGRyIClcXG4gKlxcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cXG4gKlxcbiAqIFJldHVybiBkaWdpdHMgbWFwIGlmIG51bWJlcmluZyBzeXN0ZW0gaXMgZGlmZmVyZW50IHRoYW4gYGxhdG5gLlxcbiAqL1xcbnZhciBudW1iZXJOdW1iZXJpbmdTeXN0ZW1EaWdpdHNNYXAgPSBmdW5jdGlvbiggY2xkciApIHtcXG5cXHR2YXIgYXV4LFxcblxcdFxcdG51ID0gbnVtYmVyTnVtYmVyaW5nU3lzdGVtKCBjbGRyICk7XFxuXFxuXFx0aWYgKCBudSA9PT0gXFxcImxhdG5cXFwiICkge1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuXFx0YXV4ID0gY2xkci5zdXBwbGVtZW50YWwoWyBcXFwibnVtYmVyaW5nU3lzdGVtc1xcXCIsIG51IF0pO1xcblxcblxcdGlmICggYXV4Ll90eXBlICE9PSBcXFwibnVtZXJpY1xcXCIgKSB7XFxuXFx0XFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoIFxcXCJgXFxcIiArIGF1eC5fdHlwZSArIFxcXCJgIG51bWJlcmluZyBzeXN0ZW1cXFwiICk7XFxuXFx0fVxcblxcblxcdHJldHVybiBhdXguX2RpZ2l0cztcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIEVCTkYgcmVwcmVzZW50YXRpb246XFxuICpcXG4gKiBudW1iZXJfcGF0dGVybl9yZSA9ICAgICAgICBwcmVmaXg/XFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZz9cXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW50ZWdlcl9mcmFjdGlvbl9wYXR0ZXJuIHwgc2lnbmlmaWNhbnRfcGF0dGVybilcXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2llbnRpZmljX25vdGF0aW9uP1xcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeD9cXG4gKlxcbiAqIHByZWZpeCA9ICAgICAgICAgICAgICAgICAgIG5vbl9udW1iZXJfc3R1ZmZcXG4gKlxcbiAqIHBhZGRpbmcgPSAgICAgICAgICAgICAgICAgIFxcXCIqXFxcIiByZWdleHAoLilcXG4gKlxcbiAqIGludGVnZXJfZnJhY3Rpb25fcGF0dGVybiA9IGludGVnZXJfcGF0dGVyblxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uX3BhdHRlcm4/XFxuICpcXG4gKiBpbnRlZ2VyX3BhdHRlcm4gPSAgICAgICAgICByZWdleHAoWyMsXSpbMCxdKjArKVxcbiAqXFxuICogZnJhY3Rpb25fcGF0dGVybiA9ICAgICAgICAgXFxcIi5cXFwiIHJlZ2V4cCgwKlswLTldKiMqKVxcbiAqXFxuICogc2lnbmlmaWNhbnRfcGF0dGVybiA9ICAgICAgcmVnZXhwKFsjLF0qQCsjKilcXG4gKlxcbiAqIHNjaWVudGlmaWNfbm90YXRpb24gPSAgICAgIHJlZ2V4cChFXFxcXCs/MCspXFxuICpcXG4gKiBzdWZmaXggPSAgICAgICAgICAgICAgICAgICBub25fbnVtYmVyX3N0dWZmXFxuICpcXG4gKiBub25fbnVtYmVyX3N0dWZmID0gICAgICAgICByZWdleHAoKCdbXiddKyd8Jyd8W14qI0AwLC5FXSkqKVxcbiAqXFxuICpcXG4gKiBSZWdleHAgZ3JvdXBzOlxcbiAqXFxuICogIDA6IG51bWJlcl9wYXR0ZXJuX3JlXFxuICogIDE6IHByZWZpeFxcbiAqICAyOiAtXFxuICogIDM6IC1cXG4gKiAgNDogcGFkZGluZ1xcbiAqICA1OiAoaW50ZWdlcl9mcmFjdGlvbl9wYXR0ZXJuIHwgc2lnbmlmaWNhbnRfcGF0dGVybilcXG4gKiAgNjogaW50ZWdlcl9mcmFjdGlvbl9wYXR0ZXJuXFxuICogIDc6IGludGVnZXJfcGF0dGVyblxcbiAqICA4OiBmcmFjdGlvbl9wYXR0ZXJuXFxuICogIDk6IHNpZ25pZmljYW50X3BhdHRlcm5cXG4gKiAxMDogc2NpZW50aWZpY19ub3RhdGlvblxcbiAqIDExOiBzdWZmaXhcXG4gKiAxMjogLVxcbiAqL1xcbnZhciBudW1iZXJQYXR0ZXJuUmUgPSAoIC9eKCgnKFteJ118JycpKid8W14qI0AwLC5FXSkqKShcXFxcKi4pPygoKFsjLF0qWzAsXSowKykoXFxcXC4wKlswLTldKiMqKT8pfChbIyxdKkArIyopKShFXFxcXCs/MCspPygoJ1teJ10rJ3wnJ3xbXiojQDAsLkVdKSopJC8gKTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBmb3JtYXQoIG51bWJlciwgcGF0dGVybiApXFxuICpcXG4gKiBAbnVtYmVyIFtOdW1iZXJdLlxcbiAqXFxuICogQHBhdHRlcm4gW1N0cmluZ10gcmF3IHBhdHRlcm4gZm9yIG51bWJlcnMuXFxuICpcXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBudW1iZXIuXFxuICogcmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LW51bWJlcnMuaHRtbFxcbiAqL1xcbnZhciBudW1iZXJQYXR0ZXJuUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBwYXR0ZXJuICkge1xcblxcdHZhciBhdXgxLCBhdXgyLCBmcmFjdGlvblBhdHRlcm4sIGludGVnZXJGcmFjdGlvbk9yU2lnbmlmaWNhbnRQYXR0ZXJuLCBpbnRlZ2VyUGF0dGVybixcXG5cXHRcXHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1TaWduaWZpY2FudERpZ2l0cywgbWluaW11bUZyYWN0aW9uRGlnaXRzLFxcblxcdFxcdG1pbmltdW1JbnRlZ2VyRGlnaXRzLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIHBhZGRpbmcsIHByZWZpeCwgcHJpbWFyeUdyb3VwaW5nU2l6ZSxcXG5cXHRcXHRyb3VuZEluY3JlbWVudCwgc2NpZW50aWZpY05vdGF0aW9uLCBzZWNvbmRhcnlHcm91cGluZ1NpemUsIHNpZ25pZmljYW50UGF0dGVybiwgc3VmZml4O1xcblxcblxcdHBhdHRlcm4gPSBwYXR0ZXJuLm1hdGNoKCBudW1iZXJQYXR0ZXJuUmUgKTtcXG5cXHRpZiAoICFwYXR0ZXJuICkge1xcblxcdFxcdHRocm93IG5ldyBFcnJvciggXFxcIkludmFsaWQgcGF0dGVybjogXFxcIiArIHBhdHRlcm4gKTtcXG5cXHR9XFxuXFxuXFx0cHJlZml4ID0gcGF0dGVyblsgMSBdO1xcblxcdHBhZGRpbmcgPSBwYXR0ZXJuWyA0IF07XFxuXFx0aW50ZWdlckZyYWN0aW9uT3JTaWduaWZpY2FudFBhdHRlcm4gPSBwYXR0ZXJuWyA1IF07XFxuXFx0c2lnbmlmaWNhbnRQYXR0ZXJuID0gcGF0dGVyblsgOSBdO1xcblxcdHNjaWVudGlmaWNOb3RhdGlvbiA9IHBhdHRlcm5bIDEwIF07XFxuXFx0c3VmZml4ID0gcGF0dGVyblsgMTEgXTtcXG5cXG5cXHQvLyBTaWduaWZpY2FudCBkaWdpdCBmb3JtYXRcXG5cXHRpZiAoIHNpZ25pZmljYW50UGF0dGVybiApIHtcXG5cXHRcXHRzaWduaWZpY2FudFBhdHRlcm4ucmVwbGFjZSggLyhAKykoIyopLywgZnVuY3Rpb24oIG1hdGNoLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHNNYXRjaCwgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzTWF0Y2ggKSB7XFxuXFx0XFx0XFx0bWluaW11bVNpZ25pZmljYW50RGlnaXRzID0gbWluaW11bVNpZ25pZmljYW50RGlnaXRzTWF0Y2gubGVuZ3RoO1xcblxcdFxcdFxcdG1heGltdW1TaWduaWZpY2FudERpZ2l0cyA9IG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyArXFxuXFx0XFx0XFx0XFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzTWF0Y2gubGVuZ3RoO1xcblxcdFxcdH0pO1xcblxcblxcdC8vIEludGVnZXIgYW5kIGZyYWN0aW9uYWwgZm9ybWF0XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRmcmFjdGlvblBhdHRlcm4gPSBwYXR0ZXJuWyA4IF07XFxuXFx0XFx0aW50ZWdlclBhdHRlcm4gPSBwYXR0ZXJuWyA3IF07XFxuXFxuXFx0XFx0aWYgKCBmcmFjdGlvblBhdHRlcm4gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gTWluaW11bSBmcmFjdGlvbiBkaWdpdHMsIGFuZCByb3VuZGluZy5cXG5cXHRcXHRcXHRmcmFjdGlvblBhdHRlcm4ucmVwbGFjZSggL1swLTldKy8sIGZ1bmN0aW9uKCBtYXRjaCApIHtcXG5cXHRcXHRcXHRcXHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBtYXRjaDtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRpZiAoIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyApIHtcXG5cXHRcXHRcXHRcXHRyb3VuZEluY3JlbWVudCA9ICsoIFxcXCIwLlxcXCIgKyBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgKTtcXG5cXHRcXHRcXHRcXHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBtaW5pbXVtRnJhY3Rpb25EaWdpdHMubGVuZ3RoO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0bWluaW11bUZyYWN0aW9uRGlnaXRzID0gMDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gTWF4aW11bSBmcmFjdGlvbiBkaWdpdHNcXG5cXHRcXHRcXHQvLyAxOiBpZ25vcmUgZGVjaW1hbCBjaGFyYWN0ZXJcXG5cXHRcXHRcXHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBmcmFjdGlvblBhdHRlcm4ubGVuZ3RoIC0gMSAvKiAxICovO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0bWluaW11bUZyYWN0aW9uRGlnaXRzID0gMDtcXG5cXHRcXHRcXHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBNaW5pbXVtIGludGVnZXIgZGlnaXRzXFxuXFx0XFx0aW50ZWdlclBhdHRlcm4ucmVwbGFjZSggLzArJC8sIGZ1bmN0aW9uKCBtYXRjaCApIHtcXG5cXHRcXHRcXHRtaW5pbXVtSW50ZWdlckRpZ2l0cyA9IG1hdGNoLmxlbmd0aDtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0Ly8gU2NpZW50aWZpYyBub3RhdGlvblxcblxcdGlmICggc2NpZW50aWZpY05vdGF0aW9uICkge1xcblxcdFxcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcXG5cXHRcXHRcXHRmZWF0dXJlOiBcXFwic2NpZW50aWZpYyBub3RhdGlvbiAobm90IGltcGxlbWVudGVkKVxcXCJcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0Ly8gUGFkZGluZ1xcblxcdGlmICggcGFkZGluZyApIHtcXG5cXHRcXHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XFxuXFx0XFx0XFx0ZmVhdHVyZTogXFxcInBhZGRpbmcgKG5vdCBpbXBsZW1lbnRlZClcXFwiXFxuXFx0XFx0fSk7XFxuXFx0fVxcblxcblxcdC8vIEdyb3VwaW5nXFxuXFx0aWYgKCAoIGF1eDEgPSBpbnRlZ2VyRnJhY3Rpb25PclNpZ25pZmljYW50UGF0dGVybi5sYXN0SW5kZXhPZiggXFxcIixcXFwiICkgKSAhPT0gLTEgKSB7XFxuXFxuXFx0XFx0Ly8gUHJpbWFyeSBncm91cGluZyBzaXplIGlzIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZSBsYXN0IGdyb3VwIHNlcGFyYXRvciBhbmQgdGhlIGVuZCBvZlxcblxcdFxcdC8vIHRoZSBpbnRlZ2VyIChvciB0aGUgZW5kIG9mIHRoZSBzaWduaWZpY2FudCBwYXR0ZXJuKS5cXG5cXHRcXHRhdXgyID0gaW50ZWdlckZyYWN0aW9uT3JTaWduaWZpY2FudFBhdHRlcm4uc3BsaXQoIFxcXCIuXFxcIiApWyAwIF07XFxuXFx0XFx0cHJpbWFyeUdyb3VwaW5nU2l6ZSA9IGF1eDIubGVuZ3RoIC0gYXV4MSAtIDE7XFxuXFxuXFx0XFx0Ly8gU2Vjb25kYXJ5IGdyb3VwaW5nIHNpemUgaXMgdGhlIGludGVydmFsIGJldHdlZW4gdGhlIGxhc3QgdHdvIGdyb3VwIHNlcGFyYXRvcnMuXFxuXFx0XFx0aWYgKCAoIGF1eDIgPSBpbnRlZ2VyRnJhY3Rpb25PclNpZ25pZmljYW50UGF0dGVybi5sYXN0SW5kZXhPZiggXFxcIixcXFwiLCBhdXgxIC0gMSApICkgIT09IC0xICkge1xcblxcdFxcdFxcdHNlY29uZGFyeUdyb3VwaW5nU2l6ZSA9IGF1eDEgLSAxIC0gYXV4MjtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIFJldHVybjpcXG5cXHQvLyAgMDogQHByZWZpeCBTdHJpbmdcXG5cXHQvLyAgMTogQHBhZGRpbmcgQXJyYXkgWyA8Y2hhcmFjdGVyPiwgPGNvdW50PiBdIFRPRE9cXG5cXHQvLyAgMjogQG1pbmltdW1JbnRlZ2VyRGlnaXRzIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIE51bWJlciB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBtaW5pbXVtIGludGVnZXJcXG5cXHQvLyAgICAgICAgZGlnaXRzIHRvIGJlIHVzZWQuIE51bWJlcnMgd2lsbCBiZSBwYWRkZWQgd2l0aCBsZWFkaW5nIHplcm9lcyBpZiBuZWNlc3NhcnkuXFxuXFx0Ly8gIDM6IEBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgYW5kXFxuXFx0Ly8gIDQ6IEBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgYXJlIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIE51bWJlciB2YWx1ZXMgaW5kaWNhdGluZyB0aGUgbWluaW11bSBhbmRcXG5cXHQvLyAgICAgICAgbWF4aW11bSBmcmFjdGlvbiBkaWdpdHMgdG8gYmUgdXNlZC4gTnVtYmVycyB3aWxsIGJlIHJvdW5kZWQgb3IgcGFkZGVkIHdpdGggdHJhaWxpbmdcXG5cXHQvLyAgICAgICAgemVyb2VzIGlmIG5lY2Vzc2FyeS5cXG5cXHQvLyAgNTogQG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyBhbmRcXG5cXHQvLyAgNjogQG1heGltdW1TaWduaWZpY2FudERpZ2l0cyBhcmUgcG9zaXRpdmUgaW50ZWdlciBOdW1iZXIgdmFsdWVzIGluZGljYXRpbmcgdGhlIG1pbmltdW0gYW5kXFxuXFx0Ly8gICAgICAgIG1heGltdW0gZnJhY3Rpb24gZGlnaXRzIHRvIGJlIHNob3duLiBFaXRoZXIgbm9uZSBvciBib3RoIG9mIHRoZXNlIHByb3BlcnRpZXMgYXJlXFxuXFx0Ly8gICAgICAgIHByZXNlbnQ7IGlmIHRoZXkgYXJlLCB0aGV5IG92ZXJyaWRlIG1pbmltdW0gYW5kIG1heGltdW0gaW50ZWdlciBhbmQgZnJhY3Rpb24gZGlnaXRzXFxuXFx0Ly8gICAgICAgIOKAkyB0aGUgZm9ybWF0dGVyIHVzZXMgaG93ZXZlciBtYW55IGludGVnZXIgYW5kIGZyYWN0aW9uIGRpZ2l0cyBhcmUgcmVxdWlyZWQgdG8gZGlzcGxheVxcblxcdC8vICAgICAgICB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMuXFxuXFx0Ly8gIDc6IEByb3VuZEluY3JlbWVudCBEZWNpbWFsIHJvdW5kIGluY3JlbWVudCBvciBudWxsXFxuXFx0Ly8gIDg6IEBwcmltYXJ5R3JvdXBpbmdTaXplXFxuXFx0Ly8gIDk6IEBzZWNvbmRhcnlHcm91cGluZ1NpemVcXG5cXHQvLyAxMDogQHN1ZmZpeCBTdHJpbmdcXG5cXHRyZXR1cm4gW1xcblxcdFxcdHByZWZpeCxcXG5cXHRcXHRwYWRkaW5nLFxcblxcdFxcdG1pbmltdW1JbnRlZ2VyRGlnaXRzLFxcblxcdFxcdG1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcXG5cXHRcXHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMsXFxuXFx0XFx0bWluaW11bVNpZ25pZmljYW50RGlnaXRzLFxcblxcdFxcdG1heGltdW1TaWduaWZpY2FudERpZ2l0cyxcXG5cXHRcXHRyb3VuZEluY3JlbWVudCxcXG5cXHRcXHRwcmltYXJ5R3JvdXBpbmdTaXplLFxcblxcdFxcdHNlY29uZGFyeUdyb3VwaW5nU2l6ZSxcXG5cXHRcXHRzdWZmaXhcXG5cXHRdO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogU3ltYm9sKCBuYW1lLCBjbGRyIClcXG4gKlxcbiAqIEBuYW1lIFtTdHJpbmddIFN5bWJvbCBuYW1lLlxcbiAqXFxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxcbiAqXFxuICogUmV0dXJuIHRoZSBsb2NhbGl6ZWQgc3ltYm9sIGdpdmVuIGl0cyBuYW1lLlxcbiAqL1xcbnZhciBudW1iZXJTeW1ib2wgPSBmdW5jdGlvbiggbmFtZSwgY2xkciApIHtcXG5cXHRyZXR1cm4gY2xkci5tYWluKFtcXG5cXHRcXHRcXFwibnVtYmVycy9zeW1ib2xzLW51bWJlclN5c3RlbS1cXFwiICsgbnVtYmVyTnVtYmVyaW5nU3lzdGVtKCBjbGRyICksXFxuXFx0XFx0bmFtZVxcblxcdF0pO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIG51bWJlclN5bWJvbE5hbWUgPSB7XFxuXFx0XFxcIi5cXFwiOiBcXFwiZGVjaW1hbFxcXCIsXFxuXFx0XFxcIixcXFwiOiBcXFwiZ3JvdXBcXFwiLFxcblxcdFxcXCIlXFxcIjogXFxcInBlcmNlbnRTaWduXFxcIixcXG5cXHRcXFwiK1xcXCI6IFxcXCJwbHVzU2lnblxcXCIsXFxuXFx0XFxcIi1cXFwiOiBcXFwibWludXNTaWduXFxcIixcXG5cXHRcXFwiRVxcXCI6IFxcXCJleHBvbmVudGlhbFxcXCIsXFxuXFx0XFxcIlxcXFx1MjAzMFxcXCI6IFxcXCJwZXJNaWxsZVxcXCJcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIHN5bWJvbE1hcCggY2xkciApXFxuICpcXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXFxuICpcXG4gKiBSZXR1cm4gdGhlIChsb2NhbGl6ZWQgc3ltYm9sLCBwYXR0ZXJuIHN5bWJvbCkga2V5IHZhbHVlIHBhaXIsIGVnLiB7XFxuICogICBcXFwiLlxcXCI6IFxcXCLZq1xcXCIsXFxuICogICBcXFwiLFxcXCI6IFxcXCLZrFxcXCIsXFxuICogICBcXFwiJVxcXCI6IFxcXCLZqlxcXCIsXFxuICogICAuLi5cXG4gKiB9O1xcbiAqL1xcbnZhciBudW1iZXJTeW1ib2xNYXAgPSBmdW5jdGlvbiggY2xkciApIHtcXG5cXHR2YXIgc3ltYm9sLFxcblxcdFxcdHN5bWJvbE1hcCA9IHt9O1xcblxcblxcdGZvciAoIHN5bWJvbCBpbiBudW1iZXJTeW1ib2xOYW1lICkge1xcblxcdFxcdHN5bWJvbE1hcFsgc3ltYm9sIF0gPSBudW1iZXJTeW1ib2woIG51bWJlclN5bWJvbE5hbWVbIHN5bWJvbCBdLCBjbGRyICk7XFxuXFx0fVxcblxcblxcdHJldHVybiBzeW1ib2xNYXA7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgbnVtYmVyVHJ1bmNhdGUgPSBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0aWYgKCBpc05hTiggdmFsdWUgKSApIHtcXG5cXHRcXHRyZXR1cm4gTmFOO1xcblxcdH1cXG5cXHRyZXR1cm4gTWF0aFsgdmFsdWUgPCAwID8gXFxcImNlaWxcXFwiIDogXFxcImZsb29yXFxcIiBdKCB2YWx1ZSApO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogcm91bmQoIG1ldGhvZCApXFxuICpcXG4gKiBAbWV0aG9kIFtTdHJpbmddIHdpdGggZWl0aGVyIFxcXCJyb3VuZFxcXCIsIFxcXCJjZWlsXFxcIiwgXFxcImZsb29yXFxcIiwgb3IgXFxcInRydW5jYXRlXFxcIi5cXG4gKlxcbiAqIFJldHVybiBmdW5jdGlvbiggdmFsdWUsIGluY3JlbWVudE9yRXhwICk6XFxuICpcXG4gKiAgIEB2YWx1ZSBbTnVtYmVyXSBlZy4gMTIzLjQ1LlxcbiAqXFxuICogICBAaW5jcmVtZW50T3JFeHAgW051bWJlcl0gb3B0aW9uYWwsIGVnLiAwLjE7IG9yXFxuICogICAgIFtPYmplY3RdIEVpdGhlciB7IGluY3JlbWVudDogPHZhbHVlPiB9IG9yIHsgZXhwb25lbnQ6IDx2YWx1ZT4gfVxcbiAqXFxuICogICBSZXR1cm4gdGhlIHJvdW5kZWQgbnVtYmVyLCBlZzpcXG4gKiAgIC0gcm91bmQoIFxcXCJyb3VuZFxcXCIgKSggMTIzLjQ1ICk6IDEyMztcXG4gKiAgIC0gcm91bmQoIFxcXCJjZWlsXFxcIiApKCAxMjMuNDUgKTogMTI0O1xcbiAqICAgLSByb3VuZCggXFxcImZsb29yXFxcIiApKCAxMjMuNDUgKTogMTIzO1xcbiAqICAgLSByb3VuZCggXFxcInRydW5jYXRlXFxcIiApKCAxMjMuNDUgKTogMTIzO1xcbiAqICAgLSByb3VuZCggXFxcInJvdW5kXFxcIiApKCAxMjMuNDUsIDAuMSApOiAxMjMuNTtcXG4gKiAgIC0gcm91bmQoIFxcXCJyb3VuZFxcXCIgKSggMTIzLjQ1LCAxMCApOiAxMjA7XFxuICpcXG4gKiAgIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcm91bmRcXG4gKiAgIFJlZjogIzM3NlxcbiAqL1xcbnZhciBudW1iZXJSb3VuZCA9IGZ1bmN0aW9uKCBtZXRob2QgKSB7XFxuXFx0bWV0aG9kID0gbWV0aG9kIHx8IFxcXCJyb3VuZFxcXCI7XFxuXFx0bWV0aG9kID0gbWV0aG9kID09PSBcXFwidHJ1bmNhdGVcXFwiID8gbnVtYmVyVHJ1bmNhdGUgOiBNYXRoWyBtZXRob2QgXTtcXG5cXG5cXHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlLCBpbmNyZW1lbnRPckV4cCApIHtcXG5cXHRcXHR2YXIgZXhwLCBpbmNyZW1lbnQ7XFxuXFxuXFx0XFx0dmFsdWUgPSArdmFsdWU7XFxuXFxuXFx0XFx0Ly8gSWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlciwgcmV0dXJuIE5hTi5cXG5cXHRcXHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xcblxcdFxcdFxcdHJldHVybiBOYU47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEV4cG9uZW50IGdpdmVuLlxcblxcdFxcdGlmICggdHlwZW9mIGluY3JlbWVudE9yRXhwID09PSBcXFwib2JqZWN0XFxcIiAmJiBpbmNyZW1lbnRPckV4cC5leHBvbmVudCApIHtcXG5cXHRcXHRcXHRleHAgPSAraW5jcmVtZW50T3JFeHAuZXhwb25lbnQ7XFxuXFx0XFx0XFx0aW5jcmVtZW50ID0gMTtcXG5cXG5cXHRcXHRcXHRpZiAoIGV4cCA9PT0gMCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbWV0aG9kKCB2YWx1ZSApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiB0aGUgZXhwIGlzIG5vdCBhbiBpbnRlZ2VyLCByZXR1cm4gTmFOLlxcblxcdFxcdFxcdGlmICggISggdHlwZW9mIGV4cCA9PT0gXFxcIm51bWJlclxcXCIgJiYgZXhwICUgMSA9PT0gMCApICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBOYU47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdC8vIEluY3JlbWVudCBnaXZlbi5cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGluY3JlbWVudCA9ICtpbmNyZW1lbnRPckV4cCB8fCAxO1xcblxcblxcdFxcdFxcdGlmICggaW5jcmVtZW50ID09PSAxICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBtZXRob2QoIHZhbHVlICk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIHRoZSBpbmNyZW1lbnQgaXMgbm90IGEgbnVtYmVyLCByZXR1cm4gTmFOLlxcblxcdFxcdFxcdGlmICggaXNOYU4oIGluY3JlbWVudCApICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBOYU47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGluY3JlbWVudCA9IGluY3JlbWVudC50b0V4cG9uZW50aWFsKCkuc3BsaXQoIFxcXCJlXFxcIiApO1xcblxcdFxcdFxcdGV4cCA9ICtpbmNyZW1lbnRbIDEgXTtcXG5cXHRcXHRcXHRpbmNyZW1lbnQgPSAraW5jcmVtZW50WyAwIF07XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNoaWZ0ICYgUm91bmRcXG5cXHRcXHR2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoIFxcXCJlXFxcIiApO1xcblxcdFxcdHZhbHVlWyAwIF0gPSArdmFsdWVbIDAgXSAvIGluY3JlbWVudDtcXG5cXHRcXHR2YWx1ZVsgMSBdID0gdmFsdWVbIDEgXSA/ICggK3ZhbHVlWyAxIF0gLSBleHAgKSA6IC1leHA7XFxuXFx0XFx0dmFsdWUgPSBtZXRob2QoICsoIHZhbHVlWyAwIF0gKyBcXFwiZVxcXCIgKyB2YWx1ZVsgMSBdICkgKTtcXG5cXG5cXHRcXHQvLyBTaGlmdCBiYWNrXFxuXFx0XFx0dmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCBcXFwiZVxcXCIgKTtcXG5cXHRcXHR2YWx1ZVsgMCBdID0gK3ZhbHVlWyAwIF0gKiBpbmNyZW1lbnQ7XFxuXFx0XFx0dmFsdWVbIDEgXSA9IHZhbHVlWyAxIF0gPyAoICt2YWx1ZVsgMSBdICsgZXhwICkgOiBleHA7XFxuXFx0XFx0cmV0dXJuICsoIHZhbHVlWyAwIF0gKyBcXFwiZVxcXCIgKyB2YWx1ZVsgMSBdICk7XFxuXFx0fTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIGZvcm1hdFByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIgWywgb3B0aW9uc10gKVxcbiAqXFxuICogQHBhdHRlcm4gW1N0cmluZ10gcmF3IHBhdHRlcm4gZm9yIG51bWJlcnMuXFxuICpcXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXFxuICpcXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTpcXG4gKiAtIG1pbmltdW1JbnRlZ2VyRGlnaXRzIFtOdW1iZXJdXFxuICogLSBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1GcmFjdGlvbkRpZ2l0cyBbTnVtYmVyXVxcbiAqIC0gbWluaW11bVNpZ25pZmljYW50RGlnaXRzLCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgW051bWJlcl1cXG4gKiAtIHJvdW5kIFtTdHJpbmddIFxcXCJjZWlsXFxcIiwgXFxcImZsb29yXFxcIiwgXFxcInJvdW5kXFxcIiAoZGVmYXVsdCksIG9yIFxcXCJ0cnVuY2F0ZVxcXCIuXFxuICogLSB1c2VHcm91cGluZyBbQm9vbGVhbl0gZGVmYXVsdCB0cnVlLlxcbiAqXFxuICogUmV0dXJuIHRoZSBwcm9jZXNzZWQgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgdXNlZCBpbiBudW1iZXIvZm9ybWF0LlxcbiAqIHJlZjogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1udW1iZXJzLmh0bWxcXG4gKi9cXG52YXIgbnVtYmVyRm9ybWF0UHJvcGVydGllcyA9IGZ1bmN0aW9uKCBwYXR0ZXJuLCBjbGRyLCBvcHRpb25zICkge1xcblxcdHZhciBuZWdhdGl2ZVBhdHRlcm4sIG5lZ2F0aXZlUHJlZml4LCBuZWdhdGl2ZVByb3BlcnRpZXMsIG5lZ2F0aXZlU3VmZml4LCBwb3NpdGl2ZVBhdHRlcm4sXFxuXFx0XFx0cm91bmRGbiwgcHJvcGVydGllcztcXG5cXG5cXHRmdW5jdGlvbiBnZXRPcHRpb25zKCBhdHRyaWJ1dGUsIHByb3BlcnR5SW5kZXggKSB7XFxuXFx0XFx0aWYgKCBhdHRyaWJ1dGUgaW4gb3B0aW9ucyApIHtcXG5cXHRcXHRcXHRwcm9wZXJ0aWVzWyBwcm9wZXJ0eUluZGV4IF0gPSBvcHRpb25zWyBhdHRyaWJ1dGUgXTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcdHBhdHRlcm4gPSBwYXR0ZXJuLnNwbGl0KCBcXFwiO1xcXCIgKTtcXG5cXG5cXHRwb3NpdGl2ZVBhdHRlcm4gPSBwYXR0ZXJuWyAwIF07XFxuXFxuXFx0bmVnYXRpdmVQYXR0ZXJuID0gcGF0dGVyblsgMSBdIHx8IFxcXCItXFxcIiArIHBvc2l0aXZlUGF0dGVybjtcXG5cXHRuZWdhdGl2ZVByb3BlcnRpZXMgPSBudW1iZXJQYXR0ZXJuUHJvcGVydGllcyggbmVnYXRpdmVQYXR0ZXJuICk7XFxuXFx0bmVnYXRpdmVQcmVmaXggPSBuZWdhdGl2ZVByb3BlcnRpZXNbIDAgXTtcXG5cXHRuZWdhdGl2ZVN1ZmZpeCA9IG5lZ2F0aXZlUHJvcGVydGllc1sgMTAgXTtcXG5cXG5cXHQvLyBIYXZlIHJ1bnRpbWUgY29kZSB0byByZWZlciB0byBudW1iZXJSb3VuZCgpIGluc3RlYWQgb2YgaW5jbHVkaW5nIGl0IGV4cGxpY2l0bHkuXFxuXFx0cm91bmRGbiA9IG51bWJlclJvdW5kKCBvcHRpb25zLnJvdW5kICk7XFxuXFx0cm91bmRGbi5nZW5lcmF0b3JTdHJpbmcgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRyZXR1cm4gXFxcIm51bWJlclJvdW5kKFxcXCIgKyAoIG9wdGlvbnMucm91bmQgPyBcXFwiXFxcXFxcXCJcXFwiICsgb3B0aW9ucy5yb3VuZCArIFxcXCJcXFxcXFxcIlxcXCIgOiBcXFwiXFxcIiApICsgXFxcIilcXFwiO1xcblxcdH07XFxuXFxuXFx0cHJvcGVydGllcyA9IG51bWJlclBhdHRlcm5Qcm9wZXJ0aWVzKCBwb3NpdGl2ZVBhdHRlcm4gKS5jb25jYXQoW1xcblxcdFxcdHBvc2l0aXZlUGF0dGVybixcXG5cXHRcXHRuZWdhdGl2ZVByZWZpeCArIHBvc2l0aXZlUGF0dGVybiArIG5lZ2F0aXZlU3VmZml4LFxcblxcdFxcdG5lZ2F0aXZlUHJlZml4LFxcblxcdFxcdG5lZ2F0aXZlU3VmZml4LFxcblxcdFxcdHJvdW5kRm4sXFxuXFx0XFx0bnVtYmVyU3ltYm9sKCBcXFwiaW5maW5pdHlcXFwiLCBjbGRyICksXFxuXFx0XFx0bnVtYmVyU3ltYm9sKCBcXFwibmFuXFxcIiwgY2xkciApLFxcblxcdFxcdG51bWJlclN5bWJvbE1hcCggY2xkciApLFxcblxcdFxcdG51bWJlck51bWJlcmluZ1N5c3RlbURpZ2l0c01hcCggY2xkciApXFxuXFx0XSk7XFxuXFxuXFx0aWYgKCBvcHRpb25zLmNvbXBhY3QgKSB7XFxuXFxuXFx0XFx0Ly8gVGhlIGNvbXBhY3QgZGlnaXRzIG51bWJlciBwYXR0ZXJuIGlzIGFsd2F5cyBgMCtgLCBzbyBvdmVycmlkZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMuXFxuXFx0XFx0Ly8gTm90ZTogbWluaW11bUludGVnZXJEaWdpdHMgd291bGQgYWN0dWFsbHkgcmFuZ2UgZnJvbSBgMGAgdG8gYDAwMGAgYmFzZWQgb24gdGhlIHNjYWxlIG9mXFxuXFx0XFx0Ly8gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZCwgdGhvdWdoIHdlJ3JlIGFsd2F5cyB1c2luZyAxIGFzIGEgc2ltcGxpZmljYXRpb24sIGJlY2F1c2UgdGhlXFxuXFx0XFx0Ly8gbnVtYmVyIHdvbid0IGJlIHplcm8tcGFkZGVkIHNpbmNlIHdlIGNob3NlIHRoZSByaWdodCBmb3JtYXQgYmFzZWQgb24gdGhlIHNjYWxlLCBpLmUuLFxcblxcdFxcdC8vIHdlJ2QgbmV2ZXIgc2VlIHNvbWV0aGluZyBsaWtlIGAwMDNNYCBhbnl3YXkuXFxuXFx0XFx0cHJvcGVydGllc1sgMiBdID0gMTsgLy8gbWluaW11bUludGVnZXJEaWdpdHNcXG5cXHRcXHRwcm9wZXJ0aWVzWyAzIF0gPSAwOyAvLyBtaW5pbXVtRnJhY3Rpb25EaWdpdHNcXG5cXHRcXHRwcm9wZXJ0aWVzWyA0IF0gPSAwOyAvLyBtYXhpbXVtRnJhY3Rpb25EaWdpdHNcXG5cXHRcXHRwcm9wZXJ0aWVzWyA1IF0gPSAvLyBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgJlxcblxcdFxcdFxcdHByb3BlcnRpZXNbIDYgXSA9IHVuZGVmaW5lZCA7IC8vIG1heGltdW1TaWduaWZpY2FudERpZ2l0c1xcblxcblxcdFxcdHByb3BlcnRpZXNbMjBdID0gbnVtYmVyQ29tcGFjdCggb3B0aW9ucy5jb21wYWN0LCBjbGRyICk7XFxuXFx0fVxcblxcblxcdGdldE9wdGlvbnMoIFxcXCJtaW5pbXVtSW50ZWdlckRpZ2l0c1xcXCIsIDIgKTtcXG5cXHRnZXRPcHRpb25zKCBcXFwibWluaW11bUZyYWN0aW9uRGlnaXRzXFxcIiwgMyApO1xcblxcdGdldE9wdGlvbnMoIFxcXCJtYXhpbXVtRnJhY3Rpb25EaWdpdHNcXFwiLCA0ICk7XFxuXFx0Z2V0T3B0aW9ucyggXFxcIm1pbmltdW1TaWduaWZpY2FudERpZ2l0c1xcXCIsIDUgKTtcXG5cXHRnZXRPcHRpb25zKCBcXFwibWF4aW11bVNpZ25pZmljYW50RGlnaXRzXFxcIiwgNiApO1xcblxcblxcdC8vIEdyb3VwaW5nIHNlcGFyYXRvcnNcXG5cXHRpZiAoIG9wdGlvbnMudXNlR3JvdXBpbmcgPT09IGZhbHNlICkge1xcblxcdFxcdHByb3BlcnRpZXNbIDggXSA9IG51bGw7XFxuXFx0fVxcblxcblxcdC8vIE5vcm1hbGl6ZSBudW1iZXIgb2YgZGlnaXRzIGlmIG9ubHkgb25lIG9mIGVpdGhlciBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgb3JcXG5cXHQvLyBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgaXMgcGFzc2VkIGluIGFzIGFuIG9wdGlvblxcblxcdGlmICggXFxcIm1pbmltdW1GcmFjdGlvbkRpZ2l0c1xcXCIgaW4gb3B0aW9ucyAmJiAhKCBcXFwibWF4aW11bUZyYWN0aW9uRGlnaXRzXFxcIiBpbiBvcHRpb25zICkgKSB7XFxuXFxuXFx0XFx0Ly8gbWF4aW11bUZyYWN0aW9uRGlnaXRzID0gTWF0aC5tYXgoIG1pbmltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bUZyYWN0aW9uRGlnaXRzICk7XFxuXFx0XFx0cHJvcGVydGllc1sgNCBdID0gTWF0aC5tYXgoIHByb3BlcnRpZXNbIDMgXSwgcHJvcGVydGllc1sgNCBdICk7XFxuXFx0fSBlbHNlIGlmICggISggXFxcIm1pbmltdW1GcmFjdGlvbkRpZ2l0c1xcXCIgaW4gb3B0aW9ucyApICYmXFxuXFx0XFx0XFx0XFxcIm1heGltdW1GcmFjdGlvbkRpZ2l0c1xcXCIgaW4gb3B0aW9ucyApIHtcXG5cXG5cXHRcXHQvLyBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBNYXRoLm1pbiggbWluaW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgKTtcXG5cXHRcXHRwcm9wZXJ0aWVzWyAzIF0gPSBNYXRoLm1pbiggcHJvcGVydGllc1sgMyBdLCBwcm9wZXJ0aWVzWyA0IF0gKTtcXG5cXHR9XFxuXFxuXFx0Ly8gUmV0dXJuOlxcblxcdC8vIDAtMTA6IHNlZSBudW1iZXIvcGF0dGVybi1wcm9wZXJ0aWVzLlxcblxcdC8vIDExOiBAcG9zaXRpdmVQYXR0ZXJuIFtTdHJpbmddIFBvc2l0aXZlIHBhdHRlcm4uXFxuXFx0Ly8gMTI6IEBuZWdhdGl2ZVBhdHRlcm4gW1N0cmluZ10gTmVnYXRpdmUgcGF0dGVybi5cXG5cXHQvLyAxMzogQG5lZ2F0aXZlUHJlZml4IFtTdHJpbmddIE5lZ2F0aXZlIHByZWZpeC5cXG5cXHQvLyAxNDogQG5lZ2F0aXZlU3VmZml4IFtTdHJpbmddIE5lZ2F0aXZlIHN1ZmZpeC5cXG5cXHQvLyAxNTogQHJvdW5kIFtGdW5jdGlvbl0gUm91bmQgZnVuY3Rpb24uXFxuXFx0Ly8gMTY6IEBpbmZpbml0eVN5bWJvbCBbU3RyaW5nXSBJbmZpbml0eSBzeW1ib2wuXFxuXFx0Ly8gMTc6IEBuYW5TeW1ib2wgW1N0cmluZ10gTmFOIHN5bWJvbC5cXG5cXHQvLyAxODogQHN5bWJvbE1hcCBbT2JqZWN0XSBBIGJ1bmNoIG9mIG90aGVyIHN5bWJvbHMuXFxuXFx0Ly8gMTk6IEBudURpZ2l0c01hcCBbQXJyYXldIERpZ2l0cyBtYXAgaWYgbnVtYmVyaW5nIHN5c3RlbSBpcyBkaWZmZXJlbnQgdGhhbiBgbGF0bmAuXFxuXFx0Ly8gMjA6IEBjb21wYWN0TWFwIFtPYmplY3RdIE1hcCBvZiBwZXItZGlnaXQtY291bnQgZm9ybWF0IHBhdHRlcm5zIGZvciBzcGVjaWZpZWQgY29tcGFjdCBtb2RlLlxcblxcdHJldHVybiBwcm9wZXJ0aWVzO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogR2VuZXJhdGVkIGJ5OlxcbiAqXFxuICogdmFyIHJlZ2VuZXJhdGUgPSByZXF1aXJlKCBcXFwicmVnZW5lcmF0ZVxcXCIgKTtcXG4gKiB2YXIgZm9ybWF0U3ltYm9scyA9IHJlcXVpcmUoICogXFxcInVuaWNvZGUtOC4wLjAvR2VuZXJhbF9DYXRlZ29yeS9Gb3JtYXQvc3ltYm9sc1xcXCIgKTtcXG4gKiByZWdlbmVyYXRlKCkuYWRkKCBmb3JtYXRTeW1ib2xzICkudG9TdHJpbmcoKTtcXG4gKlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3JlZ2VuZXJhdGVcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy91bmljb2RlLTguMC4wXFxuICovXFxudmFyIHJlZ2V4cENmRyA9IC9bXFxcXHhBRFxcXFx1MDYwMC1cXFxcdTA2MDVcXFxcdTA2MUNcXFxcdTA2RERcXFxcdTA3MEZcXFxcdTE4MEVcXFxcdTIwMEItXFxcXHUyMDBGXFxcXHUyMDJBLVxcXFx1MjAyRVxcXFx1MjA2MC1cXFxcdTIwNjRcXFxcdTIwNjYtXFxcXHUyMDZGXFxcXHVGRUZGXFxcXHVGRkY5LVxcXFx1RkZGQl18XFxcXHVEODA0XFxcXHVEQ0JEfFxcXFx1RDgyRltcXFxcdURDQTAtXFxcXHVEQ0EzXXxcXFxcdUQ4MzRbXFxcXHVERDczLVxcXFx1REQ3QV18XFxcXHVEQjQwW1xcXFx1REMwMVxcXFx1REMyMC1cXFxcdURDN0ZdL2c7XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogR2VuZXJhdGVkIGJ5OlxcbiAqXFxuICogdmFyIHJlZ2VuZXJhdGUgPSByZXF1aXJlKCBcXFwicmVnZW5lcmF0ZVxcXCIgKTtcXG4gKiB2YXIgZGFzaFN5bWJvbHMgPSByZXF1aXJlKCAqIFxcXCJ1bmljb2RlLTguMC4wL0dlbmVyYWxfQ2F0ZWdvcnkvRGFzaF9QdW5jdHVhdGlvbi9zeW1ib2xzXFxcIiApO1xcbiAqIHJlZ2VuZXJhdGUoKS5hZGQoIGRhc2hTeW1ib2xzICkudG9TdHJpbmcoKTtcXG4gKlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3JlZ2VuZXJhdGVcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy91bmljb2RlLTguMC4wXFxuICpcXG4gKiBOT1RFOiBJbiBhZGRpdGlvbiB0byBbOmRhc2g6XSwgIHRoZSBiZWxvdyBpbmNsdWRlcyBNSU5VUyBTSUdOIFUrMjIxMi5cXG4gKi9cXG52YXIgcmVnZXhwRGFzaEcgPSAvW1xcXFwtXFxcXHUwNThBXFxcXHUwNUJFXFxcXHUxNDAwXFxcXHUxODA2XFxcXHUyMDEwLVxcXFx1MjAxNVxcXFx1MkUxN1xcXFx1MkUxQVxcXFx1MkUzQVxcXFx1MkUzQlxcXFx1MkU0MFxcXFx1MzAxQ1xcXFx1MzAzMFxcXFx1MzBBMFxcXFx1RkUzMVxcXFx1RkUzMlxcXFx1RkU1OFxcXFx1RkU2M1xcXFx1RkYwRFxcXFx1MjIxMl0vZztcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBHZW5lcmF0ZWQgYnk6XFxuICpcXG4gKiB2YXIgcmVnZW5lcmF0ZSA9IHJlcXVpcmUoIFxcXCJyZWdlbmVyYXRlXFxcIiApO1xcbiAqIHZhciBzcGFjZVNlcGFyYXRvclN5bWJvbHMgPSByZXF1aXJlKCBcXFwidW5pY29kZS04LjAuMC9HZW5lcmFsX0NhdGVnb3J5L1NwYWNlX1NlcGFyYXRvci9zeW1ib2xzXFxcIiApO1xcbiAqIHJlZ2VuZXJhdGUoKS5hZGQoIHNwYWNlU2VwYXJhdG9yU3ltYm9scyApLnRvU3RyaW5nKCk7XFxuICpcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9yZWdlbmVyYXRlXFxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvdW5pY29kZS04LjAuMFxcbiAqL1xcbnZhciByZWdleHBac0cgPSAvWyBcXFxceEEwXFxcXHUxNjgwXFxcXHUyMDAwLVxcXFx1MjAwQVxcXFx1MjAyRlxcXFx1MjA1RlxcXFx1MzAwMF0vZztcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBMb29zZSBNYXRjaGluZzpcXG4gKiAtIElnbm9yZSBhbGwgZm9ybWF0IGNoYXJhY3RlcnMsIHdoaWNoIGluY2x1ZGVzIFJMTSwgTFJNIG9yIEFMTSB1c2VkIHRvIGNvbnRyb2wgQklESVxcbiAqICAgZm9ybWF0dGluZy5cXG4gKiAtIE1hcCBhbGwgY2hhcmFjdGVycyBpbiBbOlpzOl0gdG8gVSswMDIwIFNQQUNFO1xcbiAqIC0gTWFwIGFsbCBjaGFyYWN0ZXJzIGluIFs6RGFzaDpdIHRvIFUrMDAyRCBIWVBIRU4tTUlOVVM7XFxuICovXFxudmFyIGxvb3NlTWF0Y2hpbmcgPSBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZhbHVlXFxuXFx0XFx0LnJlcGxhY2UoIHJlZ2V4cENmRywgXFxcIlxcXCIgKVxcblxcdFxcdC5yZXBsYWNlKCByZWdleHBEYXNoRywgXFxcIi1cXFwiIClcXG5cXHRcXHQucmVwbGFjZSggcmVnZXhwWnNHLCBcXFwiIFxcXCIgKTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIHBhcnNlKCB2YWx1ZSwgcHJvcGVydGllcyApXFxuICpcXG4gKiBAdmFsdWUgW1N0cmluZ10uXFxuICpcXG4gKiBAcHJvcGVydGllcyBbT2JqZWN0XSBQYXJzZXIgcHJvcGVydGllcyBpcyBhIHJlZHVjZWQgcHJlLXByb2Nlc3NlZCBjbGRyXFxuICogZGF0YSBzZXQgcmV0dXJuZWQgYnkgbnVtYmVyUGFyc2VyUHJvcGVydGllcygpLlxcbiAqXFxuICogUmV0dXJuIHRoZSBwYXJzZWQgTnVtYmVyIChpbmNsdWRpbmcgSW5maW5pdHkpIG9yIE5hTiB3aGVuIHZhbHVlIGlzIGludmFsaWQuXFxuICogcmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LW51bWJlcnMuaHRtbFxcbiAqL1xcbnZhciBudW1iZXJQYXJzZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgcHJvcGVydGllcyApIHtcXG5cXHR2YXIgZ3JhbW1hciwgaW52ZXJ0ZWROdURpZ2l0c01hcCwgaW52ZXJ0ZWRTeW1ib2xNYXAsIG5lZ2F0aXZlLCBudW1iZXIsIHByZWZpeCwgcHJlZml4TlN1ZmZpeCxcXG5cXHRcXHRzdWZmaXgsIHRva2VuaXplciwgdmFsaWQ7XFxuXFxuXFx0Ly8gR3JhbW1hcjpcXG5cXHQvLyAtIFZhbHVlIDw9ICAgICAgICAgICBOYU4gfCBQb3NpdGl2ZU51bWJlciB8IE5lZ2F0aXZlTnVtYmVyXFxuXFx0Ly8gLSBQb3NpdGl2ZU51bWJlciA8PSAgUG9zaXRpdmVQcmVmaXggTnVtYmVyT3JJbmYgUG9zaXRpdmVTdWZpeFxcblxcdC8vIC0gTmVnYXRpdmVOdW1iZXIgPD0gIE5lZ2F0aXZlUHJlZml4IE51bWJlck9ySW5mXFxuXFx0Ly8gLSBOdW1iZXJPckluZiA8PSAgICAgTnVtYmVyIHwgSW5mXFxuXFx0Z3JhbW1hciA9IFtcXG5cXHRcXHRbIFxcXCJuYW5cXFwiIF0sXFxuXFx0XFx0WyBcXFwicHJlZml4XFxcIiwgXFxcImluZmluaXR5XFxcIiwgXFxcInN1ZmZpeFxcXCIgXSxcXG5cXHRcXHRbIFxcXCJwcmVmaXhcXFwiLCBcXFwibnVtYmVyXFxcIiwgXFxcInN1ZmZpeFxcXCIgXSxcXG5cXHRcXHRbIFxcXCJuZWdhdGl2ZVByZWZpeFxcXCIsIFxcXCJpbmZpbml0eVxcXCIsIFxcXCJuZWdhdGl2ZVN1ZmZpeFxcXCIgXSxcXG5cXHRcXHRbIFxcXCJuZWdhdGl2ZVByZWZpeFxcXCIsIFxcXCJudW1iZXJcXFwiLCBcXFwibmVnYXRpdmVTdWZmaXhcXFwiIF1cXG5cXHRdO1xcblxcblxcdGludmVydGVkU3ltYm9sTWFwID0gcHJvcGVydGllc1sgMCBdO1xcblxcdGludmVydGVkTnVEaWdpdHNNYXAgPSBwcm9wZXJ0aWVzWyAxIF0gfHwge307XFxuXFx0dG9rZW5pemVyID0gcHJvcGVydGllc1sgMiBdO1xcblxcblxcdHZhbHVlID0gbG9vc2VNYXRjaGluZyggdmFsdWUgKTtcXG5cXG5cXHRmdW5jdGlvbiBwYXJzZSggdHlwZSApIHtcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24oIGxleGVtZSApIHtcXG5cXG5cXHRcXHRcXHQvLyBSZXZlcnNlIGxvY2FsaXplZCBzeW1ib2xzIGFuZCBudW1iZXJpbmcgc3lzdGVtLlxcblxcdFxcdFxcdGxleGVtZSA9IGxleGVtZS5zcGxpdCggXFxcIlxcXCIgKS5tYXAoZnVuY3Rpb24oIGNoYXJhY3RlciApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaW52ZXJ0ZWRTeW1ib2xNYXBbIGNoYXJhY3RlciBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0aW52ZXJ0ZWROdURpZ2l0c01hcFsgY2hhcmFjdGVyIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRjaGFyYWN0ZXI7XFxuXFx0XFx0XFx0fSkuam9pbiggXFxcIlxcXCIgKTtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCB0eXBlICkge1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImluZmluaXR5XFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRudW1iZXIgPSBJbmZpbml0eTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJuYW5cXFwiOlxcblxcdFxcdFxcdFxcdFxcdG51bWJlciA9IE5hTjtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJudW1iZXJcXFwiOlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSBncm91cGluZyBzZXBhcmF0b3JzLlxcblxcdFxcdFxcdFxcdFxcdGxleGVtZSA9IGxleGVtZS5yZXBsYWNlKCAvLC9nLCBcXFwiXFxcIiApO1xcblxcblxcdFxcdFxcdFxcdFxcdG51bWJlciA9ICtsZXhlbWU7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwicHJlZml4XFxcIjpcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJuZWdhdGl2ZVByZWZpeFxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cHJlZml4ID0gbGV4ZW1lO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgXFxcInN1ZmZpeFxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0c3VmZml4ID0gbGV4ZW1lO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgXFxcIm5lZ2F0aXZlU3VmZml4XFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRzdWZmaXggPSBsZXhlbWU7XFxuXFx0XFx0XFx0XFx0XFx0bmVnYXRpdmUgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdC8vIFRoaXMgc2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQuXFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoIFxcXCJJbnRlcm5hbCBlcnJvclxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIFxcXCJcXFwiO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHRva2VuaXplTlBhcnNlKCBfdmFsdWUsIGdyYW1tYXIgKSB7XFxuXFx0XFx0cmV0dXJuIGdyYW1tYXIuc29tZShmdW5jdGlvbiggc3RhdGVtZW50ICkge1xcblxcdFxcdFxcdHZhciB2YWx1ZSA9IF92YWx1ZTtcXG5cXG5cXHRcXHRcXHQvLyBUaGUgd2hvbGUgZ3JhbW1hciBzdGF0ZW1lbnQgc2hvdWxkIGJlIHVzZWQgKGkuZS4sIC5ldmVyeSgpIHJldHVybiB0cnVlKSBhbmQgdmFsdWUgYmVcXG5cXHRcXHRcXHQvLyBlbnRpcmVseSBjb25zdW1lZCAoaS5lLiwgIXZhbHVlLmxlbmd0aCkuXFxuXFx0XFx0XFx0cmV0dXJuIHN0YXRlbWVudC5ldmVyeShmdW5jdGlvbiggdHlwZSApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHZhbHVlLm1hdGNoKCB0b2tlbml6ZXJbIHR5cGUgXSApID09PSBudWxsICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29uc3VtZSBhbmQgcGFyc2UgaXQuXFxuXFx0XFx0XFx0XFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCB0b2tlbml6ZXJbIHR5cGUgXSwgcGFyc2UoIHR5cGUgKSApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH0pICYmICF2YWx1ZS5sZW5ndGg7XFxuXFx0XFx0fSk7XFxuXFx0fVxcblxcblxcdHZhbGlkID0gdG9rZW5pemVOUGFyc2UoIHZhbHVlLCBncmFtbWFyICk7XFxuXFxuXFx0Ly8gTmFOXFxuXFx0aWYgKCAhdmFsaWQgfHwgaXNOYU4oIG51bWJlciApICkge1xcblxcdFxcdHJldHVybiBOYU47XFxuXFx0fVxcblxcblxcdHByZWZpeE5TdWZmaXggPSBcXFwiXFxcIiArIHByZWZpeCArIHN1ZmZpeDtcXG5cXG5cXHQvLyBQZXJjZW50XFxuXFx0aWYgKCBwcmVmaXhOU3VmZml4LmluZGV4T2YoIFxcXCIlXFxcIiApICE9PSAtMSApIHtcXG5cXHRcXHRudW1iZXIgLz0gMTAwO1xcblxcblxcdC8vIFBlciBtaWxsZVxcblxcdH0gZWxzZSBpZiAoIHByZWZpeE5TdWZmaXguaW5kZXhPZiggXFxcIlxcXFx1MjAzMFxcXCIgKSAhPT0gLTEgKSB7XFxuXFx0XFx0bnVtYmVyIC89IDEwMDA7XFxuXFx0fVxcblxcblxcdC8vIE5lZ2F0aXZlIG51bWJlclxcblxcdGlmICggbmVnYXRpdmUgKSB7XFxuXFx0XFx0bnVtYmVyICo9IC0xO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gbnVtYmVyO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIG51bWJlclBhcnNlckZuID0gZnVuY3Rpb24oIHByb3BlcnRpZXMgKSB7XFxuXFx0cmV0dXJuIGZ1bmN0aW9uIG51bWJlclBhcnNlciggdmFsdWUgKSB7XFxuXFx0XFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXHRcXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcoIHZhbHVlLCBcXFwidmFsdWVcXFwiICk7XFxuXFxuXFx0XFx0cmV0dXJuIG51bWJlclBhcnNlKCB2YWx1ZSwgcHJvcGVydGllcyApO1xcblxcdH07XFxuXFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBzeW1ib2xNYXAoIGNsZHIgKVxcbiAqXFxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxcbiAqXFxuICogUmV0dXJuIHRoZSAobG9jYWxpemVkIHN5bWJvbCwgcGF0dGVybiBzeW1ib2wpIGtleSB2YWx1ZSBwYWlyLCBlZy4ge1xcbiAqICAgXFxcItmrXFxcIjogXFxcIi5cXFwiLFxcbiAqICAgXFxcItmsXFxcIjogXFxcIixcXFwiLFxcbiAqICAgXFxcItmqXFxcIjogXFxcIiVcXFwiLFxcbiAqICAgLi4uXFxuICogfTtcXG4gKi9cXG52YXIgbnVtYmVyU3ltYm9sSW52ZXJ0ZWRNYXAgPSBmdW5jdGlvbiggY2xkciApIHtcXG5cXHR2YXIgc3ltYm9sLFxcblxcdFxcdHN5bWJvbE1hcCA9IHt9O1xcblxcblxcdGZvciAoIHN5bWJvbCBpbiBudW1iZXJTeW1ib2xOYW1lICkge1xcblxcdFxcdHN5bWJvbE1hcFsgbnVtYmVyU3ltYm9sKCBudW1iZXJTeW1ib2xOYW1lWyBzeW1ib2wgXSwgY2xkciApIF0gPSBzeW1ib2w7XFxuXFx0fVxcblxcblxcdHJldHVybiBzeW1ib2xNYXA7XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBvYmplY3RNYXAoIG9iamVjdCwgZm4pXFxuICpcXG4gKiAtIG9iamVjdFxcbiAqXFxuICogLSBmbiggcGFpciApID0+IHBhaXJcXG4gKi9cXG52YXIgb2JqZWN0TWFwID0gZnVuY3Rpb24oIG9iamVjdCwgZm4gKSB7XFxuXFx0cmV0dXJuIE9iamVjdC5rZXlzKCBvYmplY3QgKS5tYXAoZnVuY3Rpb24oIGtleSApIHtcXG5cXHRcXHRyZXR1cm4gZm4oWyBrZXksIG9iamVjdFsga2V5IF0gXSk7XFxuXFx0fSkucmVkdWNlKGZ1bmN0aW9uKCBvYmplY3QsIHBhaXIgKSB7XFxuXFx0XFx0b2JqZWN0WyBwYWlyWyAwIF0gXSA9IHBhaXJbIDEgXTtcXG5cXHRcXHRyZXR1cm4gb2JqZWN0O1xcblxcdH0sIHt9KTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIHJlbW92ZUxpdGVyYWxRdW90ZXMoIHN0cmluZyApXFxuICpcXG4gKiBSZXR1cm46XFxuICogLSBgJ2AgaWYgaW5wdXQgc3RyaW5nIGlzIGAnJ2AuXFxuICogLSBgbydjbG9ja2AgaWYgaW5wdXQgc3RyaW5nIGlzIGAnbycnY2xvY2snYC5cXG4gKiAtIGBmb29gIGlmIGlucHV0IHN0cmluZyBpcyBgZm9vYCwgaS5lLiwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIGluIGNhc2UgaXQgaXNuJ3QgYSBzaW5nbGUtcXVvdGVkXFxuICogICBzdHJpbmcuXFxuICovXFxudmFyIHJlbW92ZUxpdGVyYWxRdW90ZXMgPSBmdW5jdGlvbiggc3RyaW5nICkge1xcblxcdGlmICggc3RyaW5nWyAwIF0gKyBzdHJpbmdbIHN0cmluZy5sZW5ndGggLSAxIF0gIT09IFxcXCInJ1xcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIHN0cmluZztcXG5cXHR9XFxuXFx0aWYgKCBzdHJpbmcgPT09IFxcXCInJ1xcXCIgKSB7XFxuXFx0XFx0cmV0dXJuIFxcXCInXFxcIjtcXG5cXHR9XFxuXFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCAvJycvZywgXFxcIidcXFwiICkuc2xpY2UoIDEsIC0xICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBwYXJzZVByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIgKVxcbiAqXFxuICogQHBhdHRlcm4gW1N0cmluZ10gcmF3IHBhdHRlcm4gZm9yIG51bWJlcnMuXFxuICpcXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXFxuICpcXG4gKiBSZXR1cm4gcGFyc2VyIHByb3BlcnRpZXMsIHVzZWQgdG8gZmVlZCBwYXJzZXIgZnVuY3Rpb24uXFxuICpcXG4gKiBUT0RPOlxcbiAqIC0gU2NpZW50aWZpY19ub3RhdGlvbjtcXG4gKiAtIFBhZGRpbmc7XFxuICovXFxudmFyIG51bWJlclBhcnNlUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBwYXR0ZXJuLCBjbGRyLCBvcHRpb25zICkge1xcblxcdHZhciBhdXgsIGRlY2ltYWxTeW1ib2xSZSwgZGlnaXRzUmUsIGdyb3VwaW5nU2VwYXJhdG9yUmUsIGluZmluaXR5U3ltYm9sLCBpbnZlcnRlZE51RGlnaXRzTWFwLFxcblxcdFxcdGludmVydGVkU3ltYm9sTWFwLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1TaWduaWZpY2FudERpZ2l0cyxcXG5cXHRcXHRtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIG5hblN5bWJvbCwgbmVnYXRpdmVQcmVmaXgsIG5lZ2F0aXZlU3VmZml4LCBudURpZ2l0c01hcCxcXG5cXHRcXHRudW1iZXJUb2tlbml6ZXIsIHByZWZpeCwgcHJpbWFyeUdyb3VwaW5nU2l6ZSwgc2Vjb25kYXJ5R3JvdXBpbmdTaXplLCBzdWZmaXgsIHN5bWJvbE1hcCxcXG5cXHRcXHRmb3JtYXRQcm9wZXJ0aWVzID0gbnVtYmVyRm9ybWF0UHJvcGVydGllcyggcGF0dGVybiwgY2xkciwgb3B0aW9ucyApO1xcblxcblxcdHByZWZpeCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDAgXSApO1xcblxcdG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IGZvcm1hdFByb3BlcnRpZXNbIDQgXTtcXG5cXHRtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBmb3JtYXRQcm9wZXJ0aWVzWyA1IF07XFxuXFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gZm9ybWF0UHJvcGVydGllc1sgNiBdO1xcblxcdHByaW1hcnlHcm91cGluZ1NpemUgPSBmb3JtYXRQcm9wZXJ0aWVzWyA4IF07XFxuXFx0c2Vjb25kYXJ5R3JvdXBpbmdTaXplID0gZm9ybWF0UHJvcGVydGllc1sgOSBdO1xcblxcdHN1ZmZpeCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDEwIF0gKTtcXG5cXHRuZWdhdGl2ZVByZWZpeCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDEzIF0gKTtcXG5cXHRuZWdhdGl2ZVN1ZmZpeCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDE0IF0gKTtcXG5cXHRpbmZpbml0eVN5bWJvbCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDE2IF0gKTtcXG5cXHRuYW5TeW1ib2wgPSBsb29zZU1hdGNoaW5nKCBmb3JtYXRQcm9wZXJ0aWVzWyAxNyBdICk7XFxuXFx0c3ltYm9sTWFwID0gb2JqZWN0TWFwKCBmb3JtYXRQcm9wZXJ0aWVzWyAxOCBdLCBmdW5jdGlvbiggcGFpciApIHtcXG5cXHRcXHRyZXR1cm4gWyBwYWlyWyAwIF0sIGxvb3NlTWF0Y2hpbmcoIHBhaXJbIDEgXSApIF07XFxuXFx0fSk7XFxuXFx0bnVEaWdpdHNNYXAgPSBmb3JtYXRQcm9wZXJ0aWVzWyAxOSBdO1xcblxcblxcdGludmVydGVkU3ltYm9sTWFwID0gb2JqZWN0TWFwKCBudW1iZXJTeW1ib2xJbnZlcnRlZE1hcCggY2xkciApLCBmdW5jdGlvbiggcGFpciApIHtcXG5cXHRcXHRyZXR1cm4gWyBsb29zZU1hdGNoaW5nKCBwYWlyWyAwIF0gKSwgcGFpclsgMSBdIF07XFxuXFx0fSk7XFxuXFxuXFx0ZGlnaXRzUmUgPSBudURpZ2l0c01hcCA/IFxcXCJbXFxcIiArIG51RGlnaXRzTWFwICsgXFxcIl1cXFwiIDogXFxcIlxcXFxcXFxcZFxcXCI7XFxuXFx0Z3JvdXBpbmdTZXBhcmF0b3JSZSA9IHJlZ2V4cEVzY2FwZSggc3ltYm9sTWFwWyBcXFwiLFxcXCIgXSApO1xcblxcdGRlY2ltYWxTeW1ib2xSZSA9IHJlZ2V4cEVzY2FwZSggc3ltYm9sTWFwWyBcXFwiLlxcXCIgXSApO1xcblxcblxcdGlmICggbnVEaWdpdHNNYXAgKSB7XFxuXFx0XFx0aW52ZXJ0ZWROdURpZ2l0c01hcCA9IG51RGlnaXRzTWFwLnNwbGl0KCBcXFwiXFxcIiApLnJlZHVjZShmdW5jdGlvbiggb2JqZWN0LCBsb2NhbGl6ZWREaWdpdCwgaSApIHtcXG5cXHRcXHRcXHRvYmplY3RbIGxvY2FsaXplZERpZ2l0IF0gPSBTdHJpbmcoIGkgKTtcXG5cXHRcXHRcXHRyZXR1cm4gb2JqZWN0O1xcblxcdFxcdH0sIHt9ICk7XFxuXFx0fVxcblxcblxcdGF1eCA9IFsgcHJlZml4LCBzdWZmaXgsIG5lZ2F0aXZlUHJlZml4LCBuZWdhdGl2ZVN1ZmZpeCBdLm1hcChmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoIC8oJyhbXiddfCcnKSsnfCcnKXwuL2csIGZ1bmN0aW9uKCBjaGFyYWN0ZXIsIGxpdGVyYWwgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gTGl0ZXJhbHNcXG5cXHRcXHRcXHRpZiAoIGxpdGVyYWwgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlbW92ZUxpdGVyYWxRdW90ZXMoIGxpdGVyYWwgKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3ltYm9sc1xcblxcdFxcdFxcdGNoYXJhY3RlciA9IGNoYXJhY3Rlci5yZXBsYWNlKCAvW1xcXFwtK0UlXFxcXHUyMDMwXS8sIGZ1bmN0aW9uKCBzeW1ib2wgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHN5bWJvbE1hcFsgc3ltYm9sIF07XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGNoYXJhY3RlcjtcXG5cXHRcXHR9KTtcXG5cXHR9KTtcXG5cXG5cXHRwcmVmaXggPSBhdXhbIDAgXTtcXG5cXHRzdWZmaXggPSBhdXhbIDEgXTtcXG5cXHRuZWdhdGl2ZVByZWZpeCA9IGF1eFsgMiBdO1xcblxcdG5lZ2F0aXZlU3VmZml4ID0gYXV4WyAzIF07XFxuXFxuXFx0Ly8gTnVtYmVyXFxuXFx0Ly9cXG5cXHQvLyBudW1iZXJfcmUgPSAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdlciBmcmFjdGlvbj9cXG5cXHQvL1xcblxcdC8vIGludGVnZXIgPSAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHMgfCBkaWdpdHNfdXNpbmdfZ3JvdXBpbmdfc2VwYXJhdG9yc1xcblxcdC8vXFxuXFx0Ly8gZnJhY3Rpb24gPSAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cCgoLlxcXFxkKyk/KVxcblxcdC8vXFxuXFx0Ly8gZGlnaXRzID0gICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cChcXFxcZCspXFxuXFx0Ly9cXG5cXHQvLyBkaWdpdHNfd19ncm91cGluZ19zZXBhcmF0b3JzID0gICAgZGlnaXRzX3dfMV9ncm91cGluZ19zZXBhcmF0b3JzIHxcXG5cXHQvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzX3dfMl9ncm91cGluZ19zZXBhcmF0b3JzXFxuXFx0Ly9cXG5cXHQvLyBkaWdpdHNfd18xX2dyb3VwaW5nX3NlcGFyYXRvcnMgPSAgcmVnZXhwKFxcXFxkezEsM30oLFxcXFxkezN9KSspXFxuXFx0Ly9cXG5cXHQvLyBkaWdpdHNfd18yX2dyb3VwaW5nX3NlcGFyYXRvcnMgPSAgcmVnZXhwKFxcXFxkezEsMn0oKCxcXFxcZHsyfSkqKCxcXFxcZHszfSkpKVxcblxcblxcdC8vIEludGVnZXIgcGFydFxcblxcdG51bWJlclRva2VuaXplciA9IGRpZ2l0c1JlICsgXFxcIitcXFwiO1xcblxcblxcdC8vIEdyb3VwaW5nIHNlcGFyYXRvcnNcXG5cXHRpZiAoIHByaW1hcnlHcm91cGluZ1NpemUgKSB7XFxuXFx0XFx0aWYgKCBzZWNvbmRhcnlHcm91cGluZ1NpemUgKSB7XFxuXFx0XFx0XFx0YXV4ID0gZGlnaXRzUmUgKyBcXFwiezEsXFxcIiArIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSArIFxcXCJ9KChcXFwiICsgZ3JvdXBpbmdTZXBhcmF0b3JSZSArXFxuXFx0XFx0XFx0XFx0ZGlnaXRzUmUgKyBcXFwie1xcXCIgKyBzZWNvbmRhcnlHcm91cGluZ1NpemUgKyBcXFwifSkqKFxcXCIgKyBncm91cGluZ1NlcGFyYXRvclJlICtcXG5cXHRcXHRcXHRcXHRkaWdpdHNSZSArIFxcXCJ7XFxcIiArIHByaW1hcnlHcm91cGluZ1NpemUgKyBcXFwifSkpXFxcIjtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGF1eCA9IGRpZ2l0c1JlICsgXFxcInsxLFxcXCIgKyBwcmltYXJ5R3JvdXBpbmdTaXplICsgXFxcIn0oXFxcIiArIGdyb3VwaW5nU2VwYXJhdG9yUmUgK1xcblxcdFxcdFxcdFxcdGRpZ2l0c1JlICsgXFxcIntcXFwiICsgcHJpbWFyeUdyb3VwaW5nU2l6ZSArIFxcXCJ9KStcXFwiO1xcblxcdFxcdH1cXG5cXHRcXHRudW1iZXJUb2tlbml6ZXIgPSBcXFwiKFxcXCIgKyBhdXggKyBcXFwifFxcXCIgKyBudW1iZXJUb2tlbml6ZXIgKyBcXFwiKVxcXCI7XFxuXFx0fVxcblxcblxcdC8vIEZyYWN0aW9uIHBhcnQ/IE9ubHkgaW5jbHVkZWQgaWYgMSBvciAyLlxcblxcdC8vIDE6IFVzaW5nIHNpZ25pZmljYW50IGRpZ2l0IGZvcm1hdC5cXG5cXHQvLyAyOiBVc2luZyBpbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIGZvcm1hdCAmJiBpdCBoYXMgYSBtYXhpbXVtRnJhY3Rpb25EaWdpdHMuXFxuXFx0aWYgKCAhaXNOYU4oIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyAqIG1heGltdW1TaWduaWZpY2FudERpZ2l0cyApIHx8IC8qIDEgKi9cXG5cXHRcXHRcXHRcXHRtYXhpbXVtRnJhY3Rpb25EaWdpdHMgLyogMiAqLyApIHtcXG5cXG5cXHRcXHQvLyAxOiBIYW5kbGUgdHJhaWxpbmcgZGVjaW1hbCBzZXBhcmF0b3IsIGUuZy4sIGBcXFwiMS5cXFwiID0+IGAxYGAuXFxuXFx0XFx0YXV4ID0gZGVjaW1hbFN5bWJvbFJlICsgZGlnaXRzUmUgKyBcXFwiK1xcXCI7XFxuXFx0XFx0bnVtYmVyVG9rZW5pemVyID0gbnVtYmVyVG9rZW5pemVyICsgXFxcIihcXFwiICsgYXV4ICsgXFxcInxcXFwiICsgZGVjaW1hbFN5bWJvbFJlIC8qIDEgKi8gKyBcXFwiKT9cXFwiICtcXG5cXG5cXHRcXHRcXHQvLyBIYW5kbGUgbm9uLXBhZGRlZCBkZWNpbWFscywgZS5nLiwgYFxcXCIuMTJcXFwiYCA9PiBgMC4xMmAgYnkgbWFraW5nIHRoZSBpbnRlZ2VyIHBhcnRcXG5cXHRcXHRcXHQvLyBvcHRpb25hbC5cXG5cXHRcXHRcXHRcXFwifChcXFwiICsgbnVtYmVyVG9rZW5pemVyICsgXFxcIik/XFxcIiArIGF1eDtcXG5cXG5cXHRcXHRudW1iZXJUb2tlbml6ZXIgPSBcXFwiKFxcXCIgKyBudW1iZXJUb2tlbml6ZXIgKyBcXFwiKVxcXCI7XFxuXFx0fVxcblxcblxcdC8vIDA6IEBpbnZlcnRlZFN5bWJvbE1hcCBbT2JqZWN0XSBJbnZlcnRlZCBzeW1ib2wgbWFwLlxcblxcdC8vIDE6IEBpbnZlcnRlZE51RGlnaXRzTWFwIFtPYmplY3RdIEludmVydGVkIGRpZ2l0cyBtYXAgaWYgbnVtYmVyaW5nIHN5c3RlbSBpcyBkaWZmZXJlbnQgdGhhblxcblxcdC8vICAgIGBsYXRuYC5cXG5cXHQvLyAyOiBAdG9rZW5pemVyIFtPYmplY3RdIFRva2VuaXplciBtYXAsIHVzZWQgYnkgcGFyc2VyIHRvIGNvbnN1bWUgaW5wdXQuXFxuXFx0cmV0dXJuIFtcXG5cXHRcXHRpbnZlcnRlZFN5bWJvbE1hcCxcXG5cXHRcXHRpbnZlcnRlZE51RGlnaXRzTWFwLFxcblxcdFxcdHtcXG5cXHRcXHRcXHRpbmZpbml0eTogbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgcmVnZXhwRXNjYXBlKCBpbmZpbml0eVN5bWJvbCApICksXFxuXFx0XFx0XFx0bmFuOiAgbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgcmVnZXhwRXNjYXBlKCBuYW5TeW1ib2wgKSApLFxcblxcdFxcdFxcdG5lZ2F0aXZlUHJlZml4OiBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyByZWdleHBFc2NhcGUoIG5lZ2F0aXZlUHJlZml4ICkgKSxcXG5cXHRcXHRcXHRuZWdhdGl2ZVN1ZmZpeDogbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgcmVnZXhwRXNjYXBlKCBuZWdhdGl2ZVN1ZmZpeCApICksXFxuXFx0XFx0XFx0bnVtYmVyOiBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyBudW1iZXJUb2tlbml6ZXIgKSxcXG5cXHRcXHRcXHRwcmVmaXg6IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHJlZ2V4cEVzY2FwZSggcHJlZml4ICkgKSxcXG5cXHRcXHRcXHRzdWZmaXg6IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHJlZ2V4cEVzY2FwZSggc3VmZml4ICkgKVxcblxcdFxcdH1cXG5cXHRdO1xcblxcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogUGF0dGVybiggc3R5bGUgKVxcbiAqXFxuICogQHN0eWxlIFtTdHJpbmddIFxcXCJkZWNpbWFsXFxcIiAoZGVmYXVsdCkgb3IgXFxcInBlcmNlbnRcXFwiLlxcbiAqXFxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxcbiAqL1xcbnZhciBudW1iZXJQYXR0ZXJuID0gZnVuY3Rpb24oIHN0eWxlLCBjbGRyICkge1xcblxcdGlmICggc3R5bGUgIT09IFxcXCJkZWNpbWFsXFxcIiAmJiBzdHlsZSAhPT0gXFxcInBlcmNlbnRcXFwiICkge1xcblxcdFxcdHRocm93IG5ldyBFcnJvciggXFxcIkludmFsaWQgc3R5bGVcXFwiICk7XFxuXFx0fVxcblxcblxcdHJldHVybiBjbGRyLm1haW4oW1xcblxcdFxcdFxcXCJudW1iZXJzXFxcIixcXG5cXHRcXHRzdHlsZSArIFxcXCJGb3JtYXRzLW51bWJlclN5c3RlbS1cXFwiICsgbnVtYmVyTnVtYmVyaW5nU3lzdGVtKCBjbGRyICksXFxuXFx0XFx0XFxcInN0YW5kYXJkXFxcIlxcblxcdF0pO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogRUJORiByZXByZXNlbnRhdGlvbjpcXG4gKlxcbiAqIGNvbXBhY3RfcGF0dGVybl9yZSA9ICAgICAgIHByZWZpeD9cXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJfcGF0dGVybl9yZVxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeD9cXG4gKlxcbiAqIG51bWJlcl9wYXR0ZXJuX3JlID0gICAgICAgIDArXFxuICpcXG4gKiBSZWdleHAgZ3JvdXBzOlxcbiAqXFxuICogIDA6IGNvbXBhY3RfcGF0dGVybl9yZVxcbiAqICAxOiBwcmVmaXhcXG4gKiAgMjogbnVtYmVyX3BhdHRlcm5fcmUgKHRoZSBudW1iZXIgcGF0dGVybiB0byB1c2UgaW4gY29tcGFjdCBtb2RlKVxcbiAqICAzOiBzdWZmaXhcXG4gKi9cXG52YXIgbnVtYmVyQ29tcGFjdFBhdHRlcm5SZSA9ICggL14oW14wXSopKDArKShbXjBdKikkLyApO1xcblxcblxcblxcblxcbi8qKlxcbiAqIGdvdXBpbmdTZXBhcmF0b3IoIG51bWJlciwgcHJpbWFyeUdyb3VwaW5nU2l6ZSwgc2Vjb25kYXJ5R3JvdXBpbmdTaXplIClcXG4gKlxcbiAqIEBudW1iZXIgW051bWJlcl0uXFxuICpcXG4gKiBAcHJpbWFyeUdyb3VwaW5nU2l6ZSBbTnVtYmVyXVxcbiAqXFxuICogQHNlY29uZGFyeUdyb3VwaW5nU2l6ZSBbTnVtYmVyXVxcbiAqXFxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgbnVtYmVyIHdpdGggZ3JvdXAgc2VwYXJhdG9yLlxcbiAqL1xcbnZhciBudW1iZXJGb3JtYXRHcm91cGluZ1NlcGFyYXRvciA9IGZ1bmN0aW9uKCBudW1iZXIsIHByaW1hcnlHcm91cGluZ1NpemUsIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSApIHtcXG5cXHR2YXIgaW5kZXgsXFxuXFx0XFx0Y3VycmVudEdyb3VwaW5nU2l6ZSA9IHByaW1hcnlHcm91cGluZ1NpemUsXFxuXFx0XFx0cmV0ID0gXFxcIlxcXCIsXFxuXFx0XFx0c2VwID0gXFxcIixcXFwiLFxcblxcdFxcdHN3aXRjaFRvU2Vjb25kYXJ5ID0gc2Vjb25kYXJ5R3JvdXBpbmdTaXplID8gdHJ1ZSA6IGZhbHNlO1xcblxcblxcdG51bWJlciA9IFN0cmluZyggbnVtYmVyICkuc3BsaXQoIFxcXCIuXFxcIiApO1xcblxcdGluZGV4ID0gbnVtYmVyWyAwIF0ubGVuZ3RoO1xcblxcblxcdHdoaWxlICggaW5kZXggPiBjdXJyZW50R3JvdXBpbmdTaXplICkge1xcblxcdFxcdHJldCA9IG51bWJlclsgMCBdLnNsaWNlKCBpbmRleCAtIGN1cnJlbnRHcm91cGluZ1NpemUsIGluZGV4ICkgK1xcblxcdFxcdFxcdCggcmV0Lmxlbmd0aCA/IHNlcCA6IFxcXCJcXFwiICkgKyByZXQ7XFxuXFx0XFx0aW5kZXggLT0gY3VycmVudEdyb3VwaW5nU2l6ZTtcXG5cXHRcXHRpZiAoIHN3aXRjaFRvU2Vjb25kYXJ5ICkge1xcblxcdFxcdFxcdGN1cnJlbnRHcm91cGluZ1NpemUgPSBzZWNvbmRhcnlHcm91cGluZ1NpemU7XFxuXFx0XFx0XFx0c3dpdGNoVG9TZWNvbmRhcnkgPSBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdG51bWJlclsgMCBdID0gbnVtYmVyWyAwIF0uc2xpY2UoIDAsIGluZGV4ICkgKyAoIHJldC5sZW5ndGggPyBzZXAgOiBcXFwiXFxcIiApICsgcmV0O1xcblxcdHJldHVybiBudW1iZXIuam9pbiggXFxcIi5cXFwiICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBpbnRlZ2VyRnJhY3Rpb25EaWdpdHMoIG51bWJlciwgbWluaW11bUludGVnZXJEaWdpdHMsIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcXG4gKiBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIHJvdW5kLCByb3VuZEluY3JlbWVudCApXFxuICpcXG4gKiBAbnVtYmVyIFtOdW1iZXJdXFxuICpcXG4gKiBAbWluaW11bUludGVnZXJEaWdpdHMgW051bWJlcl1cXG4gKlxcbiAqIEBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgW051bWJlcl1cXG4gKlxcbiAqIEBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgW051bWJlcl1cXG4gKlxcbiAqIEByb3VuZCBbRnVuY3Rpb25dXFxuICpcXG4gKiBAcm91bmRJbmNyZW1lbnQgW0Z1bmN0aW9uXVxcbiAqXFxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgaW50ZWdlciBhbmQgZnJhY3Rpb24gZGlnaXRzLlxcbiAqL1xcbnZhciBudW1iZXJGb3JtYXRJbnRlZ2VyRnJhY3Rpb25EaWdpdHMgPSBmdW5jdGlvbiggbnVtYmVyLCBtaW5pbXVtSW50ZWdlckRpZ2l0cywgbWluaW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIHJvdW5kLFxcblxcdHJvdW5kSW5jcmVtZW50ICkge1xcblxcblxcdC8vIEZyYWN0aW9uXFxuXFx0aWYgKCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgKSB7XFxuXFxuXFx0XFx0Ly8gUm91bmRpbmdcXG5cXHRcXHRpZiAoIHJvdW5kSW5jcmVtZW50ICkge1xcblxcdFxcdFxcdG51bWJlciA9IHJvdW5kKCBudW1iZXIsIHJvdW5kSW5jcmVtZW50ICk7XFxuXFxuXFx0XFx0Ly8gTWF4aW11bSBmcmFjdGlvbiBkaWdpdHNcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdG51bWJlciA9IHJvdW5kKCBudW1iZXIsIHsgZXhwb25lbnQ6IC1tYXhpbXVtRnJhY3Rpb25EaWdpdHMgfSApO1xcblxcdFxcdH1cXG5cXG5cXHR9IGVsc2Uge1xcblxcdFxcdG51bWJlciA9IHJvdW5kKCBudW1iZXIgKTtcXG5cXHR9XFxuXFxuXFx0bnVtYmVyID0gU3RyaW5nKCBudW1iZXIgKTtcXG5cXG5cXHQvLyBNYXhpbXVtIGludGVnZXIgZGlnaXRzIChwb3N0IHN0cmluZyBwaGFzZSlcXG5cXHRpZiAoIG1heGltdW1GcmFjdGlvbkRpZ2l0cyAmJiAvZS0vLnRlc3QoIG51bWJlciApICkge1xcblxcblxcdFxcdC8vIFVzZSB0b0ZpeGVkKCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgKSB0byBtYWtlIHN1cmUgc21hbGwgbnVtYmVycyBsaWtlIDFlLTcgYXJlXFxuXFx0XFx0Ly8gZGlzcGxheWVkIHVzaW5nIHBsYWluIGRpZ2l0cyBpbnN0ZWFkIG9mIHNjaWVudGlmaWMgbm90YXRpb24uXFxuXFx0XFx0Ly8gMTogUmVtb3ZlIGxlYWRpbmcgZGVjaW1hbCB6ZXJvcy5cXG5cXHRcXHQvLyAyOiBSZW1vdmUgbGVhZGluZyBkZWNpbWFsIHNlcGFyYXRvci5cXG5cXHRcXHQvLyBOb3RlOiBTdHJpbmcoKSBpcyBzdGlsbCBwcmVmZXJyZWQgc28gaXQgZG9lc24ndCBtZXNzIHVwIHdpdGggYSBudW1iZXIgcHJlY2lzaW9uXFxuXFx0XFx0Ly8gdW5uZWNlc3NhcmlseSwgZS5nLiwgKDEyMzQ1Njc4OS4xMjMpLnRvRml4ZWQoMTApID09PSBcXFwiMTIzNDU2Nzg5LjEyMjk5OTk5NTlcXFwiLFxcblxcdFxcdC8vIFN0cmluZygxMjM0NTY3ODkuMTIzKSA9PT0gXFxcIjEyMzQ1Njc4OS4xMjNcXFwiLlxcblxcdFxcdG51bWJlciA9ICggK251bWJlciApLnRvRml4ZWQoIG1heGltdW1GcmFjdGlvbkRpZ2l0cyApXFxuXFx0XFx0XFx0LnJlcGxhY2UoIC8wKyQvLCBcXFwiXFxcIiApIC8qIDEgKi9cXG5cXHRcXHRcXHQucmVwbGFjZSggL1xcXFwuJC8sIFxcXCJcXFwiICkgLyogMiAqLztcXG5cXHR9XFxuXFxuXFx0Ly8gTWluaW11bSBmcmFjdGlvbiBkaWdpdHMgKHBvc3Qgc3RyaW5nIHBoYXNlKVxcblxcdGlmICggbWluaW11bUZyYWN0aW9uRGlnaXRzICkge1xcblxcdFxcdG51bWJlciA9IG51bWJlci5zcGxpdCggXFxcIi5cXFwiICk7XFxuXFx0XFx0bnVtYmVyWyAxIF0gPSBzdHJpbmdQYWQoIG51bWJlclsgMSBdIHx8IFxcXCJcXFwiLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIHRydWUgKTtcXG5cXHRcXHRudW1iZXIgPSBudW1iZXIuam9pbiggXFxcIi5cXFwiICk7XFxuXFx0fVxcblxcblxcdC8vIE1pbmltdW0gaW50ZWdlciBkaWdpdHNcXG5cXHRpZiAoIG1pbmltdW1JbnRlZ2VyRGlnaXRzICkge1xcblxcdFxcdG51bWJlciA9IG51bWJlci5zcGxpdCggXFxcIi5cXFwiICk7XFxuXFx0XFx0bnVtYmVyWyAwIF0gPSBzdHJpbmdQYWQoIG51bWJlclsgMCBdLCBtaW5pbXVtSW50ZWdlckRpZ2l0cyApO1xcblxcdFxcdG51bWJlciA9IG51bWJlci5qb2luKCBcXFwiLlxcXCIgKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIG51bWJlcjtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIHRvUHJlY2lzaW9uKCBudW1iZXIsIHByZWNpc2lvbiwgcm91bmQgKVxcbiAqXFxuICogQG51bWJlciAoTnVtYmVyKVxcbiAqXFxuICogQHByZWNpc2lvbiAoTnVtYmVyKSBzaWduaWZpY2FudCBmaWd1cmVzIHByZWNpc2lvbiAobm90IGRlY2ltYWwgcHJlY2lzaW9uKS5cXG4gKlxcbiAqIEByb3VuZCAoRnVuY3Rpb24pXFxuICpcXG4gKiBSZXR1cm4gbnVtYmVyLnRvUHJlY2lzaW9uKCBwcmVjaXNpb24gKSB1c2luZyB0aGUgZ2l2ZW4gcm91bmQgZnVuY3Rpb24uXFxuICovXFxudmFyIG51bWJlclRvUHJlY2lzaW9uID0gZnVuY3Rpb24oIG51bWJlciwgcHJlY2lzaW9uLCByb3VuZCApIHtcXG5cXHR2YXIgcm91bmRPcmRlcjtcXG5cXG5cXHRpZiAoIG51bWJlciA9PT0gMCApIHsgIC8vIEZpeCAjNzA2XFxuXFx0XFx0cmV0dXJuIG51bWJlcjtcXG5cXHR9XFxuXFxuXFx0cm91bmRPcmRlciA9IE1hdGguY2VpbCggTWF0aC5sb2coIE1hdGguYWJzKCBudW1iZXIgKSApIC8gTWF0aC5sb2coIDEwICkgKTtcXG5cXHRyb3VuZE9yZGVyIC09IHByZWNpc2lvbjtcXG5cXG5cXHRyZXR1cm4gcm91bmQoIG51bWJlciwgeyBleHBvbmVudDogcm91bmRPcmRlciB9ICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiB0b1ByZWNpc2lvbiggbnVtYmVyLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIG1heGltdW1TaWduaWZpY2FudERpZ2l0cywgcm91bmQgKVxcbiAqXFxuICogQG51bWJlciBbTnVtYmVyXVxcbiAqXFxuICogQG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyBbTnVtYmVyXVxcbiAqXFxuICogQG1heGltdW1TaWduaWZpY2FudERpZ2l0cyBbTnVtYmVyXVxcbiAqXFxuICogQHJvdW5kIFtGdW5jdGlvbl1cXG4gKlxcbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIHNpZ25pZmljYW50IGRpZ2l0cyBudW1iZXIuXFxuICovXFxudmFyIG51bWJlckZvcm1hdFNpZ25pZmljYW50RGlnaXRzID0gZnVuY3Rpb24oIG51bWJlciwgbWluaW11bVNpZ25pZmljYW50RGlnaXRzLCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsIHJvdW5kICkge1xcblxcdHZhciBhdE1pbmltdW0sIGF0TWF4aW11bTtcXG5cXG5cXHQvLyBTYW5pdHkgY2hlY2suXFxuXFx0aWYgKCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPiBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgKSB7XFxuXFx0XFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gbWluaW11bVNpZ25pZmljYW50RGlnaXRzO1xcblxcdH1cXG5cXG5cXHRhdE1pbmltdW0gPSBudW1iZXJUb1ByZWNpc2lvbiggbnVtYmVyLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIHJvdW5kICk7XFxuXFx0YXRNYXhpbXVtID0gbnVtYmVyVG9QcmVjaXNpb24oIG51bWJlciwgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzLCByb3VuZCApO1xcblxcblxcdC8vIFVzZSBhdE1heGltdW0gb25seSBpZiBpdCBoYXMgbW9yZSBzaWduaWZpY2FudCBkaWdpdHMgdGhhbiBhdE1pbmltdW0uXFxuXFx0bnVtYmVyID0gK2F0TWluaW11bSA9PT0gK2F0TWF4aW11bSA/IGF0TWluaW11bSA6IGF0TWF4aW11bTtcXG5cXG5cXHQvLyBFeHBhbmQgaW50ZWdlciBudW1iZXJzLCBlZy4gMTIzZTUgdG8gMTIzMDAuXFxuXFx0bnVtYmVyID0gKCArbnVtYmVyICkudG9TdHJpbmcoIDEwICk7XFxuXFxuXFx0aWYgKCAoIC9lLyApLnRlc3QoIG51bWJlciApICkge1xcblxcdFxcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcXG5cXHRcXHRcXHRmZWF0dXJlOiBcXFwiaW50ZWdlcnMgb3V0IG9mICgxZTIxLCAxZS03KVxcXCJcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0Ly8gQWRkIHRyYWlsaW5nIHplcm9zIGlmIG5lY2Vzc2FyeS5cXG5cXHRpZiAoIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyAtIG51bWJlci5yZXBsYWNlKCAvXjArfFxcXFwuL2csIFxcXCJcXFwiICkubGVuZ3RoID4gMCApIHtcXG5cXHRcXHRudW1iZXIgPSBudW1iZXIuc3BsaXQoIFxcXCIuXFxcIiApO1xcblxcdFxcdG51bWJlclsgMSBdID0gc3RyaW5nUGFkKCBudW1iZXJbIDEgXSB8fCBcXFwiXFxcIiwgbWluaW11bVNpZ25pZmljYW50RGlnaXRzIC0gbnVtYmVyWyAwIF0ucmVwbGFjZSggL14wKy8sIFxcXCJcXFwiICkubGVuZ3RoLCB0cnVlICk7XFxuXFx0XFx0bnVtYmVyID0gbnVtYmVyLmpvaW4oIFxcXCIuXFxcIiApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gbnVtYmVyO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogZm9ybWF0KCBudW1iZXIsIHByb3BlcnRpZXMgKVxcbiAqXFxuICogQG51bWJlciBbTnVtYmVyXS5cXG4gKlxcbiAqIEBwcm9wZXJ0aWVzIFtPYmplY3RdIE91dHB1dCBvZiBudW1iZXIvZm9ybWF0LXByb3BlcnRpZXMuXFxuICpcXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBudW1iZXIuXFxuICogcmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LW51bWJlcnMuaHRtbFxcbiAqL1xcbnZhciBudW1iZXJGb3JtYXQgPSBmdW5jdGlvbiggbnVtYmVyLCBwcm9wZXJ0aWVzLCBwbHVyYWxHZW5lcmF0b3IgKSB7XFxuXFx0dmFyIGF1eCwgY29tcGFjdE1hcCwgaW5maW5pdHlTeW1ib2wsIG1heGltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzLFxcblxcdFxcdG1pbmltdW1GcmFjdGlvbkRpZ2l0cywgbWluaW11bUludGVnZXJEaWdpdHMsIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgbmFuU3ltYm9sLFxcblxcdFxcdG51RGlnaXRzTWFwLCBwYWRkaW5nLCBwcmVmaXgsIHByaW1hcnlHcm91cGluZ1NpemUsIHBhdHRlcm4sIHJvdW5kLCByb3VuZEluY3JlbWVudCxcXG5cXHRcXHRzZWNvbmRhcnlHcm91cGluZ1NpemUsIHN0cmluZ1RvUGFydHMsIHN1ZmZpeCwgc3ltYm9sTWFwO1xcblxcblxcdHBhZGRpbmcgPSBwcm9wZXJ0aWVzWyAxIF07XFxuXFx0bWluaW11bUludGVnZXJEaWdpdHMgPSBwcm9wZXJ0aWVzWyAyIF07XFxuXFx0bWluaW11bUZyYWN0aW9uRGlnaXRzID0gcHJvcGVydGllc1sgMyBdO1xcblxcdG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IHByb3BlcnRpZXNbIDQgXTtcXG5cXHRtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBwcm9wZXJ0aWVzWyA1IF07XFxuXFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gcHJvcGVydGllc1sgNiBdO1xcblxcdHJvdW5kSW5jcmVtZW50ID0gcHJvcGVydGllc1sgNyBdO1xcblxcdHByaW1hcnlHcm91cGluZ1NpemUgPSBwcm9wZXJ0aWVzWyA4IF07XFxuXFx0c2Vjb25kYXJ5R3JvdXBpbmdTaXplID0gcHJvcGVydGllc1sgOSBdO1xcblxcdHJvdW5kID0gcHJvcGVydGllc1sgMTUgXTtcXG5cXHRpbmZpbml0eVN5bWJvbCA9IHByb3BlcnRpZXNbIDE2IF07XFxuXFx0bmFuU3ltYm9sID0gcHJvcGVydGllc1sgMTcgXTtcXG5cXHRzeW1ib2xNYXAgPSBwcm9wZXJ0aWVzWyAxOCBdO1xcblxcdG51RGlnaXRzTWFwID0gcHJvcGVydGllc1sgMTkgXTtcXG5cXHRjb21wYWN0TWFwID0gcHJvcGVydGllc1sgMjAgXTtcXG5cXG5cXHQvLyBOYU5cXG5cXHRpZiAoIGlzTmFOKCBudW1iZXIgKSApIHtcXG5cXHRcXHRyZXR1cm4gWyB7IHR5cGU6IFxcXCJuYW5cXFwiLCB2YWx1ZTogbmFuU3ltYm9sIH0gXTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBudW1iZXIgPCAwICkge1xcblxcdFxcdHBhdHRlcm4gPSBwcm9wZXJ0aWVzWyAxMiBdO1xcblxcdFxcdHByZWZpeCA9IHByb3BlcnRpZXNbIDEzIF07XFxuXFx0XFx0c3VmZml4ID0gcHJvcGVydGllc1sgMTQgXTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHBhdHRlcm4gPSBwcm9wZXJ0aWVzWyAxMSBdO1xcblxcdFxcdHByZWZpeCA9IHByb3BlcnRpZXNbIDAgXTtcXG5cXHRcXHRzdWZmaXggPSBwcm9wZXJ0aWVzWyAxMCBdO1xcblxcdH1cXG5cXG5cXHQvLyBGb3IgcHJlZml4LCBzdWZmaXgsIGFuZCBudW1iZXIgcGFydHMuXFxuXFx0c3RyaW5nVG9QYXJ0cyA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XFxuXFx0XFx0dmFyIG51bWJlclR5cGUgPSBcXFwiaW50ZWdlclxcXCIsXFxuXFx0XFx0XFx0cGFydHMgPSBbXTtcXG5cXG5cXHRcXHQvLyBUT0RPIE1vdmUgdGhlIHRva2VuaXphdGlvbiBvZiBhbGwgcGFydHMgdGhhdCBkb24ndCBkZXBlbmQgb24gbnVtYmVyIGludG9cXG5cXHRcXHQvLyBmb3JtYXQtcHJvcGVydGllcy5cXG5cXHRcXHRzdHJpbmcucmVwbGFjZSggLygnKFteJ118JycpKyd8JycpfC4vZywgZnVuY3Rpb24oIGNoYXJhY3RlciwgbGl0ZXJhbCApIHtcXG5cXG5cXHRcXHRcXHQvLyBMaXRlcmFsc1xcblxcdFxcdFxcdGlmICggbGl0ZXJhbCApIHtcXG5cXHRcXHRcXHRcXHRwYXJ0c1B1c2goIHBhcnRzLCBcXFwibGl0ZXJhbFxcXCIsIHJlbW92ZUxpdGVyYWxRdW90ZXMoIGxpdGVyYWwgKSApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ3VycmVuY3kgc3ltYm9sXFxuXFx0XFx0XFx0aWYgKCBjaGFyYWN0ZXIgPT09IFxcXCJcXFxcdTAwQTRcXFwiICkge1xcblxcdFxcdFxcdFxcdHBhcnRzUHVzaCggcGFydHMsIFxcXCJjdXJyZW5jeVxcXCIsIGNoYXJhY3RlciApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3ltYm9sc1xcblxcdFxcdFxcdGNoYXJhY3RlciA9IGNoYXJhY3Rlci5yZXBsYWNlKCAvWy4sXFxcXC0rRSVcXFxcdTIwMzBdLywgZnVuY3Rpb24oIHN5bWJvbCApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIHN5bWJvbCA9PT0gXFxcIi5cXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdG51bWJlclR5cGUgPSBcXFwiZnJhY3Rpb25cXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRwYXJ0c1B1c2goIHBhcnRzLCBudW1iZXJTeW1ib2xOYW1lW3N5bWJvbF0sIHN5bWJvbE1hcFsgc3ltYm9sIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBcXFwiRXJhc2VcXFwiIGhhbmRsZWQgY2hhcmFjdGVyLlxcblxcdFxcdFxcdFxcdHJldHVybiBcXFwiXFxcIjtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBOdW1iZXJcXG5cXHRcXHRcXHRjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIucmVwbGFjZSggL1swLTldLywgZnVuY3Rpb24oIGRpZ2l0ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIE51bWJlcmluZyBzeXN0ZW1cXG5cXHRcXHRcXHRcXHRpZiAoIG51RGlnaXRzTWFwICkge1xcblxcdFxcdFxcdFxcdFxcdGRpZ2l0ID0gbnVEaWdpdHNNYXBbICtkaWdpdCBdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRwYXJ0c1B1c2goIHBhcnRzLCBudW1iZXJUeXBlLCBkaWdpdCApO1xcblxcblxcdFxcdFxcdFxcdC8vIFxcXCJFcmFzZVxcXCIgaGFuZGxlZCBjaGFyYWN0ZXIuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFxcXCJcXFwiO1xcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdC8vIEV0Y1xcblxcdFxcdFxcdGNoYXJhY3Rlci5yZXBsYWNlKCAvLi8sIGZ1bmN0aW9uKCBldGMgKSB7XFxuXFx0XFx0XFx0XFx0cGFydHNQdXNoKCBwYXJ0cywgXFxcImxpdGVyYWxcXFwiLCBldGMgKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9KTtcXG5cXHRcXHRyZXR1cm4gcGFydHM7XFxuXFx0fTtcXG5cXG5cXHRwcmVmaXggPSBzdHJpbmdUb1BhcnRzKCBwcmVmaXggKTtcXG5cXHRzdWZmaXggPSBzdHJpbmdUb1BhcnRzKCBzdWZmaXggKTtcXG5cXG5cXHQvLyBJbmZpbml0eVxcblxcdGlmICggIWlzRmluaXRlKCBudW1iZXIgKSApIHtcXG5cXHRcXHRyZXR1cm4gcHJlZml4LmNvbmNhdChcXG5cXHRcXHRcXHR7IHR5cGU6IFxcXCJpbmZpbml0eVxcXCIsIHZhbHVlOiBpbmZpbml0eVN5bWJvbCB9LFxcblxcdFxcdFxcdHN1ZmZpeFxcblxcdFxcdCk7XFxuXFx0fVxcblxcblxcdC8vIFBlcmNlbnRcXG5cXHRpZiAoIHBhdHRlcm4uaW5kZXhPZiggXFxcIiVcXFwiICkgIT09IC0xICkge1xcblxcdFxcdG51bWJlciAqPSAxMDA7XFxuXFxuXFx0Ly8gUGVyIG1pbGxlXFxuXFx0fSBlbHNlIGlmICggcGF0dGVybi5pbmRleE9mKCBcXFwiXFxcXHUyMDMwXFxcIiApICE9PSAtMSApIHtcXG5cXHRcXHRudW1iZXIgKj0gMTAwMDtcXG5cXHR9XFxuXFxuXFx0dmFyIGNvbXBhY3RQYXR0ZXJuLCBjb21wYWN0RGlnaXRzLCBjb21wYWN0UHJvcGVydGllcywgZGl2aXNvciwgbnVtYmVyRXhwb25lbnQsIHBsdXJhbEZvcm07XFxuXFxuXFx0Ly8gQ29tcGFjdCBtb2RlOiBpbml0aWFsIG51bWJlciBkaWdpdCBwcm9jZXNzaW5nXFxuXFx0aWYgKCBjb21wYWN0TWFwICkge1xcblxcdFxcdG51bWJlckV4cG9uZW50ID0gTWF0aC5hYnMoIE1hdGguZmxvb3IoIG51bWJlciApICkudG9TdHJpbmcoKS5sZW5ndGggLSAxO1xcblxcdFxcdG51bWJlckV4cG9uZW50ID0gTWF0aC5taW4oIG51bWJlckV4cG9uZW50LCBjb21wYWN0TWFwLm1heEV4cG9uZW50ICk7XFxuXFxuXFx0XFx0Ly8gVXNlIGRlZmF1bHQgcGx1cmFsIGZvcm0gdG8gcGVyZm9ybSBpbml0aWFsIGRlY2ltYWwgc2hpZnRcXG5cXHRcXHRpZiAoIG51bWJlckV4cG9uZW50ID49IDMgKSB7XFxuXFx0XFx0XFx0Y29tcGFjdFBhdHRlcm4gPSBjb21wYWN0TWFwWyBudW1iZXJFeHBvbmVudCBdICYmIGNvbXBhY3RNYXBbIG51bWJlckV4cG9uZW50IF0ub3RoZXI7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggY29tcGFjdFBhdHRlcm4gPT09IFxcXCIwXFxcIiApIHtcXG5cXHRcXHRcXHRjb21wYWN0UGF0dGVybiA9IG51bGw7XFxuXFx0XFx0fSBlbHNlIGlmICggY29tcGFjdFBhdHRlcm4gKSB7XFxuXFx0XFx0XFx0Y29tcGFjdERpZ2l0cyA9IGNvbXBhY3RQYXR0ZXJuLnNwbGl0KCBcXFwiMFxcXCIgKS5sZW5ndGggLSAxO1xcblxcdFxcdFxcdGRpdmlzb3IgPSBudW1iZXJFeHBvbmVudCAtICggY29tcGFjdERpZ2l0cyAtIDEgKTtcXG5cXHRcXHRcXHRudW1iZXIgPSBudW1iZXIgLyBNYXRoLnBvdyggMTAsIGRpdmlzb3IgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdC8vIFNpZ25pZmljYW50IGRpZ2l0IGZvcm1hdFxcblxcdGlmICggIWlzTmFOKCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgKiBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgKSApIHtcXG5cXHRcXHRudW1iZXIgPSBudW1iZXJGb3JtYXRTaWduaWZpY2FudERpZ2l0cyggbnVtYmVyLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsXFxuXFx0XFx0XFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzLCByb3VuZCApO1xcblxcblxcdC8vIEludGVnZXIgYW5kIGZyYWN0aW9uYWwgZm9ybWF0XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRudW1iZXIgPSBudW1iZXJGb3JtYXRJbnRlZ2VyRnJhY3Rpb25EaWdpdHMoIG51bWJlciwgbWluaW11bUludGVnZXJEaWdpdHMsXFxuXFx0XFx0XFx0bWluaW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIHJvdW5kLCByb3VuZEluY3JlbWVudCApO1xcblxcdH1cXG5cXG5cXHQvLyBDb21wYWN0IG1vZGU6IGFwcGx5IGZvcm1hdHRpbmdcXG5cXHRpZiAoIGNvbXBhY3RNYXAgJiYgY29tcGFjdFBhdHRlcm4gKSB7XFxuXFxuXFx0XFx0Ly8gR2V0IHBsdXJhbCBmb3JtIGFmdGVyIHBvc3NpYmxlIHJvdW5kaW5nc1xcblxcdFxcdHBsdXJhbEZvcm0gPSBwbHVyYWxHZW5lcmF0b3IgPyBwbHVyYWxHZW5lcmF0b3IoICtudW1iZXIgKSA6IFxcXCJvdGhlclxcXCI7XFxuXFxuXFx0XFx0Y29tcGFjdFBhdHRlcm4gPSBjb21wYWN0TWFwWyBudW1iZXJFeHBvbmVudCBdWyBwbHVyYWxGb3JtIF0gfHwgY29tcGFjdFBhdHRlcm47XFxuXFx0XFx0Y29tcGFjdFByb3BlcnRpZXMgPSBjb21wYWN0UGF0dGVybi5tYXRjaCggbnVtYmVyQ29tcGFjdFBhdHRlcm5SZSApO1xcblxcblxcdFxcdC8vIFRPRE8gTW92ZSB0aGUgdG9rZW5pemF0aW9uIG9mIGFsbCBwYXJ0cyB0aGF0IGRvbid0IGRlcGVuZCBvbiBudW1iZXIgaW50b1xcblxcdFxcdC8vIGZvcm1hdC1wcm9wZXJ0aWVzLlxcblxcdFxcdGF1eCA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XFxuXFx0XFx0XFx0dmFyIHBhcnRzID0gW107XFxuXFx0XFx0XFx0c3RyaW5nLnJlcGxhY2UoIC8oXFxcXHMrKXwoW15cXFxcczBdKykvZywgZnVuY3Rpb24oIGdhcmJhZ2UsIHNwYWNlLCBjb21wYWN0ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIExpdGVyYWxzXFxuXFx0XFx0XFx0XFx0aWYgKCBzcGFjZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJ0c1B1c2goIHBhcnRzLCBcXFwibGl0ZXJhbFxcXCIsIHNwYWNlICk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBDb21wYWN0IHZhbHVlXFxuXFx0XFx0XFx0XFx0aWYgKCBjb21wYWN0ICkge1xcblxcdFxcdFxcdFxcdFxcdHBhcnRzUHVzaCggcGFydHMsIFxcXCJjb21wYWN0XFxcIiwgY29tcGFjdCApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0cmV0dXJuIHBhcnRzO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gdXBkYXRlIHByZWZpeC9zdWZmaXggd2l0aCBjb21wYWN0IHByZWZpeC9zdWZmaXhcXG5cXHRcXHRwcmVmaXggPSBwcmVmaXguY29uY2F0KCBhdXgoIGNvbXBhY3RQcm9wZXJ0aWVzWyAxIF0gKSApO1xcblxcdFxcdHN1ZmZpeCA9IGF1eCggY29tcGFjdFByb3BlcnRpZXNbIDMgXSApLmNvbmNhdCggc3VmZml4ICk7XFxuXFx0fVxcblxcblxcdC8vIFJlbW92ZSB0aGUgcG9zc2libGUgbnVtYmVyIG1pbnVzIHNpZ25cXG5cXHRudW1iZXIgPSBudW1iZXIucmVwbGFjZSggL14tLywgXFxcIlxcXCIgKTtcXG5cXG5cXHQvLyBHcm91cGluZyBzZXBhcmF0b3JzXFxuXFx0aWYgKCBwcmltYXJ5R3JvdXBpbmdTaXplICkge1xcblxcdFxcdG51bWJlciA9IG51bWJlckZvcm1hdEdyb3VwaW5nU2VwYXJhdG9yKCBudW1iZXIsIHByaW1hcnlHcm91cGluZ1NpemUsXFxuXFx0XFx0XFx0c2Vjb25kYXJ5R3JvdXBpbmdTaXplICk7XFxuXFx0fVxcblxcblxcdC8vIFNjaWVudGlmaWMgbm90YXRpb25cXG5cXHQvLyBUT0RPIGltcGxlbWVudCBoZXJlXFxuXFxuXFx0Ly8gUGFkZGluZy8nKFteJ118JycpKyd8Jyd8Wy4sXFxcXC0rRSVcXFxcdTIwMzBdL2dcXG5cXHQvLyBUT0RPIGltcGxlbWVudCBoZXJlXFxuXFxuXFx0cmV0dXJuIHByZWZpeC5jb25jYXQoXFxuXFx0XFx0c3RyaW5nVG9QYXJ0cyggbnVtYmVyICksXFxuXFx0XFx0c3VmZml4XFxuXFx0KTtcXG59O1xcblxcblxcblxcblxcbnZhciBudW1iZXJUb1BhcnRzRm9ybWF0dGVyRm4gPSBmdW5jdGlvbiggcHJvcGVydGllcywgcGx1cmFsR2VuZXJhdG9yICkge1xcblxcdHJldHVybiBmdW5jdGlvbiBudW1iZXJUb1BhcnRzRm9ybWF0dGVyKCB2YWx1ZSApIHtcXG5cXHRcXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdFxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gbnVtYmVyRm9ybWF0KCB2YWx1ZSwgcHJvcGVydGllcywgcGx1cmFsR2VuZXJhdG9yICk7XFxuXFx0fTtcXG59O1xcblxcblxcblxcblxcbmZ1bmN0aW9uIHZhbGlkYXRlRGlnaXRzKCBwcm9wZXJ0aWVzICkge1xcblxcdHZhciBtaW5pbXVtSW50ZWdlckRpZ2l0cyA9IHByb3BlcnRpZXNbIDIgXSxcXG5cXHRcXHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBwcm9wZXJ0aWVzWyAzIF0sXFxuXFx0XFx0bWF4aW11bUZyYWN0aW9uRGlnaXRzID0gcHJvcGVydGllc1sgNCBdLFxcblxcdFxcdG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyA9IHByb3BlcnRpZXNbIDUgXSxcXG5cXHRcXHRtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBwcm9wZXJ0aWVzWyA2IF07XFxuXFxuXFx0Ly8gVmFsaWRhdGUgc2lnbmlmaWNhbnQgZGlnaXQgZm9ybWF0IHByb3BlcnRpZXNcXG5cXHRpZiAoICFpc05hTiggbWluaW11bVNpZ25pZmljYW50RGlnaXRzICogbWF4aW11bVNpZ25pZmljYW50RGlnaXRzICkgKSB7XFxuXFx0XFx0dmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSggbWluaW11bVNpZ25pZmljYW50RGlnaXRzLCBcXFwibWluaW11bVNpZ25pZmljYW50RGlnaXRzXFxcIiwgMSwgMjEgKTtcXG5cXHRcXHR2YWxpZGF0ZVBhcmFtZXRlclJhbmdlKCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsIFxcXCJtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHNcXFwiLFxcblxcdFxcdFxcdG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgMjEgKTtcXG5cXG5cXHR9IGVsc2UgaWYgKCAhaXNOYU4oIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyApIHx8ICFpc05hTiggbWF4aW11bVNpZ25pZmljYW50RGlnaXRzICkgKSB7XFxuXFx0XFx0dGhyb3cgbmV3IEVycm9yKCBcXFwiTmVpdGhlciBvciBib3RoIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHNpZ25pZmljYW50IGRpZ2l0cyBtdXN0IGJlIFxcXCIgK1xcblxcdFxcdFxcdFxcXCJwcmVzZW50XFxcIiApO1xcblxcblxcdC8vIFZhbGlkYXRlIGludGVnZXIgYW5kIGZyYWN0aW9uYWwgZm9ybWF0XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR2YWxpZGF0ZVBhcmFtZXRlclJhbmdlKCBtaW5pbXVtSW50ZWdlckRpZ2l0cywgXFxcIm1pbmltdW1JbnRlZ2VyRGlnaXRzXFxcIiwgMSwgMjEgKTtcXG5cXHRcXHR2YWxpZGF0ZVBhcmFtZXRlclJhbmdlKCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIFxcXCJtaW5pbXVtRnJhY3Rpb25EaWdpdHNcXFwiLCAwLCAyMCApO1xcblxcdFxcdHZhbGlkYXRlUGFyYW1ldGVyUmFuZ2UoIG1heGltdW1GcmFjdGlvbkRpZ2l0cywgXFxcIm1heGltdW1GcmFjdGlvbkRpZ2l0c1xcXCIsXFxuXFx0XFx0XFx0bWluaW11bUZyYWN0aW9uRGlnaXRzLCAyMCApO1xcblxcdH1cXG59XFxuXFxuLyoqXFxuICogLm51bWJlckZvcm1hdHRlciggW29wdGlvbnNdIClcXG4gKlxcbiAqIEBvcHRpb25zIFtPYmplY3RdOlxcbiAqIC0gc3R5bGU6IFtTdHJpbmddIFxcXCJkZWNpbWFsXFxcIiAoZGVmYXVsdCkgb3IgXFxcInBlcmNlbnRcXFwiLlxcbiAqIC0gc2VlIGFsc28gbnVtYmVyL2Zvcm1hdCBvcHRpb25zLlxcbiAqXFxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgbnVtYmVyIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgZGVmYXVsdC9pbnN0YW5jZVxcbiAqIGxvY2FsZS5cXG4gKi9cXG5HbG9iYWxpemUubnVtYmVyRm9ybWF0dGVyID1cXG5HbG9iYWxpemUucHJvdG90eXBlLm51bWJlckZvcm1hdHRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xcblxcdHZhciBhcmdzLCBudW1iZXJUb1BhcnRzRm9ybWF0dGVyLCByZXR1cm5GbjtcXG5cXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXFxcIm9wdGlvbnNcXFwiICk7XFxuXFxuXFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFx0YXJncyA9IFsgb3B0aW9ucyBdO1xcblxcblxcdG51bWJlclRvUGFydHNGb3JtYXR0ZXIgPSB0aGlzLm51bWJlclRvUGFydHNGb3JtYXR0ZXIoIG9wdGlvbnMgKTtcXG5cXHRyZXR1cm5GbiA9IG51bWJlckZvcm1hdHRlckZuKCBudW1iZXJUb1BhcnRzRm9ybWF0dGVyICk7XFxuXFx0cnVudGltZUJpbmQoIGFyZ3MsIHRoaXMuY2xkciwgcmV0dXJuRm4sIFsgbnVtYmVyVG9QYXJ0c0Zvcm1hdHRlciBdICk7XFxuXFxuXFx0cmV0dXJuIHJldHVybkZuO1xcbn07XFxuXFxuLyoqXFxuICogLm51bWJlclRvUGFydHNGb3JtYXR0ZXIoIFtvcHRpb25zXSApXFxuICpcXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTpcXG4gKiAtIHN0eWxlOiBbU3RyaW5nXSBcXFwic3ltYm9sXFxcIiAoZGVmYXVsdCksIFxcXCJhY2NvdW50aW5nXFxcIiwgXFxcImNvZGVcXFwiIG9yIFxcXCJuYW1lXFxcIi5cXG4gKiAtIHNlZSBhbHNvIG51bWJlci9mb3JtYXQgb3B0aW9ucy5cXG4gKlxcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhIG51bWJlciB0byBwYXJ0cyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kXFxuICogZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXFxuICovXFxuR2xvYmFsaXplLm51bWJlclRvUGFydHNGb3JtYXR0ZXIgPVxcbkdsb2JhbGl6ZS5wcm90b3R5cGUubnVtYmVyVG9QYXJ0c0Zvcm1hdHRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xcblxcdHZhciBhcmdzLCBjbGRyLCBmbkFyZ3MsIHBhdHRlcm4sIHByb3BlcnRpZXMsIHJldHVybkZuO1xcblxcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcXFwib3B0aW9uc1xcXCIgKTtcXG5cXG5cXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXHRjbGRyID0gdGhpcy5jbGRyO1xcblxcblxcdGFyZ3MgPSBbIG9wdGlvbnMgXTtcXG5cXG5cXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcXG5cXG5cXHRjbGRyLm9uKCBcXFwiZ2V0XFxcIiwgdmFsaWRhdGVDbGRyICk7XFxuXFx0dHJ5IHtcXG5cXHRcXHRpZiAoIG9wdGlvbnMucmF3ICkge1xcblxcdFxcdFxcdHBhdHRlcm4gPSBvcHRpb25zLnJhdztcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHBhdHRlcm4gPSBudW1iZXJQYXR0ZXJuKCBvcHRpb25zLnN0eWxlIHx8IFxcXCJkZWNpbWFsXFxcIiwgY2xkciApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRwcm9wZXJ0aWVzID0gbnVtYmVyRm9ybWF0UHJvcGVydGllcyggcGF0dGVybiwgY2xkciwgb3B0aW9ucyApO1xcblxcdFxcdGZuQXJncyA9IFsgcHJvcGVydGllcyBdO1xcblxcdH0gZmluYWxseSB7XFxuXFx0XFx0Y2xkci5vZmYoIFxcXCJnZXRcXFwiLCB2YWxpZGF0ZUNsZHIgKTtcXG5cXHR9XFxuXFxuXFx0dmFsaWRhdGVEaWdpdHMoIHByb3BlcnRpZXMgKTtcXG5cXG5cXHRpZiAoIG9wdGlvbnMuY29tcGFjdCApIHtcXG5cXHRcXHRmbkFyZ3MucHVzaCggdGhpcy5wbHVyYWxHZW5lcmF0b3IoKSApO1xcblxcdH1cXG5cXHRyZXR1cm5GbiA9IG51bWJlclRvUGFydHNGb3JtYXR0ZXJGbi5hcHBseSggbnVsbCwgZm5BcmdzICk7XFxuXFx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBmbkFyZ3MgKTtcXG5cXG5cXHRyZXR1cm4gcmV0dXJuRm47XFxufTtcXG5cXG4vKipcXG4gKiAubnVtYmVyUGFyc2VyKCBbb3B0aW9uc10gKVxcbiAqXFxuICogQG9wdGlvbnMgW09iamVjdF06XFxuICogLSBzdHlsZTogW1N0cmluZ10gXFxcImRlY2ltYWxcXFwiIChkZWZhdWx0KSBvciBcXFwicGVyY2VudFxcXCIuXFxuICpcXG4gKiBSZXR1cm4gdGhlIG51bWJlciBwYXJzZXIgYWNjb3JkaW5nIHRvIHRoZSBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cXG4gKi9cXG5HbG9iYWxpemUubnVtYmVyUGFyc2VyID1cXG5HbG9iYWxpemUucHJvdG90eXBlLm51bWJlclBhcnNlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xcblxcdHZhciBhcmdzLCBjbGRyLCBwYXR0ZXJuLCBwcm9wZXJ0aWVzLCByZXR1cm5GbjtcXG5cXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXFxcIm9wdGlvbnNcXFwiICk7XFxuXFxuXFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFx0Y2xkciA9IHRoaXMuY2xkcjtcXG5cXG5cXHRhcmdzID0gWyBvcHRpb25zIF07XFxuXFxuXFx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XFxuXFx0aWYgKCBvcHRpb25zLmNvbXBhY3QgKSB7XFxuXFx0XFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xcblxcdFxcdFxcdGZlYXR1cmU6IFxcXCJjb21wYWN0IG51bWJlciBwYXJzaW5nIChub3QgaW1wbGVtZW50ZWQpXFxcIlxcblxcdFxcdH0pO1xcblxcdH1cXG5cXG5cXHRjbGRyLm9uKCBcXFwiZ2V0XFxcIiwgdmFsaWRhdGVDbGRyICk7XFxuXFxuXFx0aWYgKCBvcHRpb25zLnJhdyApIHtcXG5cXHRcXHRwYXR0ZXJuID0gb3B0aW9ucy5yYXc7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHRwYXR0ZXJuID0gbnVtYmVyUGF0dGVybiggb3B0aW9ucy5zdHlsZSB8fCBcXFwiZGVjaW1hbFxcXCIsIGNsZHIgKTtcXG5cXHR9XFxuXFxuXFx0cHJvcGVydGllcyA9IG51bWJlclBhcnNlUHJvcGVydGllcyggcGF0dGVybiwgY2xkciwgb3B0aW9ucyApO1xcblxcblxcdGNsZHIub2ZmKCBcXFwiZ2V0XFxcIiwgdmFsaWRhdGVDbGRyICk7XFxuXFxuXFx0cmV0dXJuRm4gPSBudW1iZXJQYXJzZXJGbiggcHJvcGVydGllcyApO1xcblxcblxcdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBwcm9wZXJ0aWVzIF0gKTtcXG5cXG5cXHRyZXR1cm4gcmV0dXJuRm47XFxufTtcXG5cXG4vKipcXG4gKiAuZm9ybWF0TnVtYmVyKCB2YWx1ZSBbLCBvcHRpb25zXSApXFxuICpcXG4gKiBAdmFsdWUgW051bWJlcl0gbnVtYmVyIHRvIGJlIGZvcm1hdHRlZC5cXG4gKlxcbiAqIEBvcHRpb25zIFtPYmplY3RdOiBzZWUgbnVtYmVyL2Zvcm1hdC1wcm9wZXJ0aWVzLlxcbiAqXFxuICogRm9ybWF0IGEgbnVtYmVyIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXFxuICovXFxuR2xvYmFsaXplLmZvcm1hdE51bWJlciA9XFxuR2xvYmFsaXplLnByb3RvdHlwZS5mb3JtYXROdW1iZXIgPSBmdW5jdGlvbiggdmFsdWUsIG9wdGlvbnMgKSB7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcXFwidmFsdWVcXFwiICk7XFxuXFxuXFx0cmV0dXJuIHRoaXMubnVtYmVyRm9ybWF0dGVyKCBvcHRpb25zICkoIHZhbHVlICk7XFxufTtcXG5cXG4vKipcXG4gKiAuZm9ybWF0TnVtYmVyVG9QYXJ0cyggdmFsdWUgWywgb3B0aW9uc10gKVxcbiAqXFxuICogQHZhbHVlIFtOdW1iZXJdIG51bWJlciB0byBiZSBmb3JtYXR0ZWQuXFxuICpcXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTogc2VlIG51bWJlci9mb3JtYXQtcHJvcGVydGllcy5cXG4gKlxcbiAqIEZvcm1hdCBhIG51bWJlciB0byBwYXJzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXFxuICovXFxuR2xvYmFsaXplLmZvcm1hdE51bWJlclRvUGFydHMgPVxcbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0TnVtYmVyVG9QYXJ0cyA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXG5cXHRyZXR1cm4gdGhpcy5udW1iZXJUb1BhcnRzRm9ybWF0dGVyKCBvcHRpb25zICkoIHZhbHVlICk7XFxufTtcXG5cXG4vKipcXG4gKiAucGFyc2VOdW1iZXIoIHZhbHVlIFssIG9wdGlvbnNdIClcXG4gKlxcbiAqIEB2YWx1ZSBbU3RyaW5nXVxcbiAqXFxuICogQG9wdGlvbnMgW09iamVjdF06IFNlZSBudW1iZXJQYXJzZXIoKS5cXG4gKlxcbiAqIFJldHVybiB0aGUgcGFyc2VkIE51bWJlciAoaW5jbHVkaW5nIEluZmluaXR5KSBvciBOYU4gd2hlbiB2YWx1ZSBpcyBpbnZhbGlkLlxcbiAqL1xcbkdsb2JhbGl6ZS5wYXJzZU51bWJlciA9XFxuR2xvYmFsaXplLnByb3RvdHlwZS5wYXJzZU51bWJlciA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXG5cXHRyZXR1cm4gdGhpcy5udW1iZXJQYXJzZXIoIG9wdGlvbnMgKSggdmFsdWUgKTtcXG59O1xcblxcbi8qKlxcbiAqIE9wdGltaXphdGlvbiB0byBhdm9pZCBkdXBsaWNhdGluZyBzb21lIGludGVybmFsIGZ1bmN0aW9ucyBhY3Jvc3MgbW9kdWxlcy5cXG4gKi9cXG5HbG9iYWxpemUuX2NyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlID0gY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmU7XFxuR2xvYmFsaXplLl9udW1iZXJOdW1iZXJpbmdTeXN0ZW0gPSBudW1iZXJOdW1iZXJpbmdTeXN0ZW07XFxuR2xvYmFsaXplLl9udW1iZXJOdW1iZXJpbmdTeXN0ZW1EaWdpdHNNYXAgPSBudW1iZXJOdW1iZXJpbmdTeXN0ZW1EaWdpdHNNYXA7XFxuR2xvYmFsaXplLl9udW1iZXJQYXR0ZXJuID0gbnVtYmVyUGF0dGVybjtcXG5HbG9iYWxpemUuX251bWJlclN5bWJvbCA9IG51bWJlclN5bWJvbDtcXG5HbG9iYWxpemUuX2xvb3NlTWF0Y2hpbmcgPSBsb29zZU1hdGNoaW5nO1xcbkdsb2JhbGl6ZS5fcmVtb3ZlTGl0ZXJhbFF1b3RlcyA9IHJlbW92ZUxpdGVyYWxRdW90ZXM7XFxuR2xvYmFsaXplLl9zdHJpbmdQYWQgPSBzdHJpbmdQYWQ7XFxuR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIgPSB2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXI7XFxuR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcgPSB2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmc7XFxuXFxucmV0dXJuIEdsb2JhbGl6ZTtcXG5cXG5cXG5cXG5cXG59KSk7XFxuXCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(25))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL2N1cnJlbmN5LmpzPzY0MzgiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHNjcmlwdC1sb2FkZXJcXFxcYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxyYXctbG9hZGVyXFxcXGluZGV4LmpzIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxnbG9iYWxpemVcXFxcZGlzdFxcXFxnbG9iYWxpemVcXFxcY3VycmVuY3kuanNcIikpIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n")},function(module,exports){eval('module.exports = "/*!\\n * Globalize v1.5.0\\n *\\n * http://github.com/jquery/globalize\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2020-03-25T12:19Z\\n */\\n(function( root, factory ) {\\n\\n\\t// UMD returnExports\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\n\\t\\t// AMD\\n\\t\\tdefine([\\n\\t\\t\\t\\"cldr\\",\\n\\t\\t\\t\\"../globalize\\",\\n\\t\\t\\t\\"./number\\",\\n\\t\\t\\t\\"cldr/event\\",\\n\\t\\t\\t\\"cldr/supplemental\\"\\n\\t\\t], factory );\\n\\t} else if ( typeof exports === \\"object\\" ) {\\n\\n\\t\\t// Node, CommonJS\\n\\t\\tmodule.exports = factory( require( \\"cldrjs\\" ), require( \\"../globalize\\" ) );\\n\\t} else {\\n\\n\\t\\t// Global\\n\\t\\tfactory( root.Cldr, root.Globalize );\\n\\t}\\n}(this, function( Cldr, Globalize ) {\\n\\nvar alwaysArray = Globalize._alwaysArray,\\n\\tcreateError = Globalize._createError,\\n\\tformatMessageToParts = Globalize._formatMessageToParts,\\n\\tnumberNumberingSystem = Globalize._numberNumberingSystem,\\n\\tnumberPattern = Globalize._numberPattern,\\n\\tpartsJoin = Globalize._partsJoin,\\n\\tpartsPush = Globalize._partsPush,\\n\\truntimeBind = Globalize._runtimeBind,\\n\\tstringPad = Globalize._stringPad,\\n\\tvalidateCldr = Globalize._validateCldr,\\n\\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\\n\\tvalidateParameterPresence = Globalize._validateParameterPresence,\\n\\tvalidateParameterType = Globalize._validateParameterType,\\n\\tvalidateParameterTypeNumber = Globalize._validateParameterTypeNumber,\\n\\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\\n\\n\\nvar createErrorPluralModulePresence = function() {\\n\\treturn createError( \\"E_MISSING_PLURAL_MODULE\\", \\"Plural module not loaded.\\" );\\n};\\n\\n\\n\\n\\nvar validateParameterTypeCurrency = function( value, name ) {\\n\\tvalidateParameterType(\\n\\t\\tvalue,\\n\\t\\tname,\\n\\t\\tvalue === undefined || typeof value === \\"string\\" && ( /^[A-Za-z]{3}$/ ).test( value ),\\n\\t\\t\\"3-letter currency code string as defined by ISO 4217\\"\\n\\t);\\n};\\n\\n\\n\\n\\nvar currencyFormatterFn = function( currencyToPartsFormatter ) {\\n\\treturn function currencyFormatter( value ) {\\n\\t\\treturn partsJoin( currencyToPartsFormatter( value ));\\n\\t};\\n};\\n\\n\\n\\n\\n/**\\n * supplementalOverride( currency, pattern, cldr )\\n *\\n * Return pattern with fraction digits overriden by supplemental currency data.\\n */\\nvar currencySupplementalOverride = function( currency, pattern, cldr ) {\\n\\tvar digits,\\n\\t\\tfraction = \\"\\",\\n\\t\\tfractionData = cldr.supplemental([ \\"currencyData/fractions\\", currency ]) ||\\n\\t\\t\\tcldr.supplemental( \\"currencyData/fractions/DEFAULT\\" );\\n\\n\\tdigits = +fractionData._digits;\\n\\n\\tif ( digits ) {\\n\\t\\tfraction = \\".\\" + stringPad( \\"0\\", digits ).slice( 0, -1 ) + fractionData._rounding;\\n\\t}\\n\\n\\treturn pattern.replace( /\\\\.(#+|0*[0-9]|0+[0-9]?)/g, fraction );\\n};\\n\\n\\n\\n\\nvar objectFilter = function( object, testRe ) {\\n\\tvar key,\\n\\t\\tcopy = {};\\n\\n\\tfor ( key in object ) {\\n\\t\\tif ( testRe.test( key ) ) {\\n\\t\\t\\tcopy[ key ] = object[ key ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn copy;\\n};\\n\\n\\n\\n\\nvar currencyUnitPatterns = function( cldr ) {\\n\\treturn objectFilter( cldr.main([\\n\\t\\t\\"numbers\\",\\n\\t\\t\\"currencyFormats-numberSystem-\\" + numberNumberingSystem( cldr )\\n\\t]), /^unitPattern/ );\\n};\\n\\n\\n\\n\\n/**\\n * nameProperties( currency, cldr )\\n *\\n * Return number pattern with the appropriate currency code in as literal.\\n */\\nvar currencyNameProperties = function( currency, cldr ) {\\n\\tvar pattern = numberPattern( \\"decimal\\", cldr );\\n\\n\\t// The number of decimal places and the rounding for each currency is not locale-specific. Those\\n\\t// values overridden by Supplemental Currency Data.\\n\\tpattern = currencySupplementalOverride( currency, pattern, cldr );\\n\\n\\treturn {\\n\\t\\tdisplayNames: objectFilter( cldr.main([\\n\\t\\t\\t\\"numbers/currencies\\",\\n\\t\\t\\tcurrency\\n\\t\\t]), /^displayName/ ),\\n\\t\\tpattern: pattern,\\n\\t\\tunitPatterns: currencyUnitPatterns( cldr )\\n\\t};\\n};\\n\\n\\n\\n\\n/**\\n * Unicode regular expression for: everything except math symbols, currency signs, dingbats, and\\n * box-drawing characters.\\n *\\n * Generated by:\\n *\\n * regenerate()\\n *   .addRange( 0x0, 0x10FFFF )\\n *   .remove( require( \\"unicode-7.0.0/categories/S/symbols\\" ) ).toString();\\n *\\n * https://github.com/mathiasbynens/regenerate\\n * https://github.com/mathiasbynens/unicode-7.0.0\\n */\\nvar regexpNotS = /[\\\\0-#%-\\\\*,-;\\\\?-\\\\]_a-\\\\{\\\\}\\\\x7F-\\\\xA1\\\\xA7\\\\xAA\\\\xAB\\\\xAD\\\\xB2\\\\xB3\\\\xB5-\\\\xB7\\\\xB9-\\\\xD6\\\\xD8-\\\\xF6\\\\xF8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0300-\\\\u0374\\\\u0376-\\\\u0383\\\\u0386-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u0483-\\\\u058C\\\\u0590-\\\\u0605\\\\u0609\\\\u060A\\\\u060C\\\\u060D\\\\u0610-\\\\u06DD\\\\u06DF-\\\\u06E8\\\\u06EA-\\\\u06FC\\\\u06FF-\\\\u07F5\\\\u07F7-\\\\u09F1\\\\u09F4-\\\\u09F9\\\\u09FC-\\\\u0AF0\\\\u0AF2-\\\\u0B6F\\\\u0B71-\\\\u0BF2\\\\u0BFB-\\\\u0C7E\\\\u0C80-\\\\u0D78\\\\u0D7A-\\\\u0E3E\\\\u0E40-\\\\u0F00\\\\u0F04-\\\\u0F12\\\\u0F14\\\\u0F18\\\\u0F19\\\\u0F20-\\\\u0F33\\\\u0F35\\\\u0F37\\\\u0F39-\\\\u0FBD\\\\u0FC6\\\\u0FCD\\\\u0FD0-\\\\u0FD4\\\\u0FD9-\\\\u109D\\\\u10A0-\\\\u138F\\\\u139A-\\\\u17DA\\\\u17DC-\\\\u193F\\\\u1941-\\\\u19DD\\\\u1A00-\\\\u1B60\\\\u1B6B-\\\\u1B73\\\\u1B7D-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FCC\\\\u1FD0-\\\\u1FDC\\\\u1FE0-\\\\u1FEC\\\\u1FF0-\\\\u1FFC\\\\u1FFF-\\\\u2043\\\\u2045-\\\\u2051\\\\u2053-\\\\u2079\\\\u207D-\\\\u2089\\\\u208D-\\\\u209F\\\\u20BE-\\\\u20FF\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2150-\\\\u218F\\\\u2308-\\\\u230B\\\\u2329\\\\u232A\\\\u23FB-\\\\u23FF\\\\u2427-\\\\u243F\\\\u244B-\\\\u249B\\\\u24EA-\\\\u24FF\\\\u2768-\\\\u2793\\\\u27C5\\\\u27C6\\\\u27E6-\\\\u27EF\\\\u2983-\\\\u2998\\\\u29D8-\\\\u29DB\\\\u29FC\\\\u29FD\\\\u2B74\\\\u2B75\\\\u2B96\\\\u2B97\\\\u2BBA-\\\\u2BBC\\\\u2BC9\\\\u2BD2-\\\\u2CE4\\\\u2CEB-\\\\u2E7F\\\\u2E9A\\\\u2EF4-\\\\u2EFF\\\\u2FD6-\\\\u2FEF\\\\u2FFC-\\\\u3003\\\\u3005-\\\\u3011\\\\u3014-\\\\u301F\\\\u3021-\\\\u3035\\\\u3038-\\\\u303D\\\\u3040-\\\\u309A\\\\u309D-\\\\u318F\\\\u3192-\\\\u3195\\\\u31A0-\\\\u31BF\\\\u31E4-\\\\u31FF\\\\u321F-\\\\u3229\\\\u3248-\\\\u324F\\\\u3251-\\\\u325F\\\\u3280-\\\\u3289\\\\u32B1-\\\\u32BF\\\\u32FF\\\\u3400-\\\\u4DBF\\\\u4E00-\\\\uA48F\\\\uA4C7-\\\\uA6FF\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B-\\\\uA827\\\\uA82C-\\\\uA835\\\\uA83A-\\\\uAA76\\\\uAA7A-\\\\uAB5A\\\\uAB5C-\\\\uD7FF\\\\uDC00-\\\\uFB28\\\\uFB2A-\\\\uFBB1\\\\uFBC2-\\\\uFDFB\\\\uFDFE-\\\\uFE61\\\\uFE63\\\\uFE67\\\\uFE68\\\\uFE6A-\\\\uFF03\\\\uFF05-\\\\uFF0A\\\\uFF0C-\\\\uFF1B\\\\uFF1F-\\\\uFF3D\\\\uFF3F\\\\uFF41-\\\\uFF5B\\\\uFF5D\\\\uFF5F-\\\\uFFDF\\\\uFFE7\\\\uFFEF-\\\\uFFFB\\\\uFFFE\\\\uFFFF]|\\\\uD800[\\\\uDC00-\\\\uDD36\\\\uDD40-\\\\uDD78\\\\uDD8A\\\\uDD8B\\\\uDD8D-\\\\uDD8F\\\\uDD9C-\\\\uDD9F\\\\uDDA1-\\\\uDDCF\\\\uDDFD-\\\\uDFFF]|[\\\\uD801\\\\uD803-\\\\uD819\\\\uD81B-\\\\uD82E\\\\uD830-\\\\uD833\\\\uD836-\\\\uD83A\\\\uD83F-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|\\\\uD802[\\\\uDC00-\\\\uDC76\\\\uDC79-\\\\uDEC7\\\\uDEC9-\\\\uDFFF]|\\\\uD81A[\\\\uDC00-\\\\uDF3B\\\\uDF40-\\\\uDF44\\\\uDF46-\\\\uDFFF]|\\\\uD82F[\\\\uDC00-\\\\uDC9B\\\\uDC9D-\\\\uDFFF]|\\\\uD834[\\\\uDCF6-\\\\uDCFF\\\\uDD27\\\\uDD28\\\\uDD65-\\\\uDD69\\\\uDD6D-\\\\uDD82\\\\uDD85-\\\\uDD8B\\\\uDDAA-\\\\uDDAD\\\\uDDDE-\\\\uDDFF\\\\uDE42-\\\\uDE44\\\\uDE46-\\\\uDEFF\\\\uDF57-\\\\uDFFF]|\\\\uD835[\\\\uDC00-\\\\uDEC0\\\\uDEC2-\\\\uDEDA\\\\uDEDC-\\\\uDEFA\\\\uDEFC-\\\\uDF14\\\\uDF16-\\\\uDF34\\\\uDF36-\\\\uDF4E\\\\uDF50-\\\\uDF6E\\\\uDF70-\\\\uDF88\\\\uDF8A-\\\\uDFA8\\\\uDFAA-\\\\uDFC2\\\\uDFC4-\\\\uDFFF]|\\\\uD83B[\\\\uDC00-\\\\uDEEF\\\\uDEF2-\\\\uDFFF]|\\\\uD83C[\\\\uDC2C-\\\\uDC2F\\\\uDC94-\\\\uDC9F\\\\uDCAF\\\\uDCB0\\\\uDCC0\\\\uDCD0\\\\uDCF6-\\\\uDD0F\\\\uDD2F\\\\uDD6C-\\\\uDD6F\\\\uDD9B-\\\\uDDE5\\\\uDE03-\\\\uDE0F\\\\uDE3B-\\\\uDE3F\\\\uDE49-\\\\uDE4F\\\\uDE52-\\\\uDEFF\\\\uDF2D-\\\\uDF2F\\\\uDF7E\\\\uDF7F\\\\uDFCF-\\\\uDFD3\\\\uDFF8-\\\\uDFFF]|\\\\uD83D[\\\\uDCFF\\\\uDD4B-\\\\uDD4F\\\\uDD7A\\\\uDDA4\\\\uDE43\\\\uDE44\\\\uDED0-\\\\uDEDF\\\\uDEED-\\\\uDEEF\\\\uDEF4-\\\\uDEFF\\\\uDF74-\\\\uDF7F\\\\uDFD5-\\\\uDFFF]|\\\\uD83E[\\\\uDC0C-\\\\uDC0F\\\\uDC48-\\\\uDC4F\\\\uDC5A-\\\\uDC5F\\\\uDC88-\\\\uDC8F\\\\uDCAE-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF]/;\\n\\n\\n\\n\\n/**\\n * symbolProperties( currency, cldr )\\n *\\n * Return pattern replacing `` with the appropriate currency symbol literal.\\n */\\nvar currencySymbolProperties = function( currency, cldr, options ) {\\n\\tvar currencySpacing, pattern, symbol, symbolEntries,\\n\\t\\tregexp = {\\n\\t\\t\\t\\"[:digit:]\\": /\\\\d/,\\n\\t\\t\\t\\"[:^S:]\\": regexpNotS\\n\\t\\t};\\n\\n\\tif ( options.style === \\"code\\" ) {\\n\\t\\tsymbol = currency;\\n\\t} else {\\n\\t\\tsymbolEntries = [ \\"symbol\\" ];\\n\\n\\t\\t// If options.symbolForm === \\"narrow\\" was passed, prepend it.\\n\\t\\tif ( options.symbolForm === \\"narrow\\" ) {\\n\\t\\t\\tsymbolEntries.unshift( \\"symbol-alt-narrow\\" );\\n\\t\\t}\\n\\n\\t\\tsymbolEntries.some(function( symbolEntry ) {\\n\\t\\t\\treturn symbol = cldr.main([\\n\\t\\t\\t\\t\\"numbers/currencies\\",\\n\\t\\t\\t\\tcurrency,\\n\\t\\t\\t\\tsymbolEntry\\n\\t\\t\\t]);\\n\\t\\t});\\n\\t}\\n\\n\\tcurrencySpacing = [ \\"beforeCurrency\\", \\"afterCurrency\\" ].map(function( position ) {\\n\\t\\treturn cldr.main([\\n\\t\\t\\t\\"numbers\\",\\n\\t\\t\\t\\"currencyFormats-numberSystem-\\" + numberNumberingSystem( cldr ),\\n\\t\\t\\t\\"currencySpacing\\",\\n\\t\\t\\tposition\\n\\t\\t]);\\n\\t});\\n\\n\\tpattern = cldr.main([\\n\\t\\t\\"numbers\\",\\n\\t\\t\\"currencyFormats-numberSystem-\\" + numberNumberingSystem( cldr ),\\n\\t\\toptions.style === \\"accounting\\" ? \\"accounting\\" : \\"standard\\"\\n\\t]);\\n\\n\\tpattern =\\n\\n\\t\\t// The number of decimal places and the rounding for each currency is not locale-specific.\\n\\t\\t// Those values are overridden by Supplemental Currency Data.\\n\\t\\tcurrencySupplementalOverride( currency, pattern, cldr )\\n\\n\\t\\t// Replace \\"\\" (\\\\u00A4) with the appropriate symbol literal.\\n\\t\\t.split( \\";\\" ).map(function( pattern ) {\\n\\n\\t\\t\\treturn pattern.split( \\"\\\\u00A4\\" ).map(function( part, i ) {\\n\\t\\t\\t\\tvar currencyMatch = regexp[ currencySpacing[ i ].currencyMatch ],\\n\\t\\t\\t\\t\\tsurroundingMatch = regexp[ currencySpacing[ i ].surroundingMatch ],\\n\\t\\t\\t\\t\\tinsertBetween = \\"\\";\\n\\n\\t\\t\\t\\t// For currencyMatch and surroundingMatch definitions, read [1].\\n\\t\\t\\t\\t// When i === 0, beforeCurrency is being handled. Otherwise, afterCurrency.\\n\\t\\t\\t\\t// 1: http://www.unicode.org/reports/tr35/tr35-numbers.html#Currencies\\n\\t\\t\\t\\tcurrencyMatch = currencyMatch.test( symbol.charAt( i ? symbol.length - 1 : 0 ) );\\n\\t\\t\\t\\tsurroundingMatch = surroundingMatch.test(\\n\\t\\t\\t\\t\\tpart.charAt( i ? 0 : part.length - 1 ).replace( /[#@,.]/g, \\"0\\" )\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\tif ( currencyMatch && part && surroundingMatch ) {\\n\\t\\t\\t\\t\\tinsertBetween = currencySpacing[ i ].insertBetween;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ( i ? insertBetween : \\"\\" ) + part + ( i ? \\"\\" : insertBetween );\\n\\t\\t\\t}).join( \\"\\\\u00A4\\" );\\n\\t\\t}).join( \\";\\" );\\n\\n\\treturn {\\n\\t\\tpattern: pattern,\\n\\t\\tsymbol: symbol\\n\\t};\\n};\\n\\n\\n\\n\\n/**\\n * nameFormat( formattedNumber, pluralForm, properties )\\n *\\n * Return the appropriate name form currency format.\\n */\\nvar currencyNameFormat = function( formattedNumber, pluralForm, properties ) {\\n\\tvar displayName, unitPattern,\\n\\t\\tparts = [],\\n\\t\\tdisplayNames = properties.displayNames || {},\\n\\t\\tunitPatterns = properties.unitPatterns;\\n\\n\\tdisplayName = displayNames[ \\"displayName-count-\\" + pluralForm ] ||\\n\\t\\tdisplayNames[ \\"displayName-count-other\\" ] ||\\n\\t\\tdisplayNames.displayName ||\\n\\t\\tproperties.currency;\\n\\tunitPattern = unitPatterns[ \\"unitPattern-count-\\" + pluralForm ] ||\\n\\t\\tunitPatterns[ \\"unitPattern-count-other\\" ];\\n\\n\\tformatMessageToParts( unitPattern, [ formattedNumber, displayName ]).forEach(function( part ) {\\n\\t\\tif ( part.type === \\"variable\\" && part.name === \\"0\\" ) {\\n\\t\\t\\tpart.value.forEach(function( part ) {\\n\\t\\t\\t\\tpartsPush( parts, part.type, part.value );\\n\\t\\t\\t});\\n\\t\\t} else if ( part.type === \\"variable\\" && part.name === \\"1\\" ) {\\n\\t\\t\\tpartsPush( parts, \\"currency\\", part.value );\\n\\t\\t} else {\\n\\t\\t\\tpartsPush( parts, \\"literal\\", part.value );\\n\\t\\t}\\n\\t});\\n\\n\\treturn parts;\\n};\\n\\n\\n\\n\\n/**\\n * symbolFormat( parts, symbol )\\n *\\n * Return the appropriate symbol/account form format.\\n */\\nvar currencySymbolFormat = function( parts, symbol ) {\\n\\tparts.forEach(function( part ) {\\n\\t\\tif ( part.type === \\"currency\\" ) {\\n\\t\\t\\tpart.value = symbol;\\n\\t\\t}\\n\\t});\\n\\treturn parts;\\n};\\n\\n\\n\\n\\nvar currencyToPartsFormatterFn = function( numberToPartsFormatter, pluralGenerator, properties ) {\\n\\tvar fn;\\n\\n\\t// Return formatter when style is \\"name\\".\\n\\tif ( pluralGenerator && properties ) {\\n\\t\\tfn = function currencyToPartsFormatter( value ) {\\n\\t\\t\\tvalidateParameterPresence( value, \\"value\\" );\\n\\t\\t\\tvalidateParameterTypeNumber( value, \\"value\\" );\\n\\t\\t\\treturn currencyNameFormat(\\n\\t\\t\\t\\tnumberToPartsFormatter( value ),\\n\\t\\t\\t\\tpluralGenerator( value ),\\n\\t\\t\\t\\tproperties\\n\\t\\t\\t);\\n\\t\\t};\\n\\n\\t// Return formatter when style is \\"symbol\\", \\"accounting\\", or \\"code\\".\\n\\t} else {\\n\\t\\tfn = function currencyToPartsFormatter( value ) {\\n\\n\\t\\t\\t// 1: Reusing pluralGenerator argument, but in this case it is actually `symbol`\\n\\t\\t\\treturn currencySymbolFormat( numberToPartsFormatter( value ), pluralGenerator /* 1 */ );\\n\\t\\t};\\n\\t}\\n\\n\\treturn fn;\\n};\\n\\n\\n\\n\\n/**\\n * objectOmit( object, keys )\\n *\\n * Return a copy of the object, filtered to omit the blacklisted key or array of keys.\\n */\\nvar objectOmit = function( object, keys ) {\\n\\tvar key,\\n\\t\\tcopy = {};\\n\\n\\tkeys = alwaysArray( keys );\\n\\n\\tfor ( key in object ) {\\n\\t\\tif ( keys.indexOf( key ) === -1 ) {\\n\\t\\t\\tcopy[ key ] = object[ key ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn copy;\\n};\\n\\n\\n\\n\\nfunction validateRequiredCldr( path, value ) {\\n\\tvalidateCldr( path, value, {\\n\\t\\tskip: [\\n\\t\\t\\t/numbers\\\\/currencies\\\\/[^/]+\\\\/symbol-alt-/,\\n\\t\\t\\t/supplemental\\\\/currencyData\\\\/fractions\\\\/[A-Za-z]{3}$/\\n\\t\\t]\\n\\t});\\n}\\n\\n/**\\n * .currencyFormatter( currency [, options] )\\n *\\n * @currency [String] 3-letter currency code as defined by ISO 4217.\\n *\\n * @options [Object]:\\n * - style: [String] \\"symbol\\" (default), \\"accounting\\", \\"code\\" or \\"name\\".\\n * - see also number/format options.\\n *\\n * Return a function that formats a currency according to the given options and default/instance\\n * locale.\\n */\\nGlobalize.currencyFormatter =\\nGlobalize.prototype.currencyFormatter = function( currency, options ) {\\n\\tvar args, currencyToPartsFormatter, returnFn;\\n\\n\\tvalidateParameterPresence( currency, \\"currency\\" );\\n\\tvalidateParameterTypeCurrency( currency, \\"currency\\" );\\n\\n\\tvalidateParameterTypePlainObject( options, \\"options\\" );\\n\\n\\toptions = options || {};\\n\\targs = [ currency, options ];\\n\\n\\tcurrencyToPartsFormatter = this.currencyToPartsFormatter( currency, options );\\n\\treturnFn = currencyFormatterFn( currencyToPartsFormatter );\\n\\truntimeBind( args, this.cldr, returnFn, [ currencyToPartsFormatter ] );\\n\\n\\treturn returnFn;\\n};\\n\\n/**\\n * .currencyToPartsFormatter( currency [, options] )\\n *\\n * @currency [String] 3-letter currency code as defined by ISO 4217.\\n *\\n * @options [Object]:\\n * - style: [String] \\"symbol\\" (default), \\"accounting\\", \\"code\\" or \\"name\\".\\n * - see also number/format options.\\n *\\n * Return a currency formatter function (of the form below) according to the given options and the\\n * default/instance locale.\\n *\\n * fn( value )\\n *\\n * @value [Number]\\n *\\n * Return a function that formats a currency to parts according to the given options\\n * and the default/instance locale.\\n */\\nGlobalize.currencyToPartsFormatter =\\nGlobalize.prototype.currencyToPartsFormatter = function( currency, options ) {\\n\\tvar args, cldr, numberToPartsFormatter, pluralGenerator, properties, returnFn, style;\\n\\n\\tvalidateParameterPresence( currency, \\"currency\\" );\\n\\tvalidateParameterTypeCurrency( currency, \\"currency\\" );\\n\\n\\tvalidateParameterTypePlainObject( options, \\"options\\" );\\n\\n\\tcldr = this.cldr;\\n\\toptions = options || {};\\n\\n\\targs = [ currency, options ];\\n\\tstyle = options.style || \\"symbol\\";\\n\\n\\tvalidateDefaultLocale( cldr );\\n\\n\\t// Get properties given style (\\"symbol\\" default, \\"code\\" or \\"name\\").\\n\\tcldr.on( \\"get\\", validateRequiredCldr );\\n\\ttry {\\n\\t\\tproperties = ({\\n\\t\\t\\taccounting: currencySymbolProperties,\\n\\t\\t\\tcode: currencySymbolProperties,\\n\\t\\t\\tname: currencyNameProperties,\\n\\t\\t\\tsymbol: currencySymbolProperties\\n\\t\\t}[ style ] )( currency, cldr, options );\\n\\t} finally {\\n\\t\\tcldr.off( \\"get\\", validateRequiredCldr );\\n\\t}\\n\\n\\t// options = options minus style, plus raw pattern.\\n\\toptions = objectOmit( options, \\"style\\" );\\n\\toptions.raw = properties.pattern;\\n\\n\\t// Return formatter when style is \\"symbol\\", \\"accounting\\", or \\"code\\".\\n\\tif ( style === \\"symbol\\" || style === \\"accounting\\" || style === \\"code\\" ) {\\n\\t\\tnumberToPartsFormatter = this.numberToPartsFormatter( options );\\n\\n\\t\\treturnFn = currencyToPartsFormatterFn( numberToPartsFormatter, properties.symbol );\\n\\n\\t\\truntimeBind( args, cldr, returnFn, [ numberToPartsFormatter, properties.symbol ] );\\n\\n\\t// Return formatter when style is \\"name\\".\\n\\t} else {\\n\\t\\tnumberToPartsFormatter = this.numberToPartsFormatter( options );\\n\\n\\t\\t// Is plural module present? Yes, use its generator. Nope, use an error generator.\\n\\t\\tpluralGenerator = this.plural !== undefined ?\\n\\t\\t\\tthis.pluralGenerator() :\\n\\t\\t\\tcreateErrorPluralModulePresence;\\n\\n\\t\\treturnFn = currencyToPartsFormatterFn(\\n\\t\\t\\tnumberToPartsFormatter,\\n\\t\\t\\tpluralGenerator,\\n\\t\\t\\tproperties\\n\\t\\t);\\n\\n\\t\\truntimeBind( args, cldr, returnFn, [\\n\\t\\t\\tnumberToPartsFormatter,\\n\\t\\t\\tpluralGenerator,\\n\\t\\t\\tproperties\\n\\t\\t]);\\n\\t}\\n\\n\\treturn returnFn;\\n};\\n\\n/**\\n * .currencyParser( currency [, options] )\\n *\\n * @currency [String] 3-letter currency code as defined by ISO 4217.\\n *\\n * @options [Object] see currencyFormatter.\\n *\\n * Return the currency parser according to the given options and the default/instance locale.\\n */\\nGlobalize.currencyParser =\\nGlobalize.prototype.currencyParser = function( /* currency, options */ ) {\\n\\n\\t// TODO implement parser.\\n\\n};\\n\\n/**\\n * .formatCurrency( value, currency [, options] )\\n *\\n * @value [Number] number to be formatted.\\n *\\n * @currency [String] 3-letter currency code as defined by ISO 4217.\\n *\\n * @options [Object] see currencyFormatter.\\n *\\n * Format a currency according to the given options and the default/instance locale.\\n */\\nGlobalize.formatCurrency =\\nGlobalize.prototype.formatCurrency = function( value, currency, options ) {\\n\\tvalidateParameterPresence( value, \\"value\\" );\\n\\tvalidateParameterTypeNumber( value, \\"value\\" );\\n\\treturn this.currencyFormatter( currency, options )( value );\\n};\\n\\n/**\\n * .formatCurrencyToParts( value, currency [, options] )\\n *\\n * @value [Number] number to be formatted.\\n *\\n * @currency [String] 3-letter currency code as defined by ISO 4217.\\n *\\n * @options [Object] see currencyFormatter.\\n *\\n * Format a currency to parts according to the given options and the default/instance locale.\\n */\\nGlobalize.formatCurrencyToParts =\\nGlobalize.prototype.formatCurrencyToParts = function( value, currency, options ) {\\n\\tvalidateParameterPresence( value, \\"value\\" );\\n\\tvalidateParameterTypeNumber( value, \\"value\\" );\\n\\treturn this.currencyToPartsFormatter( currency, options )( value );\\n};\\n\\n/**\\n * .parseCurrency( value, currency [, options] )\\n *\\n * @value [String]\\n *\\n * @currency [String] 3-letter currency code as defined by ISO 4217.\\n *\\n * @options [Object]: See currencyFormatter.\\n *\\n * Return the parsed currency or NaN when value is invalid.\\n */\\nGlobalize.parseCurrency =\\nGlobalize.prototype.parseCurrency = function( /* value, currency, options */ ) {\\n};\\n\\nreturn Globalize;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL2N1cnJlbmN5LmpzPzliM2UiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIEdsb2JhbGl6ZSB2MS41LjBcXG4gKlxcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcXG4gKlxcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAqXFxuICogRGF0ZTogMjAyMC0wMy0yNVQxMjoxOVpcXG4gKi9cXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XFxuXFxuXFx0Ly8gVU1EIHJldHVybkV4cG9ydHNcXG5cXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZGVmaW5lLmFtZCApIHtcXG5cXG5cXHRcXHQvLyBBTURcXG5cXHRcXHRkZWZpbmUoW1xcblxcdFxcdFxcdFxcXCJjbGRyXFxcIixcXG5cXHRcXHRcXHRcXFwiLi4vZ2xvYmFsaXplXFxcIixcXG5cXHRcXHRcXHRcXFwiLi9udW1iZXJcXFwiLFxcblxcdFxcdFxcdFxcXCJjbGRyL2V2ZW50XFxcIixcXG5cXHRcXHRcXHRcXFwiY2xkci9zdXBwbGVtZW50YWxcXFwiXFxuXFx0XFx0XSwgZmFjdG9yeSApO1xcblxcdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHQvLyBOb2RlLCBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXFxcImNsZHJqc1xcXCIgKSwgcmVxdWlyZSggXFxcIi4uL2dsb2JhbGl6ZVxcXCIgKSApO1xcblxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0Ly8gR2xvYmFsXFxuXFx0XFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xcblxcdH1cXG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XFxuXFxudmFyIGFsd2F5c0FycmF5ID0gR2xvYmFsaXplLl9hbHdheXNBcnJheSxcXG5cXHRjcmVhdGVFcnJvciA9IEdsb2JhbGl6ZS5fY3JlYXRlRXJyb3IsXFxuXFx0Zm9ybWF0TWVzc2FnZVRvUGFydHMgPSBHbG9iYWxpemUuX2Zvcm1hdE1lc3NhZ2VUb1BhcnRzLFxcblxcdG51bWJlck51bWJlcmluZ1N5c3RlbSA9IEdsb2JhbGl6ZS5fbnVtYmVyTnVtYmVyaW5nU3lzdGVtLFxcblxcdG51bWJlclBhdHRlcm4gPSBHbG9iYWxpemUuX251bWJlclBhdHRlcm4sXFxuXFx0cGFydHNKb2luID0gR2xvYmFsaXplLl9wYXJ0c0pvaW4sXFxuXFx0cGFydHNQdXNoID0gR2xvYmFsaXplLl9wYXJ0c1B1c2gsXFxuXFx0cnVudGltZUJpbmQgPSBHbG9iYWxpemUuX3J1bnRpbWVCaW5kLFxcblxcdHN0cmluZ1BhZCA9IEdsb2JhbGl6ZS5fc3RyaW5nUGFkLFxcblxcdHZhbGlkYXRlQ2xkciA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVDbGRyLFxcblxcdHZhbGlkYXRlRGVmYXVsdExvY2FsZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVEZWZhdWx0TG9jYWxlLFxcblxcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UsXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGUsXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIsXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0O1xcblxcblxcbnZhciBjcmVhdGVFcnJvclBsdXJhbE1vZHVsZVByZXNlbmNlID0gZnVuY3Rpb24oKSB7XFxuXFx0cmV0dXJuIGNyZWF0ZUVycm9yKCBcXFwiRV9NSVNTSU5HX1BMVVJBTF9NT0RVTEVcXFwiLCBcXFwiUGx1cmFsIG1vZHVsZSBub3QgbG9hZGVkLlxcXCIgKTtcXG59O1xcblxcblxcblxcblxcbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVDdXJyZW5jeSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXFxuXFx0XFx0dmFsdWUsXFxuXFx0XFx0bmFtZSxcXG5cXHRcXHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgKCAvXltBLVphLXpdezN9JC8gKS50ZXN0KCB2YWx1ZSApLFxcblxcdFxcdFxcXCIzLWxldHRlciBjdXJyZW5jeSBjb2RlIHN0cmluZyBhcyBkZWZpbmVkIGJ5IElTTyA0MjE3XFxcIlxcblxcdCk7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgY3VycmVuY3lGb3JtYXR0ZXJGbiA9IGZ1bmN0aW9uKCBjdXJyZW5jeVRvUGFydHNGb3JtYXR0ZXIgKSB7XFxuXFx0cmV0dXJuIGZ1bmN0aW9uIGN1cnJlbmN5Rm9ybWF0dGVyKCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gcGFydHNKb2luKCBjdXJyZW5jeVRvUGFydHNGb3JtYXR0ZXIoIHZhbHVlICkpO1xcblxcdH07XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBzdXBwbGVtZW50YWxPdmVycmlkZSggY3VycmVuY3ksIHBhdHRlcm4sIGNsZHIgKVxcbiAqXFxuICogUmV0dXJuIHBhdHRlcm4gd2l0aCBmcmFjdGlvbiBkaWdpdHMgb3ZlcnJpZGVuIGJ5IHN1cHBsZW1lbnRhbCBjdXJyZW5jeSBkYXRhLlxcbiAqL1xcbnZhciBjdXJyZW5jeVN1cHBsZW1lbnRhbE92ZXJyaWRlID0gZnVuY3Rpb24oIGN1cnJlbmN5LCBwYXR0ZXJuLCBjbGRyICkge1xcblxcdHZhciBkaWdpdHMsXFxuXFx0XFx0ZnJhY3Rpb24gPSBcXFwiXFxcIixcXG5cXHRcXHRmcmFjdGlvbkRhdGEgPSBjbGRyLnN1cHBsZW1lbnRhbChbIFxcXCJjdXJyZW5jeURhdGEvZnJhY3Rpb25zXFxcIiwgY3VycmVuY3kgXSkgfHxcXG5cXHRcXHRcXHRjbGRyLnN1cHBsZW1lbnRhbCggXFxcImN1cnJlbmN5RGF0YS9mcmFjdGlvbnMvREVGQVVMVFxcXCIgKTtcXG5cXG5cXHRkaWdpdHMgPSArZnJhY3Rpb25EYXRhLl9kaWdpdHM7XFxuXFxuXFx0aWYgKCBkaWdpdHMgKSB7XFxuXFx0XFx0ZnJhY3Rpb24gPSBcXFwiLlxcXCIgKyBzdHJpbmdQYWQoIFxcXCIwXFxcIiwgZGlnaXRzICkuc2xpY2UoIDAsIC0xICkgKyBmcmFjdGlvbkRhdGEuX3JvdW5kaW5nO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gcGF0dGVybi5yZXBsYWNlKCAvXFxcXC4oIyt8MCpbMC05XXwwK1swLTldPykvZywgZnJhY3Rpb24gKTtcXG59O1xcblxcblxcblxcblxcbnZhciBvYmplY3RGaWx0ZXIgPSBmdW5jdGlvbiggb2JqZWN0LCB0ZXN0UmUgKSB7XFxuXFx0dmFyIGtleSxcXG5cXHRcXHRjb3B5ID0ge307XFxuXFxuXFx0Zm9yICgga2V5IGluIG9iamVjdCApIHtcXG5cXHRcXHRpZiAoIHRlc3RSZS50ZXN0KCBrZXkgKSApIHtcXG5cXHRcXHRcXHRjb3B5WyBrZXkgXSA9IG9iamVjdFsga2V5IF07XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gY29weTtcXG59O1xcblxcblxcblxcblxcbnZhciBjdXJyZW5jeVVuaXRQYXR0ZXJucyA9IGZ1bmN0aW9uKCBjbGRyICkge1xcblxcdHJldHVybiBvYmplY3RGaWx0ZXIoIGNsZHIubWFpbihbXFxuXFx0XFx0XFxcIm51bWJlcnNcXFwiLFxcblxcdFxcdFxcXCJjdXJyZW5jeUZvcm1hdHMtbnVtYmVyU3lzdGVtLVxcXCIgKyBudW1iZXJOdW1iZXJpbmdTeXN0ZW0oIGNsZHIgKVxcblxcdF0pLCAvXnVuaXRQYXR0ZXJuLyApO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogbmFtZVByb3BlcnRpZXMoIGN1cnJlbmN5LCBjbGRyIClcXG4gKlxcbiAqIFJldHVybiBudW1iZXIgcGF0dGVybiB3aXRoIHRoZSBhcHByb3ByaWF0ZSBjdXJyZW5jeSBjb2RlIGluIGFzIGxpdGVyYWwuXFxuICovXFxudmFyIGN1cnJlbmN5TmFtZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggY3VycmVuY3ksIGNsZHIgKSB7XFxuXFx0dmFyIHBhdHRlcm4gPSBudW1iZXJQYXR0ZXJuKCBcXFwiZGVjaW1hbFxcXCIsIGNsZHIgKTtcXG5cXG5cXHQvLyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGFuZCB0aGUgcm91bmRpbmcgZm9yIGVhY2ggY3VycmVuY3kgaXMgbm90IGxvY2FsZS1zcGVjaWZpYy4gVGhvc2VcXG5cXHQvLyB2YWx1ZXMgb3ZlcnJpZGRlbiBieSBTdXBwbGVtZW50YWwgQ3VycmVuY3kgRGF0YS5cXG5cXHRwYXR0ZXJuID0gY3VycmVuY3lTdXBwbGVtZW50YWxPdmVycmlkZSggY3VycmVuY3ksIHBhdHRlcm4sIGNsZHIgKTtcXG5cXG5cXHRyZXR1cm4ge1xcblxcdFxcdGRpc3BsYXlOYW1lczogb2JqZWN0RmlsdGVyKCBjbGRyLm1haW4oW1xcblxcdFxcdFxcdFxcXCJudW1iZXJzL2N1cnJlbmNpZXNcXFwiLFxcblxcdFxcdFxcdGN1cnJlbmN5XFxuXFx0XFx0XSksIC9eZGlzcGxheU5hbWUvICksXFxuXFx0XFx0cGF0dGVybjogcGF0dGVybixcXG5cXHRcXHR1bml0UGF0dGVybnM6IGN1cnJlbmN5VW5pdFBhdHRlcm5zKCBjbGRyIClcXG5cXHR9O1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogVW5pY29kZSByZWd1bGFyIGV4cHJlc3Npb24gZm9yOiBldmVyeXRoaW5nIGV4Y2VwdCBtYXRoIHN5bWJvbHMsIGN1cnJlbmN5IHNpZ25zLCBkaW5nYmF0cywgYW5kXFxuICogYm94LWRyYXdpbmcgY2hhcmFjdGVycy5cXG4gKlxcbiAqIEdlbmVyYXRlZCBieTpcXG4gKlxcbiAqIHJlZ2VuZXJhdGUoKVxcbiAqICAgLmFkZFJhbmdlKCAweDAsIDB4MTBGRkZGIClcXG4gKiAgIC5yZW1vdmUoIHJlcXVpcmUoIFxcXCJ1bmljb2RlLTcuMC4wL2NhdGVnb3JpZXMvUy9zeW1ib2xzXFxcIiApICkudG9TdHJpbmcoKTtcXG4gKlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3JlZ2VuZXJhdGVcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy91bmljb2RlLTcuMC4wXFxuICovXFxudmFyIHJlZ2V4cE5vdFMgPSAvW1xcXFwwLSMlLVxcXFwqLC07XFxcXD8tXFxcXF1fYS1cXFxce1xcXFx9XFxcXHg3Ri1cXFxceEExXFxcXHhBN1xcXFx4QUFcXFxceEFCXFxcXHhBRFxcXFx4QjJcXFxceEIzXFxcXHhCNS1cXFxceEI3XFxcXHhCOS1cXFxceEQ2XFxcXHhEOC1cXFxceEY2XFxcXHhGOC1cXFxcdTAyQzFcXFxcdTAyQzYtXFxcXHUwMkQxXFxcXHUwMkUwLVxcXFx1MDJFNFxcXFx1MDJFQ1xcXFx1MDJFRVxcXFx1MDMwMC1cXFxcdTAzNzRcXFxcdTAzNzYtXFxcXHUwMzgzXFxcXHUwMzg2LVxcXFx1MDNGNVxcXFx1MDNGNy1cXFxcdTA0ODFcXFxcdTA0ODMtXFxcXHUwNThDXFxcXHUwNTkwLVxcXFx1MDYwNVxcXFx1MDYwOVxcXFx1MDYwQVxcXFx1MDYwQ1xcXFx1MDYwRFxcXFx1MDYxMC1cXFxcdTA2RERcXFxcdTA2REYtXFxcXHUwNkU4XFxcXHUwNkVBLVxcXFx1MDZGQ1xcXFx1MDZGRi1cXFxcdTA3RjVcXFxcdTA3RjctXFxcXHUwOUYxXFxcXHUwOUY0LVxcXFx1MDlGOVxcXFx1MDlGQy1cXFxcdTBBRjBcXFxcdTBBRjItXFxcXHUwQjZGXFxcXHUwQjcxLVxcXFx1MEJGMlxcXFx1MEJGQi1cXFxcdTBDN0VcXFxcdTBDODAtXFxcXHUwRDc4XFxcXHUwRDdBLVxcXFx1MEUzRVxcXFx1MEU0MC1cXFxcdTBGMDBcXFxcdTBGMDQtXFxcXHUwRjEyXFxcXHUwRjE0XFxcXHUwRjE4XFxcXHUwRjE5XFxcXHUwRjIwLVxcXFx1MEYzM1xcXFx1MEYzNVxcXFx1MEYzN1xcXFx1MEYzOS1cXFxcdTBGQkRcXFxcdTBGQzZcXFxcdTBGQ0RcXFxcdTBGRDAtXFxcXHUwRkQ0XFxcXHUwRkQ5LVxcXFx1MTA5RFxcXFx1MTBBMC1cXFxcdTEzOEZcXFxcdTEzOUEtXFxcXHUxN0RBXFxcXHUxN0RDLVxcXFx1MTkzRlxcXFx1MTk0MS1cXFxcdTE5RERcXFxcdTFBMDAtXFxcXHUxQjYwXFxcXHUxQjZCLVxcXFx1MUI3M1xcXFx1MUI3RC1cXFxcdTFGQkNcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkNDXFxcXHUxRkQwLVxcXFx1MUZEQ1xcXFx1MUZFMC1cXFxcdTFGRUNcXFxcdTFGRjAtXFxcXHUxRkZDXFxcXHUxRkZGLVxcXFx1MjA0M1xcXFx1MjA0NS1cXFxcdTIwNTFcXFxcdTIwNTMtXFxcXHUyMDc5XFxcXHUyMDdELVxcXFx1MjA4OVxcXFx1MjA4RC1cXFxcdTIwOUZcXFxcdTIwQkUtXFxcXHUyMEZGXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzOVxcXFx1MjEzQy1cXFxcdTIxM0ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTUwLVxcXFx1MjE4RlxcXFx1MjMwOC1cXFxcdTIzMEJcXFxcdTIzMjlcXFxcdTIzMkFcXFxcdTIzRkItXFxcXHUyM0ZGXFxcXHUyNDI3LVxcXFx1MjQzRlxcXFx1MjQ0Qi1cXFxcdTI0OUJcXFxcdTI0RUEtXFxcXHUyNEZGXFxcXHUyNzY4LVxcXFx1Mjc5M1xcXFx1MjdDNVxcXFx1MjdDNlxcXFx1MjdFNi1cXFxcdTI3RUZcXFxcdTI5ODMtXFxcXHUyOTk4XFxcXHUyOUQ4LVxcXFx1MjlEQlxcXFx1MjlGQ1xcXFx1MjlGRFxcXFx1MkI3NFxcXFx1MkI3NVxcXFx1MkI5NlxcXFx1MkI5N1xcXFx1MkJCQS1cXFxcdTJCQkNcXFxcdTJCQzlcXFxcdTJCRDItXFxcXHUyQ0U0XFxcXHUyQ0VCLVxcXFx1MkU3RlxcXFx1MkU5QVxcXFx1MkVGNC1cXFxcdTJFRkZcXFxcdTJGRDYtXFxcXHUyRkVGXFxcXHUyRkZDLVxcXFx1MzAwM1xcXFx1MzAwNS1cXFxcdTMwMTFcXFxcdTMwMTQtXFxcXHUzMDFGXFxcXHUzMDIxLVxcXFx1MzAzNVxcXFx1MzAzOC1cXFxcdTMwM0RcXFxcdTMwNDAtXFxcXHUzMDlBXFxcXHUzMDlELVxcXFx1MzE4RlxcXFx1MzE5Mi1cXFxcdTMxOTVcXFxcdTMxQTAtXFxcXHUzMUJGXFxcXHUzMUU0LVxcXFx1MzFGRlxcXFx1MzIxRi1cXFxcdTMyMjlcXFxcdTMyNDgtXFxcXHUzMjRGXFxcXHUzMjUxLVxcXFx1MzI1RlxcXFx1MzI4MC1cXFxcdTMyODlcXFxcdTMyQjEtXFxcXHUzMkJGXFxcXHUzMkZGXFxcXHUzNDAwLVxcXFx1NERCRlxcXFx1NEUwMC1cXFxcdUE0OEZcXFxcdUE0QzctXFxcXHVBNkZGXFxcXHVBNzE3LVxcXFx1QTcxRlxcXFx1QTcyMi1cXFxcdUE3ODhcXFxcdUE3OEItXFxcXHVBODI3XFxcXHVBODJDLVxcXFx1QTgzNVxcXFx1QTgzQS1cXFxcdUFBNzZcXFxcdUFBN0EtXFxcXHVBQjVBXFxcXHVBQjVDLVxcXFx1RDdGRlxcXFx1REMwMC1cXFxcdUZCMjhcXFxcdUZCMkEtXFxcXHVGQkIxXFxcXHVGQkMyLVxcXFx1RkRGQlxcXFx1RkRGRS1cXFxcdUZFNjFcXFxcdUZFNjNcXFxcdUZFNjdcXFxcdUZFNjhcXFxcdUZFNkEtXFxcXHVGRjAzXFxcXHVGRjA1LVxcXFx1RkYwQVxcXFx1RkYwQy1cXFxcdUZGMUJcXFxcdUZGMUYtXFxcXHVGRjNEXFxcXHVGRjNGXFxcXHVGRjQxLVxcXFx1RkY1QlxcXFx1RkY1RFxcXFx1RkY1Ri1cXFxcdUZGREZcXFxcdUZGRTdcXFxcdUZGRUYtXFxcXHVGRkZCXFxcXHVGRkZFXFxcXHVGRkZGXXxcXFxcdUQ4MDBbXFxcXHVEQzAwLVxcXFx1REQzNlxcXFx1REQ0MC1cXFxcdURENzhcXFxcdUREOEFcXFxcdUREOEJcXFxcdUREOEQtXFxcXHVERDhGXFxcXHVERDlDLVxcXFx1REQ5RlxcXFx1RERBMS1cXFxcdUREQ0ZcXFxcdURERkQtXFxcXHVERkZGXXxbXFxcXHVEODAxXFxcXHVEODAzLVxcXFx1RDgxOVxcXFx1RDgxQi1cXFxcdUQ4MkVcXFxcdUQ4MzAtXFxcXHVEODMzXFxcXHVEODM2LVxcXFx1RDgzQVxcXFx1RDgzRi1cXFxcdURCRkZdW1xcXFx1REMwMC1cXFxcdURGRkZdfFxcXFx1RDgwMltcXFxcdURDMDAtXFxcXHVEQzc2XFxcXHVEQzc5LVxcXFx1REVDN1xcXFx1REVDOS1cXFxcdURGRkZdfFxcXFx1RDgxQVtcXFxcdURDMDAtXFxcXHVERjNCXFxcXHVERjQwLVxcXFx1REY0NFxcXFx1REY0Ni1cXFxcdURGRkZdfFxcXFx1RDgyRltcXFxcdURDMDAtXFxcXHVEQzlCXFxcXHVEQzlELVxcXFx1REZGRl18XFxcXHVEODM0W1xcXFx1RENGNi1cXFxcdURDRkZcXFxcdUREMjdcXFxcdUREMjhcXFxcdURENjUtXFxcXHVERDY5XFxcXHVERDZELVxcXFx1REQ4MlxcXFx1REQ4NS1cXFxcdUREOEJcXFxcdUREQUEtXFxcXHVEREFEXFxcXHVERERFLVxcXFx1RERGRlxcXFx1REU0Mi1cXFxcdURFNDRcXFxcdURFNDYtXFxcXHVERUZGXFxcXHVERjU3LVxcXFx1REZGRl18XFxcXHVEODM1W1xcXFx1REMwMC1cXFxcdURFQzBcXFxcdURFQzItXFxcXHVERURBXFxcXHVERURDLVxcXFx1REVGQVxcXFx1REVGQy1cXFxcdURGMTRcXFxcdURGMTYtXFxcXHVERjM0XFxcXHVERjM2LVxcXFx1REY0RVxcXFx1REY1MC1cXFxcdURGNkVcXFxcdURGNzAtXFxcXHVERjg4XFxcXHVERjhBLVxcXFx1REZBOFxcXFx1REZBQS1cXFxcdURGQzJcXFxcdURGQzQtXFxcXHVERkZGXXxcXFxcdUQ4M0JbXFxcXHVEQzAwLVxcXFx1REVFRlxcXFx1REVGMi1cXFxcdURGRkZdfFxcXFx1RDgzQ1tcXFxcdURDMkMtXFxcXHVEQzJGXFxcXHVEQzk0LVxcXFx1REM5RlxcXFx1RENBRlxcXFx1RENCMFxcXFx1RENDMFxcXFx1RENEMFxcXFx1RENGNi1cXFxcdUREMEZcXFxcdUREMkZcXFxcdURENkMtXFxcXHVERDZGXFxcXHVERDlCLVxcXFx1RERFNVxcXFx1REUwMy1cXFxcdURFMEZcXFxcdURFM0ItXFxcXHVERTNGXFxcXHVERTQ5LVxcXFx1REU0RlxcXFx1REU1Mi1cXFxcdURFRkZcXFxcdURGMkQtXFxcXHVERjJGXFxcXHVERjdFXFxcXHVERjdGXFxcXHVERkNGLVxcXFx1REZEM1xcXFx1REZGOC1cXFxcdURGRkZdfFxcXFx1RDgzRFtcXFxcdURDRkZcXFxcdURENEItXFxcXHVERDRGXFxcXHVERDdBXFxcXHVEREE0XFxcXHVERTQzXFxcXHVERTQ0XFxcXHVERUQwLVxcXFx1REVERlxcXFx1REVFRC1cXFxcdURFRUZcXFxcdURFRjQtXFxcXHVERUZGXFxcXHVERjc0LVxcXFx1REY3RlxcXFx1REZENS1cXFxcdURGRkZdfFxcXFx1RDgzRVtcXFxcdURDMEMtXFxcXHVEQzBGXFxcXHVEQzQ4LVxcXFx1REM0RlxcXFx1REM1QS1cXFxcdURDNUZcXFxcdURDODgtXFxcXHVEQzhGXFxcXHVEQ0FFLVxcXFx1REZGRl18W1xcXFx1RDgwMC1cXFxcdURCRkZdLztcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBzeW1ib2xQcm9wZXJ0aWVzKCBjdXJyZW5jeSwgY2xkciApXFxuICpcXG4gKiBSZXR1cm4gcGF0dGVybiByZXBsYWNpbmcgYMKkYCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBjdXJyZW5jeSBzeW1ib2wgbGl0ZXJhbC5cXG4gKi9cXG52YXIgY3VycmVuY3lTeW1ib2xQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIGN1cnJlbmN5LCBjbGRyLCBvcHRpb25zICkge1xcblxcdHZhciBjdXJyZW5jeVNwYWNpbmcsIHBhdHRlcm4sIHN5bWJvbCwgc3ltYm9sRW50cmllcyxcXG5cXHRcXHRyZWdleHAgPSB7XFxuXFx0XFx0XFx0XFxcIls6ZGlnaXQ6XVxcXCI6IC9cXFxcZC8sXFxuXFx0XFx0XFx0XFxcIls6XlM6XVxcXCI6IHJlZ2V4cE5vdFNcXG5cXHRcXHR9O1xcblxcblxcdGlmICggb3B0aW9ucy5zdHlsZSA9PT0gXFxcImNvZGVcXFwiICkge1xcblxcdFxcdHN5bWJvbCA9IGN1cnJlbmN5O1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0c3ltYm9sRW50cmllcyA9IFsgXFxcInN5bWJvbFxcXCIgXTtcXG5cXG5cXHRcXHQvLyBJZiBvcHRpb25zLnN5bWJvbEZvcm0gPT09IFxcXCJuYXJyb3dcXFwiIHdhcyBwYXNzZWQsIHByZXBlbmQgaXQuXFxuXFx0XFx0aWYgKCBvcHRpb25zLnN5bWJvbEZvcm0gPT09IFxcXCJuYXJyb3dcXFwiICkge1xcblxcdFxcdFxcdHN5bWJvbEVudHJpZXMudW5zaGlmdCggXFxcInN5bWJvbC1hbHQtbmFycm93XFxcIiApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRzeW1ib2xFbnRyaWVzLnNvbWUoZnVuY3Rpb24oIHN5bWJvbEVudHJ5ICkge1xcblxcdFxcdFxcdHJldHVybiBzeW1ib2wgPSBjbGRyLm1haW4oW1xcblxcdFxcdFxcdFxcdFxcXCJudW1iZXJzL2N1cnJlbmNpZXNcXFwiLFxcblxcdFxcdFxcdFxcdGN1cnJlbmN5LFxcblxcdFxcdFxcdFxcdHN5bWJvbEVudHJ5XFxuXFx0XFx0XFx0XSk7XFxuXFx0XFx0fSk7XFxuXFx0fVxcblxcblxcdGN1cnJlbmN5U3BhY2luZyA9IFsgXFxcImJlZm9yZUN1cnJlbmN5XFxcIiwgXFxcImFmdGVyQ3VycmVuY3lcXFwiIF0ubWFwKGZ1bmN0aW9uKCBwb3NpdGlvbiApIHtcXG5cXHRcXHRyZXR1cm4gY2xkci5tYWluKFtcXG5cXHRcXHRcXHRcXFwibnVtYmVyc1xcXCIsXFxuXFx0XFx0XFx0XFxcImN1cnJlbmN5Rm9ybWF0cy1udW1iZXJTeXN0ZW0tXFxcIiArIG51bWJlck51bWJlcmluZ1N5c3RlbSggY2xkciApLFxcblxcdFxcdFxcdFxcXCJjdXJyZW5jeVNwYWNpbmdcXFwiLFxcblxcdFxcdFxcdHBvc2l0aW9uXFxuXFx0XFx0XSk7XFxuXFx0fSk7XFxuXFxuXFx0cGF0dGVybiA9IGNsZHIubWFpbihbXFxuXFx0XFx0XFxcIm51bWJlcnNcXFwiLFxcblxcdFxcdFxcXCJjdXJyZW5jeUZvcm1hdHMtbnVtYmVyU3lzdGVtLVxcXCIgKyBudW1iZXJOdW1iZXJpbmdTeXN0ZW0oIGNsZHIgKSxcXG5cXHRcXHRvcHRpb25zLnN0eWxlID09PSBcXFwiYWNjb3VudGluZ1xcXCIgPyBcXFwiYWNjb3VudGluZ1xcXCIgOiBcXFwic3RhbmRhcmRcXFwiXFxuXFx0XSk7XFxuXFxuXFx0cGF0dGVybiA9XFxuXFxuXFx0XFx0Ly8gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBhbmQgdGhlIHJvdW5kaW5nIGZvciBlYWNoIGN1cnJlbmN5IGlzIG5vdCBsb2NhbGUtc3BlY2lmaWMuXFxuXFx0XFx0Ly8gVGhvc2UgdmFsdWVzIGFyZSBvdmVycmlkZGVuIGJ5IFN1cHBsZW1lbnRhbCBDdXJyZW5jeSBEYXRhLlxcblxcdFxcdGN1cnJlbmN5U3VwcGxlbWVudGFsT3ZlcnJpZGUoIGN1cnJlbmN5LCBwYXR0ZXJuLCBjbGRyIClcXG5cXG5cXHRcXHQvLyBSZXBsYWNlIFxcXCLCpFxcXCIgKFxcXFx1MDBBNCkgd2l0aCB0aGUgYXBwcm9wcmlhdGUgc3ltYm9sIGxpdGVyYWwuXFxuXFx0XFx0LnNwbGl0KCBcXFwiO1xcXCIgKS5tYXAoZnVuY3Rpb24oIHBhdHRlcm4gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBhdHRlcm4uc3BsaXQoIFxcXCJcXFxcdTAwQTRcXFwiICkubWFwKGZ1bmN0aW9uKCBwYXJ0LCBpICkge1xcblxcdFxcdFxcdFxcdHZhciBjdXJyZW5jeU1hdGNoID0gcmVnZXhwWyBjdXJyZW5jeVNwYWNpbmdbIGkgXS5jdXJyZW5jeU1hdGNoIF0sXFxuXFx0XFx0XFx0XFx0XFx0c3Vycm91bmRpbmdNYXRjaCA9IHJlZ2V4cFsgY3VycmVuY3lTcGFjaW5nWyBpIF0uc3Vycm91bmRpbmdNYXRjaCBdLFxcblxcdFxcdFxcdFxcdFxcdGluc2VydEJldHdlZW4gPSBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBGb3IgY3VycmVuY3lNYXRjaCBhbmQgc3Vycm91bmRpbmdNYXRjaCBkZWZpbml0aW9ucywgcmVhZCBbMV0uXFxuXFx0XFx0XFx0XFx0Ly8gV2hlbiBpID09PSAwLCBiZWZvcmVDdXJyZW5jeSBpcyBiZWluZyBoYW5kbGVkLiBPdGhlcndpc2UsIGFmdGVyQ3VycmVuY3kuXFxuXFx0XFx0XFx0XFx0Ly8gMTogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1udW1iZXJzLmh0bWwjQ3VycmVuY2llc1xcblxcdFxcdFxcdFxcdGN1cnJlbmN5TWF0Y2ggPSBjdXJyZW5jeU1hdGNoLnRlc3QoIHN5bWJvbC5jaGFyQXQoIGkgPyBzeW1ib2wubGVuZ3RoIC0gMSA6IDAgKSApO1xcblxcdFxcdFxcdFxcdHN1cnJvdW5kaW5nTWF0Y2ggPSBzdXJyb3VuZGluZ01hdGNoLnRlc3QoXFxuXFx0XFx0XFx0XFx0XFx0cGFydC5jaGFyQXQoIGkgPyAwIDogcGFydC5sZW5ndGggLSAxICkucmVwbGFjZSggL1sjQCwuXS9nLCBcXFwiMFxcXCIgKVxcblxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjdXJyZW5jeU1hdGNoICYmIHBhcnQgJiYgc3Vycm91bmRpbmdNYXRjaCApIHtcXG5cXHRcXHRcXHRcXHRcXHRpbnNlcnRCZXR3ZWVuID0gY3VycmVuY3lTcGFjaW5nWyBpIF0uaW5zZXJ0QmV0d2VlbjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuICggaSA/IGluc2VydEJldHdlZW4gOiBcXFwiXFxcIiApICsgcGFydCArICggaSA/IFxcXCJcXFwiIDogaW5zZXJ0QmV0d2VlbiApO1xcblxcdFxcdFxcdH0pLmpvaW4oIFxcXCJcXFxcdTAwQTRcXFwiICk7XFxuXFx0XFx0fSkuam9pbiggXFxcIjtcXFwiICk7XFxuXFxuXFx0cmV0dXJuIHtcXG5cXHRcXHRwYXR0ZXJuOiBwYXR0ZXJuLFxcblxcdFxcdHN5bWJvbDogc3ltYm9sXFxuXFx0fTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIG5hbWVGb3JtYXQoIGZvcm1hdHRlZE51bWJlciwgcGx1cmFsRm9ybSwgcHJvcGVydGllcyApXFxuICpcXG4gKiBSZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5hbWUgZm9ybSBjdXJyZW5jeSBmb3JtYXQuXFxuICovXFxudmFyIGN1cnJlbmN5TmFtZUZvcm1hdCA9IGZ1bmN0aW9uKCBmb3JtYXR0ZWROdW1iZXIsIHBsdXJhbEZvcm0sIHByb3BlcnRpZXMgKSB7XFxuXFx0dmFyIGRpc3BsYXlOYW1lLCB1bml0UGF0dGVybixcXG5cXHRcXHRwYXJ0cyA9IFtdLFxcblxcdFxcdGRpc3BsYXlOYW1lcyA9IHByb3BlcnRpZXMuZGlzcGxheU5hbWVzIHx8IHt9LFxcblxcdFxcdHVuaXRQYXR0ZXJucyA9IHByb3BlcnRpZXMudW5pdFBhdHRlcm5zO1xcblxcblxcdGRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWVzWyBcXFwiZGlzcGxheU5hbWUtY291bnQtXFxcIiArIHBsdXJhbEZvcm0gXSB8fFxcblxcdFxcdGRpc3BsYXlOYW1lc1sgXFxcImRpc3BsYXlOYW1lLWNvdW50LW90aGVyXFxcIiBdIHx8XFxuXFx0XFx0ZGlzcGxheU5hbWVzLmRpc3BsYXlOYW1lIHx8XFxuXFx0XFx0cHJvcGVydGllcy5jdXJyZW5jeTtcXG5cXHR1bml0UGF0dGVybiA9IHVuaXRQYXR0ZXJuc1sgXFxcInVuaXRQYXR0ZXJuLWNvdW50LVxcXCIgKyBwbHVyYWxGb3JtIF0gfHxcXG5cXHRcXHR1bml0UGF0dGVybnNbIFxcXCJ1bml0UGF0dGVybi1jb3VudC1vdGhlclxcXCIgXTtcXG5cXG5cXHRmb3JtYXRNZXNzYWdlVG9QYXJ0cyggdW5pdFBhdHRlcm4sIFsgZm9ybWF0dGVkTnVtYmVyLCBkaXNwbGF5TmFtZSBdKS5mb3JFYWNoKGZ1bmN0aW9uKCBwYXJ0ICkge1xcblxcdFxcdGlmICggcGFydC50eXBlID09PSBcXFwidmFyaWFibGVcXFwiICYmIHBhcnQubmFtZSA9PT0gXFxcIjBcXFwiICkge1xcblxcdFxcdFxcdHBhcnQudmFsdWUuZm9yRWFjaChmdW5jdGlvbiggcGFydCApIHtcXG5cXHRcXHRcXHRcXHRwYXJ0c1B1c2goIHBhcnRzLCBwYXJ0LnR5cGUsIHBhcnQudmFsdWUgKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9IGVsc2UgaWYgKCBwYXJ0LnR5cGUgPT09IFxcXCJ2YXJpYWJsZVxcXCIgJiYgcGFydC5uYW1lID09PSBcXFwiMVxcXCIgKSB7XFxuXFx0XFx0XFx0cGFydHNQdXNoKCBwYXJ0cywgXFxcImN1cnJlbmN5XFxcIiwgcGFydC52YWx1ZSApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cGFydHNQdXNoKCBwYXJ0cywgXFxcImxpdGVyYWxcXFwiLCBwYXJ0LnZhbHVlICk7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdHJldHVybiBwYXJ0cztcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIHN5bWJvbEZvcm1hdCggcGFydHMsIHN5bWJvbCApXFxuICpcXG4gKiBSZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHN5bWJvbC9hY2NvdW50IGZvcm0gZm9ybWF0LlxcbiAqL1xcbnZhciBjdXJyZW5jeVN5bWJvbEZvcm1hdCA9IGZ1bmN0aW9uKCBwYXJ0cywgc3ltYm9sICkge1xcblxcdHBhcnRzLmZvckVhY2goZnVuY3Rpb24oIHBhcnQgKSB7XFxuXFx0XFx0aWYgKCBwYXJ0LnR5cGUgPT09IFxcXCJjdXJyZW5jeVxcXCIgKSB7XFxuXFx0XFx0XFx0cGFydC52YWx1ZSA9IHN5bWJvbDtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFx0cmV0dXJuIHBhcnRzO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIGN1cnJlbmN5VG9QYXJ0c0Zvcm1hdHRlckZuID0gZnVuY3Rpb24oIG51bWJlclRvUGFydHNGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApIHtcXG5cXHR2YXIgZm47XFxuXFxuXFx0Ly8gUmV0dXJuIGZvcm1hdHRlciB3aGVuIHN0eWxlIGlzIFxcXCJuYW1lXFxcIi5cXG5cXHRpZiAoIHBsdXJhbEdlbmVyYXRvciAmJiBwcm9wZXJ0aWVzICkge1xcblxcdFxcdGZuID0gZnVuY3Rpb24gY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdFxcdFxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXHRcXHRcXHRyZXR1cm4gY3VycmVuY3lOYW1lRm9ybWF0KFxcblxcdFxcdFxcdFxcdG51bWJlclRvUGFydHNGb3JtYXR0ZXIoIHZhbHVlICksXFxuXFx0XFx0XFx0XFx0cGx1cmFsR2VuZXJhdG9yKCB2YWx1ZSApLFxcblxcdFxcdFxcdFxcdHByb3BlcnRpZXNcXG5cXHRcXHRcXHQpO1xcblxcdFxcdH07XFxuXFxuXFx0Ly8gUmV0dXJuIGZvcm1hdHRlciB3aGVuIHN0eWxlIGlzIFxcXCJzeW1ib2xcXFwiLCBcXFwiYWNjb3VudGluZ1xcXCIsIG9yIFxcXCJjb2RlXFxcIi5cXG5cXHR9IGVsc2Uge1xcblxcdFxcdGZuID0gZnVuY3Rpb24gY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHQvLyAxOiBSZXVzaW5nIHBsdXJhbEdlbmVyYXRvciBhcmd1bWVudCwgYnV0IGluIHRoaXMgY2FzZSBpdCBpcyBhY3R1YWxseSBgc3ltYm9sYFxcblxcdFxcdFxcdHJldHVybiBjdXJyZW5jeVN5bWJvbEZvcm1hdCggbnVtYmVyVG9QYXJ0c0Zvcm1hdHRlciggdmFsdWUgKSwgcGx1cmFsR2VuZXJhdG9yIC8qIDEgKi8gKTtcXG5cXHRcXHR9O1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gZm47XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBvYmplY3RPbWl0KCBvYmplY3QsIGtleXMgKVxcbiAqXFxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0LCBmaWx0ZXJlZCB0byBvbWl0IHRoZSBibGFja2xpc3RlZCBrZXkgb3IgYXJyYXkgb2Yga2V5cy5cXG4gKi9cXG52YXIgb2JqZWN0T21pdCA9IGZ1bmN0aW9uKCBvYmplY3QsIGtleXMgKSB7XFxuXFx0dmFyIGtleSxcXG5cXHRcXHRjb3B5ID0ge307XFxuXFxuXFx0a2V5cyA9IGFsd2F5c0FycmF5KCBrZXlzICk7XFxuXFxuXFx0Zm9yICgga2V5IGluIG9iamVjdCApIHtcXG5cXHRcXHRpZiAoIGtleXMuaW5kZXhPZigga2V5ICkgPT09IC0xICkge1xcblxcdFxcdFxcdGNvcHlbIGtleSBdID0gb2JqZWN0WyBrZXkgXTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBjb3B5O1xcbn07XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gdmFsaWRhdGVSZXF1aXJlZENsZHIoIHBhdGgsIHZhbHVlICkge1xcblxcdHZhbGlkYXRlQ2xkciggcGF0aCwgdmFsdWUsIHtcXG5cXHRcXHRza2lwOiBbXFxuXFx0XFx0XFx0L251bWJlcnNcXFxcL2N1cnJlbmNpZXNcXFxcL1teL10rXFxcXC9zeW1ib2wtYWx0LS8sXFxuXFx0XFx0XFx0L3N1cHBsZW1lbnRhbFxcXFwvY3VycmVuY3lEYXRhXFxcXC9mcmFjdGlvbnNcXFxcL1tBLVphLXpdezN9JC9cXG5cXHRcXHRdXFxuXFx0fSk7XFxufVxcblxcbi8qKlxcbiAqIC5jdXJyZW5jeUZvcm1hdHRlciggY3VycmVuY3kgWywgb3B0aW9uc10gKVxcbiAqXFxuICogQGN1cnJlbmN5IFtTdHJpbmddIDMtbGV0dGVyIGN1cnJlbmN5IGNvZGUgYXMgZGVmaW5lZCBieSBJU08gNDIxNy5cXG4gKlxcbiAqIEBvcHRpb25zIFtPYmplY3RdOlxcbiAqIC0gc3R5bGU6IFtTdHJpbmddIFxcXCJzeW1ib2xcXFwiIChkZWZhdWx0KSwgXFxcImFjY291bnRpbmdcXFwiLCBcXFwiY29kZVxcXCIgb3IgXFxcIm5hbWVcXFwiLlxcbiAqIC0gc2VlIGFsc28gbnVtYmVyL2Zvcm1hdCBvcHRpb25zLlxcbiAqXFxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgY3VycmVuY3kgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCBkZWZhdWx0L2luc3RhbmNlXFxuICogbG9jYWxlLlxcbiAqL1xcbkdsb2JhbGl6ZS5jdXJyZW5jeUZvcm1hdHRlciA9XFxuR2xvYmFsaXplLnByb3RvdHlwZS5jdXJyZW5jeUZvcm1hdHRlciA9IGZ1bmN0aW9uKCBjdXJyZW5jeSwgb3B0aW9ucyApIHtcXG5cXHR2YXIgYXJncywgY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyLCByZXR1cm5GbjtcXG5cXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCBjdXJyZW5jeSwgXFxcImN1cnJlbmN5XFxcIiApO1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZUN1cnJlbmN5KCBjdXJyZW5jeSwgXFxcImN1cnJlbmN5XFxcIiApO1xcblxcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcXFwib3B0aW9uc1xcXCIgKTtcXG5cXG5cXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXHRhcmdzID0gWyBjdXJyZW5jeSwgb3B0aW9ucyBdO1xcblxcblxcdGN1cnJlbmN5VG9QYXJ0c0Zvcm1hdHRlciA9IHRoaXMuY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyKCBjdXJyZW5jeSwgb3B0aW9ucyApO1xcblxcdHJldHVybkZuID0gY3VycmVuY3lGb3JtYXR0ZXJGbiggY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyICk7XFxuXFx0cnVudGltZUJpbmQoIGFyZ3MsIHRoaXMuY2xkciwgcmV0dXJuRm4sIFsgY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyIF0gKTtcXG5cXG5cXHRyZXR1cm4gcmV0dXJuRm47XFxufTtcXG5cXG4vKipcXG4gKiAuY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyKCBjdXJyZW5jeSBbLCBvcHRpb25zXSApXFxuICpcXG4gKiBAY3VycmVuY3kgW1N0cmluZ10gMy1sZXR0ZXIgY3VycmVuY3kgY29kZSBhcyBkZWZpbmVkIGJ5IElTTyA0MjE3LlxcbiAqXFxuICogQG9wdGlvbnMgW09iamVjdF06XFxuICogLSBzdHlsZTogW1N0cmluZ10gXFxcInN5bWJvbFxcXCIgKGRlZmF1bHQpLCBcXFwiYWNjb3VudGluZ1xcXCIsIFxcXCJjb2RlXFxcIiBvciBcXFwibmFtZVxcXCIuXFxuICogLSBzZWUgYWxzbyBudW1iZXIvZm9ybWF0IG9wdGlvbnMuXFxuICpcXG4gKiBSZXR1cm4gYSBjdXJyZW5jeSBmb3JtYXR0ZXIgZnVuY3Rpb24gKG9mIHRoZSBmb3JtIGJlbG93KSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHRoZVxcbiAqIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxcbiAqXFxuICogZm4oIHZhbHVlIClcXG4gKlxcbiAqIEB2YWx1ZSBbTnVtYmVyXVxcbiAqXFxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgY3VycmVuY3kgdG8gcGFydHMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zXFxuICogYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cXG4gKi9cXG5HbG9iYWxpemUuY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyID1cXG5HbG9iYWxpemUucHJvdG90eXBlLmN1cnJlbmN5VG9QYXJ0c0Zvcm1hdHRlciA9IGZ1bmN0aW9uKCBjdXJyZW5jeSwgb3B0aW9ucyApIHtcXG5cXHR2YXIgYXJncywgY2xkciwgbnVtYmVyVG9QYXJ0c0Zvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzLCByZXR1cm5Gbiwgc3R5bGU7XFxuXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggY3VycmVuY3ksIFxcXCJjdXJyZW5jeVxcXCIgKTtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVDdXJyZW5jeSggY3VycmVuY3ksIFxcXCJjdXJyZW5jeVxcXCIgKTtcXG5cXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXFxcIm9wdGlvbnNcXFwiICk7XFxuXFxuXFx0Y2xkciA9IHRoaXMuY2xkcjtcXG5cXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG5cXHRhcmdzID0gWyBjdXJyZW5jeSwgb3B0aW9ucyBdO1xcblxcdHN0eWxlID0gb3B0aW9ucy5zdHlsZSB8fCBcXFwic3ltYm9sXFxcIjtcXG5cXG5cXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcXG5cXG5cXHQvLyBHZXQgcHJvcGVydGllcyBnaXZlbiBzdHlsZSAoXFxcInN5bWJvbFxcXCIgZGVmYXVsdCwgXFxcImNvZGVcXFwiIG9yIFxcXCJuYW1lXFxcIikuXFxuXFx0Y2xkci5vbiggXFxcImdldFxcXCIsIHZhbGlkYXRlUmVxdWlyZWRDbGRyICk7XFxuXFx0dHJ5IHtcXG5cXHRcXHRwcm9wZXJ0aWVzID0gKHtcXG5cXHRcXHRcXHRhY2NvdW50aW5nOiBjdXJyZW5jeVN5bWJvbFByb3BlcnRpZXMsXFxuXFx0XFx0XFx0Y29kZTogY3VycmVuY3lTeW1ib2xQcm9wZXJ0aWVzLFxcblxcdFxcdFxcdG5hbWU6IGN1cnJlbmN5TmFtZVByb3BlcnRpZXMsXFxuXFx0XFx0XFx0c3ltYm9sOiBjdXJyZW5jeVN5bWJvbFByb3BlcnRpZXNcXG5cXHRcXHR9WyBzdHlsZSBdICkoIGN1cnJlbmN5LCBjbGRyLCBvcHRpb25zICk7XFxuXFx0fSBmaW5hbGx5IHtcXG5cXHRcXHRjbGRyLm9mZiggXFxcImdldFxcXCIsIHZhbGlkYXRlUmVxdWlyZWRDbGRyICk7XFxuXFx0fVxcblxcblxcdC8vIG9wdGlvbnMgPSBvcHRpb25zIG1pbnVzIHN0eWxlLCBwbHVzIHJhdyBwYXR0ZXJuLlxcblxcdG9wdGlvbnMgPSBvYmplY3RPbWl0KCBvcHRpb25zLCBcXFwic3R5bGVcXFwiICk7XFxuXFx0b3B0aW9ucy5yYXcgPSBwcm9wZXJ0aWVzLnBhdHRlcm47XFxuXFxuXFx0Ly8gUmV0dXJuIGZvcm1hdHRlciB3aGVuIHN0eWxlIGlzIFxcXCJzeW1ib2xcXFwiLCBcXFwiYWNjb3VudGluZ1xcXCIsIG9yIFxcXCJjb2RlXFxcIi5cXG5cXHRpZiAoIHN0eWxlID09PSBcXFwic3ltYm9sXFxcIiB8fCBzdHlsZSA9PT0gXFxcImFjY291bnRpbmdcXFwiIHx8IHN0eWxlID09PSBcXFwiY29kZVxcXCIgKSB7XFxuXFx0XFx0bnVtYmVyVG9QYXJ0c0Zvcm1hdHRlciA9IHRoaXMubnVtYmVyVG9QYXJ0c0Zvcm1hdHRlciggb3B0aW9ucyApO1xcblxcblxcdFxcdHJldHVybkZuID0gY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyRm4oIG51bWJlclRvUGFydHNGb3JtYXR0ZXIsIHByb3BlcnRpZXMuc3ltYm9sICk7XFxuXFxuXFx0XFx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbIG51bWJlclRvUGFydHNGb3JtYXR0ZXIsIHByb3BlcnRpZXMuc3ltYm9sIF0gKTtcXG5cXG5cXHQvLyBSZXR1cm4gZm9ybWF0dGVyIHdoZW4gc3R5bGUgaXMgXFxcIm5hbWVcXFwiLlxcblxcdH0gZWxzZSB7XFxuXFx0XFx0bnVtYmVyVG9QYXJ0c0Zvcm1hdHRlciA9IHRoaXMubnVtYmVyVG9QYXJ0c0Zvcm1hdHRlciggb3B0aW9ucyApO1xcblxcblxcdFxcdC8vIElzIHBsdXJhbCBtb2R1bGUgcHJlc2VudD8gWWVzLCB1c2UgaXRzIGdlbmVyYXRvci4gTm9wZSwgdXNlIGFuIGVycm9yIGdlbmVyYXRvci5cXG5cXHRcXHRwbHVyYWxHZW5lcmF0b3IgPSB0aGlzLnBsdXJhbCAhPT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHR0aGlzLnBsdXJhbEdlbmVyYXRvcigpIDpcXG5cXHRcXHRcXHRjcmVhdGVFcnJvclBsdXJhbE1vZHVsZVByZXNlbmNlO1xcblxcblxcdFxcdHJldHVybkZuID0gY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyRm4oXFxuXFx0XFx0XFx0bnVtYmVyVG9QYXJ0c0Zvcm1hdHRlcixcXG5cXHRcXHRcXHRwbHVyYWxHZW5lcmF0b3IsXFxuXFx0XFx0XFx0cHJvcGVydGllc1xcblxcdFxcdCk7XFxuXFxuXFx0XFx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbXFxuXFx0XFx0XFx0bnVtYmVyVG9QYXJ0c0Zvcm1hdHRlcixcXG5cXHRcXHRcXHRwbHVyYWxHZW5lcmF0b3IsXFxuXFx0XFx0XFx0cHJvcGVydGllc1xcblxcdFxcdF0pO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gcmV0dXJuRm47XFxufTtcXG5cXG4vKipcXG4gKiAuY3VycmVuY3lQYXJzZXIoIGN1cnJlbmN5IFssIG9wdGlvbnNdIClcXG4gKlxcbiAqIEBjdXJyZW5jeSBbU3RyaW5nXSAzLWxldHRlciBjdXJyZW5jeSBjb2RlIGFzIGRlZmluZWQgYnkgSVNPIDQyMTcuXFxuICpcXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgY3VycmVuY3lGb3JtYXR0ZXIuXFxuICpcXG4gKiBSZXR1cm4gdGhlIGN1cnJlbmN5IHBhcnNlciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cXG4gKi9cXG5HbG9iYWxpemUuY3VycmVuY3lQYXJzZXIgPVxcbkdsb2JhbGl6ZS5wcm90b3R5cGUuY3VycmVuY3lQYXJzZXIgPSBmdW5jdGlvbiggLyogY3VycmVuY3ksIG9wdGlvbnMgKi8gKSB7XFxuXFxuXFx0Ly8gVE9ETyBpbXBsZW1lbnQgcGFyc2VyLlxcblxcbn07XFxuXFxuLyoqXFxuICogLmZvcm1hdEN1cnJlbmN5KCB2YWx1ZSwgY3VycmVuY3kgWywgb3B0aW9uc10gKVxcbiAqXFxuICogQHZhbHVlIFtOdW1iZXJdIG51bWJlciB0byBiZSBmb3JtYXR0ZWQuXFxuICpcXG4gKiBAY3VycmVuY3kgW1N0cmluZ10gMy1sZXR0ZXIgY3VycmVuY3kgY29kZSBhcyBkZWZpbmVkIGJ5IElTTyA0MjE3LlxcbiAqXFxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGN1cnJlbmN5Rm9ybWF0dGVyLlxcbiAqXFxuICogRm9ybWF0IGEgY3VycmVuY3kgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCB0aGUgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXFxuICovXFxuR2xvYmFsaXplLmZvcm1hdEN1cnJlbmN5ID1cXG5HbG9iYWxpemUucHJvdG90eXBlLmZvcm1hdEN1cnJlbmN5ID0gZnVuY3Rpb24oIHZhbHVlLCBjdXJyZW5jeSwgb3B0aW9ucyApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXHRyZXR1cm4gdGhpcy5jdXJyZW5jeUZvcm1hdHRlciggY3VycmVuY3ksIG9wdGlvbnMgKSggdmFsdWUgKTtcXG59O1xcblxcbi8qKlxcbiAqIC5mb3JtYXRDdXJyZW5jeVRvUGFydHMoIHZhbHVlLCBjdXJyZW5jeSBbLCBvcHRpb25zXSApXFxuICpcXG4gKiBAdmFsdWUgW051bWJlcl0gbnVtYmVyIHRvIGJlIGZvcm1hdHRlZC5cXG4gKlxcbiAqIEBjdXJyZW5jeSBbU3RyaW5nXSAzLWxldHRlciBjdXJyZW5jeSBjb2RlIGFzIGRlZmluZWQgYnkgSVNPIDQyMTcuXFxuICpcXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgY3VycmVuY3lGb3JtYXR0ZXIuXFxuICpcXG4gKiBGb3JtYXQgYSBjdXJyZW5jeSB0byBwYXJ0cyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cXG4gKi9cXG5HbG9iYWxpemUuZm9ybWF0Q3VycmVuY3lUb1BhcnRzID1cXG5HbG9iYWxpemUucHJvdG90eXBlLmZvcm1hdEN1cnJlbmN5VG9QYXJ0cyA9IGZ1bmN0aW9uKCB2YWx1ZSwgY3VycmVuY3ksIG9wdGlvbnMgKSB7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcXFwidmFsdWVcXFwiICk7XFxuXFx0cmV0dXJuIHRoaXMuY3VycmVuY3lUb1BhcnRzRm9ybWF0dGVyKCBjdXJyZW5jeSwgb3B0aW9ucyApKCB2YWx1ZSApO1xcbn07XFxuXFxuLyoqXFxuICogLnBhcnNlQ3VycmVuY3koIHZhbHVlLCBjdXJyZW5jeSBbLCBvcHRpb25zXSApXFxuICpcXG4gKiBAdmFsdWUgW1N0cmluZ11cXG4gKlxcbiAqIEBjdXJyZW5jeSBbU3RyaW5nXSAzLWxldHRlciBjdXJyZW5jeSBjb2RlIGFzIGRlZmluZWQgYnkgSVNPIDQyMTcuXFxuICpcXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTogU2VlIGN1cnJlbmN5Rm9ybWF0dGVyLlxcbiAqXFxuICogUmV0dXJuIHRoZSBwYXJzZWQgY3VycmVuY3kgb3IgTmFOIHdoZW4gdmFsdWUgaXMgaW52YWxpZC5cXG4gKi9cXG5HbG9iYWxpemUucGFyc2VDdXJyZW5jeSA9XFxuR2xvYmFsaXplLnByb3RvdHlwZS5wYXJzZUN1cnJlbmN5ID0gZnVuY3Rpb24oIC8qIHZhbHVlLCBjdXJyZW5jeSwgb3B0aW9ucyAqLyApIHtcXG59O1xcblxcbnJldHVybiBHbG9iYWxpemU7XFxuXFxuXFxuXFxuXFxufSkpO1xcblwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(27))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL2RhdGUuanM/NmNjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXGdsb2JhbGl6ZVxcXFxkaXN0XFxcXGdsb2JhbGl6ZVxcXFxkYXRlLmpzXCIpKSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n")},function(module,exports){eval('module.exports = "/**\\n * Globalize v1.5.0\\n *\\n * http://github.com/jquery/globalize\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2020-03-25T12:19Z\\n */\\n/*!\\n * Globalize v1.5.0 2020-03-25T12:19Z Released under the MIT license\\n * http://git.io/TrdQbw\\n */\\n(function( root, factory ) {\\n\\n\\t// UMD returnExports\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\n\\t\\t// AMD\\n\\t\\tdefine([\\n\\t\\t\\t\\"cldr\\",\\n\\t\\t\\t\\"../globalize\\",\\n\\t\\t\\t\\"./number\\",\\n\\t\\t\\t\\"cldr/event\\",\\n\\t\\t\\t\\"cldr/supplemental\\"\\n\\t\\t], factory );\\n\\t} else if ( typeof exports === \\"object\\" ) {\\n\\n\\t\\t// Node, CommonJS\\n\\t\\tmodule.exports = factory( require( \\"cldrjs\\" ), require( \\"../globalize\\" ) );\\n\\t} else {\\n\\n\\t\\t// Extend global\\n\\t\\tfactory( root.Cldr, root.Globalize );\\n\\t}\\n}(this, function( Cldr, Globalize ) {\\n\\nvar createError = Globalize._createError,\\n\\tcreateErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,\\n\\tformatMessage = Globalize._formatMessage,\\n\\tisPlainObject = Globalize._isPlainObject,\\n\\tlooseMatching = Globalize._looseMatching,\\n\\tnumberNumberingSystemDigitsMap = Globalize._numberNumberingSystemDigitsMap,\\n\\tnumberSymbol = Globalize._numberSymbol,\\n\\tpartsJoin = Globalize._partsJoin,\\n\\tpartsPush = Globalize._partsPush,\\n\\tregexpEscape = Globalize._regexpEscape,\\n\\tremoveLiteralQuotes = Globalize._removeLiteralQuotes,\\n\\truntimeBind = Globalize._runtimeBind,\\n\\tstringPad = Globalize._stringPad,\\n\\tvalidate = Globalize._validate,\\n\\tvalidateCldr = Globalize._validateCldr,\\n\\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\\n\\tvalidateParameterPresence = Globalize._validateParameterPresence,\\n\\tvalidateParameterType = Globalize._validateParameterType,\\n\\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,\\n\\tvalidateParameterTypeString = Globalize._validateParameterTypeString;\\n\\n\\nvar validateParameterTypeDate = function( value, name ) {\\n\\tvalidateParameterType( value, name, value === undefined || value instanceof Date, \\"Date\\" );\\n};\\n\\n\\n\\n\\nvar createErrorInvalidParameterValue = function( name, value ) {\\n\\treturn createError( \\"E_INVALID_PAR_VALUE\\", \\"Invalid `{name}` value ({value}).\\", {\\n\\t\\tname: name,\\n\\t\\tvalue: value\\n\\t});\\n};\\n\\n\\n\\n\\n/**\\n * Create a map between the skeleton fields and their positions, e.g.,\\n * {\\n *   G: 0\\n *   y: 1\\n *   ...\\n * }\\n */\\nvar validateSkeletonFieldsPosMap = \\"GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx\\".split( \\"\\" ).reduce(function( memo, item, i ) {\\n\\tmemo[ item ] = i;\\n\\treturn memo;\\n}, {});\\n\\n\\n\\n\\n/**\\n * validateSkeleton( skeleton )\\n *\\n * skeleton: Assume `j` has already been converted into a localized hour field.\\n */\\nvar validateSkeleton = function validateSkeleton( skeleton ) {\\n\\tvar last,\\n\\n\\t\\t// Using easier to read variable.\\n\\t\\tfieldsPosMap = validateSkeletonFieldsPosMap;\\n\\n\\t// \\"The fields are from the Date Field Symbol Table in Date Format Patterns\\"\\n\\t// Ref: http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\\n\\t// I.e., check for invalid characters.\\n\\tskeleton.replace( /[^GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx]/, function( field ) {\\n\\t\\tthrow createError(\\n\\t\\t\\t\\"E_INVALID_OPTIONS\\", \\"Invalid field `{invalidField}` of skeleton `{value}`\\",\\n\\t\\t\\t{\\n\\t\\t\\t\\tinvalidField: field,\\n\\t\\t\\t\\ttype: \\"skeleton\\",\\n\\t\\t\\t\\tvalue: skeleton\\n\\t\\t\\t}\\n\\t\\t);\\n\\t});\\n\\n\\t// \\"The canonical order is from top to bottom in that table; that is, yM not My\\".\\n\\t// http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\\n\\t// I.e., check for invalid order.\\n\\tskeleton.split( \\"\\" ).every(function( field ) {\\n\\t\\tif ( fieldsPosMap[ field ] < last ) {\\n\\t\\t\\tthrow createError(\\n\\t\\t\\t\\t\\"E_INVALID_OPTIONS\\", \\"Invalid order `{invalidField}` of skeleton `{value}`\\",\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tinvalidField: field,\\n\\t\\t\\t\\t\\ttype: \\"skeleton\\",\\n\\t\\t\\t\\t\\tvalue: skeleton\\n\\t\\t\\t\\t}\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\tlast = fieldsPosMap[ field ];\\n\\t\\treturn true;\\n\\t});\\n};\\n\\n\\n\\n\\n/**\\n * Returns a new object created by using `object`\'s values as keys, and the keys as values.\\n */\\nvar objectInvert = function( object, fn ) {\\n\\tfn = fn || function( object, key, value ) {\\n\\t\\tobject[ value ] = key;\\n\\t\\treturn object;\\n\\t};\\n\\treturn Object.keys( object ).reduce(function( newObject, key ) {\\n\\t\\treturn fn( newObject, key, object[ key ] );\\n\\t}, {});\\n};\\n\\n\\n\\n\\n// Invert key and values, e.g., {\\"e\\": \\"eEc\\"} ==> {\\"e\\": \\"e\\", \\"E\\": \\"e\\", \\"c\\": \\"e\\"}.\\nvar dateExpandPatternSimilarFieldsMap = objectInvert({\\n\\t\\"e\\": \\"eEc\\",\\n\\t\\"L\\": \\"ML\\"\\n}, function( object, key, value ) {\\n\\tvalue.split( \\"\\" ).forEach(function( field ) {\\n\\t\\tobject[ field ] = key;\\n\\t});\\n\\treturn object;\\n});\\n\\n\\n\\n\\nvar dateExpandPatternNormalizePatternType = function( character ) {\\n\\treturn dateExpandPatternSimilarFieldsMap[ character ] || character;\\n};\\n\\n\\n\\n\\nvar datePatternRe = ( /([a-z])\\\\1*|\'([^\']|\'\')+\'|\'\'|./ig );\\n\\n\\n\\n\\nvar stringRepeat = function( str, count ) {\\n\\tvar i, result = \\"\\";\\n\\tfor ( i = 0; i < count; i++ ) {\\n\\t\\tresult = result + str;\\n\\t}\\n\\treturn result;\\n};\\n\\n\\n\\n\\nfunction expandBestMatchFormat( skeletonWithoutFractionalSeconds, bestMatchFormat ) {\\n\\tvar i, j, bestMatchFormatParts, matchedType, matchedLength, requestedType,\\n\\t\\trequestedLength, requestedSkeletonParts,\\n\\n\\t\\t// Using an easier to read variable.\\n\\t\\tnormalizePatternType = dateExpandPatternNormalizePatternType;\\n\\n\\trequestedSkeletonParts = skeletonWithoutFractionalSeconds.match( datePatternRe );\\n\\tbestMatchFormatParts = bestMatchFormat.match( datePatternRe );\\n\\n\\tfor ( i = 0; i < bestMatchFormatParts.length; i++ ) {\\n\\t\\tmatchedType = bestMatchFormatParts[i].charAt( 0 );\\n\\t\\tmatchedLength = bestMatchFormatParts[i].length;\\n\\t\\tfor ( j = 0; j < requestedSkeletonParts.length; j++ ) {\\n\\t\\t\\trequestedType = requestedSkeletonParts[j].charAt( 0 );\\n\\t\\t\\trequestedLength = requestedSkeletonParts[j].length;\\n\\t\\t\\tif ( normalizePatternType( matchedType ) === normalizePatternType( requestedType ) &&\\n\\t\\t\\t\\tmatchedLength < requestedLength\\n\\t\\t\\t) {\\n\\t\\t\\t\\tbestMatchFormatParts[i] = stringRepeat( matchedType, requestedLength );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn bestMatchFormatParts.join( \\"\\" );\\n}\\n\\n// See: http://www.unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\\nvar dateExpandPatternAugmentFormat = function( requestedSkeleton, bestMatchFormat, decimalSeparator ) {\\n\\tvar countOfFractionalSeconds, fractionalSecondMatch, lastSecondIdx,\\n\\t\\tskeletonWithoutFractionalSeconds;\\n\\n\\tfractionalSecondMatch = requestedSkeleton.match( /S/g );\\n\\tcountOfFractionalSeconds = fractionalSecondMatch ? fractionalSecondMatch.length : 0;\\n\\tskeletonWithoutFractionalSeconds = requestedSkeleton.replace( /S/g, \\"\\" );\\n\\n\\tbestMatchFormat = expandBestMatchFormat( skeletonWithoutFractionalSeconds, bestMatchFormat );\\n\\n\\tlastSecondIdx = bestMatchFormat.lastIndexOf( \\"s\\" );\\n\\tif ( lastSecondIdx !== -1 && countOfFractionalSeconds !== 0 ) {\\n\\t\\tbestMatchFormat =\\n\\t\\t\\tbestMatchFormat.slice( 0, lastSecondIdx + 1 ) +\\n\\t\\t\\tdecimalSeparator +\\n\\t\\t\\tstringRepeat( \\"S\\", countOfFractionalSeconds ) +\\n\\t\\t\\tbestMatchFormat.slice( lastSecondIdx + 1 );\\n\\t}\\n\\treturn bestMatchFormat;\\n};\\n\\n\\n\\n\\nvar dateExpandPatternCompareFormats = function( formatA, formatB ) {\\n\\tvar a, b, distance, lenA, lenB, typeA, typeB, i, j,\\n\\n\\t\\t// Using easier to read variables.\\n\\t\\tnormalizePatternType = dateExpandPatternNormalizePatternType;\\n\\n\\tif ( formatA === formatB ) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tformatA = formatA.match( datePatternRe );\\n\\tformatB = formatB.match( datePatternRe );\\n\\n\\tif ( formatA.length !== formatB.length ) {\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tdistance = 1;\\n\\tfor ( i = 0; i < formatA.length; i++ ) {\\n\\t\\ta = formatA[ i ].charAt( 0 );\\n\\t\\ttypeA = normalizePatternType( a );\\n\\t\\ttypeB = null;\\n\\t\\tfor ( j = 0; j < formatB.length; j++ ) {\\n\\t\\t\\tb = formatB[ j ].charAt( 0 );\\n\\t\\t\\ttypeB = normalizePatternType( b );\\n\\t\\t\\tif ( typeA === typeB ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttypeB = null;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( typeB === null ) {\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tlenA = formatA[ i ].length;\\n\\t\\tlenB = formatB[ j ].length;\\n\\t\\tdistance = distance + Math.abs( lenA - lenB );\\n\\n\\t\\t// Most symbols have a small distance from each other, e.g., M  L; E  c; a  b  B;\\n\\t\\t// H  k  h  K; ...\\n\\t\\tif ( a !== b ) {\\n\\t\\t\\tdistance += 1;\\n\\t\\t}\\n\\n\\t\\t// Numeric (l<3) and text fields (l>=3) are given a larger distance from each other.\\n\\t\\tif ( ( lenA < 3 && lenB >= 3 ) || ( lenA >= 3 && lenB < 3 ) ) {\\n\\t\\t\\tdistance += 20;\\n\\t\\t}\\n\\t}\\n\\treturn distance;\\n};\\n\\n\\n\\n\\nvar dateExpandPatternGetBestMatchPattern = function( cldr, askedSkeleton ) {\\n\\tvar availableFormats, decimalSeparator, pattern, ratedFormats, skeleton,\\n\\t\\tpath = \\"dates/calendars/gregorian/dateTimeFormats/availableFormats\\",\\n\\n\\t\\t// Using easier to read variables.\\n\\t\\taugmentFormat = dateExpandPatternAugmentFormat,\\n\\t\\tcompareFormats = dateExpandPatternCompareFormats;\\n\\n\\tpattern = cldr.main([ path, askedSkeleton ]);\\n\\n\\tif ( askedSkeleton && !pattern ) {\\n\\t\\tavailableFormats = cldr.main([ path ]);\\n\\t\\tratedFormats = [];\\n\\n\\t\\tfor ( skeleton in availableFormats ) {\\n\\t\\t\\tratedFormats.push({\\n\\t\\t\\t\\tskeleton: skeleton,\\n\\t\\t\\t\\tpattern: availableFormats[ skeleton ],\\n\\t\\t\\t\\trate: compareFormats( askedSkeleton, skeleton )\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tratedFormats = ratedFormats\\n\\t\\t\\t.filter( function( format ) {\\n\\t\\t\\t\\treturn format.rate > -1;\\n\\t\\t\\t} )\\n\\t\\t\\t.sort( function( formatA, formatB ) {\\n\\t\\t\\t\\treturn formatA.rate - formatB.rate;\\n\\t\\t\\t});\\n\\n\\t\\tif ( ratedFormats.length ) {\\n\\t\\t\\tdecimalSeparator = numberSymbol( \\"decimal\\", cldr );\\n\\t\\t\\tpattern = augmentFormat( askedSkeleton, ratedFormats[0].pattern, decimalSeparator );\\n\\t\\t}\\n\\t}\\n\\n\\treturn pattern;\\n};\\n\\n\\n\\n\\n/**\\n * expandPattern( options, cldr )\\n *\\n * @options [Object] if String, it\'s considered a skeleton. Object accepts:\\n * - skeleton: [String] lookup availableFormat;\\n * - date: [String] ( \\"full\\" | \\"long\\" | \\"medium\\" | \\"short\\" );\\n * - time: [String] ( \\"full\\" | \\"long\\" | \\"medium\\" | \\"short\\" );\\n * - datetime: [String] ( \\"full\\" | \\"long\\" | \\"medium\\" | \\"short\\" );\\n * - raw: [String] For more info see datetime/format.js.\\n *\\n * @cldr [Cldr instance].\\n *\\n * Return the corresponding pattern.\\n * Eg for \\"en\\":\\n * - \\"GyMMMd\\" returns \\"MMM d, y G\\";\\n * - { skeleton: \\"GyMMMd\\" } returns \\"MMM d, y G\\";\\n * - { date: \\"full\\" } returns \\"EEEE, MMMM d, y\\";\\n * - { time: \\"full\\" } returns \\"h:mm:ss a zzzz\\";\\n * - { datetime: \\"full\\" } returns \\"EEEE, MMMM d, y \'at\' h:mm:ss a zzzz\\";\\n * - { raw: \\"dd/mm\\" } returns \\"dd/mm\\";\\n */\\nvar dateExpandPattern = function( options, cldr ) {\\n\\tvar dateSkeleton, result, skeleton, timeSkeleton, type,\\n\\n\\t\\t// Using easier to read variables.\\n\\t\\tgetBestMatchPattern = dateExpandPatternGetBestMatchPattern;\\n\\n\\tfunction combineDateTime( type, datePattern, timePattern ) {\\n\\t\\treturn formatMessage(\\n\\t\\t\\tcldr.main([\\n\\t\\t\\t\\t\\"dates/calendars/gregorian/dateTimeFormats\\",\\n\\t\\t\\t\\ttype\\n\\t\\t\\t]),\\n\\t\\t\\t[ timePattern, datePattern ]\\n\\t\\t);\\n\\t}\\n\\n\\tswitch ( true ) {\\n\\t\\tcase \\"skeleton\\" in options:\\n\\t\\t\\tskeleton = options.skeleton;\\n\\n\\t\\t\\t// Preferred hour (j).\\n\\t\\t\\tskeleton = skeleton.replace( /j/g, function() {\\n\\t\\t\\t\\treturn cldr.supplemental.timeData.preferred();\\n\\t\\t\\t});\\n\\n\\t\\t\\tvalidateSkeleton( skeleton );\\n\\n\\t\\t\\t// Try direct map (note that getBestMatchPattern handles it).\\n\\t\\t\\t// ... or, try to \\"best match\\" the whole skeleton.\\n\\t\\t\\tresult = getBestMatchPattern(\\n\\t\\t\\t\\tcldr,\\n\\t\\t\\t\\tskeleton\\n\\t\\t\\t);\\n\\t\\t\\tif ( result ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ... or, try to \\"best match\\" the date and time parts individually.\\n\\t\\t\\ttimeSkeleton = skeleton.split( /[^hHKkmsSAzZOvVXx]/ ).slice( -1 )[ 0 ];\\n\\t\\t\\tdateSkeleton = skeleton.split( /[^GyYuUrQqMLlwWdDFgEec]/ )[ 0 ];\\n\\t\\t\\tdateSkeleton = getBestMatchPattern(\\n\\t\\t\\t\\tcldr,\\n\\t\\t\\t\\tdateSkeleton\\n\\t\\t\\t);\\n\\t\\t\\ttimeSkeleton = getBestMatchPattern(\\n\\t\\t\\t\\tcldr,\\n\\t\\t\\t\\ttimeSkeleton\\n\\t\\t\\t);\\n\\n\\t\\t\\tif ( /(MMMM|LLLL).*[Ec]/.test( dateSkeleton ) ) {\\n\\t\\t\\t\\ttype = \\"full\\";\\n\\t\\t\\t} else if ( /MMMM|LLLL/.test( dateSkeleton ) ) {\\n\\t\\t\\t\\ttype = \\"long\\";\\n\\t\\t\\t} else if ( /MMM|LLL/.test( dateSkeleton ) ) {\\n\\t\\t\\t\\ttype = \\"medium\\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttype = \\"short\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( dateSkeleton && timeSkeleton ) {\\n\\t\\t\\t\\tresult = combineDateTime( type, dateSkeleton, timeSkeleton );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult = dateSkeleton || timeSkeleton;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbreak;\\n\\n\\t\\tcase \\"date\\" in options:\\n\\t\\tcase \\"time\\" in options:\\n\\t\\t\\tresult = cldr.main([\\n\\t\\t\\t\\t\\"dates/calendars/gregorian\\",\\n\\t\\t\\t\\t\\"date\\" in options ? \\"dateFormats\\" : \\"timeFormats\\",\\n\\t\\t\\t\\t( options.date || options.time )\\n\\t\\t\\t]);\\n\\t\\t\\tbreak;\\n\\n\\t\\tcase \\"datetime\\" in options:\\n\\t\\t\\tresult = combineDateTime( options.datetime,\\n\\t\\t\\t\\tcldr.main([ \\"dates/calendars/gregorian/dateFormats\\", options.datetime ]),\\n\\t\\t\\t\\tcldr.main([ \\"dates/calendars/gregorian/timeFormats\\", options.datetime ])\\n\\t\\t\\t);\\n\\t\\t\\tbreak;\\n\\n\\t\\tcase \\"raw\\" in options:\\n\\t\\t\\tresult = options.raw;\\n\\t\\t\\tbreak;\\n\\n\\t\\tdefault:\\n\\t\\t\\tthrow createErrorInvalidParameterValue({\\n\\t\\t\\t\\tname: \\"options\\",\\n\\t\\t\\t\\tvalue: options\\n\\t\\t\\t});\\n\\t}\\n\\n\\treturn result;\\n};\\n\\n\\n\\n\\nvar dateWeekDays = [ \\"sun\\", \\"mon\\", \\"tue\\", \\"wed\\", \\"thu\\", \\"fri\\", \\"sat\\" ];\\n\\n\\n\\n\\n/**\\n * firstDayOfWeek\\n */\\nvar dateFirstDayOfWeek = function( cldr ) {\\n\\treturn dateWeekDays.indexOf( cldr.supplemental.weekData.firstDay() );\\n};\\n\\n\\n\\n\\n/**\\n * getTimeZoneName( length, type )\\n */\\nvar dateGetTimeZoneName = function( length, type, timeZone, cldr ) {\\n\\tvar metaZone, result;\\n\\n\\tif ( !timeZone ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tresult = cldr.main([\\n\\t\\t\\"dates/timeZoneNames/zone\\",\\n\\t\\ttimeZone,\\n\\t\\tlength < 4 ? \\"short\\" : \\"long\\",\\n\\t\\ttype\\n\\t]);\\n\\n\\tif ( result ) {\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// The latest metazone data of the metazone array.\\n\\t// TODO expand to support the historic metazones based on the given date.\\n\\tmetaZone = cldr.supplemental([\\n\\t\\t\\"metaZones/metazoneInfo/timezone\\", timeZone, 0,\\n\\t\\t\\"usesMetazone/_mzone\\"\\n\\t]);\\n\\n\\treturn cldr.main([\\n\\t\\t\\"dates/timeZoneNames/metazone\\",\\n\\t\\tmetaZone,\\n\\t\\tlength < 4 ? \\"short\\" : \\"long\\",\\n\\t\\ttype\\n\\t]);\\n};\\n\\n\\n\\n\\n/**\\n * timezoneHourFormatShortH( hourFormat )\\n *\\n * @hourFormat [String]\\n *\\n * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.\\n * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\\n *\\n * Example:\\n * - \\"+HH.mm;-HH.mm\\" => \\"+H;-H\\"\\n * - \\"+HH:mm;-HH:mm\\" => \\"+H;-H\\"\\n * - \\"+HH:mm;HH:mm\\" => \\"+H;H\\" (Note MINUS SIGN \\\\u2212)\\n * - \\"+HHmm;-HHmm\\" => \\"+H:-H\\"\\n */\\nvar dateTimezoneHourFormatH = function( hourFormat ) {\\n\\treturn hourFormat\\n\\t\\t.split( \\";\\" )\\n\\t\\t.map(function( format ) {\\n\\t\\t\\treturn format.slice( 0, format.indexOf( \\"H\\" ) + 1 );\\n\\t\\t})\\n\\t\\t.join( \\";\\" );\\n};\\n\\n\\n\\n\\n/**\\n * timezoneHourFormatLongHm( hourFormat )\\n *\\n * @hourFormat [String]\\n *\\n * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.\\n * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\\n *\\n * Example (hFormat === \\"H\\"): (used for short Hm)\\n * - \\"+HH.mm;-HH.mm\\" => \\"+H.mm;-H.mm\\"\\n * - \\"+HH:mm;-HH:mm\\" => \\"+H:mm;-H:mm\\"\\n * - \\"+HH:mm;HH:mm\\" => \\"+H:mm;H:mm\\" (Note MINUS SIGN \\\\u2212)\\n * - \\"+HHmm;-HHmm\\" => \\"+Hmm:-Hmm\\"\\n *\\n * Example (hFormat === \\"HH\\": (used for long Hm)\\n * - \\"+HH.mm;-HH.mm\\" => \\"+HH.mm;-HH.mm\\"\\n * - \\"+HH:mm;-HH:mm\\" => \\"+HH:mm;-HH:mm\\"\\n * - \\"+H:mm;-H:mm\\"   => \\"+HH:mm;-HH:mm\\"\\n * - \\"+HH:mm;HH:mm\\" => \\"+HH:mm;HH:mm\\" (Note MINUS SIGN \\\\u2212)\\n * - \\"+HHmm;-HHmm\\" => \\"+HHmm:-HHmm\\"\\n */\\nvar dateTimezoneHourFormatHm = function( hourFormat, hFormat ) {\\n\\treturn hourFormat\\n\\t\\t.split( \\";\\" )\\n\\t\\t.map(function( format ) {\\n\\t\\t\\tvar parts = format.split( /H+/ );\\n\\t\\t\\tparts.splice( 1, 0, hFormat );\\n\\t\\t\\treturn parts.join( \\"\\" );\\n\\t\\t})\\n\\t\\t.join( \\";\\" );\\n};\\n\\n\\n\\n\\nvar runtimeCacheDataBind = function( key, data ) {\\n\\tvar fn = function() {\\n\\t\\treturn data;\\n\\t};\\n\\tfn.dataCacheKey = key;\\n\\treturn fn;\\n};\\n\\n\\n\\n\\n/**\\n * properties( pattern, cldr )\\n *\\n * @pattern [String] raw pattern.\\n * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\\n *\\n * @cldr [Cldr instance].\\n *\\n * Return the properties given the pattern and cldr.\\n *\\n * TODO Support other calendar types.\\n */\\nvar dateFormatProperties = function( pattern, cldr, timeZone ) {\\n\\tvar properties = {\\n\\t\\t\\tnumberFormatters: {},\\n\\t\\t\\tpattern: pattern,\\n\\t\\t\\ttimeSeparator: numberSymbol( \\"timeSeparator\\", cldr )\\n\\t\\t},\\n\\t\\twidths = [ \\"abbreviated\\", \\"wide\\", \\"narrow\\" ];\\n\\n\\tfunction setNumberFormatterPattern( pad ) {\\n\\t\\tproperties.numberFormatters[ pad ] = stringPad( \\"\\", pad );\\n\\t}\\n\\n\\tif ( timeZone ) {\\n\\t\\tproperties.timeZoneData = runtimeCacheDataBind( \\"iana/\\" + timeZone, {\\n\\t\\t\\toffsets: cldr.get([ \\"globalize-iana/zoneData\\", timeZone, \\"offsets\\" ]),\\n\\t\\t\\tuntils: cldr.get([ \\"globalize-iana/zoneData\\", timeZone, \\"untils\\" ]),\\n\\t\\t\\tisdsts: cldr.get([ \\"globalize-iana/zoneData\\", timeZone, \\"isdsts\\" ])\\n\\t\\t});\\n\\t}\\n\\n\\tpattern.replace( datePatternRe, function( current ) {\\n\\t\\tvar aux, chr, daylightTzName, formatNumber, genericTzName, length, standardTzName;\\n\\n\\t\\tchr = current.charAt( 0 );\\n\\t\\tlength = current.length;\\n\\n\\t\\tif ( chr === \\"j\\" ) {\\n\\n\\t\\t\\t// Locale preferred hHKk.\\n\\t\\t\\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\\n\\t\\t\\tproperties.preferredTime = chr = cldr.supplemental.timeData.preferred();\\n\\t\\t}\\n\\n\\t\\t// ZZZZ: same as \\"OOOO\\".\\n\\t\\tif ( chr === \\"Z\\" && length === 4 ) {\\n\\t\\t\\tchr = \\"O\\";\\n\\t\\t\\tlength = 4;\\n\\t\\t}\\n\\n\\t\\t// z...zzz: \\"{shortRegion}\\", eg. \\"PST\\" or \\"PDT\\".\\n\\t\\t// zzzz: \\"{regionName} {Standard Time}\\" or \\"{regionName} {Daylight Time}\\",\\n\\t\\t//       e.g., \\"Pacific Standard Time\\" or \\"Pacific Daylight Time\\".\\n\\t\\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\\n\\t\\tif ( chr === \\"z\\" ) {\\n\\t\\t\\tstandardTzName = dateGetTimeZoneName( length, \\"standard\\", timeZone, cldr );\\n\\t\\t\\tdaylightTzName = dateGetTimeZoneName( length, \\"daylight\\", timeZone, cldr );\\n\\t\\t\\tif ( standardTzName ) {\\n\\t\\t\\t\\tproperties.standardTzName = standardTzName;\\n\\t\\t\\t}\\n\\t\\t\\tif ( daylightTzName ) {\\n\\t\\t\\t\\tproperties.daylightTzName = daylightTzName;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Fall through the \\"O\\" format in case one name is missing.\\n\\t\\t\\tif ( !standardTzName || !daylightTzName ) {\\n\\t\\t\\t\\tchr = \\"O\\";\\n\\t\\t\\t\\tif ( length < 4 ) {\\n\\t\\t\\t\\t\\tlength = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// v...vvv: \\"{shortRegion}\\", eg. \\"PT\\".\\n\\t\\t// vvvv: \\"{regionName} {Time}\\" or \\"{regionName} {Time}\\",\\n\\t\\t// e.g., \\"Pacific Time\\"\\n\\t\\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\\n\\t\\tif ( chr === \\"v\\" ) {\\n\\t\\t\\tgenericTzName = dateGetTimeZoneName( length, \\"generic\\", timeZone, cldr );\\n\\n\\t\\t\\t// Fall back to \\"V\\" format.\\n\\t\\t\\tif ( !genericTzName ) {\\n\\t\\t\\t\\tchr = \\"V\\";\\n\\t\\t\\t\\tlength = 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tswitch ( chr ) {\\n\\n\\t\\t\\t// Era\\n\\t\\t\\tcase \\"G\\":\\n\\t\\t\\t\\tproperties.eras = cldr.main([\\n\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/eras\\",\\n\\t\\t\\t\\t\\tlength <= 3 ? \\"eraAbbr\\" : ( length === 4 ? \\"eraNames\\" : \\"eraNarrow\\" )\\n\\t\\t\\t\\t]);\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Year\\n\\t\\t\\tcase \\"y\\":\\n\\n\\t\\t\\t\\t// Plain year.\\n\\t\\t\\t\\tformatNumber = true;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"Y\\":\\n\\n\\t\\t\\t\\t// Year in \\"Week of Year\\"\\n\\t\\t\\t\\tproperties.firstDay = dateFirstDayOfWeek( cldr );\\n\\t\\t\\t\\tproperties.minDays = cldr.supplemental.weekData.minDays();\\n\\t\\t\\t\\tformatNumber = true;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"u\\": // Extended year. Need to be implemented.\\n\\t\\t\\tcase \\"U\\": // Cyclic year name. Need to be implemented.\\n\\t\\t\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\t\\t\\tfeature: \\"year pattern `\\" + chr + \\"`\\"\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t// Quarter\\n\\t\\t\\tcase \\"Q\\":\\n\\t\\t\\tcase \\"q\\":\\n\\t\\t\\t\\tif ( length > 2 ) {\\n\\t\\t\\t\\t\\tif ( !properties.quarters ) {\\n\\t\\t\\t\\t\\t\\tproperties.quarters = {};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( !properties.quarters[ chr ] ) {\\n\\t\\t\\t\\t\\t\\tproperties.quarters[ chr ] = {};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tproperties.quarters[ chr ][ length ] = cldr.main([\\n\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/quarters\\",\\n\\t\\t\\t\\t\\t\\tchr === \\"Q\\" ? \\"format\\" : \\"stand-alone\\",\\n\\t\\t\\t\\t\\t\\twidths[ length - 3 ]\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tformatNumber = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Month\\n\\t\\t\\tcase \\"M\\":\\n\\t\\t\\tcase \\"L\\":\\n\\t\\t\\t\\tif ( length > 2 ) {\\n\\t\\t\\t\\t\\tif ( !properties.months ) {\\n\\t\\t\\t\\t\\t\\tproperties.months = {};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( !properties.months[ chr ] ) {\\n\\t\\t\\t\\t\\t\\tproperties.months[ chr ] = {};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tproperties.months[ chr ][ length ] = cldr.main([\\n\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/months\\",\\n\\t\\t\\t\\t\\t\\tchr === \\"M\\" ? \\"format\\" : \\"stand-alone\\",\\n\\t\\t\\t\\t\\t\\twidths[ length - 3 ]\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tformatNumber = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Week - Week of Year (w) or Week of Month (W).\\n\\t\\t\\tcase \\"w\\":\\n\\t\\t\\tcase \\"W\\":\\n\\t\\t\\t\\tproperties.firstDay = dateFirstDayOfWeek( cldr );\\n\\t\\t\\t\\tproperties.minDays = cldr.supplemental.weekData.minDays();\\n\\t\\t\\t\\tformatNumber = true;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Day\\n\\t\\t\\tcase \\"d\\":\\n\\t\\t\\tcase \\"D\\":\\n\\t\\t\\tcase \\"F\\":\\n\\t\\t\\t\\tformatNumber = true;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"g\\":\\n\\n\\t\\t\\t\\t// Modified Julian day. Need to be implemented.\\n\\t\\t\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\t\\t\\tfeature: \\"Julian day pattern `g`\\"\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t// Week day\\n\\t\\t\\tcase \\"e\\":\\n\\t\\t\\tcase \\"c\\":\\n\\t\\t\\t\\tif ( length <= 2 ) {\\n\\t\\t\\t\\t\\tproperties.firstDay = dateFirstDayOfWeek( cldr );\\n\\t\\t\\t\\t\\tformatNumber = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"E\\":\\n\\t\\t\\t\\tif ( !properties.days ) {\\n\\t\\t\\t\\t\\tproperties.days = {};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !properties.days[ chr ] ) {\\n\\t\\t\\t\\t\\tproperties.days[ chr ] = {};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( length === 6 ) {\\n\\n\\t\\t\\t\\t\\t// If short day names are not explicitly specified, abbreviated day names are\\n\\t\\t\\t\\t\\t// used instead.\\n\\t\\t\\t\\t\\t// http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\\n\\t\\t\\t\\t\\t// http://unicode.org/cldr/trac/ticket/6790\\n\\t\\t\\t\\t\\tproperties.days[ chr ][ length ] = cldr.main([\\n\\t\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/days\\",\\n\\t\\t\\t\\t\\t\\t\\tchr === \\"c\\" ? \\"stand-alone\\" : \\"format\\",\\n\\t\\t\\t\\t\\t\\t\\t\\"short\\"\\n\\t\\t\\t\\t\\t\\t]) || cldr.main([\\n\\t\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/days\\",\\n\\t\\t\\t\\t\\t\\t\\tchr === \\"c\\" ? \\"stand-alone\\" : \\"format\\",\\n\\t\\t\\t\\t\\t\\t\\t\\"abbreviated\\"\\n\\t\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tproperties.days[ chr ][ length ] = cldr.main([\\n\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/days\\",\\n\\t\\t\\t\\t\\t\\tchr === \\"c\\" ? \\"stand-alone\\" : \\"format\\",\\n\\t\\t\\t\\t\\t\\twidths[ length < 3 ? 0 : length - 3 ]\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Period (AM or PM)\\n\\t\\t\\tcase \\"a\\":\\n\\t\\t\\t\\tproperties.dayPeriods = {\\n\\t\\t\\t\\t\\tam: cldr.main(\\n\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/dayPeriods/format/wide/am\\"\\n\\t\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\tpm: cldr.main(\\n\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/dayPeriods/format/wide/pm\\"\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Hour\\n\\t\\t\\tcase \\"h\\": // 1-12\\n\\t\\t\\tcase \\"H\\": // 0-23\\n\\t\\t\\tcase \\"K\\": // 0-11\\n\\t\\t\\tcase \\"k\\": // 1-24\\n\\n\\t\\t\\t// Minute\\n\\t\\t\\tcase \\"m\\":\\n\\n\\t\\t\\t// Second\\n\\t\\t\\tcase \\"s\\":\\n\\t\\t\\tcase \\"S\\":\\n\\t\\t\\tcase \\"A\\":\\n\\t\\t\\t\\tformatNumber = true;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Zone\\n\\t\\t\\tcase \\"v\\":\\n\\t\\t\\t\\tif ( length !== 1 && length !== 4 ) {\\n\\t\\t\\t\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\t\\t\\t\\tfeature: \\"timezone pattern `\\" + pattern + \\"`\\"\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tproperties.genericTzName = genericTzName;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"V\\":\\n\\n\\t\\t\\t\\tif ( length === 1 ) {\\n\\t\\t\\t\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\t\\t\\t\\tfeature: \\"timezone pattern `\\" + pattern + \\"`\\"\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( timeZone ) {\\n\\t\\t\\t\\t\\tif ( length === 2 ) {\\n\\t\\t\\t\\t\\t\\tproperties.timeZoneName = timeZone;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar timeZoneName,\\n\\t\\t\\t\\t\\t\\texemplarCity = cldr.main([\\n\\t\\t\\t\\t\\t\\t\\t\\"dates/timeZoneNames/zone\\", timeZone, \\"exemplarCity\\"\\n\\t\\t\\t\\t\\t\\t]);\\n\\n\\t\\t\\t\\t\\tif ( length === 3 ) {\\n\\t\\t\\t\\t\\t\\tif ( !exemplarCity ) {\\n\\t\\t\\t\\t\\t\\t\\texemplarCity = cldr.main([\\n\\t\\t\\t\\t\\t\\t\\t\\t\\"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity\\"\\n\\t\\t\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ttimeZoneName = exemplarCity;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( exemplarCity && length === 4 ) {\\n\\t\\t\\t\\t\\t\\ttimeZoneName = formatMessage(\\n\\t\\t\\t\\t\\t\\t\\tcldr.main(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\"dates/timeZoneNames/regionFormat\\"\\n\\t\\t\\t\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\t\\t\\t[ exemplarCity ]\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( timeZoneName ) {\\n\\t\\t\\t\\t\\t\\tproperties.timeZoneName = timeZoneName;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( current === \\"v\\" ) {\\n\\t\\t\\t\\t\\tlength = 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"O\\":\\n\\n\\t\\t\\t\\t// O: \\"{gmtFormat}+H;{gmtFormat}-H\\" or \\"{gmtZeroFormat}\\", eg. \\"GMT-8\\" or \\"GMT\\".\\n\\t\\t\\t\\t// OOOO: \\"{gmtFormat}{hourFormat}\\" or \\"{gmtZeroFormat}\\", eg. \\"GMT-08:00\\" or \\"GMT\\".\\n\\t\\t\\t\\tproperties.gmtFormat = cldr.main( \\"dates/timeZoneNames/gmtFormat\\" );\\n\\t\\t\\t\\tproperties.gmtZeroFormat = cldr.main( \\"dates/timeZoneNames/gmtZeroFormat\\" );\\n\\n\\t\\t\\t\\t// Unofficial deduction of the hourFormat variations.\\n\\t\\t\\t\\t// Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293\\n\\t\\t\\t\\taux = cldr.main( \\"dates/timeZoneNames/hourFormat\\" );\\n\\t\\t\\t\\tproperties.hourFormat = length < 4 ?\\n\\t\\t\\t\\t\\t[ dateTimezoneHourFormatH( aux ), dateTimezoneHourFormatHm( aux, \\"H\\" ) ] :\\n\\t\\t\\t\\t\\tdateTimezoneHourFormatHm( aux, \\"HH\\" );\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"Z\\":\\n\\t\\t\\tcase \\"X\\":\\n\\t\\t\\tcase \\"x\\":\\n\\t\\t\\t\\tsetNumberFormatterPattern( 1 );\\n\\t\\t\\t\\tsetNumberFormatterPattern( 2 );\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif ( formatNumber ) {\\n\\t\\t\\tsetNumberFormatterPattern( length );\\n\\t\\t}\\n\\t});\\n\\n\\treturn properties;\\n};\\n\\n\\n\\n\\nvar dateFormatterFn = function( dateToPartsFormatter ) {\\n\\treturn function dateFormatter( value ) {\\n\\t\\treturn partsJoin( dateToPartsFormatter( value ));\\n\\t};\\n};\\n\\n\\n\\n\\n/**\\n * parseProperties( cldr )\\n *\\n * @cldr [Cldr instance].\\n *\\n * @timeZone [String] FIXME.\\n *\\n * Return parser properties.\\n */\\nvar dateParseProperties = function( cldr, timeZone ) {\\n\\tvar properties = {\\n\\t\\tpreferredTimeData: cldr.supplemental.timeData.preferred()\\n\\t};\\n\\n\\tif ( timeZone ) {\\n\\t\\tproperties.timeZoneData = runtimeCacheDataBind( \\"iana/\\" + timeZone, {\\n\\t\\t\\toffsets: cldr.get([ \\"globalize-iana/zoneData\\", timeZone, \\"offsets\\" ]),\\n\\t\\t\\tuntils: cldr.get([ \\"globalize-iana/zoneData\\", timeZone, \\"untils\\" ]),\\n\\t\\t\\tisdsts: cldr.get([ \\"globalize-iana/zoneData\\", timeZone, \\"isdsts\\" ])\\n\\t\\t});\\n\\t}\\n\\n\\treturn properties;\\n};\\n\\n\\nvar ZonedDateTime = (function() {\\nfunction definePrivateProperty(object, property, value) {\\n  Object.defineProperty(object, property, {\\n    value: value\\n  });\\n}\\n\\nfunction getUntilsIndex(original, untils) {\\n  var index = 0;\\n  var originalTime = original.getTime();\\n\\n  // TODO Should we do binary search for improved performance?\\n  while (index < untils.length - 1 && originalTime >= untils[index]) {\\n    index++;\\n  }\\n  return index;\\n}\\n\\nfunction setWrap(fn) {\\n  var offset1 = this.getTimezoneOffset();\\n  var ret = fn();\\n  this.original.setTime(new Date(this.getTime()));\\n  var offset2 = this.getTimezoneOffset();\\n  if (offset2 - offset1) {\\n    this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);\\n  }\\n  return ret;\\n}\\n\\nvar ZonedDateTime = function(date, timeZoneData) {\\n  definePrivateProperty(this, \\"original\\", new Date(date.getTime()));\\n  definePrivateProperty(this, \\"local\\", new Date(date.getTime()));\\n  definePrivateProperty(this, \\"timeZoneData\\", timeZoneData);\\n  definePrivateProperty(this, \\"setWrap\\", setWrap);\\n  if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {\\n    throw new Error(\\"Invalid IANA data\\");\\n  }\\n  this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1000);\\n};\\n\\nZonedDateTime.prototype.clone = function() {\\n  return new ZonedDateTime(this.original, this.timeZoneData);\\n};\\n\\n// Date field getters.\\n[\\"getFullYear\\", \\"getMonth\\", \\"getDate\\", \\"getDay\\", \\"getHours\\", \\"getMinutes\\",\\n\\"getSeconds\\", \\"getMilliseconds\\"].forEach(function(method) {\\n  // Corresponding UTC method, e.g., \\"getUTCFullYear\\" if method === \\"getFullYear\\".\\n  var utcMethod = \\"getUTC\\" + method.substr(3);\\n  ZonedDateTime.prototype[method] = function() {\\n    return this.local[utcMethod]();\\n  };\\n});\\n\\n// Note: Define .valueOf = .getTime for arithmetic operations like date1 - date2.\\nZonedDateTime.prototype.valueOf =\\nZonedDateTime.prototype.getTime = function() {\\n  return this.local.getTime() + this.getTimezoneOffset() * 60 * 1000;\\n};\\n\\nZonedDateTime.prototype.getTimezoneOffset = function() {\\n  var index = getUntilsIndex(this.original, this.timeZoneData.untils);\\n  return this.timeZoneData.offsets[index];\\n};\\n\\n// Date field setters.\\n[\\"setFullYear\\", \\"setMonth\\", \\"setDate\\", \\"setHours\\", \\"setMinutes\\", \\"setSeconds\\", \\"setMilliseconds\\"].forEach(function(method) {\\n  // Corresponding UTC method, e.g., \\"setUTCFullYear\\" if method === \\"setFullYear\\".\\n  var utcMethod = \\"setUTC\\" + method.substr(3);\\n  ZonedDateTime.prototype[method] = function(value) {\\n    var local = this.local;\\n    // Note setWrap is needed for seconds and milliseconds just because\\n    // abs(value) could be >= a minute.\\n    return this.setWrap(function() {\\n      return local[utcMethod](value);\\n    });\\n  };\\n});\\n\\nZonedDateTime.prototype.setTime = function(time) {\\n  return this.local.setTime(time);\\n};\\n\\nZonedDateTime.prototype.isDST = function() {\\n  var index = getUntilsIndex(this.original, this.timeZoneData.untils);\\n  return Boolean(this.timeZoneData.isdsts[index]);\\n};\\n\\nZonedDateTime.prototype.inspect = function() {\\n  var index = getUntilsIndex(this.original, this.timeZoneData.untils);\\n  var abbrs = this.timeZoneData.abbrs;\\n  return this.local.toISOString().replace(/Z$/, \\"\\") + \\" \\" +\\n    (abbrs && abbrs[index] + \\" \\" || (this.getTimezoneOffset() * -1) + \\" \\") +\\n    (this.isDST() ? \\"(daylight savings)\\" : \\"\\");\\n};\\n\\nZonedDateTime.prototype.toDate = function() {\\n  return new Date(this.getTime());\\n};\\n\\n// Type cast getters.\\n[\\"toISOString\\", \\"toJSON\\", \\"toUTCString\\"].forEach(function(method) {\\n  ZonedDateTime.prototype[method] = function() {\\n    return this.toDate()[method]();\\n  };\\n});\\n\\nreturn ZonedDateTime;\\n}());\\n\\n\\n/**\\n * isLeapYear( year )\\n *\\n * @year [Number]\\n *\\n * Returns an indication whether the specified year is a leap year.\\n */\\nvar dateIsLeapYear = function( year ) {\\n\\treturn new Date( year, 1, 29 ).getMonth() === 1;\\n};\\n\\n\\n\\n\\n/**\\n * lastDayOfMonth( date )\\n *\\n * @date [Date]\\n *\\n * Return the last day of the given date\'s month\\n */\\nvar dateLastDayOfMonth = function( date ) {\\n\\treturn new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();\\n};\\n\\n\\n\\n\\n/**\\n * startOf changes the input to the beginning of the given unit.\\n *\\n * For example, starting at the start of a day, resets hours, minutes\\n * seconds and milliseconds to 0. Starting at the month does the same, but\\n * also sets the date to 1.\\n *\\n * Returns the modified date\\n */\\nvar dateStartOf = function( date, unit ) {\\n\\tdate = date instanceof ZonedDateTime ? date.clone() : new Date( date.getTime() );\\n\\tswitch ( unit ) {\\n\\t\\tcase \\"year\\":\\n\\t\\t\\tdate.setMonth( 0 );\\n\\t\\t/* falls through */\\n\\t\\tcase \\"month\\":\\n\\t\\t\\tdate.setDate( 1 );\\n\\t\\t/* falls through */\\n\\t\\tcase \\"day\\":\\n\\t\\t\\tdate.setHours( 0 );\\n\\t\\t/* falls through */\\n\\t\\tcase \\"hour\\":\\n\\t\\t\\tdate.setMinutes( 0 );\\n\\t\\t/* falls through */\\n\\t\\tcase \\"minute\\":\\n\\t\\t\\tdate.setSeconds( 0 );\\n\\t\\t/* falls through */\\n\\t\\tcase \\"second\\":\\n\\t\\t\\tdate.setMilliseconds( 0 );\\n\\t}\\n\\treturn date;\\n};\\n\\n\\n\\n\\n/**\\n * Differently from native date.setDate(), this function returns a date whose\\n * day remains inside the month boundaries. For example:\\n *\\n * setDate( FebDate, 31 ): a \\"Feb 28\\" date.\\n * setDate( SepDate, 31 ): a \\"Sep 30\\" date.\\n */\\nvar dateSetDate = function( date, day ) {\\n\\tvar lastDay = new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();\\n\\n\\tdate.setDate( day < 1 ? 1 : day < lastDay ? day : lastDay );\\n};\\n\\n\\n\\n\\n/**\\n * Differently from native date.setMonth(), this function adjusts date if\\n * needed, so final month is always the one set.\\n *\\n * setMonth( Jan31Date, 1 ): a \\"Feb 28\\" date.\\n * setDate( Jan31Date, 8 ): a \\"Sep 30\\" date.\\n */\\nvar dateSetMonth = function( date, month ) {\\n\\tvar originalDate = date.getDate();\\n\\n\\tdate.setDate( 1 );\\n\\tdate.setMonth( month );\\n\\tdateSetDate( date, originalDate );\\n};\\n\\n\\n\\n\\nvar outOfRange = function( value, low, high ) {\\n\\treturn value < low || value > high;\\n};\\n\\n\\n\\n\\n/**\\n * parse( value, tokens, properties )\\n *\\n * @value [String] string date.\\n *\\n * @tokens [Object] tokens returned by date/tokenizer.\\n *\\n * @properties [Object] output returned by date/tokenizer-properties.\\n *\\n * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\\n */\\nvar dateParse = function( value, tokens, properties ) {\\n\\tvar amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid,\\n\\t\\tYEAR = 0,\\n\\t\\tMONTH = 1,\\n\\t\\tDAY = 2,\\n\\t\\tHOUR = 3,\\n\\t\\tMINUTE = 4,\\n\\t\\tSECOND = 5,\\n\\t\\tMILLISECONDS = 6,\\n\\t\\tdate = new Date(),\\n\\t\\ttruncateAt = [],\\n\\t\\tunits = [ \\"year\\", \\"month\\", \\"day\\", \\"hour\\", \\"minute\\", \\"second\\", \\"milliseconds\\" ];\\n\\n\\t// Create globalize date with given timezone data.\\n\\tif ( properties.timeZoneData ) {\\n\\t\\tdate = new ZonedDateTime( date, properties.timeZoneData() );\\n\\t}\\n\\n\\tif ( !tokens.length ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\tvalid = tokens.every(function( token ) {\\n\\t\\tvar century, chr, value, length;\\n\\n\\t\\tif ( token.type === \\"literal\\" ) {\\n\\n\\t\\t\\t// continue\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tchr = token.type.charAt( 0 );\\n\\t\\tlength = token.type.length;\\n\\n\\t\\tif ( chr === \\"j\\" ) {\\n\\n\\t\\t\\t// Locale preferred hHKk.\\n\\t\\t\\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\\n\\t\\t\\tchr = properties.preferredTimeData;\\n\\t\\t}\\n\\n\\t\\tswitch ( chr ) {\\n\\n\\t\\t\\t// Era\\n\\t\\t\\tcase \\"G\\":\\n\\t\\t\\t\\ttruncateAt.push( YEAR );\\n\\t\\t\\t\\tera = +token.value;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Year\\n\\t\\t\\tcase \\"y\\":\\n\\t\\t\\t\\tvalue = token.value;\\n\\t\\t\\t\\tif ( length === 2 ) {\\n\\t\\t\\t\\t\\tif ( outOfRange( value, 0, 99 ) ) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// mimic dojo/date/locale: choose century to apply, according to a sliding\\n\\t\\t\\t\\t\\t// window of 80 years before and 20 years after present year.\\n\\t\\t\\t\\t\\tcentury = Math.floor( date.getFullYear() / 100 ) * 100;\\n\\t\\t\\t\\t\\tvalue += century;\\n\\t\\t\\t\\t\\tif ( value > date.getFullYear() + 20 ) {\\n\\t\\t\\t\\t\\t\\tvalue -= 100;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdate.setFullYear( value );\\n\\t\\t\\t\\ttruncateAt.push( YEAR );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"Y\\": // Year in \\"Week of Year\\"\\n\\t\\t\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\t\\t\\tfeature: \\"year pattern `\\" + chr + \\"`\\"\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t// Quarter (skip)\\n\\t\\t\\tcase \\"Q\\":\\n\\t\\t\\tcase \\"q\\":\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Month\\n\\t\\t\\tcase \\"M\\":\\n\\t\\t\\tcase \\"L\\":\\n\\t\\t\\t\\tif ( length <= 2 ) {\\n\\t\\t\\t\\t\\tvalue = token.value;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvalue = +token.value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( outOfRange( value, 1, 12 ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Setting the month later so that we have the correct year and can determine\\n\\t\\t\\t\\t// the correct last day of February in case of leap year.\\n\\t\\t\\t\\tmonth = value;\\n\\t\\t\\t\\ttruncateAt.push( MONTH );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Week (skip)\\n\\t\\t\\tcase \\"w\\": // Week of Year.\\n\\t\\t\\tcase \\"W\\": // Week of Month.\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Day\\n\\t\\t\\tcase \\"d\\":\\n\\t\\t\\t\\tday = token.value;\\n\\t\\t\\t\\ttruncateAt.push( DAY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"D\\":\\n\\t\\t\\t\\tdaysOfYear = token.value;\\n\\t\\t\\t\\ttruncateAt.push( DAY );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"F\\":\\n\\n\\t\\t\\t\\t// Day of Week in month. eg. 2nd Wed in July.\\n\\t\\t\\t\\t// Skip\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Week day\\n\\t\\t\\tcase \\"e\\":\\n\\t\\t\\tcase \\"c\\":\\n\\t\\t\\tcase \\"E\\":\\n\\n\\t\\t\\t\\t// Skip.\\n\\t\\t\\t\\t// value = arrayIndexOf( dateWeekDays, token.value );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Period (AM or PM)\\n\\t\\t\\tcase \\"a\\":\\n\\t\\t\\t\\tamPm = token.value;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Hour\\n\\t\\t\\tcase \\"h\\": // 1-12\\n\\t\\t\\t\\tvalue = token.value;\\n\\t\\t\\t\\tif ( outOfRange( value, 1, 12 ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\thour = hour12 = true;\\n\\t\\t\\t\\tdate.setHours( value === 12 ? 0 : value );\\n\\t\\t\\t\\ttruncateAt.push( HOUR );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"K\\": // 0-11\\n\\t\\t\\t\\tvalue = token.value;\\n\\t\\t\\t\\tif ( outOfRange( value, 0, 11 ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\thour = hour12 = true;\\n\\t\\t\\t\\tdate.setHours( value );\\n\\t\\t\\t\\ttruncateAt.push( HOUR );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"k\\": // 1-24\\n\\t\\t\\t\\tvalue = token.value;\\n\\t\\t\\t\\tif ( outOfRange( value, 1, 24 ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\thour = true;\\n\\t\\t\\t\\tdate.setHours( value === 24 ? 0 : value );\\n\\t\\t\\t\\ttruncateAt.push( HOUR );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"H\\": // 0-23\\n\\t\\t\\t\\tvalue = token.value;\\n\\t\\t\\t\\tif ( outOfRange( value, 0, 23 ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\thour = true;\\n\\t\\t\\t\\tdate.setHours( value );\\n\\t\\t\\t\\ttruncateAt.push( HOUR );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Minute\\n\\t\\t\\tcase \\"m\\":\\n\\t\\t\\t\\tvalue = token.value;\\n\\t\\t\\t\\tif ( outOfRange( value, 0, 59 ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdate.setMinutes( value );\\n\\t\\t\\t\\ttruncateAt.push( MINUTE );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Second\\n\\t\\t\\tcase \\"s\\":\\n\\t\\t\\t\\tvalue = token.value;\\n\\t\\t\\t\\tif ( outOfRange( value, 0, 59 ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdate.setSeconds( value );\\n\\t\\t\\t\\ttruncateAt.push( SECOND );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"A\\":\\n\\t\\t\\t\\tdate.setHours( 0 );\\n\\t\\t\\t\\tdate.setMinutes( 0 );\\n\\t\\t\\t\\tdate.setSeconds( 0 );\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"S\\":\\n\\t\\t\\t\\tvalue = Math.round( token.value * Math.pow( 10, 3 - length ) );\\n\\t\\t\\t\\tdate.setMilliseconds( value );\\n\\t\\t\\t\\ttruncateAt.push( MILLISECONDS );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Zone\\n\\t\\t\\tcase \\"z\\":\\n\\t\\t\\tcase \\"Z\\":\\n\\t\\t\\tcase \\"O\\":\\n\\t\\t\\tcase \\"v\\":\\n\\t\\t\\tcase \\"V\\":\\n\\t\\t\\tcase \\"X\\":\\n\\t\\t\\tcase \\"x\\":\\n\\t\\t\\t\\tif ( typeof token.value === \\"number\\" ) {\\n\\t\\t\\t\\t\\ttimezoneOffset = token.value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t});\\n\\n\\tif ( !valid ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// 12-hour format needs AM or PM, 24-hour format doesn\'t, ie. return null\\n\\t// if amPm && !hour12 || !amPm && hour12.\\n\\tif ( hour && !( !amPm ^ hour12 ) ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\tif ( era === 0 ) {\\n\\n\\t\\t// 1 BC = year 0\\n\\t\\tdate.setFullYear( date.getFullYear() * -1 + 1 );\\n\\t}\\n\\n\\tif ( month !== undefined ) {\\n\\t\\tdateSetMonth( date, month - 1 );\\n\\t}\\n\\n\\tif ( day !== undefined ) {\\n\\t\\tif ( outOfRange( day, 1, dateLastDayOfMonth( date ) ) ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tdate.setDate( day );\\n\\t} else if ( daysOfYear !== undefined ) {\\n\\t\\tif ( outOfRange( daysOfYear, 1, dateIsLeapYear( date.getFullYear() ) ? 366 : 365 ) ) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tdate.setMonth( 0 );\\n\\t\\tdate.setDate( daysOfYear );\\n\\t}\\n\\n\\tif ( hour12 && amPm === \\"pm\\" ) {\\n\\t\\tdate.setHours( date.getHours() + 12 );\\n\\t}\\n\\n\\tif ( timezoneOffset !== undefined ) {\\n\\t\\tdate.setMinutes( date.getMinutes() + timezoneOffset - date.getTimezoneOffset() );\\n\\t}\\n\\n\\t// Truncate date at the most precise unit defined. Eg.\\n\\t// If value is \\"12/31\\", and pattern is \\"MM/dd\\":\\n\\t// => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );\\n\\ttruncateAt = Math.max.apply( null, truncateAt );\\n\\tdate = dateStartOf( date, units[ truncateAt ] );\\n\\n\\t// Get date back from globalize date.\\n\\tif ( date instanceof ZonedDateTime ) {\\n\\t\\tdate = date.toDate();\\n\\t}\\n\\n\\treturn date;\\n};\\n\\n\\n\\n\\n/**\\n * tokenizer( value, numberParser, properties )\\n *\\n * @value [String] string date.\\n *\\n * @numberParser [Function]\\n *\\n * @properties [Object] output returned by date/tokenizer-properties.\\n *\\n * Returns an Array of tokens, eg. value \\"5 o\'clock PM\\", pattern \\"h \'o\'\'clock\' a\\":\\n * [{\\n *   type: \\"h\\",\\n *   lexeme: \\"5\\"\\n * }, {\\n *   type: \\"literal\\",\\n *   lexeme: \\" \\"\\n * }, {\\n *   type: \\"literal\\",\\n *   lexeme: \\"o\'clock\\"\\n * }, {\\n *   type: \\"literal\\",\\n *   lexeme: \\" \\"\\n * }, {\\n *   type: \\"a\\",\\n *   lexeme: \\"PM\\",\\n *   value: \\"pm\\"\\n * }]\\n *\\n * OBS: lexeme\'s are always String and may return invalid ranges depending of the token type.\\n * Eg. \\"99\\" for month number.\\n *\\n * Return an empty Array when not successfully parsed.\\n */\\nvar dateTokenizer = function( value, numberParser, properties ) {\\n\\tvar digitsRe, valid,\\n\\t\\ttokens = [],\\n\\t\\twidths = [ \\"abbreviated\\", \\"wide\\", \\"narrow\\" ];\\n\\n\\tdigitsRe = properties.digitsRe;\\n\\tvalue = looseMatching( value );\\n\\n\\tvalid = properties.pattern.match( datePatternRe ).every(function( current ) {\\n\\t\\tvar aux, chr, length, numeric, tokenRe,\\n\\t\\t\\ttoken = {};\\n\\n\\t\\tfunction hourFormatParse( tokenRe, numberParser ) {\\n\\t\\t\\tvar aux, isPositive,\\n\\t\\t\\t\\tmatch = value.match( tokenRe );\\n\\t\\t\\tnumberParser = numberParser || function( value ) {\\n\\t\\t\\t\\treturn +value;\\n\\t\\t\\t};\\n\\n\\t\\t\\tif ( !match ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tisPositive = match[ 1 ];\\n\\n\\t\\t\\t// hourFormat containing H only, e.g., `+H;-H`\\n\\t\\t\\tif ( match.length < 6 ) {\\n\\t\\t\\t\\taux = isPositive ? 1 : 3;\\n\\t\\t\\t\\ttoken.value = numberParser( match[ aux ] ) * 60;\\n\\n\\t\\t\\t// hourFormat containing H and m, e.g., `+HHmm;-HHmm`\\n\\t\\t\\t} else if ( match.length < 10 ) {\\n\\t\\t\\t\\taux = isPositive ? [ 1, 3 ] : [ 5, 7 ];\\n\\t\\t\\t\\ttoken.value = numberParser( match[ aux[ 0 ] ] ) * 60 +\\n\\t\\t\\t\\t\\tnumberParser( match[ aux[ 1 ] ] );\\n\\n\\t\\t\\t// hourFormat containing H, m, and s e.g., `+HHmmss;-HHmmss`\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taux = isPositive ? [ 1, 3, 5 ] : [ 7, 9, 11 ];\\n\\t\\t\\t\\ttoken.value = numberParser( match[ aux[ 0 ] ] ) * 60 +\\n\\t\\t\\t\\t\\tnumberParser( match[ aux[ 1 ] ] ) +\\n\\t\\t\\t\\t\\tnumberParser( match[ aux[ 2 ] ] ) / 60;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isPositive ) {\\n\\t\\t\\t\\ttoken.value *= -1;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfunction oneDigitIfLengthOne() {\\n\\t\\t\\tif ( length === 1 ) {\\n\\n\\t\\t\\t\\t// Unicode equivalent to /\\\\d/\\n\\t\\t\\t\\tnumeric = true;\\n\\t\\t\\t\\treturn tokenRe = digitsRe;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction oneOrTwoDigitsIfLengthOne() {\\n\\t\\t\\tif ( length === 1 ) {\\n\\n\\t\\t\\t\\t// Unicode equivalent to /\\\\d\\\\d?/\\n\\t\\t\\t\\tnumeric = true;\\n\\t\\t\\t\\treturn tokenRe = new RegExp( \\"^(\\" + digitsRe.source + \\"){1,2}\\" );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction oneOrTwoDigitsIfLengthOneOrTwo() {\\n\\t\\t\\tif ( length === 1 || length === 2 ) {\\n\\n\\t\\t\\t\\t// Unicode equivalent to /\\\\d\\\\d?/\\n\\t\\t\\t\\tnumeric = true;\\n\\t\\t\\t\\treturn tokenRe = new RegExp( \\"^(\\" + digitsRe.source + \\"){1,2}\\" );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction twoDigitsIfLengthTwo() {\\n\\t\\t\\tif ( length === 2 ) {\\n\\n\\t\\t\\t\\t// Unicode equivalent to /\\\\d\\\\d/\\n\\t\\t\\t\\tnumeric = true;\\n\\t\\t\\t\\treturn tokenRe = new RegExp( \\"^(\\" + digitsRe.source + \\"){2}\\" );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Brute-force test every locale entry in an attempt to match the given value.\\n\\t\\t// Return the first found one (and set token accordingly), or null.\\n\\t\\tfunction lookup( path ) {\\n\\t\\t\\tvar array = properties[ path.join( \\"/\\" ) ];\\n\\n\\t\\t\\tif ( !array ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// array of pairs [key, value] sorted by desc value length.\\n\\t\\t\\tarray.some(function( item ) {\\n\\t\\t\\t\\tvar valueRe = item[ 1 ];\\n\\t\\t\\t\\tif ( valueRe.test( value ) ) {\\n\\t\\t\\t\\t\\ttoken.value = item[ 0 ];\\n\\t\\t\\t\\t\\ttokenRe = item[ 1 ];\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\ttoken.type = current;\\n\\t\\tchr = current.charAt( 0 );\\n\\t\\tlength = current.length;\\n\\n\\t\\tif ( chr === \\"Z\\" ) {\\n\\n\\t\\t\\t// Z..ZZZ: same as \\"xxxx\\".\\n\\t\\t\\tif ( length < 4 ) {\\n\\t\\t\\t\\tchr = \\"x\\";\\n\\t\\t\\t\\tlength = 4;\\n\\n\\t\\t\\t// ZZZZ: same as \\"OOOO\\".\\n\\t\\t\\t} else if ( length < 5 ) {\\n\\t\\t\\t\\tchr = \\"O\\";\\n\\t\\t\\t\\tlength = 4;\\n\\n\\t\\t\\t// ZZZZZ: same as \\"XXXXX\\"\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tchr = \\"X\\";\\n\\t\\t\\t\\tlength = 5;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( chr === \\"z\\" ) {\\n\\t\\t\\tif ( properties.standardOrDaylightTzName ) {\\n\\t\\t\\t\\ttoken.value = null;\\n\\t\\t\\t\\ttokenRe = properties.standardOrDaylightTzName;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// v...vvv: \\"{shortRegion}\\", eg. \\"PT\\".\\n\\t\\t// vvvv: \\"{regionName} {Time}\\" or \\"{regionName} {Time}\\",\\n\\t\\t// e.g., \\"Pacific Time\\"\\n\\t\\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\\n\\t\\tif ( chr === \\"v\\" ) {\\n\\t\\t\\tif ( properties.genericTzName ) {\\n\\t\\t\\t\\ttoken.value = null;\\n\\t\\t\\t\\ttokenRe = properties.genericTzName;\\n\\n\\t\\t\\t// Fall back to \\"V\\" format.\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tchr = \\"V\\";\\n\\t\\t\\t\\tlength = 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( chr === \\"V\\" && properties.timeZoneName ) {\\n\\t\\t\\ttoken.value = length === 2 ? properties.timeZoneName : null;\\n\\t\\t\\ttokenRe = properties.timeZoneNameRe;\\n\\t\\t}\\n\\n\\t\\tswitch ( chr ) {\\n\\n\\t\\t\\t// Era\\n\\t\\t\\tcase \\"G\\":\\n\\t\\t\\t\\tlookup([\\n\\t\\t\\t\\t\\t\\"gregorian/eras\\",\\n\\t\\t\\t\\t\\tlength <= 3 ? \\"eraAbbr\\" : ( length === 4 ? \\"eraNames\\" : \\"eraNarrow\\" )\\n\\t\\t\\t\\t]);\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Year\\n\\t\\t\\tcase \\"y\\":\\n\\t\\t\\tcase \\"Y\\":\\n\\t\\t\\t\\tnumeric = true;\\n\\n\\t\\t\\t\\t// number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...\\n\\t\\t\\t\\tif ( length === 1 ) {\\n\\n\\t\\t\\t\\t\\t// Unicode equivalent to /\\\\d+/.\\n\\t\\t\\t\\t\\ttokenRe = new RegExp( \\"^(\\" + digitsRe.source + \\")+\\" );\\n\\t\\t\\t\\t} else if ( length === 2 ) {\\n\\n\\t\\t\\t\\t\\t// Lenient parsing: there\'s no year pattern to indicate non-zero-padded 2-digits\\n\\t\\t\\t\\t\\t// year, so parser accepts both zero-padded and non-zero-padded for `yy`.\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t// Unicode equivalent to /\\\\d\\\\d?/\\n\\t\\t\\t\\t\\ttokenRe = new RegExp( \\"^(\\" + digitsRe.source + \\"){1,2}\\" );\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// Unicode equivalent to /\\\\d{length,}/\\n\\t\\t\\t\\t\\ttokenRe = new RegExp( \\"^(\\" + digitsRe.source + \\"){\\" + length + \\",}\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Quarter\\n\\t\\t\\tcase \\"Q\\":\\n\\t\\t\\tcase \\"q\\":\\n\\n\\t\\t\\t\\t// number l=1:{1}, l=2:{2}.\\n\\t\\t\\t\\t// lookup l=3...\\n\\t\\t\\t\\toneDigitIfLengthOne() || twoDigitsIfLengthTwo() ||\\n\\t\\t\\t\\t\\tlookup([\\n\\t\\t\\t\\t\\t\\t\\"gregorian/quarters\\",\\n\\t\\t\\t\\t\\t\\tchr === \\"Q\\" ? \\"format\\" : \\"stand-alone\\",\\n\\t\\t\\t\\t\\t\\twidths[ length - 3 ]\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Month\\n\\t\\t\\tcase \\"M\\":\\n\\t\\t\\tcase \\"L\\":\\n\\n\\t\\t\\t\\t// number l=1:{1,2}, l=2:{2}.\\n\\t\\t\\t\\t// lookup l=3...\\n\\t\\t\\t\\t//\\n\\t\\t\\t\\t// Lenient parsing: skeleton \\"yMd\\" (i.e., one M) may include MM for the pattern,\\n\\t\\t\\t\\t// therefore parser accepts both zero-padded and non-zero-padded for M and MM.\\n\\t\\t\\t\\t// Similar for L.\\n\\t\\t\\t\\toneOrTwoDigitsIfLengthOneOrTwo() || lookup([\\n\\t\\t\\t\\t\\t\\"gregorian/months\\",\\n\\t\\t\\t\\t\\tchr === \\"M\\" ? \\"format\\" : \\"stand-alone\\",\\n\\t\\t\\t\\t\\twidths[ length - 3 ]\\n\\t\\t\\t\\t]);\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Day\\n\\t\\t\\tcase \\"D\\":\\n\\n\\t\\t\\t\\t// number {l,3}.\\n\\t\\t\\t\\tif ( length <= 3 ) {\\n\\n\\t\\t\\t\\t\\t// Equivalent to /\\\\d{length,3}/\\n\\t\\t\\t\\t\\tnumeric = true;\\n\\t\\t\\t\\t\\ttokenRe = new RegExp( \\"^(\\" + digitsRe.source + \\"){\\" + length + \\",3}\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"W\\":\\n\\t\\t\\tcase \\"F\\":\\n\\n\\t\\t\\t\\t// number l=1:{1}.\\n\\t\\t\\t\\toneDigitIfLengthOne();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Week day\\n\\t\\t\\tcase \\"e\\":\\n\\t\\t\\tcase \\"c\\":\\n\\n\\t\\t\\t\\t// number l=1:{1}, l=2:{2}.\\n\\t\\t\\t\\t// lookup for length >=3.\\n\\t\\t\\t\\tif ( length <= 2 ) {\\n\\t\\t\\t\\t\\toneDigitIfLengthOne() || twoDigitsIfLengthTwo();\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"E\\":\\n\\t\\t\\t\\tif ( length === 6 ) {\\n\\n\\t\\t\\t\\t\\t// Note: if short day names are not explicitly specified, abbreviated day\\n\\t\\t\\t\\t\\t// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\\n\\t\\t\\t\\t\\tlookup([\\n\\t\\t\\t\\t\\t\\t\\"gregorian/days\\",\\n\\t\\t\\t\\t\\t\\t[ chr === \\"c\\" ? \\"stand-alone\\" : \\"format\\" ],\\n\\t\\t\\t\\t\\t\\t\\"short\\"\\n\\t\\t\\t\\t\\t]) || lookup([\\n\\t\\t\\t\\t\\t\\t\\"gregorian/days\\",\\n\\t\\t\\t\\t\\t\\t[ chr === \\"c\\" ? \\"stand-alone\\" : \\"format\\" ],\\n\\t\\t\\t\\t\\t\\t\\"abbreviated\\"\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlookup([\\n\\t\\t\\t\\t\\t\\t\\"gregorian/days\\",\\n\\t\\t\\t\\t\\t\\t[ chr === \\"c\\" ? \\"stand-alone\\" : \\"format\\" ],\\n\\t\\t\\t\\t\\t\\twidths[ length < 3 ? 0 : length - 3 ]\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Period (AM or PM)\\n\\t\\t\\tcase \\"a\\":\\n\\t\\t\\t\\tlookup([\\n\\t\\t\\t\\t\\t\\"gregorian/dayPeriods/format/wide\\"\\n\\t\\t\\t\\t]);\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Week\\n\\t\\t\\tcase \\"w\\":\\n\\n\\t\\t\\t\\t// number l1:{1,2}, l2:{2}.\\n\\t\\t\\t\\toneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Day, Hour, Minute, or Second\\n\\t\\t\\tcase \\"d\\":\\n\\t\\t\\tcase \\"h\\":\\n\\t\\t\\tcase \\"H\\":\\n\\t\\t\\tcase \\"K\\":\\n\\t\\t\\tcase \\"k\\":\\n\\t\\t\\tcase \\"j\\":\\n\\t\\t\\tcase \\"m\\":\\n\\t\\t\\tcase \\"s\\":\\n\\n\\t\\t\\t\\t// number l1:{1,2}, l2:{2}.\\n\\t\\t\\t\\t//\\n\\t\\t\\t\\t// Lenient parsing:\\n\\t\\t\\t\\t// - skeleton \\"hms\\" (i.e., one m) always includes mm for the pattern, i.e., it\'s\\n\\t\\t\\t\\t//   impossible to use a different skeleton to parse non-zero-padded minutes,\\n\\t\\t\\t\\t//   therefore parser accepts both zero-padded and non-zero-padded for m. Similar\\n\\t\\t\\t\\t//   for seconds s.\\n\\t\\t\\t\\t// - skeleton \\"hms\\" (i.e., one h) may include h or hh for the pattern, i.e., it\'s\\n\\t\\t\\t\\t//   impossible to use a different skeleton to parser non-zero-padded hours for some\\n\\t\\t\\t\\t//   locales, therefore parser accepts both zero-padded and non-zero-padded for h.\\n\\t\\t\\t\\t//   Similar for d (in skeleton yMd).\\n\\t\\t\\t\\toneOrTwoDigitsIfLengthOneOrTwo();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"S\\":\\n\\n\\t\\t\\t\\t// number {l}.\\n\\n\\t\\t\\t\\t// Unicode equivalent to /\\\\d{length}/\\n\\t\\t\\t\\tnumeric = true;\\n\\t\\t\\t\\ttokenRe = new RegExp( \\"^(\\" + digitsRe.source + \\"){\\" + length + \\"}\\" );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"A\\":\\n\\n\\t\\t\\t\\t// number {l+5}.\\n\\n\\t\\t\\t\\t// Unicode equivalent to /\\\\d{length+5}/\\n\\t\\t\\t\\tnumeric = true;\\n\\t\\t\\t\\ttokenRe = new RegExp( \\"^(\\" + digitsRe.source + \\"){\\" + ( length + 5 ) + \\"}\\" );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Zone\\n\\t\\t\\tcase \\"v\\":\\n\\t\\t\\tcase \\"V\\":\\n\\t\\t\\tcase \\"z\\":\\n\\t\\t\\t\\tif ( tokenRe && tokenRe.test( value ) ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( chr === \\"V\\" && length === 2 ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"O\\":\\n\\n\\t\\t\\t\\t// O: \\"{gmtFormat}+H;{gmtFormat}-H\\" or \\"{gmtZeroFormat}\\", eg. \\"GMT-8\\" or \\"GMT\\".\\n\\t\\t\\t\\t// OOOO: \\"{gmtFormat}{hourFormat}\\" or \\"{gmtZeroFormat}\\", eg. \\"GMT-08:00\\" or \\"GMT\\".\\n\\t\\t\\t\\tif ( value === properties[ \\"timeZoneNames/gmtZeroFormat\\" ] ) {\\n\\t\\t\\t\\t\\ttoken.value = 0;\\n\\t\\t\\t\\t\\ttokenRe = properties[ \\"timeZoneNames/gmtZeroFormatRe\\" ];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\taux = properties[ \\"timeZoneNames/hourFormat\\" ].some(function( hourFormatRe ) {\\n\\t\\t\\t\\t\\t\\tif ( hourFormatParse( hourFormatRe, numberParser ) ) {\\n\\t\\t\\t\\t\\t\\t\\ttokenRe = hourFormatRe;\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\tif ( !aux ) {\\n\\t\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"X\\":\\n\\n\\t\\t\\t\\t// Same as x*, except it uses \\"Z\\" for zero offset.\\n\\t\\t\\t\\tif ( value === \\"Z\\" ) {\\n\\t\\t\\t\\t\\ttoken.value = 0;\\n\\t\\t\\t\\t\\ttokenRe = /^Z/;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"x\\":\\n\\n\\t\\t\\t\\t// x: hourFormat(\\"+HH[mm];-HH[mm]\\")\\n\\t\\t\\t\\t// xx: hourFormat(\\"+HHmm;-HHmm\\")\\n\\t\\t\\t\\t// xxx: hourFormat(\\"+HH:mm;-HH:mm\\")\\n\\t\\t\\t\\t// xxxx: hourFormat(\\"+HHmm[ss];-HHmm[ss]\\")\\n\\t\\t\\t\\t// xxxxx: hourFormat(\\"+HH:mm[:ss];-HH:mm[:ss]\\")\\n\\t\\t\\t\\taux = properties.x.some(function( hourFormatRe ) {\\n\\t\\t\\t\\t\\tif ( hourFormatParse( hourFormatRe ) ) {\\n\\t\\t\\t\\t\\t\\ttokenRe = hourFormatRe;\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tif ( !aux ) {\\n\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"\'\\":\\n\\t\\t\\t\\ttoken.type = \\"literal\\";\\n\\t\\t\\t\\ttokenRe = new RegExp( \\"^\\" + regexpEscape( removeLiteralQuotes( current ) ) );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\ttoken.type = \\"literal\\";\\n\\t\\t\\t\\ttokenRe = new RegExp( \\"^\\" + regexpEscape( current ) );\\n\\t\\t}\\n\\n\\t\\tif ( !tokenRe ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Get lexeme and consume it.\\n\\t\\tvalue = value.replace( tokenRe, function( lexeme ) {\\n\\t\\t\\ttoken.lexeme = lexeme;\\n\\t\\t\\tif ( numeric ) {\\n\\t\\t\\t\\ttoken.value = numberParser( lexeme );\\n\\t\\t\\t}\\n\\t\\t\\treturn \\"\\";\\n\\t\\t});\\n\\n\\t\\tif ( !token.lexeme ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif ( numeric && isNaN( token.value ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\ttokens.push( token );\\n\\t\\treturn true;\\n\\t});\\n\\n\\tif ( value !== \\"\\" ) {\\n\\t\\tvalid = false;\\n\\t}\\n\\n\\treturn valid ? tokens : [];\\n};\\n\\n\\n\\n\\nvar dateParserFn = function( numberParser, parseProperties, tokenizerProperties ) {\\n\\treturn function dateParser( value ) {\\n\\t\\tvar tokens;\\n\\n\\t\\tvalidateParameterPresence( value, \\"value\\" );\\n\\t\\tvalidateParameterTypeString( value, \\"value\\" );\\n\\n\\t\\ttokens = dateTokenizer( value, numberParser, tokenizerProperties );\\n\\t\\treturn dateParse( value, tokens, parseProperties ) || null;\\n\\t};\\n};\\n\\n\\n\\n\\nvar objectFilter = function( object, testRe ) {\\n\\tvar key,\\n\\t\\tcopy = {};\\n\\n\\tfor ( key in object ) {\\n\\t\\tif ( testRe.test( key ) ) {\\n\\t\\t\\tcopy[ key ] = object[ key ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn copy;\\n};\\n\\n\\n\\n\\n/**\\n * tokenizerProperties( pattern, cldr )\\n *\\n * @pattern [String] raw pattern.\\n *\\n * @cldr [Cldr instance].\\n *\\n * Return Object with data that will be used by tokenizer.\\n */\\nvar dateTokenizerProperties = function( pattern, cldr, timeZone ) {\\n\\tvar digitsReSource,\\n\\t\\tproperties = {\\n\\t\\t\\tpattern: looseMatching( pattern )\\n\\t\\t},\\n\\t\\ttimeSeparator = numberSymbol( \\"timeSeparator\\", cldr ),\\n\\t\\twidths = [ \\"abbreviated\\", \\"wide\\", \\"narrow\\" ];\\n\\n\\tdigitsReSource = numberNumberingSystemDigitsMap( cldr );\\n\\tdigitsReSource = digitsReSource ? \\"[\\" + digitsReSource + \\"]\\" : \\"\\\\\\\\d\\";\\n\\tproperties.digitsRe = new RegExp( digitsReSource );\\n\\n\\t// Transform:\\n\\t// - \\"+H;-H\\" -> /\\\\+(\\\\d\\\\d?)|-(\\\\d\\\\d?)/\\n\\t// - \\"+HH;-HH\\" -> /\\\\+(\\\\d\\\\d)|-(\\\\d\\\\d)/\\n\\t// - \\"+HHmm;-HHmm\\" -> /\\\\+(\\\\d\\\\d)(\\\\d\\\\d)|-(\\\\d\\\\d)(\\\\d\\\\d)/\\n\\t// - \\"+HH:mm;-HH:mm\\" -> /\\\\+(\\\\d\\\\d):(\\\\d\\\\d)|-(\\\\d\\\\d):(\\\\d\\\\d)/\\n\\t//\\n\\t// If gmtFormat is GMT{0}, the regexp must fill {0} in each side, e.g.:\\n\\t// - \\"+H;-H\\" -> /GMT\\\\+(\\\\d\\\\d?)|GMT-(\\\\d\\\\d?)/\\n\\tfunction hourFormatRe( hourFormat, gmtFormat, digitsReSource, timeSeparator ) {\\n\\t\\tvar re;\\n\\n\\t\\tif ( !digitsReSource ) {\\n\\t\\t\\tdigitsReSource = \\"\\\\\\\\d\\";\\n\\t\\t}\\n\\t\\tif ( !gmtFormat ) {\\n\\t\\t\\tgmtFormat = \\"{0}\\";\\n\\t\\t}\\n\\n\\t\\tre = hourFormat\\n\\t\\t\\t.replace( \\"+\\", \\"\\\\\\\\+\\" )\\n\\n\\t\\t\\t// Unicode equivalent to (\\\\\\\\d\\\\\\\\d)\\n\\t\\t\\t.replace( /HH|mm|ss/g, \\"((\\" + digitsReSource + \\"){2})\\" )\\n\\n\\t\\t\\t// Unicode equivalent to (\\\\\\\\d\\\\\\\\d?)\\n\\t\\t\\t.replace( /H|m/g, \\"((\\" + digitsReSource + \\"){1,2})\\" );\\n\\n\\t\\tif ( timeSeparator ) {\\n\\t\\t\\tre = re.replace( /:/g, timeSeparator );\\n\\t\\t}\\n\\n\\t\\tre = re.split( \\";\\" ).map(function( part ) {\\n\\t\\t\\treturn gmtFormat.replace( \\"{0}\\", part );\\n\\t\\t}).join( \\"|\\" );\\n\\n\\t\\treturn new RegExp( \\"^\\" + re );\\n\\t}\\n\\n\\tfunction populateProperties( path, value ) {\\n\\n\\t\\t// Skip\\n\\t\\tvar skipRe = /(timeZoneNames\\\\/zone|supplemental\\\\/metaZones|timeZoneNames\\\\/metazone|timeZoneNames\\\\/regionFormat|timeZoneNames\\\\/gmtFormat)/;\\n\\t\\tif ( skipRe.test( path ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( !value ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// The `dates` and `calendars` trim\'s purpose is to reduce properties\' key size only.\\n\\t\\tpath = path.replace( /^.*\\\\/dates\\\\//, \\"\\" ).replace( /calendars\\\\//, \\"\\" );\\n\\n\\t\\t// Specific filter for \\"gregorian/dayPeriods/format/wide\\".\\n\\t\\tif ( path === \\"gregorian/dayPeriods/format/wide\\" ) {\\n\\t\\t\\tvalue = objectFilter( value, /^am|^pm/ );\\n\\t\\t}\\n\\n\\t\\t// Transform object into array of pairs [key, /value/], sort by desc value length.\\n\\t\\tif ( isPlainObject( value ) ) {\\n\\t\\t\\tvalue = Object.keys( value ).map(function( key ) {\\n\\t\\t\\t\\treturn [ key, new RegExp( \\"^\\" + regexpEscape( looseMatching( value[ key ] ) ) ) ];\\n\\t\\t\\t}).sort(function( a, b ) {\\n\\t\\t\\t\\treturn b[ 1 ].source.length - a[ 1 ].source.length;\\n\\t\\t\\t});\\n\\n\\t\\t// If typeof value === \\"string\\".\\n\\t\\t} else {\\n\\t\\t\\tvalue = looseMatching( value );\\n\\t\\t}\\n\\t\\tproperties[ path ] = value;\\n\\t}\\n\\n\\tfunction regexpSourceSomeTerm( terms ) {\\n\\t\\treturn \\"(\\" + terms.filter(function( item ) {\\n\\t\\t\\treturn item;\\n\\t\\t}).reduce(function( memo, item ) {\\n\\t\\t\\treturn memo + \\"|\\" + item;\\n\\t\\t}) + \\")\\";\\n\\t}\\n\\n\\tcldr.on( \\"get\\", populateProperties );\\n\\n\\tpattern.match( datePatternRe ).forEach(function( current ) {\\n\\t\\tvar aux, chr, daylightTzName, gmtFormat, length, standardTzName;\\n\\n\\t\\tchr = current.charAt( 0 );\\n\\t\\tlength = current.length;\\n\\n\\t\\tif ( chr === \\"Z\\" ) {\\n\\t\\t\\tif ( length < 5 ) {\\n\\t\\t\\t\\tchr = \\"O\\";\\n\\t\\t\\t\\tlength = 4;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tchr = \\"X\\";\\n\\t\\t\\t\\tlength = 5;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// z...zzz: \\"{shortRegion}\\", eg. \\"PST\\" or \\"PDT\\".\\n\\t\\t// zzzz: \\"{regionName} {Standard Time}\\" or \\"{regionName} {Daylight Time}\\",\\n\\t\\t//       e.g., \\"Pacific Standard Time\\" or \\"Pacific Daylight Time\\".\\n\\t\\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\\n\\t\\tif ( chr === \\"z\\" ) {\\n\\t\\t\\tstandardTzName = dateGetTimeZoneName( length, \\"standard\\", timeZone, cldr );\\n\\t\\t\\tdaylightTzName = dateGetTimeZoneName( length, \\"daylight\\", timeZone, cldr );\\n\\t\\t\\tif ( standardTzName ) {\\n\\t\\t\\t\\tstandardTzName = regexpEscape( looseMatching( standardTzName ) );\\n\\t\\t\\t}\\n\\t\\t\\tif ( daylightTzName ) {\\n\\t\\t\\t\\tdaylightTzName = regexpEscape( looseMatching( daylightTzName ) );\\n\\t\\t\\t}\\n\\t\\t\\tif ( standardTzName || daylightTzName ) {\\n\\t\\t\\t\\tproperties.standardOrDaylightTzName = new RegExp(\\n\\t\\t\\t\\t\\t\\"^\\" + regexpSourceSomeTerm([ standardTzName, daylightTzName ])\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Fall through the \\"O\\" format in case one name is missing.\\n\\t\\t\\tif ( !standardTzName || !daylightTzName ) {\\n\\t\\t\\t\\tchr = \\"O\\";\\n\\t\\t\\t\\tif ( length < 4 ) {\\n\\t\\t\\t\\t\\tlength = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// v...vvv: \\"{shortRegion}\\", eg. \\"PT\\".\\n\\t\\t// vvvv: \\"{regionName} {Time}\\" or \\"{regionName} {Time}\\",\\n\\t\\t// e.g., \\"Pacific Time\\"\\n\\t\\t// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns\\n\\t\\tif ( chr === \\"v\\" ) {\\n\\t\\t\\tif ( length !== 1 && length !== 4 ) {\\n\\t\\t\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\t\\t\\tfeature: \\"timezone pattern `\\" + pattern + \\"`\\"\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\tvar genericTzName = dateGetTimeZoneName( length, \\"generic\\", timeZone, cldr );\\n\\t\\t\\tif ( genericTzName ) {\\n\\t\\t\\t\\tproperties.genericTzName = new RegExp(\\n\\t\\t\\t\\t\\t\\"^\\" + regexpEscape( looseMatching( genericTzName ) )\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tchr = \\"O\\";\\n\\n\\t\\t\\t// Fall back to \\"V\\" format.\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tchr = \\"V\\";\\n\\t\\t\\t\\tlength = 4;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tswitch ( chr ) {\\n\\n\\t\\t\\t// Era\\n\\t\\t\\tcase \\"G\\":\\n\\t\\t\\t\\tcldr.main([\\n\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/eras\\",\\n\\t\\t\\t\\t\\tlength <= 3 ? \\"eraAbbr\\" : ( length === 4 ? \\"eraNames\\" : \\"eraNarrow\\" )\\n\\t\\t\\t\\t]);\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Year\\n\\t\\t\\tcase \\"u\\": // Extended year. Need to be implemented.\\n\\t\\t\\tcase \\"U\\": // Cyclic year name. Need to be implemented.\\n\\t\\t\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\t\\t\\tfeature: \\"year pattern `\\" + chr + \\"`\\"\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t// Quarter\\n\\t\\t\\tcase \\"Q\\":\\n\\t\\t\\tcase \\"q\\":\\n\\t\\t\\t\\tif ( length > 2 ) {\\n\\t\\t\\t\\t\\tcldr.main([\\n\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/quarters\\",\\n\\t\\t\\t\\t\\t\\tchr === \\"Q\\" ? \\"format\\" : \\"stand-alone\\",\\n\\t\\t\\t\\t\\t\\twidths[ length - 3 ]\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Month\\n\\t\\t\\tcase \\"M\\":\\n\\t\\t\\tcase \\"L\\":\\n\\n\\t\\t\\t\\t// number l=1:{1,2}, l=2:{2}.\\n\\t\\t\\t\\t// lookup l=3...\\n\\t\\t\\t\\tif ( length > 2 ) {\\n\\t\\t\\t\\t\\tcldr.main([\\n\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/months\\",\\n\\t\\t\\t\\t\\t\\tchr === \\"M\\" ? \\"format\\" : \\"stand-alone\\",\\n\\t\\t\\t\\t\\t\\twidths[ length - 3 ]\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Day\\n\\t\\t\\tcase \\"g\\":\\n\\n\\t\\t\\t\\t// Modified Julian day. Need to be implemented.\\n\\t\\t\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\t\\t\\tfeature: \\"Julian day pattern `g`\\"\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t// Week day\\n\\t\\t\\tcase \\"e\\":\\n\\t\\t\\tcase \\"c\\":\\n\\n\\t\\t\\t\\t// lookup for length >=3.\\n\\t\\t\\t\\tif ( length <= 2 ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"E\\":\\n\\t\\t\\t\\tif ( length === 6 ) {\\n\\n\\t\\t\\t\\t\\t// Note: if short day names are not explicitly specified, abbreviated day\\n\\t\\t\\t\\t\\t// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras\\n\\t\\t\\t\\t\\tcldr.main([\\n\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/days\\",\\n\\t\\t\\t\\t\\t\\t[ chr === \\"c\\" ? \\"stand-alone\\" : \\"format\\" ],\\n\\t\\t\\t\\t\\t\\t\\"short\\"\\n\\t\\t\\t\\t\\t]) || cldr.main([\\n\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/days\\",\\n\\t\\t\\t\\t\\t\\t[ chr === \\"c\\" ? \\"stand-alone\\" : \\"format\\" ],\\n\\t\\t\\t\\t\\t\\t\\"abbreviated\\"\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcldr.main([\\n\\t\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/days\\",\\n\\t\\t\\t\\t\\t\\t[ chr === \\"c\\" ? \\"stand-alone\\" : \\"format\\" ],\\n\\t\\t\\t\\t\\t\\twidths[ length < 3 ? 0 : length - 3 ]\\n\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Period (AM or PM)\\n\\t\\t\\tcase \\"a\\":\\n\\t\\t\\t\\tcldr.main(\\n\\t\\t\\t\\t\\t\\"dates/calendars/gregorian/dayPeriods/format/wide\\"\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Zone\\n\\t\\t\\tcase \\"V\\":\\n\\n\\t\\t\\t\\tif ( length === 1 ) {\\n\\t\\t\\t\\t\\tthrow createErrorUnsupportedFeature({\\n\\t\\t\\t\\t\\t\\tfeature: \\"timezone pattern `\\" + pattern + \\"`\\"\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( timeZone ) {\\n\\t\\t\\t\\t\\tif ( length === 2 ) {\\n\\n\\t\\t\\t\\t\\t\\t// Skip looseMatching processing since timeZone is a canonical posix value.\\n\\t\\t\\t\\t\\t\\tproperties.timeZoneName = timeZone;\\n\\t\\t\\t\\t\\t\\tproperties.timeZoneNameRe = new RegExp( \\"^\\" + regexpEscape( timeZone ) );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar timeZoneName,\\n\\t\\t\\t\\t\\t\\texemplarCity = cldr.main([\\n\\t\\t\\t\\t\\t\\t\\t\\"dates/timeZoneNames/zone\\", timeZone, \\"exemplarCity\\"\\n\\t\\t\\t\\t\\t\\t]);\\n\\n\\t\\t\\t\\t\\tif ( length === 3 ) {\\n\\t\\t\\t\\t\\t\\tif ( !exemplarCity ) {\\n\\t\\t\\t\\t\\t\\t\\texemplarCity = cldr.main([\\n\\t\\t\\t\\t\\t\\t\\t\\t\\"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity\\"\\n\\t\\t\\t\\t\\t\\t\\t]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ttimeZoneName = exemplarCity;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( exemplarCity && length === 4 ) {\\n\\t\\t\\t\\t\\t\\ttimeZoneName = formatMessage(\\n\\t\\t\\t\\t\\t\\t\\tcldr.main(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\"dates/timeZoneNames/regionFormat\\"\\n\\t\\t\\t\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\t\\t\\t[ exemplarCity ]\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( timeZoneName ) {\\n\\t\\t\\t\\t\\t\\ttimeZoneName = looseMatching( timeZoneName );\\n\\t\\t\\t\\t\\t\\tproperties.timeZoneName = timeZoneName;\\n\\t\\t\\t\\t\\t\\tproperties.timeZoneNameRe = new RegExp(\\n\\t\\t\\t\\t\\t\\t\\t\\"^\\" + regexpEscape( timeZoneName )\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( current === \\"v\\" ) {\\n\\t\\t\\t\\t\\tlength = 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"z\\":\\n\\t\\t\\tcase \\"O\\":\\n\\t\\t\\t\\tgmtFormat = cldr.main( \\"dates/timeZoneNames/gmtFormat\\" );\\n\\t\\t\\t\\tcldr.main( \\"dates/timeZoneNames/gmtZeroFormat\\" );\\n\\t\\t\\t\\tcldr.main( \\"dates/timeZoneNames/hourFormat\\" );\\n\\t\\t\\t\\tproperties[ \\"timeZoneNames/gmtZeroFormatRe\\" ] =\\n\\t\\t\\t\\t\\tnew RegExp( \\"^\\" + regexpEscape( properties[ \\"timeZoneNames/gmtZeroFormat\\" ] ) );\\n\\t\\t\\t\\taux = properties[ \\"timeZoneNames/hourFormat\\" ];\\n\\t\\t\\t\\tproperties[ \\"timeZoneNames/hourFormat\\" ] = (\\n\\t\\t\\t\\t\\tlength < 4 ?\\n\\t\\t\\t\\t\\t\\t[ dateTimezoneHourFormatHm( aux, \\"H\\" ), dateTimezoneHourFormatH( aux ) ] :\\n\\t\\t\\t\\t\\t\\t[ dateTimezoneHourFormatHm( aux, \\"HH\\" ) ]\\n\\t\\t\\t\\t).map(function( hourFormat ) {\\n\\t\\t\\t\\t\\treturn hourFormatRe(\\n\\t\\t\\t\\t\\t\\thourFormat,\\n\\t\\t\\t\\t\\t\\tgmtFormat,\\n\\t\\t\\t\\t\\t\\tdigitsReSource,\\n\\t\\t\\t\\t\\t\\ttimeSeparator\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"X\\":\\n\\t\\t\\tcase \\"x\\":\\n\\n\\t\\t\\t\\t// x: hourFormat(\\"+HH[mm];-HH[mm]\\")\\n\\t\\t\\t\\t// xx: hourFormat(\\"+HHmm;-HHmm\\")\\n\\t\\t\\t\\t// xxx: hourFormat(\\"+HH:mm;-HH:mm\\")\\n\\t\\t\\t\\t// xxxx: hourFormat(\\"+HHmm[ss];-HHmm[ss]\\")\\n\\t\\t\\t\\t// xxxxx: hourFormat(\\"+HH:mm[:ss];-HH:mm[:ss]\\")\\n\\t\\t\\t\\tproperties.x = [\\n\\t\\t\\t\\t\\t[ \\"+HHmm;-HHmm\\", \\"+HH;-HH\\" ],\\n\\t\\t\\t\\t\\t[ \\"+HHmm;-HHmm\\" ],\\n\\t\\t\\t\\t\\t[ \\"+HH:mm;-HH:mm\\" ],\\n\\t\\t\\t\\t\\t[ \\"+HHmmss;-HHmmss\\", \\"+HHmm;-HHmm\\" ],\\n\\t\\t\\t\\t\\t[ \\"+HH:mm:ss;-HH:mm:ss\\", \\"+HH:mm;-HH:mm\\" ]\\n\\t\\t\\t\\t][ length - 1 ].map(function( hourFormat ) {\\n\\t\\t\\t\\t\\treturn hourFormatRe( hourFormat );\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\t});\\n\\n\\tcldr.off( \\"get\\", populateProperties );\\n\\n\\treturn properties;\\n};\\n\\n\\n\\n\\n/**\\n * dayOfWeek( date, firstDay )\\n *\\n * @date\\n *\\n * @firstDay the result of `dateFirstDayOfWeek( cldr )`\\n *\\n * Return the day of the week normalized by the territory\'s firstDay [0-6].\\n * Eg for \\"mon\\":\\n * - return 0 if territory is GB, or BR, or DE, or FR (week starts on \\"mon\\");\\n * - return 1 if territory is US (week starts on \\"sun\\");\\n * - return 2 if territory is EG (week starts on \\"sat\\");\\n */\\nvar dateDayOfWeek = function( date, firstDay ) {\\n\\treturn ( date.getDay() - firstDay + 7 ) % 7;\\n};\\n\\n\\n\\n\\n/**\\n * distanceInDays( from, to )\\n *\\n * Return the distance in days between from and to Dates.\\n */\\nvar dateDistanceInDays = function( from, to ) {\\n\\tvar inDays = 864e5;\\n\\treturn ( to.getTime() - from.getTime() ) / inDays;\\n};\\n\\n\\n\\n\\n/**\\n * dayOfYear\\n *\\n * Return the distance in days of the date to the begin of the year [0-d].\\n */\\nvar dateDayOfYear = function( date ) {\\n\\treturn Math.floor( dateDistanceInDays( dateStartOf( date, \\"year\\" ), date ) );\\n};\\n\\n\\n\\n\\n// Invert key and values, e.g., {\\"year\\": \\"yY\\"} ==> {\\"y\\": \\"year\\", \\"Y\\": \\"year\\"}\\nvar dateFieldsMap = objectInvert({\\n\\t\\"era\\": \\"G\\",\\n\\t\\"year\\": \\"yY\\",\\n\\t\\"quarter\\": \\"qQ\\",\\n\\t\\"month\\": \\"ML\\",\\n\\t\\"week\\": \\"wW\\",\\n\\t\\"day\\": \\"dDF\\",\\n\\t\\"weekday\\": \\"ecE\\",\\n\\t\\"dayperiod\\": \\"a\\",\\n\\t\\"hour\\": \\"hHkK\\",\\n\\t\\"minute\\": \\"m\\",\\n\\t\\"second\\": \\"sSA\\",\\n\\t\\"zone\\": \\"zvVOxX\\"\\n}, function( object, key, value ) {\\n\\tvalue.split( \\"\\" ).forEach(function( symbol ) {\\n\\t\\tobject[ symbol ] = key;\\n\\t});\\n\\treturn object;\\n});\\n\\n\\n\\n\\n/**\\n * millisecondsInDay\\n */\\nvar dateMillisecondsInDay = function( date ) {\\n\\n\\t// TODO Handle daylight savings discontinuities\\n\\treturn date - dateStartOf( date, \\"day\\" );\\n};\\n\\n\\n\\n\\n/**\\n * hourFormat( date, format, timeSeparator, formatNumber )\\n *\\n * Return date\'s timezone offset according to the format passed.\\n * Eg for format when timezone offset is 180:\\n * - \\"+H;-H\\": -3\\n * - \\"+HHmm;-HHmm\\": -0300\\n * - \\"+HH:mm;-HH:mm\\": -03:00\\n * - \\"+HH:mm:ss;-HH:mm:ss\\": -03:00:00\\n */\\nvar dateTimezoneHourFormat = function( date, format, timeSeparator, formatNumber ) {\\n\\tvar absOffset,\\n\\t\\toffset = date.getTimezoneOffset();\\n\\n\\tabsOffset = Math.abs( offset );\\n\\tformatNumber = formatNumber || {\\n\\t\\t1: function( value ) {\\n\\t\\t\\treturn stringPad( value, 1 );\\n\\t\\t},\\n\\t\\t2: function( value ) {\\n\\t\\t\\treturn stringPad( value, 2 );\\n\\t\\t}\\n\\t};\\n\\n\\treturn format\\n\\n\\t\\t// Pick the correct sign side (+ or -).\\n\\t\\t.split( \\";\\" )[ offset > 0 ? 1 : 0 ]\\n\\n\\t\\t// Localize time separator\\n\\t\\t.replace( \\":\\", timeSeparator )\\n\\n\\t\\t// Update hours offset.\\n\\t\\t.replace( /HH?/, function( match ) {\\n\\t\\t\\treturn formatNumber[ match.length ]( Math.floor( absOffset / 60 ) );\\n\\t\\t})\\n\\n\\t\\t// Update minutes offset and return.\\n\\t\\t.replace( /mm/, function() {\\n\\t\\t\\treturn formatNumber[ 2 ]( Math.floor( absOffset % 60 ) );\\n\\t\\t})\\n\\n\\t\\t// Update minutes offset and return.\\n\\t\\t.replace( /ss/, function() {\\n\\t\\t\\treturn formatNumber[ 2 ]( Math.floor( absOffset % 1 * 60 ) );\\n\\t\\t});\\n};\\n\\n\\n\\n\\n/**\\n * format( date, properties )\\n *\\n * @date [Date instance].\\n *\\n * @properties\\n *\\n * TODO Support other calendar types.\\n *\\n * Disclosure: this function borrows excerpts of dojo/date/locale.\\n */\\nvar dateFormat = function( date, numberFormatters, properties ) {\\n\\tvar parts = [];\\n\\n\\tvar timeSeparator = properties.timeSeparator;\\n\\n\\t// create globalize date with given timezone data\\n\\tif ( properties.timeZoneData ) {\\n\\t\\tdate = new ZonedDateTime( date, properties.timeZoneData() );\\n\\t}\\n\\n\\tproperties.pattern.replace( datePatternRe, function( current ) {\\n\\t\\tvar aux, dateField, type, value,\\n\\t\\t\\tchr = current.charAt( 0 ),\\n\\t\\t\\tlength = current.length;\\n\\n\\t\\tif ( chr === \\"j\\" ) {\\n\\n\\t\\t\\t// Locale preferred hHKk.\\n\\t\\t\\t// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data\\n\\t\\t\\tchr = properties.preferredTime;\\n\\t\\t}\\n\\n\\t\\tif ( chr === \\"Z\\" ) {\\n\\n\\t\\t\\t// Z..ZZZ: same as \\"xxxx\\".\\n\\t\\t\\tif ( length < 4 ) {\\n\\t\\t\\t\\tchr = \\"x\\";\\n\\t\\t\\t\\tlength = 4;\\n\\n\\t\\t\\t// ZZZZ: same as \\"OOOO\\".\\n\\t\\t\\t} else if ( length < 5 ) {\\n\\t\\t\\t\\tchr = \\"O\\";\\n\\t\\t\\t\\tlength = 4;\\n\\n\\t\\t\\t// ZZZZZ: same as \\"XXXXX\\"\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tchr = \\"X\\";\\n\\t\\t\\t\\tlength = 5;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// z...zzz: \\"{shortRegion}\\", e.g., \\"PST\\" or \\"PDT\\".\\n\\t\\t// zzzz: \\"{regionName} {Standard Time}\\" or \\"{regionName} {Daylight Time}\\",\\n\\t\\t//       e.g., \\"Pacific Standard Time\\" or \\"Pacific Daylight Time\\".\\n\\t\\tif ( chr === \\"z\\" ) {\\n\\t\\t\\tif ( date.isDST ) {\\n\\t\\t\\t\\tvalue = date.isDST() ? properties.daylightTzName : properties.standardTzName;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Fall back to \\"O\\" format.\\n\\t\\t\\tif ( !value ) {\\n\\t\\t\\t\\tchr = \\"O\\";\\n\\t\\t\\t\\tif ( length < 4 ) {\\n\\t\\t\\t\\t\\tlength = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tswitch ( chr ) {\\n\\n\\t\\t\\t// Era\\n\\t\\t\\tcase \\"G\\":\\n\\t\\t\\t\\tvalue = properties.eras[ date.getFullYear() < 0 ? 0 : 1 ];\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Year\\n\\t\\t\\tcase \\"y\\":\\n\\n\\t\\t\\t\\t// Plain year.\\n\\t\\t\\t\\t// The length specifies the padding, but for two letters it also specifies the\\n\\t\\t\\t\\t// maximum length.\\n\\t\\t\\t\\tvalue = date.getFullYear();\\n\\t\\t\\t\\tif ( length === 2 ) {\\n\\t\\t\\t\\t\\tvalue = String( value );\\n\\t\\t\\t\\t\\tvalue = +value.substr( value.length - 2 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"Y\\":\\n\\n\\t\\t\\t\\t// Year in \\"Week of Year\\"\\n\\t\\t\\t\\t// The length specifies the padding, but for two letters it also specifies the\\n\\t\\t\\t\\t// maximum length.\\n\\t\\t\\t\\t// yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays\\n\\t\\t\\t\\tvalue = new Date( date.getTime() );\\n\\t\\t\\t\\tvalue.setDate(\\n\\t\\t\\t\\t\\tvalue.getDate() + 7 -\\n\\t\\t\\t\\t\\tdateDayOfWeek( date, properties.firstDay ) -\\n\\t\\t\\t\\t\\tproperties.firstDay -\\n\\t\\t\\t\\t\\tproperties.minDays\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tvalue = value.getFullYear();\\n\\t\\t\\t\\tif ( length === 2 ) {\\n\\t\\t\\t\\t\\tvalue = String( value );\\n\\t\\t\\t\\t\\tvalue = +value.substr( value.length - 2 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Quarter\\n\\t\\t\\tcase \\"Q\\":\\n\\t\\t\\tcase \\"q\\":\\n\\t\\t\\t\\tvalue = Math.ceil( ( date.getMonth() + 1 ) / 3 );\\n\\t\\t\\t\\tif ( length > 2 ) {\\n\\t\\t\\t\\t\\tvalue = properties.quarters[ chr ][ length ][ value ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Month\\n\\t\\t\\tcase \\"M\\":\\n\\t\\t\\tcase \\"L\\":\\n\\t\\t\\t\\tvalue = date.getMonth() + 1;\\n\\t\\t\\t\\tif ( length > 2 ) {\\n\\t\\t\\t\\t\\tvalue = properties.months[ chr ][ length ][ value ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Week\\n\\t\\t\\tcase \\"w\\":\\n\\n\\t\\t\\t\\t// Week of Year.\\n\\t\\t\\t\\t// woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.\\n\\t\\t\\t\\t// TODO should pad on ww? Not documented, but I guess so.\\n\\t\\t\\t\\tvalue = dateDayOfWeek( dateStartOf( date, \\"year\\" ), properties.firstDay );\\n\\t\\t\\t\\tvalue = Math.ceil( ( dateDayOfYear( date ) + value ) / 7 ) -\\n\\t\\t\\t\\t\\t( 7 - value >= properties.minDays ? 0 : 1 );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"W\\":\\n\\n\\t\\t\\t\\t// Week of Month.\\n\\t\\t\\t\\t// wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.\\n\\t\\t\\t\\tvalue = dateDayOfWeek( dateStartOf( date, \\"month\\" ), properties.firstDay );\\n\\t\\t\\t\\tvalue = Math.ceil( ( date.getDate() + value ) / 7 ) -\\n\\t\\t\\t\\t\\t( 7 - value >= properties.minDays ? 0 : 1 );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Day\\n\\t\\t\\tcase \\"d\\":\\n\\t\\t\\t\\tvalue = date.getDate();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"D\\":\\n\\t\\t\\t\\tvalue = dateDayOfYear( date ) + 1;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"F\\":\\n\\n\\t\\t\\t\\t// Day of Week in month. eg. 2nd Wed in July.\\n\\t\\t\\t\\tvalue = Math.floor( date.getDate() / 7 ) + 1;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Week day\\n\\t\\t\\tcase \\"e\\":\\n\\t\\t\\tcase \\"c\\":\\n\\t\\t\\t\\tif ( length <= 2 ) {\\n\\n\\t\\t\\t\\t\\t// Range is [1-7] (deduced by example provided on documentation)\\n\\t\\t\\t\\t\\t// TODO Should pad with zeros (not specified in the docs)?\\n\\t\\t\\t\\t\\tvalue = dateDayOfWeek( date, properties.firstDay ) + 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"E\\":\\n\\t\\t\\t\\tvalue = dateWeekDays[ date.getDay() ];\\n\\t\\t\\t\\tvalue = properties.days[ chr ][ length ][ value ];\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Period (AM or PM)\\n\\t\\t\\tcase \\"a\\":\\n\\t\\t\\t\\tvalue = properties.dayPeriods[ date.getHours() < 12 ? \\"am\\" : \\"pm\\" ];\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Hour\\n\\t\\t\\tcase \\"h\\": // 1-12\\n\\t\\t\\t\\tvalue = ( date.getHours() % 12 ) || 12;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"H\\": // 0-23\\n\\t\\t\\t\\tvalue = date.getHours();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"K\\": // 0-11\\n\\t\\t\\t\\tvalue = date.getHours() % 12;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"k\\": // 1-24\\n\\t\\t\\t\\tvalue = date.getHours() || 24;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Minute\\n\\t\\t\\tcase \\"m\\":\\n\\t\\t\\t\\tvalue = date.getMinutes();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Second\\n\\t\\t\\tcase \\"s\\":\\n\\t\\t\\t\\tvalue = date.getSeconds();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"S\\":\\n\\t\\t\\t\\tvalue = Math.round( date.getMilliseconds() * Math.pow( 10, length - 3 ) );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"A\\":\\n\\t\\t\\t\\tvalue = Math.round( dateMillisecondsInDay( date ) * Math.pow( 10, length - 3 ) );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Zone\\n\\t\\t\\tcase \\"z\\":\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"v\\":\\n\\n\\t\\t\\t\\t// v...vvv: \\"{shortRegion}\\", eg. \\"PT\\".\\n\\t\\t\\t\\t// vvvv: \\"{regionName} {Time}\\",\\n\\t\\t\\t\\t//       e.g., \\"Pacific Time\\".\\n\\t\\t\\t\\tif ( properties.genericTzName ) {\\n\\t\\t\\t\\t\\tvalue = properties.genericTzName;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"V\\":\\n\\n\\t\\t\\t\\t//VVVV: \\"{explarCity} {Time}\\", e.g., \\"Los Angeles Time\\"\\n\\t\\t\\t\\tif ( properties.timeZoneName ) {\\n\\t\\t\\t\\t\\tvalue = properties.timeZoneName;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( current === \\"v\\" ) {\\n\\t\\t\\t\\t\\tlength = 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"O\\":\\n\\n\\t\\t\\t\\t// O: \\"{gmtFormat}+H;{gmtFormat}-H\\" or \\"{gmtZeroFormat}\\", eg. \\"GMT-8\\" or \\"GMT\\".\\n\\t\\t\\t\\t// OOOO: \\"{gmtFormat}{hourFormat}\\" or \\"{gmtZeroFormat}\\", eg. \\"GMT-08:00\\" or \\"GMT\\".\\n\\t\\t\\t\\tif ( date.getTimezoneOffset() === 0 ) {\\n\\t\\t\\t\\t\\tvalue = properties.gmtZeroFormat;\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// If O..OOO and timezone offset has non-zero minutes, show minutes.\\n\\t\\t\\t\\t\\tif ( length < 4 ) {\\n\\t\\t\\t\\t\\t\\taux = date.getTimezoneOffset();\\n\\t\\t\\t\\t\\t\\taux = properties.hourFormat[ aux % 60 - aux % 1 === 0 ? 0 : 1 ];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\taux = properties.hourFormat;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvalue = dateTimezoneHourFormat(\\n\\t\\t\\t\\t\\t\\tdate,\\n\\t\\t\\t\\t\\t\\taux,\\n\\t\\t\\t\\t\\t\\ttimeSeparator,\\n\\t\\t\\t\\t\\t\\tnumberFormatters\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\tvalue = properties.gmtFormat.replace( /\\\\{0\\\\}/, value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\"X\\":\\n\\n\\t\\t\\t\\t// Same as x*, except it uses \\"Z\\" for zero offset.\\n\\t\\t\\t\\tif ( date.getTimezoneOffset() === 0 ) {\\n\\t\\t\\t\\t\\tvalue = \\"Z\\";\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t/* falls through */\\n\\t\\t\\tcase \\"x\\":\\n\\n\\t\\t\\t\\t// x: hourFormat(\\"+HH[mm];-HH[mm]\\")\\n\\t\\t\\t\\t// xx: hourFormat(\\"+HHmm;-HHmm\\")\\n\\t\\t\\t\\t// xxx: hourFormat(\\"+HH:mm;-HH:mm\\")\\n\\t\\t\\t\\t// xxxx: hourFormat(\\"+HHmm[ss];-HHmm[ss]\\")\\n\\t\\t\\t\\t// xxxxx: hourFormat(\\"+HH:mm[:ss];-HH:mm[:ss]\\")\\n\\t\\t\\t\\taux = date.getTimezoneOffset();\\n\\n\\t\\t\\t\\t// If x and timezone offset has non-zero minutes, use xx (i.e., show minutes).\\n\\t\\t\\t\\tif ( length === 1 && aux % 60 - aux % 1 !== 0 ) {\\n\\t\\t\\t\\t\\tlength += 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If (xxxx or xxxxx) and timezone offset has zero seconds, use xx or xxx\\n\\t\\t\\t\\t// respectively (i.e., don\'t show optional seconds).\\n\\t\\t\\t\\tif ( ( length === 4 || length === 5 ) && aux % 1 === 0 ) {\\n\\t\\t\\t\\t\\tlength -= 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvalue = [\\n\\t\\t\\t\\t\\t\\"+HH;-HH\\",\\n\\t\\t\\t\\t\\t\\"+HHmm;-HHmm\\",\\n\\t\\t\\t\\t\\t\\"+HH:mm;-HH:mm\\",\\n\\t\\t\\t\\t\\t\\"+HHmmss;-HHmmss\\",\\n\\t\\t\\t\\t\\t\\"+HH:mm:ss;-HH:mm:ss\\"\\n\\t\\t\\t\\t][ length - 1 ];\\n\\n\\t\\t\\t\\tvalue = dateTimezoneHourFormat( date, value, \\":\\" );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// timeSeparator\\n\\t\\t\\tcase \\":\\":\\n\\t\\t\\t\\tvalue = timeSeparator;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// \' literals.\\n\\t\\t\\tcase \\"\'\\":\\n\\t\\t\\t\\tvalue = removeLiteralQuotes( current );\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t// Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and\\n\\t\\t\\t// arabic characters.\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tvalue = current;\\n\\n\\t\\t}\\n\\t\\tif ( typeof value === \\"number\\" ) {\\n\\t\\t\\tvalue = numberFormatters[ length ]( value );\\n\\t\\t}\\n\\n\\t\\tdateField = dateFieldsMap[ chr ];\\n\\t\\ttype = dateField ? dateField : \\"literal\\";\\n\\n\\t\\tpartsPush( parts, type, value );\\n\\t});\\n\\n\\treturn parts;\\n\\n};\\n\\n\\n\\n\\nvar dateToPartsFormatterFn = function( numberFormatters, properties ) {\\n\\treturn function dateToPartsFormatter( value ) {\\n\\t\\tvalidateParameterPresence( value, \\"value\\" );\\n\\t\\tvalidateParameterTypeDate( value, \\"value\\" );\\n\\n\\t\\treturn dateFormat( value, numberFormatters, properties );\\n\\t};\\n\\n};\\n\\n\\n\\n\\nfunction optionsHasStyle( options ) {\\n\\treturn options.skeleton !== undefined ||\\n\\t\\toptions.date !== undefined ||\\n\\t\\toptions.time !== undefined ||\\n\\t\\toptions.datetime !== undefined ||\\n\\t\\toptions.raw !== undefined;\\n}\\n\\nfunction validateRequiredCldr( path, value ) {\\n\\tvalidateCldr( path, value, {\\n\\t\\tskip: [\\n\\t\\t\\t/dates\\\\/calendars\\\\/gregorian\\\\/dateTimeFormats\\\\/availableFormats/,\\n\\t\\t\\t/dates\\\\/calendars\\\\/gregorian\\\\/days\\\\/.*\\\\/short/,\\n\\t\\t\\t/dates\\\\/timeZoneNames\\\\/zone/,\\n\\t\\t\\t/dates\\\\/timeZoneNames\\\\/metazone/,\\n\\t\\t\\t/globalize-iana/,\\n\\t\\t\\t/supplemental\\\\/metaZones/,\\n\\t\\t\\t/supplemental\\\\/timeData\\\\/(?!001)/,\\n\\t\\t\\t/supplemental\\\\/weekData\\\\/(?!001)/\\n\\t\\t]\\n\\t});\\n}\\n\\nfunction validateOptionsPreset( options ) {\\n\\tvalidateOptionsPresetEach( \\"date\\", options );\\n\\tvalidateOptionsPresetEach( \\"time\\", options );\\n\\tvalidateOptionsPresetEach( \\"datetime\\", options );\\n}\\n\\nfunction validateOptionsPresetEach( type, options ) {\\n\\tvar value = options[ type ];\\n\\tvalidate(\\n\\t\\t\\"E_INVALID_OPTIONS\\",\\n\\t\\t\\"Invalid `{{type}: \\\\\\"{value}\\\\\\"}`.\\",\\n\\t\\tvalue === undefined || [ \\"short\\", \\"medium\\", \\"long\\", \\"full\\" ].indexOf( value ) !== -1,\\n\\t\\t{ type: type, value: value }\\n\\t);\\n}\\n\\nfunction validateOptionsSkeleton( pattern, skeleton ) {\\n\\tvalidate(\\n\\t\\t\\"E_INVALID_OPTIONS\\",\\n\\t\\t\\"Invalid `{skeleton: \\\\\\"{value}\\\\\\"}` based on provided CLDR.\\",\\n\\t\\tskeleton === undefined || ( typeof pattern === \\"string\\" && pattern ),\\n\\t\\t{ type: \\"skeleton\\", value: skeleton }\\n\\t);\\n}\\n\\nfunction validateRequiredIana( timeZone ) {\\n\\treturn function( path, value ) {\\n\\n\\t\\tif ( !/globalize-iana/.test( path ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvalidate(\\n\\t\\t\\t\\"E_MISSING_IANA_TZ\\",\\n\\t\\t\\t\\"Missing required IANA timezone content for `{timeZone}`: `{path}`.\\",\\n\\t\\t\\tvalue,\\n\\t\\t\\t{\\n\\t\\t\\t\\tpath: path.replace( /globalize-iana\\\\//, \\"\\" ),\\n\\t\\t\\t\\ttimeZone: timeZone\\n\\t\\t\\t}\\n\\t\\t);\\n\\t};\\n}\\n\\n/**\\n * .loadTimeZone( json )\\n *\\n * @json [JSON]\\n *\\n * Load IANA timezone data.\\n */\\nGlobalize.loadTimeZone = function( json ) {\\n\\tvar customData = {\\n\\t\\t\\t\\"globalize-iana\\": json\\n\\t\\t};\\n\\n\\tvalidateParameterPresence( json, \\"json\\" );\\n\\tvalidateParameterTypePlainObject( json, \\"json\\" );\\n\\n\\tCldr.load( customData );\\n};\\n\\n/**\\n * .dateFormatter( options )\\n *\\n * @options [Object] see date/expand_pattern for more info.\\n *\\n * Return a date formatter function (of the form below) according to the given options and the\\n * default/instance locale.\\n *\\n * fn( value )\\n *\\n * @value [Date]\\n *\\n * Return a function that formats a date according to the given `format` and the default/instance\\n * locale.\\n */\\nGlobalize.dateFormatter =\\nGlobalize.prototype.dateFormatter = function( options ) {\\n\\tvar args, dateToPartsFormatter, returnFn;\\n\\n\\tvalidateParameterTypePlainObject( options, \\"options\\" );\\n\\n\\toptions = options || {};\\n\\tif ( !optionsHasStyle( options ) ) {\\n\\t\\toptions.skeleton = \\"yMd\\";\\n\\t}\\n\\targs = [ options ];\\n\\n\\tdateToPartsFormatter = this.dateToPartsFormatter( options );\\n\\treturnFn = dateFormatterFn( dateToPartsFormatter );\\n\\truntimeBind( args, this.cldr, returnFn, [ dateToPartsFormatter ] );\\n\\n\\treturn returnFn;\\n};\\n\\n/**\\n * .dateToPartsFormatter( options )\\n *\\n * @options [Object] see date/expand_pattern for more info.\\n *\\n * Return a date formatter function (of the form below) according to the given options and the\\n * default/instance locale.\\n *\\n * fn( value )\\n *\\n * @value [Date]\\n *\\n * Return a function that formats a date to parts according to the given `format`\\n * and the default/instance\\n * locale.\\n */\\nGlobalize.dateToPartsFormatter =\\nGlobalize.prototype.dateToPartsFormatter = function( options ) {\\n\\tvar args, cldr, numberFormatters, pad, pattern, properties, returnFn,\\n\\t\\ttimeZone, ianaListener;\\n\\n\\tvalidateParameterTypePlainObject( options, \\"options\\" );\\n\\n\\tcldr = this.cldr;\\n\\toptions = options || {};\\n\\tif ( !optionsHasStyle( options ) ) {\\n\\t\\toptions.skeleton = \\"yMd\\";\\n\\t}\\n\\n\\tvalidateOptionsPreset( options );\\n\\tvalidateDefaultLocale( cldr );\\n\\n\\ttimeZone = options.timeZone;\\n\\tvalidateParameterTypeString( timeZone, \\"options.timeZone\\" );\\n\\n\\targs = [ options ];\\n\\n\\tcldr.on( \\"get\\", validateRequiredCldr );\\n\\tif ( timeZone ) {\\n\\t\\tianaListener = validateRequiredIana( timeZone );\\n\\t\\tcldr.on( \\"get\\", ianaListener );\\n\\t}\\n\\ttry {\\n\\t\\tpattern = dateExpandPattern( options, cldr );\\n\\t\\tvalidateOptionsSkeleton( pattern, options.skeleton );\\n\\t\\tproperties = dateFormatProperties( pattern, cldr, timeZone );\\n\\t} finally {\\n\\t\\tcldr.off( \\"get\\", validateRequiredCldr );\\n\\t\\tif ( ianaListener ) {\\n\\t\\t\\tcldr.off( \\"get\\", ianaListener );\\n\\t\\t}\\n\\t}\\n\\n\\t// Create needed number formatters.\\n\\tnumberFormatters = properties.numberFormatters;\\n\\tdelete properties.numberFormatters;\\n\\tfor ( pad in numberFormatters ) {\\n\\t\\tnumberFormatters[ pad ] = this.numberFormatter({\\n\\t\\t\\traw: numberFormatters[ pad ]\\n\\t\\t});\\n\\t}\\n\\n\\treturnFn = dateToPartsFormatterFn( numberFormatters, properties );\\n\\n\\truntimeBind( args, cldr, returnFn, [ numberFormatters, properties ] );\\n\\n\\treturn returnFn;\\n};\\n\\n/**\\n * .dateParser( options )\\n *\\n * @options [Object] see date/expand_pattern for more info.\\n *\\n * Return a function that parses a string date according to the given `formats` and the\\n * default/instance locale.\\n */\\nGlobalize.dateParser =\\nGlobalize.prototype.dateParser = function( options ) {\\n\\tvar args, cldr, numberParser, parseProperties, pattern, returnFn, timeZone,\\n\\t\\ttokenizerProperties;\\n\\n\\tvalidateParameterTypePlainObject( options, \\"options\\" );\\n\\n\\tcldr = this.cldr;\\n\\toptions = options || {};\\n\\tif ( !optionsHasStyle( options ) ) {\\n\\t\\toptions.skeleton = \\"yMd\\";\\n\\t}\\n\\n\\tvalidateOptionsPreset( options );\\n\\tvalidateDefaultLocale( cldr );\\n\\n\\ttimeZone = options.timeZone;\\n\\tvalidateParameterTypeString( timeZone, \\"options.timeZone\\" );\\n\\n\\targs = [ options ];\\n\\n\\ttry {\\n\\t\\tcldr.on( \\"get\\", validateRequiredCldr );\\n\\t\\tif ( timeZone ) {\\n\\t\\t\\tcldr.on( \\"get\\", validateRequiredIana( timeZone ) );\\n\\t\\t}\\n\\t\\tpattern = dateExpandPattern( options, cldr );\\n\\t\\tvalidateOptionsSkeleton( pattern, options.skeleton );\\n\\t\\ttokenizerProperties = dateTokenizerProperties( pattern, cldr, timeZone );\\n\\t\\tparseProperties = dateParseProperties( cldr, timeZone );\\n\\t} finally {\\n\\t\\tcldr.off( \\"get\\", validateRequiredCldr );\\n\\t\\tif ( timeZone ) {\\n\\t\\t\\tcldr.off( \\"get\\", validateRequiredIana( timeZone ) );\\n\\t\\t}\\n\\t}\\n\\tnumberParser = this.numberParser({ raw: \\"0\\" });\\n\\n\\treturnFn = dateParserFn( numberParser, parseProperties, tokenizerProperties );\\n\\n\\truntimeBind( args, cldr, returnFn, [ numberParser, parseProperties, tokenizerProperties ] );\\n\\n\\treturn returnFn;\\n};\\n\\n/**\\n * .formatDate( value, options )\\n *\\n * @value [Date]\\n *\\n * @options [Object] see date/expand_pattern for more info.\\n *\\n * Formats a date or number according to the given options string and the default/instance locale.\\n */\\nGlobalize.formatDate =\\nGlobalize.prototype.formatDate = function( value, options ) {\\n\\tvalidateParameterPresence( value, \\"value\\" );\\n\\tvalidateParameterTypeDate( value, \\"value\\" );\\n\\n\\treturn this.dateFormatter( options )( value );\\n};\\n\\n/**\\n * .formatDateToParts( value, options )\\n *\\n * @value [Date]\\n *\\n * @options [Object] see date/expand_pattern for more info.\\n *\\n * Formats a date or number to parts according to the given options and the default/instance locale.\\n */\\nGlobalize.formatDateToParts =\\nGlobalize.prototype.formatDateToParts = function( value, options ) {\\n\\tvalidateParameterPresence( value, \\"value\\" );\\n\\tvalidateParameterTypeDate( value, \\"value\\" );\\n\\n\\treturn this.dateToPartsFormatter( options )( value );\\n};\\n\\n/**\\n * .parseDate( value, options )\\n *\\n * @value [String]\\n *\\n * @options [Object] see date/expand_pattern for more info.\\n *\\n * Return a Date instance or null.\\n */\\nGlobalize.parseDate =\\nGlobalize.prototype.parseDate = function( value, options ) {\\n\\tvalidateParameterPresence( value, \\"value\\" );\\n\\tvalidateParameterTypeString( value, \\"value\\" );\\n\\n\\treturn this.dateParser( options )( value );\\n};\\n\\nreturn Globalize;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL2RhdGUuanM/NzhiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqXFxuICogR2xvYmFsaXplIHYxLjUuMFxcbiAqXFxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxcbiAqXFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDIwLTAzLTI1VDEyOjE5WlxcbiAqL1xcbi8qIVxcbiAqIEdsb2JhbGl6ZSB2MS41LjAgMjAyMC0wMy0yNVQxMjoxOVogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICogaHR0cDovL2dpdC5pby9UcmRRYndcXG4gKi9cXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XFxuXFxuXFx0Ly8gVU1EIHJldHVybkV4cG9ydHNcXG5cXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZGVmaW5lLmFtZCApIHtcXG5cXG5cXHRcXHQvLyBBTURcXG5cXHRcXHRkZWZpbmUoW1xcblxcdFxcdFxcdFxcXCJjbGRyXFxcIixcXG5cXHRcXHRcXHRcXFwiLi4vZ2xvYmFsaXplXFxcIixcXG5cXHRcXHRcXHRcXFwiLi9udW1iZXJcXFwiLFxcblxcdFxcdFxcdFxcXCJjbGRyL2V2ZW50XFxcIixcXG5cXHRcXHRcXHRcXFwiY2xkci9zdXBwbGVtZW50YWxcXFwiXFxuXFx0XFx0XSwgZmFjdG9yeSApO1xcblxcdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHQvLyBOb2RlLCBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXFxcImNsZHJqc1xcXCIgKSwgcmVxdWlyZSggXFxcIi4uL2dsb2JhbGl6ZVxcXCIgKSApO1xcblxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0Ly8gRXh0ZW5kIGdsb2JhbFxcblxcdFxcdGZhY3RvcnkoIHJvb3QuQ2xkciwgcm9vdC5HbG9iYWxpemUgKTtcXG5cXHR9XFxufSh0aGlzLCBmdW5jdGlvbiggQ2xkciwgR2xvYmFsaXplICkge1xcblxcbnZhciBjcmVhdGVFcnJvciA9IEdsb2JhbGl6ZS5fY3JlYXRlRXJyb3IsXFxuXFx0Y3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUgPSBHbG9iYWxpemUuX2NyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlLFxcblxcdGZvcm1hdE1lc3NhZ2UgPSBHbG9iYWxpemUuX2Zvcm1hdE1lc3NhZ2UsXFxuXFx0aXNQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5faXNQbGFpbk9iamVjdCxcXG5cXHRsb29zZU1hdGNoaW5nID0gR2xvYmFsaXplLl9sb29zZU1hdGNoaW5nLFxcblxcdG51bWJlck51bWJlcmluZ1N5c3RlbURpZ2l0c01hcCA9IEdsb2JhbGl6ZS5fbnVtYmVyTnVtYmVyaW5nU3lzdGVtRGlnaXRzTWFwLFxcblxcdG51bWJlclN5bWJvbCA9IEdsb2JhbGl6ZS5fbnVtYmVyU3ltYm9sLFxcblxcdHBhcnRzSm9pbiA9IEdsb2JhbGl6ZS5fcGFydHNKb2luLFxcblxcdHBhcnRzUHVzaCA9IEdsb2JhbGl6ZS5fcGFydHNQdXNoLFxcblxcdHJlZ2V4cEVzY2FwZSA9IEdsb2JhbGl6ZS5fcmVnZXhwRXNjYXBlLFxcblxcdHJlbW92ZUxpdGVyYWxRdW90ZXMgPSBHbG9iYWxpemUuX3JlbW92ZUxpdGVyYWxRdW90ZXMsXFxuXFx0cnVudGltZUJpbmQgPSBHbG9iYWxpemUuX3J1bnRpbWVCaW5kLFxcblxcdHN0cmluZ1BhZCA9IEdsb2JhbGl6ZS5fc3RyaW5nUGFkLFxcblxcdHZhbGlkYXRlID0gR2xvYmFsaXplLl92YWxpZGF0ZSxcXG5cXHR2YWxpZGF0ZUNsZHIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlQ2xkcixcXG5cXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlRGVmYXVsdExvY2FsZSxcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlLFxcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlLFxcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCxcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZztcXG5cXG5cXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlRGF0ZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoIHZhbHVlLCBuYW1lLCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSwgXFxcIkRhdGVcXFwiICk7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgY3JlYXRlRXJyb3JJbnZhbGlkUGFyYW1ldGVyVmFsdWUgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIGNyZWF0ZUVycm9yKCBcXFwiRV9JTlZBTElEX1BBUl9WQUxVRVxcXCIsIFxcXCJJbnZhbGlkIGB7bmFtZX1gIHZhbHVlICh7dmFsdWV9KS5cXFwiLCB7XFxuXFx0XFx0bmFtZTogbmFtZSxcXG5cXHRcXHR2YWx1ZTogdmFsdWVcXG5cXHR9KTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIENyZWF0ZSBhIG1hcCBiZXR3ZWVuIHRoZSBza2VsZXRvbiBmaWVsZHMgYW5kIHRoZWlyIHBvc2l0aW9ucywgZS5nLixcXG4gKiB7XFxuICogICBHOiAwXFxuICogICB5OiAxXFxuICogICAuLi5cXG4gKiB9XFxuICovXFxudmFyIHZhbGlkYXRlU2tlbGV0b25GaWVsZHNQb3NNYXAgPSBcXFwiR3lZdVVyUXFNTGx3V0VlY2RERmdoSEtrbXNTQXpaT3ZWWHhcXFwiLnNwbGl0KCBcXFwiXFxcIiApLnJlZHVjZShmdW5jdGlvbiggbWVtbywgaXRlbSwgaSApIHtcXG5cXHRtZW1vWyBpdGVtIF0gPSBpO1xcblxcdHJldHVybiBtZW1vO1xcbn0sIHt9KTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiB2YWxpZGF0ZVNrZWxldG9uKCBza2VsZXRvbiApXFxuICpcXG4gKiBza2VsZXRvbjogQXNzdW1lIGBqYCBoYXMgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCBpbnRvIGEgbG9jYWxpemVkIGhvdXIgZmllbGQuXFxuICovXFxudmFyIHZhbGlkYXRlU2tlbGV0b24gPSBmdW5jdGlvbiB2YWxpZGF0ZVNrZWxldG9uKCBza2VsZXRvbiApIHtcXG5cXHR2YXIgbGFzdCxcXG5cXG5cXHRcXHQvLyBVc2luZyBlYXNpZXIgdG8gcmVhZCB2YXJpYWJsZS5cXG5cXHRcXHRmaWVsZHNQb3NNYXAgPSB2YWxpZGF0ZVNrZWxldG9uRmllbGRzUG9zTWFwO1xcblxcblxcdC8vIFxcXCJUaGUgZmllbGRzIGFyZSBmcm9tIHRoZSBEYXRlIEZpZWxkIFN5bWJvbCBUYWJsZSBpbiBEYXRlIEZvcm1hdCBQYXR0ZXJuc1xcXCJcXG5cXHQvLyBSZWY6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNhdmFpbGFibGVGb3JtYXRzX2FwcGVuZEl0ZW1zXFxuXFx0Ly8gSS5lLiwgY2hlY2sgZm9yIGludmFsaWQgY2hhcmFjdGVycy5cXG5cXHRza2VsZXRvbi5yZXBsYWNlKCAvW15HeVl1VXJRcU1MbHdXRWVjZERGZ2hIS2ttc1NBelpPdlZYeF0vLCBmdW5jdGlvbiggZmllbGQgKSB7XFxuXFx0XFx0dGhyb3cgY3JlYXRlRXJyb3IoXFxuXFx0XFx0XFx0XFxcIkVfSU5WQUxJRF9PUFRJT05TXFxcIiwgXFxcIkludmFsaWQgZmllbGQgYHtpbnZhbGlkRmllbGR9YCBvZiBza2VsZXRvbiBge3ZhbHVlfWBcXFwiLFxcblxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRpbnZhbGlkRmllbGQ6IGZpZWxkLFxcblxcdFxcdFxcdFxcdHR5cGU6IFxcXCJza2VsZXRvblxcXCIsXFxuXFx0XFx0XFx0XFx0dmFsdWU6IHNrZWxldG9uXFxuXFx0XFx0XFx0fVxcblxcdFxcdCk7XFxuXFx0fSk7XFxuXFxuXFx0Ly8gXFxcIlRoZSBjYW5vbmljYWwgb3JkZXIgaXMgZnJvbSB0b3AgdG8gYm90dG9tIGluIHRoYXQgdGFibGU7IHRoYXQgaXMsIHlNIG5vdCBNeVxcXCIuXFxuXFx0Ly8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI2F2YWlsYWJsZUZvcm1hdHNfYXBwZW5kSXRlbXNcXG5cXHQvLyBJLmUuLCBjaGVjayBmb3IgaW52YWxpZCBvcmRlci5cXG5cXHRza2VsZXRvbi5zcGxpdCggXFxcIlxcXCIgKS5ldmVyeShmdW5jdGlvbiggZmllbGQgKSB7XFxuXFx0XFx0aWYgKCBmaWVsZHNQb3NNYXBbIGZpZWxkIF0gPCBsYXN0ICkge1xcblxcdFxcdFxcdHRocm93IGNyZWF0ZUVycm9yKFxcblxcdFxcdFxcdFxcdFxcXCJFX0lOVkFMSURfT1BUSU9OU1xcXCIsIFxcXCJJbnZhbGlkIG9yZGVyIGB7aW52YWxpZEZpZWxkfWAgb2Ygc2tlbGV0b24gYHt2YWx1ZX1gXFxcIixcXG5cXHRcXHRcXHRcXHR7XFxuXFx0XFx0XFx0XFx0XFx0aW52YWxpZEZpZWxkOiBmaWVsZCxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiBcXFwic2tlbGV0b25cXFwiLFxcblxcdFxcdFxcdFxcdFxcdHZhbHVlOiBza2VsZXRvblxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHQpO1xcblxcdFxcdH1cXG5cXHRcXHRsYXN0ID0gZmllbGRzUG9zTWFwWyBmaWVsZCBdO1xcblxcdFxcdHJldHVybiB0cnVlO1xcblxcdH0pO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogUmV0dXJucyBhIG5ldyBvYmplY3QgY3JlYXRlZCBieSB1c2luZyBgb2JqZWN0YCdzIHZhbHVlcyBhcyBrZXlzLCBhbmQgdGhlIGtleXMgYXMgdmFsdWVzLlxcbiAqL1xcbnZhciBvYmplY3RJbnZlcnQgPSBmdW5jdGlvbiggb2JqZWN0LCBmbiApIHtcXG5cXHRmbiA9IGZuIHx8IGZ1bmN0aW9uKCBvYmplY3QsIGtleSwgdmFsdWUgKSB7XFxuXFx0XFx0b2JqZWN0WyB2YWx1ZSBdID0ga2V5O1xcblxcdFxcdHJldHVybiBvYmplY3Q7XFxuXFx0fTtcXG5cXHRyZXR1cm4gT2JqZWN0LmtleXMoIG9iamVjdCApLnJlZHVjZShmdW5jdGlvbiggbmV3T2JqZWN0LCBrZXkgKSB7XFxuXFx0XFx0cmV0dXJuIGZuKCBuZXdPYmplY3QsIGtleSwgb2JqZWN0WyBrZXkgXSApO1xcblxcdH0sIHt9KTtcXG59O1xcblxcblxcblxcblxcbi8vIEludmVydCBrZXkgYW5kIHZhbHVlcywgZS5nLiwge1xcXCJlXFxcIjogXFxcImVFY1xcXCJ9ID09PiB7XFxcImVcXFwiOiBcXFwiZVxcXCIsIFxcXCJFXFxcIjogXFxcImVcXFwiLCBcXFwiY1xcXCI6IFxcXCJlXFxcIn0uXFxudmFyIGRhdGVFeHBhbmRQYXR0ZXJuU2ltaWxhckZpZWxkc01hcCA9IG9iamVjdEludmVydCh7XFxuXFx0XFxcImVcXFwiOiBcXFwiZUVjXFxcIixcXG5cXHRcXFwiTFxcXCI6IFxcXCJNTFxcXCJcXG59LCBmdW5jdGlvbiggb2JqZWN0LCBrZXksIHZhbHVlICkge1xcblxcdHZhbHVlLnNwbGl0KCBcXFwiXFxcIiApLmZvckVhY2goZnVuY3Rpb24oIGZpZWxkICkge1xcblxcdFxcdG9iamVjdFsgZmllbGQgXSA9IGtleTtcXG5cXHR9KTtcXG5cXHRyZXR1cm4gb2JqZWN0O1xcbn0pO1xcblxcblxcblxcblxcbnZhciBkYXRlRXhwYW5kUGF0dGVybk5vcm1hbGl6ZVBhdHRlcm5UeXBlID0gZnVuY3Rpb24oIGNoYXJhY3RlciApIHtcXG5cXHRyZXR1cm4gZGF0ZUV4cGFuZFBhdHRlcm5TaW1pbGFyRmllbGRzTWFwWyBjaGFyYWN0ZXIgXSB8fCBjaGFyYWN0ZXI7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgZGF0ZVBhdHRlcm5SZSA9ICggLyhbYS16XSlcXFxcMSp8JyhbXiddfCcnKSsnfCcnfC4vaWcgKTtcXG5cXG5cXG5cXG5cXG52YXIgc3RyaW5nUmVwZWF0ID0gZnVuY3Rpb24oIHN0ciwgY291bnQgKSB7XFxuXFx0dmFyIGksIHJlc3VsdCA9IFxcXCJcXFwiO1xcblxcdGZvciAoIGkgPSAwOyBpIDwgY291bnQ7IGkrKyApIHtcXG5cXHRcXHRyZXN1bHQgPSByZXN1bHQgKyBzdHI7XFxuXFx0fVxcblxcdHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBleHBhbmRCZXN0TWF0Y2hGb3JtYXQoIHNrZWxldG9uV2l0aG91dEZyYWN0aW9uYWxTZWNvbmRzLCBiZXN0TWF0Y2hGb3JtYXQgKSB7XFxuXFx0dmFyIGksIGosIGJlc3RNYXRjaEZvcm1hdFBhcnRzLCBtYXRjaGVkVHlwZSwgbWF0Y2hlZExlbmd0aCwgcmVxdWVzdGVkVHlwZSxcXG5cXHRcXHRyZXF1ZXN0ZWRMZW5ndGgsIHJlcXVlc3RlZFNrZWxldG9uUGFydHMsXFxuXFxuXFx0XFx0Ly8gVXNpbmcgYW4gZWFzaWVyIHRvIHJlYWQgdmFyaWFibGUuXFxuXFx0XFx0bm9ybWFsaXplUGF0dGVyblR5cGUgPSBkYXRlRXhwYW5kUGF0dGVybk5vcm1hbGl6ZVBhdHRlcm5UeXBlO1xcblxcblxcdHJlcXVlc3RlZFNrZWxldG9uUGFydHMgPSBza2VsZXRvbldpdGhvdXRGcmFjdGlvbmFsU2Vjb25kcy5tYXRjaCggZGF0ZVBhdHRlcm5SZSApO1xcblxcdGJlc3RNYXRjaEZvcm1hdFBhcnRzID0gYmVzdE1hdGNoRm9ybWF0Lm1hdGNoKCBkYXRlUGF0dGVyblJlICk7XFxuXFxuXFx0Zm9yICggaSA9IDA7IGkgPCBiZXN0TWF0Y2hGb3JtYXRQYXJ0cy5sZW5ndGg7IGkrKyApIHtcXG5cXHRcXHRtYXRjaGVkVHlwZSA9IGJlc3RNYXRjaEZvcm1hdFBhcnRzW2ldLmNoYXJBdCggMCApO1xcblxcdFxcdG1hdGNoZWRMZW5ndGggPSBiZXN0TWF0Y2hGb3JtYXRQYXJ0c1tpXS5sZW5ndGg7XFxuXFx0XFx0Zm9yICggaiA9IDA7IGogPCByZXF1ZXN0ZWRTa2VsZXRvblBhcnRzLmxlbmd0aDsgaisrICkge1xcblxcdFxcdFxcdHJlcXVlc3RlZFR5cGUgPSByZXF1ZXN0ZWRTa2VsZXRvblBhcnRzW2pdLmNoYXJBdCggMCApO1xcblxcdFxcdFxcdHJlcXVlc3RlZExlbmd0aCA9IHJlcXVlc3RlZFNrZWxldG9uUGFydHNbal0ubGVuZ3RoO1xcblxcdFxcdFxcdGlmICggbm9ybWFsaXplUGF0dGVyblR5cGUoIG1hdGNoZWRUeXBlICkgPT09IG5vcm1hbGl6ZVBhdHRlcm5UeXBlKCByZXF1ZXN0ZWRUeXBlICkgJiZcXG5cXHRcXHRcXHRcXHRtYXRjaGVkTGVuZ3RoIDwgcmVxdWVzdGVkTGVuZ3RoXFxuXFx0XFx0XFx0KSB7XFxuXFx0XFx0XFx0XFx0YmVzdE1hdGNoRm9ybWF0UGFydHNbaV0gPSBzdHJpbmdSZXBlYXQoIG1hdGNoZWRUeXBlLCByZXF1ZXN0ZWRMZW5ndGggKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gYmVzdE1hdGNoRm9ybWF0UGFydHMuam9pbiggXFxcIlxcXCIgKTtcXG59XFxuXFxuLy8gU2VlOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjTWF0Y2hpbmdfU2tlbGV0b25zXFxudmFyIGRhdGVFeHBhbmRQYXR0ZXJuQXVnbWVudEZvcm1hdCA9IGZ1bmN0aW9uKCByZXF1ZXN0ZWRTa2VsZXRvbiwgYmVzdE1hdGNoRm9ybWF0LCBkZWNpbWFsU2VwYXJhdG9yICkge1xcblxcdHZhciBjb3VudE9mRnJhY3Rpb25hbFNlY29uZHMsIGZyYWN0aW9uYWxTZWNvbmRNYXRjaCwgbGFzdFNlY29uZElkeCxcXG5cXHRcXHRza2VsZXRvbldpdGhvdXRGcmFjdGlvbmFsU2Vjb25kcztcXG5cXG5cXHRmcmFjdGlvbmFsU2Vjb25kTWF0Y2ggPSByZXF1ZXN0ZWRTa2VsZXRvbi5tYXRjaCggL1MvZyApO1xcblxcdGNvdW50T2ZGcmFjdGlvbmFsU2Vjb25kcyA9IGZyYWN0aW9uYWxTZWNvbmRNYXRjaCA/IGZyYWN0aW9uYWxTZWNvbmRNYXRjaC5sZW5ndGggOiAwO1xcblxcdHNrZWxldG9uV2l0aG91dEZyYWN0aW9uYWxTZWNvbmRzID0gcmVxdWVzdGVkU2tlbGV0b24ucmVwbGFjZSggL1MvZywgXFxcIlxcXCIgKTtcXG5cXG5cXHRiZXN0TWF0Y2hGb3JtYXQgPSBleHBhbmRCZXN0TWF0Y2hGb3JtYXQoIHNrZWxldG9uV2l0aG91dEZyYWN0aW9uYWxTZWNvbmRzLCBiZXN0TWF0Y2hGb3JtYXQgKTtcXG5cXG5cXHRsYXN0U2Vjb25kSWR4ID0gYmVzdE1hdGNoRm9ybWF0Lmxhc3RJbmRleE9mKCBcXFwic1xcXCIgKTtcXG5cXHRpZiAoIGxhc3RTZWNvbmRJZHggIT09IC0xICYmIGNvdW50T2ZGcmFjdGlvbmFsU2Vjb25kcyAhPT0gMCApIHtcXG5cXHRcXHRiZXN0TWF0Y2hGb3JtYXQgPVxcblxcdFxcdFxcdGJlc3RNYXRjaEZvcm1hdC5zbGljZSggMCwgbGFzdFNlY29uZElkeCArIDEgKSArXFxuXFx0XFx0XFx0ZGVjaW1hbFNlcGFyYXRvciArXFxuXFx0XFx0XFx0c3RyaW5nUmVwZWF0KCBcXFwiU1xcXCIsIGNvdW50T2ZGcmFjdGlvbmFsU2Vjb25kcyApICtcXG5cXHRcXHRcXHRiZXN0TWF0Y2hGb3JtYXQuc2xpY2UoIGxhc3RTZWNvbmRJZHggKyAxICk7XFxuXFx0fVxcblxcdHJldHVybiBiZXN0TWF0Y2hGb3JtYXQ7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgZGF0ZUV4cGFuZFBhdHRlcm5Db21wYXJlRm9ybWF0cyA9IGZ1bmN0aW9uKCBmb3JtYXRBLCBmb3JtYXRCICkge1xcblxcdHZhciBhLCBiLCBkaXN0YW5jZSwgbGVuQSwgbGVuQiwgdHlwZUEsIHR5cGVCLCBpLCBqLFxcblxcblxcdFxcdC8vIFVzaW5nIGVhc2llciB0byByZWFkIHZhcmlhYmxlcy5cXG5cXHRcXHRub3JtYWxpemVQYXR0ZXJuVHlwZSA9IGRhdGVFeHBhbmRQYXR0ZXJuTm9ybWFsaXplUGF0dGVyblR5cGU7XFxuXFxuXFx0aWYgKCBmb3JtYXRBID09PSBmb3JtYXRCICkge1xcblxcdFxcdHJldHVybiAwO1xcblxcdH1cXG5cXG5cXHRmb3JtYXRBID0gZm9ybWF0QS5tYXRjaCggZGF0ZVBhdHRlcm5SZSApO1xcblxcdGZvcm1hdEIgPSBmb3JtYXRCLm1hdGNoKCBkYXRlUGF0dGVyblJlICk7XFxuXFxuXFx0aWYgKCBmb3JtYXRBLmxlbmd0aCAhPT0gZm9ybWF0Qi5sZW5ndGggKSB7XFxuXFx0XFx0cmV0dXJuIC0xO1xcblxcdH1cXG5cXG5cXHRkaXN0YW5jZSA9IDE7XFxuXFx0Zm9yICggaSA9IDA7IGkgPCBmb3JtYXRBLmxlbmd0aDsgaSsrICkge1xcblxcdFxcdGEgPSBmb3JtYXRBWyBpIF0uY2hhckF0KCAwICk7XFxuXFx0XFx0dHlwZUEgPSBub3JtYWxpemVQYXR0ZXJuVHlwZSggYSApO1xcblxcdFxcdHR5cGVCID0gbnVsbDtcXG5cXHRcXHRmb3IgKCBqID0gMDsgaiA8IGZvcm1hdEIubGVuZ3RoOyBqKysgKSB7XFxuXFx0XFx0XFx0YiA9IGZvcm1hdEJbIGogXS5jaGFyQXQoIDAgKTtcXG5cXHRcXHRcXHR0eXBlQiA9IG5vcm1hbGl6ZVBhdHRlcm5UeXBlKCBiICk7XFxuXFx0XFx0XFx0aWYgKCB0eXBlQSA9PT0gdHlwZUIgKSB7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0eXBlQiA9IG51bGw7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRpZiAoIHR5cGVCID09PSBudWxsICkge1xcblxcdFxcdFxcdHJldHVybiAtMTtcXG5cXHRcXHR9XFxuXFx0XFx0bGVuQSA9IGZvcm1hdEFbIGkgXS5sZW5ndGg7XFxuXFx0XFx0bGVuQiA9IGZvcm1hdEJbIGogXS5sZW5ndGg7XFxuXFx0XFx0ZGlzdGFuY2UgPSBkaXN0YW5jZSArIE1hdGguYWJzKCBsZW5BIC0gbGVuQiApO1xcblxcblxcdFxcdC8vIE1vc3Qgc3ltYm9scyBoYXZlIGEgc21hbGwgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLCBlLmcuLCBNIOKJhSBMOyBFIOKJhSBjOyBhIOKJhSBiIOKJhSBCO1xcblxcdFxcdC8vIEgg4omFIGsg4omFIGgg4omFIEs7IC4uLlxcblxcdFxcdGlmICggYSAhPT0gYiApIHtcXG5cXHRcXHRcXHRkaXN0YW5jZSArPSAxO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBOdW1lcmljIChsPDMpIGFuZCB0ZXh0IGZpZWxkcyAobD49MykgYXJlIGdpdmVuIGEgbGFyZ2VyIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci5cXG5cXHRcXHRpZiAoICggbGVuQSA8IDMgJiYgbGVuQiA+PSAzICkgfHwgKCBsZW5BID49IDMgJiYgbGVuQiA8IDMgKSApIHtcXG5cXHRcXHRcXHRkaXN0YW5jZSArPSAyMDtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdHJldHVybiBkaXN0YW5jZTtcXG59O1xcblxcblxcblxcblxcbnZhciBkYXRlRXhwYW5kUGF0dGVybkdldEJlc3RNYXRjaFBhdHRlcm4gPSBmdW5jdGlvbiggY2xkciwgYXNrZWRTa2VsZXRvbiApIHtcXG5cXHR2YXIgYXZhaWxhYmxlRm9ybWF0cywgZGVjaW1hbFNlcGFyYXRvciwgcGF0dGVybiwgcmF0ZWRGb3JtYXRzLCBza2VsZXRvbixcXG5cXHRcXHRwYXRoID0gXFxcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF0ZVRpbWVGb3JtYXRzL2F2YWlsYWJsZUZvcm1hdHNcXFwiLFxcblxcblxcdFxcdC8vIFVzaW5nIGVhc2llciB0byByZWFkIHZhcmlhYmxlcy5cXG5cXHRcXHRhdWdtZW50Rm9ybWF0ID0gZGF0ZUV4cGFuZFBhdHRlcm5BdWdtZW50Rm9ybWF0LFxcblxcdFxcdGNvbXBhcmVGb3JtYXRzID0gZGF0ZUV4cGFuZFBhdHRlcm5Db21wYXJlRm9ybWF0cztcXG5cXG5cXHRwYXR0ZXJuID0gY2xkci5tYWluKFsgcGF0aCwgYXNrZWRTa2VsZXRvbiBdKTtcXG5cXG5cXHRpZiAoIGFza2VkU2tlbGV0b24gJiYgIXBhdHRlcm4gKSB7XFxuXFx0XFx0YXZhaWxhYmxlRm9ybWF0cyA9IGNsZHIubWFpbihbIHBhdGggXSk7XFxuXFx0XFx0cmF0ZWRGb3JtYXRzID0gW107XFxuXFxuXFx0XFx0Zm9yICggc2tlbGV0b24gaW4gYXZhaWxhYmxlRm9ybWF0cyApIHtcXG5cXHRcXHRcXHRyYXRlZEZvcm1hdHMucHVzaCh7XFxuXFx0XFx0XFx0XFx0c2tlbGV0b246IHNrZWxldG9uLFxcblxcdFxcdFxcdFxcdHBhdHRlcm46IGF2YWlsYWJsZUZvcm1hdHNbIHNrZWxldG9uIF0sXFxuXFx0XFx0XFx0XFx0cmF0ZTogY29tcGFyZUZvcm1hdHMoIGFza2VkU2tlbGV0b24sIHNrZWxldG9uIClcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmF0ZWRGb3JtYXRzID0gcmF0ZWRGb3JtYXRzXFxuXFx0XFx0XFx0LmZpbHRlciggZnVuY3Rpb24oIGZvcm1hdCApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZm9ybWF0LnJhdGUgPiAtMTtcXG5cXHRcXHRcXHR9IClcXG5cXHRcXHRcXHQuc29ydCggZnVuY3Rpb24oIGZvcm1hdEEsIGZvcm1hdEIgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZvcm1hdEEucmF0ZSAtIGZvcm1hdEIucmF0ZTtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRpZiAoIHJhdGVkRm9ybWF0cy5sZW5ndGggKSB7XFxuXFx0XFx0XFx0ZGVjaW1hbFNlcGFyYXRvciA9IG51bWJlclN5bWJvbCggXFxcImRlY2ltYWxcXFwiLCBjbGRyICk7XFxuXFx0XFx0XFx0cGF0dGVybiA9IGF1Z21lbnRGb3JtYXQoIGFza2VkU2tlbGV0b24sIHJhdGVkRm9ybWF0c1swXS5wYXR0ZXJuLCBkZWNpbWFsU2VwYXJhdG9yICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gcGF0dGVybjtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIGV4cGFuZFBhdHRlcm4oIG9wdGlvbnMsIGNsZHIgKVxcbiAqXFxuICogQG9wdGlvbnMgW09iamVjdF0gaWYgU3RyaW5nLCBpdCdzIGNvbnNpZGVyZWQgYSBza2VsZXRvbi4gT2JqZWN0IGFjY2VwdHM6XFxuICogLSBza2VsZXRvbjogW1N0cmluZ10gbG9va3VwIGF2YWlsYWJsZUZvcm1hdDtcXG4gKiAtIGRhdGU6IFtTdHJpbmddICggXFxcImZ1bGxcXFwiIHwgXFxcImxvbmdcXFwiIHwgXFxcIm1lZGl1bVxcXCIgfCBcXFwic2hvcnRcXFwiICk7XFxuICogLSB0aW1lOiBbU3RyaW5nXSAoIFxcXCJmdWxsXFxcIiB8IFxcXCJsb25nXFxcIiB8IFxcXCJtZWRpdW1cXFwiIHwgXFxcInNob3J0XFxcIiApO1xcbiAqIC0gZGF0ZXRpbWU6IFtTdHJpbmddICggXFxcImZ1bGxcXFwiIHwgXFxcImxvbmdcXFwiIHwgXFxcIm1lZGl1bVxcXCIgfCBcXFwic2hvcnRcXFwiICk7XFxuICogLSByYXc6IFtTdHJpbmddIEZvciBtb3JlIGluZm8gc2VlIGRhdGV0aW1lL2Zvcm1hdC5qcy5cXG4gKlxcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cXG4gKlxcbiAqIFJldHVybiB0aGUgY29ycmVzcG9uZGluZyBwYXR0ZXJuLlxcbiAqIEVnIGZvciBcXFwiZW5cXFwiOlxcbiAqIC0gXFxcIkd5TU1NZFxcXCIgcmV0dXJucyBcXFwiTU1NIGQsIHkgR1xcXCI7XFxuICogLSB7IHNrZWxldG9uOiBcXFwiR3lNTU1kXFxcIiB9IHJldHVybnMgXFxcIk1NTSBkLCB5IEdcXFwiO1xcbiAqIC0geyBkYXRlOiBcXFwiZnVsbFxcXCIgfSByZXR1cm5zIFxcXCJFRUVFLCBNTU1NIGQsIHlcXFwiO1xcbiAqIC0geyB0aW1lOiBcXFwiZnVsbFxcXCIgfSByZXR1cm5zIFxcXCJoOm1tOnNzIGEgenp6elxcXCI7XFxuICogLSB7IGRhdGV0aW1lOiBcXFwiZnVsbFxcXCIgfSByZXR1cm5zIFxcXCJFRUVFLCBNTU1NIGQsIHkgJ2F0JyBoOm1tOnNzIGEgenp6elxcXCI7XFxuICogLSB7IHJhdzogXFxcImRkL21tXFxcIiB9IHJldHVybnMgXFxcImRkL21tXFxcIjtcXG4gKi9cXG52YXIgZGF0ZUV4cGFuZFBhdHRlcm4gPSBmdW5jdGlvbiggb3B0aW9ucywgY2xkciApIHtcXG5cXHR2YXIgZGF0ZVNrZWxldG9uLCByZXN1bHQsIHNrZWxldG9uLCB0aW1lU2tlbGV0b24sIHR5cGUsXFxuXFxuXFx0XFx0Ly8gVXNpbmcgZWFzaWVyIHRvIHJlYWQgdmFyaWFibGVzLlxcblxcdFxcdGdldEJlc3RNYXRjaFBhdHRlcm4gPSBkYXRlRXhwYW5kUGF0dGVybkdldEJlc3RNYXRjaFBhdHRlcm47XFxuXFxuXFx0ZnVuY3Rpb24gY29tYmluZURhdGVUaW1lKCB0eXBlLCBkYXRlUGF0dGVybiwgdGltZVBhdHRlcm4gKSB7XFxuXFx0XFx0cmV0dXJuIGZvcm1hdE1lc3NhZ2UoXFxuXFx0XFx0XFx0Y2xkci5tYWluKFtcXG5cXHRcXHRcXHRcXHRcXFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXRlVGltZUZvcm1hdHNcXFwiLFxcblxcdFxcdFxcdFxcdHR5cGVcXG5cXHRcXHRcXHRdKSxcXG5cXHRcXHRcXHRbIHRpbWVQYXR0ZXJuLCBkYXRlUGF0dGVybiBdXFxuXFx0XFx0KTtcXG5cXHR9XFxuXFxuXFx0c3dpdGNoICggdHJ1ZSApIHtcXG5cXHRcXHRjYXNlIFxcXCJza2VsZXRvblxcXCIgaW4gb3B0aW9uczpcXG5cXHRcXHRcXHRza2VsZXRvbiA9IG9wdGlvbnMuc2tlbGV0b247XFxuXFxuXFx0XFx0XFx0Ly8gUHJlZmVycmVkIGhvdXIgKGopLlxcblxcdFxcdFxcdHNrZWxldG9uID0gc2tlbGV0b24ucmVwbGFjZSggL2ovZywgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsZHIuc3VwcGxlbWVudGFsLnRpbWVEYXRhLnByZWZlcnJlZCgpO1xcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHZhbGlkYXRlU2tlbGV0b24oIHNrZWxldG9uICk7XFxuXFxuXFx0XFx0XFx0Ly8gVHJ5IGRpcmVjdCBtYXAgKG5vdGUgdGhhdCBnZXRCZXN0TWF0Y2hQYXR0ZXJuIGhhbmRsZXMgaXQpLlxcblxcdFxcdFxcdC8vIC4uLiBvciwgdHJ5IHRvIFxcXCJiZXN0IG1hdGNoXFxcIiB0aGUgd2hvbGUgc2tlbGV0b24uXFxuXFx0XFx0XFx0cmVzdWx0ID0gZ2V0QmVzdE1hdGNoUGF0dGVybihcXG5cXHRcXHRcXHRcXHRjbGRyLFxcblxcdFxcdFxcdFxcdHNrZWxldG9uXFxuXFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRpZiAoIHJlc3VsdCApIHtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gLi4uIG9yLCB0cnkgdG8gXFxcImJlc3QgbWF0Y2hcXFwiIHRoZSBkYXRlIGFuZCB0aW1lIHBhcnRzIGluZGl2aWR1YWxseS5cXG5cXHRcXHRcXHR0aW1lU2tlbGV0b24gPSBza2VsZXRvbi5zcGxpdCggL1teaEhLa21zU0F6Wk92Vlh4XS8gKS5zbGljZSggLTEgKVsgMCBdO1xcblxcdFxcdFxcdGRhdGVTa2VsZXRvbiA9IHNrZWxldG9uLnNwbGl0KCAvW15HeVl1VXJRcU1MbHdXZERGZ0VlY10vIClbIDAgXTtcXG5cXHRcXHRcXHRkYXRlU2tlbGV0b24gPSBnZXRCZXN0TWF0Y2hQYXR0ZXJuKFxcblxcdFxcdFxcdFxcdGNsZHIsXFxuXFx0XFx0XFx0XFx0ZGF0ZVNrZWxldG9uXFxuXFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR0aW1lU2tlbGV0b24gPSBnZXRCZXN0TWF0Y2hQYXR0ZXJuKFxcblxcdFxcdFxcdFxcdGNsZHIsXFxuXFx0XFx0XFx0XFx0dGltZVNrZWxldG9uXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRpZiAoIC8oTU1NTXxMTExMKS4qW0VjXS8udGVzdCggZGF0ZVNrZWxldG9uICkgKSB7XFxuXFx0XFx0XFx0XFx0dHlwZSA9IFxcXCJmdWxsXFxcIjtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCAvTU1NTXxMTExMLy50ZXN0KCBkYXRlU2tlbGV0b24gKSApIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gXFxcImxvbmdcXFwiO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoIC9NTU18TExMLy50ZXN0KCBkYXRlU2tlbGV0b24gKSApIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gXFxcIm1lZGl1bVxcXCI7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gXFxcInNob3J0XFxcIjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBkYXRlU2tlbGV0b24gJiYgdGltZVNrZWxldG9uICkge1xcblxcdFxcdFxcdFxcdHJlc3VsdCA9IGNvbWJpbmVEYXRlVGltZSggdHlwZSwgZGF0ZVNrZWxldG9uLCB0aW1lU2tlbGV0b24gKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHJlc3VsdCA9IGRhdGVTa2VsZXRvbiB8fCB0aW1lU2tlbGV0b247XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdGNhc2UgXFxcImRhdGVcXFwiIGluIG9wdGlvbnM6XFxuXFx0XFx0Y2FzZSBcXFwidGltZVxcXCIgaW4gb3B0aW9uczpcXG5cXHRcXHRcXHRyZXN1bHQgPSBjbGRyLm1haW4oW1xcblxcdFxcdFxcdFxcdFxcXCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuXFxcIixcXG5cXHRcXHRcXHRcXHRcXFwiZGF0ZVxcXCIgaW4gb3B0aW9ucyA/IFxcXCJkYXRlRm9ybWF0c1xcXCIgOiBcXFwidGltZUZvcm1hdHNcXFwiLFxcblxcdFxcdFxcdFxcdCggb3B0aW9ucy5kYXRlIHx8IG9wdGlvbnMudGltZSApXFxuXFx0XFx0XFx0XSk7XFxuXFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0Y2FzZSBcXFwiZGF0ZXRpbWVcXFwiIGluIG9wdGlvbnM6XFxuXFx0XFx0XFx0cmVzdWx0ID0gY29tYmluZURhdGVUaW1lKCBvcHRpb25zLmRhdGV0aW1lLFxcblxcdFxcdFxcdFxcdGNsZHIubWFpbihbIFxcXCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RhdGVGb3JtYXRzXFxcIiwgb3B0aW9ucy5kYXRldGltZSBdKSxcXG5cXHRcXHRcXHRcXHRjbGRyLm1haW4oWyBcXFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi90aW1lRm9ybWF0c1xcXCIsIG9wdGlvbnMuZGF0ZXRpbWUgXSlcXG5cXHRcXHRcXHQpO1xcblxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdGNhc2UgXFxcInJhd1xcXCIgaW4gb3B0aW9uczpcXG5cXHRcXHRcXHRyZXN1bHQgPSBvcHRpb25zLnJhdztcXG5cXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdHRocm93IGNyZWF0ZUVycm9ySW52YWxpZFBhcmFtZXRlclZhbHVlKHtcXG5cXHRcXHRcXHRcXHRuYW1lOiBcXFwib3B0aW9uc1xcXCIsXFxuXFx0XFx0XFx0XFx0dmFsdWU6IG9wdGlvbnNcXG5cXHRcXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHJlc3VsdDtcXG59O1xcblxcblxcblxcblxcbnZhciBkYXRlV2Vla0RheXMgPSBbIFxcXCJzdW5cXFwiLCBcXFwibW9uXFxcIiwgXFxcInR1ZVxcXCIsIFxcXCJ3ZWRcXFwiLCBcXFwidGh1XFxcIiwgXFxcImZyaVxcXCIsIFxcXCJzYXRcXFwiIF07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogZmlyc3REYXlPZldlZWtcXG4gKi9cXG52YXIgZGF0ZUZpcnN0RGF5T2ZXZWVrID0gZnVuY3Rpb24oIGNsZHIgKSB7XFxuXFx0cmV0dXJuIGRhdGVXZWVrRGF5cy5pbmRleE9mKCBjbGRyLnN1cHBsZW1lbnRhbC53ZWVrRGF0YS5maXJzdERheSgpICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBnZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgdHlwZSApXFxuICovXFxudmFyIGRhdGVHZXRUaW1lWm9uZU5hbWUgPSBmdW5jdGlvbiggbGVuZ3RoLCB0eXBlLCB0aW1lWm9uZSwgY2xkciApIHtcXG5cXHR2YXIgbWV0YVpvbmUsIHJlc3VsdDtcXG5cXG5cXHRpZiAoICF0aW1lWm9uZSApIHtcXG5cXHRcXHRyZXR1cm47XFxuXFx0fVxcblxcblxcdHJlc3VsdCA9IGNsZHIubWFpbihbXFxuXFx0XFx0XFxcImRhdGVzL3RpbWVab25lTmFtZXMvem9uZVxcXCIsXFxuXFx0XFx0dGltZVpvbmUsXFxuXFx0XFx0bGVuZ3RoIDwgNCA/IFxcXCJzaG9ydFxcXCIgOiBcXFwibG9uZ1xcXCIsXFxuXFx0XFx0dHlwZVxcblxcdF0pO1xcblxcblxcdGlmICggcmVzdWx0ICkge1xcblxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0fVxcblxcblxcdC8vIFRoZSBsYXRlc3QgbWV0YXpvbmUgZGF0YSBvZiB0aGUgbWV0YXpvbmUgYXJyYXkuXFxuXFx0Ly8gVE9ETyBleHBhbmQgdG8gc3VwcG9ydCB0aGUgaGlzdG9yaWMgbWV0YXpvbmVzIGJhc2VkIG9uIHRoZSBnaXZlbiBkYXRlLlxcblxcdG1ldGFab25lID0gY2xkci5zdXBwbGVtZW50YWwoW1xcblxcdFxcdFxcXCJtZXRhWm9uZXMvbWV0YXpvbmVJbmZvL3RpbWV6b25lXFxcIiwgdGltZVpvbmUsIDAsXFxuXFx0XFx0XFxcInVzZXNNZXRhem9uZS9fbXpvbmVcXFwiXFxuXFx0XSk7XFxuXFxuXFx0cmV0dXJuIGNsZHIubWFpbihbXFxuXFx0XFx0XFxcImRhdGVzL3RpbWVab25lTmFtZXMvbWV0YXpvbmVcXFwiLFxcblxcdFxcdG1ldGFab25lLFxcblxcdFxcdGxlbmd0aCA8IDQgPyBcXFwic2hvcnRcXFwiIDogXFxcImxvbmdcXFwiLFxcblxcdFxcdHR5cGVcXG5cXHRdKTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIHRpbWV6b25lSG91ckZvcm1hdFNob3J0SCggaG91ckZvcm1hdCApXFxuICpcXG4gKiBAaG91ckZvcm1hdCBbU3RyaW5nXVxcbiAqXFxuICogVW5vZmZpY2lhbCBkZWR1Y3Rpb24gb2YgdGhlIHNob3J0IGhvdXJGb3JtYXQgZ2l2ZW4gdGltZSB6b25lIGBob3VyRm9ybWF0YCBlbGVtZW50LlxcbiAqIE9mZmljaWFsIHNwZWMgaXMgcGVuZGluZyByZXNvbHV0aW9uOiBodHRwOi8vdW5pY29kZS5vcmcvY2xkci90cmFjL3RpY2tldC84MjkzXFxuICpcXG4gKiBFeGFtcGxlOlxcbiAqIC0gXFxcIitISC5tbTstSEgubW1cXFwiID0+IFxcXCIrSDstSFxcXCJcXG4gKiAtIFxcXCIrSEg6bW07LUhIOm1tXFxcIiA9PiBcXFwiK0g7LUhcXFwiXFxuICogLSBcXFwiK0hIOm1tO+KIkkhIOm1tXFxcIiA9PiBcXFwiK0g74oiSSFxcXCIgKE5vdGUgTUlOVVMgU0lHTiBcXFxcdTIyMTIpXFxuICogLSBcXFwiK0hIbW07LUhIbW1cXFwiID0+IFxcXCIrSDotSFxcXCJcXG4gKi9cXG52YXIgZGF0ZVRpbWV6b25lSG91ckZvcm1hdEggPSBmdW5jdGlvbiggaG91ckZvcm1hdCApIHtcXG5cXHRyZXR1cm4gaG91ckZvcm1hdFxcblxcdFxcdC5zcGxpdCggXFxcIjtcXFwiIClcXG5cXHRcXHQubWFwKGZ1bmN0aW9uKCBmb3JtYXQgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZvcm1hdC5zbGljZSggMCwgZm9ybWF0LmluZGV4T2YoIFxcXCJIXFxcIiApICsgMSApO1xcblxcdFxcdH0pXFxuXFx0XFx0LmpvaW4oIFxcXCI7XFxcIiApO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogdGltZXpvbmVIb3VyRm9ybWF0TG9uZ0htKCBob3VyRm9ybWF0IClcXG4gKlxcbiAqIEBob3VyRm9ybWF0IFtTdHJpbmddXFxuICpcXG4gKiBVbm9mZmljaWFsIGRlZHVjdGlvbiBvZiB0aGUgc2hvcnQgaG91ckZvcm1hdCBnaXZlbiB0aW1lIHpvbmUgYGhvdXJGb3JtYXRgIGVsZW1lbnQuXFxuICogT2ZmaWNpYWwgc3BlYyBpcyBwZW5kaW5nIHJlc29sdXRpb246IGh0dHA6Ly91bmljb2RlLm9yZy9jbGRyL3RyYWMvdGlja2V0LzgyOTNcXG4gKlxcbiAqIEV4YW1wbGUgKGhGb3JtYXQgPT09IFxcXCJIXFxcIik6ICh1c2VkIGZvciBzaG9ydCBIbSlcXG4gKiAtIFxcXCIrSEgubW07LUhILm1tXFxcIiA9PiBcXFwiK0gubW07LUgubW1cXFwiXFxuICogLSBcXFwiK0hIOm1tOy1ISDptbVxcXCIgPT4gXFxcIitIOm1tOy1IOm1tXFxcIlxcbiAqIC0gXFxcIitISDptbTviiJJISDptbVxcXCIgPT4gXFxcIitIOm1tO+KIkkg6bW1cXFwiIChOb3RlIE1JTlVTIFNJR04gXFxcXHUyMjEyKVxcbiAqIC0gXFxcIitISG1tOy1ISG1tXFxcIiA9PiBcXFwiK0htbTotSG1tXFxcIlxcbiAqXFxuICogRXhhbXBsZSAoaEZvcm1hdCA9PT0gXFxcIkhIXFxcIjogKHVzZWQgZm9yIGxvbmcgSG0pXFxuICogLSBcXFwiK0hILm1tOy1ISC5tbVxcXCIgPT4gXFxcIitISC5tbTstSEgubW1cXFwiXFxuICogLSBcXFwiK0hIOm1tOy1ISDptbVxcXCIgPT4gXFxcIitISDptbTstSEg6bW1cXFwiXFxuICogLSBcXFwiK0g6bW07LUg6bW1cXFwiICAgPT4gXFxcIitISDptbTstSEg6bW1cXFwiXFxuICogLSBcXFwiK0hIOm1tO+KIkkhIOm1tXFxcIiA9PiBcXFwiK0hIOm1tO+KIkkhIOm1tXFxcIiAoTm90ZSBNSU5VUyBTSUdOIFxcXFx1MjIxMilcXG4gKiAtIFxcXCIrSEhtbTstSEhtbVxcXCIgPT4gXFxcIitISG1tOi1ISG1tXFxcIlxcbiAqL1xcbnZhciBkYXRlVGltZXpvbmVIb3VyRm9ybWF0SG0gPSBmdW5jdGlvbiggaG91ckZvcm1hdCwgaEZvcm1hdCApIHtcXG5cXHRyZXR1cm4gaG91ckZvcm1hdFxcblxcdFxcdC5zcGxpdCggXFxcIjtcXFwiIClcXG5cXHRcXHQubWFwKGZ1bmN0aW9uKCBmb3JtYXQgKSB7XFxuXFx0XFx0XFx0dmFyIHBhcnRzID0gZm9ybWF0LnNwbGl0KCAvSCsvICk7XFxuXFx0XFx0XFx0cGFydHMuc3BsaWNlKCAxLCAwLCBoRm9ybWF0ICk7XFxuXFx0XFx0XFx0cmV0dXJuIHBhcnRzLmpvaW4oIFxcXCJcXFwiICk7XFxuXFx0XFx0fSlcXG5cXHRcXHQuam9pbiggXFxcIjtcXFwiICk7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgcnVudGltZUNhY2hlRGF0YUJpbmQgPSBmdW5jdGlvbigga2V5LCBkYXRhICkge1xcblxcdHZhciBmbiA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiBkYXRhO1xcblxcdH07XFxuXFx0Zm4uZGF0YUNhY2hlS2V5ID0ga2V5O1xcblxcdHJldHVybiBmbjtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIHByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIgKVxcbiAqXFxuICogQHBhdHRlcm4gW1N0cmluZ10gcmF3IHBhdHRlcm4uXFxuICogcmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjRGF0ZV9Gb3JtYXRfUGF0dGVybnNcXG4gKlxcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cXG4gKlxcbiAqIFJldHVybiB0aGUgcHJvcGVydGllcyBnaXZlbiB0aGUgcGF0dGVybiBhbmQgY2xkci5cXG4gKlxcbiAqIFRPRE8gU3VwcG9ydCBvdGhlciBjYWxlbmRhciB0eXBlcy5cXG4gKi9cXG52YXIgZGF0ZUZvcm1hdFByb3BlcnRpZXMgPSBmdW5jdGlvbiggcGF0dGVybiwgY2xkciwgdGltZVpvbmUgKSB7XFxuXFx0dmFyIHByb3BlcnRpZXMgPSB7XFxuXFx0XFx0XFx0bnVtYmVyRm9ybWF0dGVyczoge30sXFxuXFx0XFx0XFx0cGF0dGVybjogcGF0dGVybixcXG5cXHRcXHRcXHR0aW1lU2VwYXJhdG9yOiBudW1iZXJTeW1ib2woIFxcXCJ0aW1lU2VwYXJhdG9yXFxcIiwgY2xkciApXFxuXFx0XFx0fSxcXG5cXHRcXHR3aWR0aHMgPSBbIFxcXCJhYmJyZXZpYXRlZFxcXCIsIFxcXCJ3aWRlXFxcIiwgXFxcIm5hcnJvd1xcXCIgXTtcXG5cXG5cXHRmdW5jdGlvbiBzZXROdW1iZXJGb3JtYXR0ZXJQYXR0ZXJuKCBwYWQgKSB7XFxuXFx0XFx0cHJvcGVydGllcy5udW1iZXJGb3JtYXR0ZXJzWyBwYWQgXSA9IHN0cmluZ1BhZCggXFxcIlxcXCIsIHBhZCApO1xcblxcdH1cXG5cXG5cXHRpZiAoIHRpbWVab25lICkge1xcblxcdFxcdHByb3BlcnRpZXMudGltZVpvbmVEYXRhID0gcnVudGltZUNhY2hlRGF0YUJpbmQoIFxcXCJpYW5hL1xcXCIgKyB0aW1lWm9uZSwge1xcblxcdFxcdFxcdG9mZnNldHM6IGNsZHIuZ2V0KFsgXFxcImdsb2JhbGl6ZS1pYW5hL3pvbmVEYXRhXFxcIiwgdGltZVpvbmUsIFxcXCJvZmZzZXRzXFxcIiBdKSxcXG5cXHRcXHRcXHR1bnRpbHM6IGNsZHIuZ2V0KFsgXFxcImdsb2JhbGl6ZS1pYW5hL3pvbmVEYXRhXFxcIiwgdGltZVpvbmUsIFxcXCJ1bnRpbHNcXFwiIF0pLFxcblxcdFxcdFxcdGlzZHN0czogY2xkci5nZXQoWyBcXFwiZ2xvYmFsaXplLWlhbmEvem9uZURhdGFcXFwiLCB0aW1lWm9uZSwgXFxcImlzZHN0c1xcXCIgXSlcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0cGF0dGVybi5yZXBsYWNlKCBkYXRlUGF0dGVyblJlLCBmdW5jdGlvbiggY3VycmVudCApIHtcXG5cXHRcXHR2YXIgYXV4LCBjaHIsIGRheWxpZ2h0VHpOYW1lLCBmb3JtYXROdW1iZXIsIGdlbmVyaWNUek5hbWUsIGxlbmd0aCwgc3RhbmRhcmRUek5hbWU7XFxuXFxuXFx0XFx0Y2hyID0gY3VycmVudC5jaGFyQXQoIDAgKTtcXG5cXHRcXHRsZW5ndGggPSBjdXJyZW50Lmxlbmd0aDtcXG5cXG5cXHRcXHRpZiAoIGNociA9PT0gXFxcImpcXFwiICkge1xcblxcblxcdFxcdFxcdC8vIExvY2FsZSBwcmVmZXJyZWQgaEhLay5cXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjVGltZV9EYXRhXFxuXFx0XFx0XFx0cHJvcGVydGllcy5wcmVmZXJyZWRUaW1lID0gY2hyID0gY2xkci5zdXBwbGVtZW50YWwudGltZURhdGEucHJlZmVycmVkKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFpaWlo6IHNhbWUgYXMgXFxcIk9PT09cXFwiLlxcblxcdFxcdGlmICggY2hyID09PSBcXFwiWlxcXCIgJiYgbGVuZ3RoID09PSA0ICkge1xcblxcdFxcdFxcdGNociA9IFxcXCJPXFxcIjtcXG5cXHRcXHRcXHRsZW5ndGggPSA0O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyB6Li4uenp6OiBcXFwie3Nob3J0UmVnaW9ufVxcXCIsIGVnLiBcXFwiUFNUXFxcIiBvciBcXFwiUERUXFxcIi5cXG5cXHRcXHQvLyB6enp6OiBcXFwie3JlZ2lvbk5hbWV9IHtTdGFuZGFyZCBUaW1lfVxcXCIgb3IgXFxcIntyZWdpb25OYW1lfSB7RGF5bGlnaHQgVGltZX1cXFwiLFxcblxcdFxcdC8vICAgICAgIGUuZy4sIFxcXCJQYWNpZmljIFN0YW5kYXJkIFRpbWVcXFwiIG9yIFxcXCJQYWNpZmljIERheWxpZ2h0IFRpbWVcXFwiLlxcblxcdFxcdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXFxuXFx0XFx0aWYgKCBjaHIgPT09IFxcXCJ6XFxcIiApIHtcXG5cXHRcXHRcXHRzdGFuZGFyZFR6TmFtZSA9IGRhdGVHZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgXFxcInN0YW5kYXJkXFxcIiwgdGltZVpvbmUsIGNsZHIgKTtcXG5cXHRcXHRcXHRkYXlsaWdodFR6TmFtZSA9IGRhdGVHZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgXFxcImRheWxpZ2h0XFxcIiwgdGltZVpvbmUsIGNsZHIgKTtcXG5cXHRcXHRcXHRpZiAoIHN0YW5kYXJkVHpOYW1lICkge1xcblxcdFxcdFxcdFxcdHByb3BlcnRpZXMuc3RhbmRhcmRUek5hbWUgPSBzdGFuZGFyZFR6TmFtZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCBkYXlsaWdodFR6TmFtZSApIHtcXG5cXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLmRheWxpZ2h0VHpOYW1lID0gZGF5bGlnaHRUek5hbWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZhbGwgdGhyb3VnaCB0aGUgXFxcIk9cXFwiIGZvcm1hdCBpbiBjYXNlIG9uZSBuYW1lIGlzIG1pc3NpbmcuXFxuXFx0XFx0XFx0aWYgKCAhc3RhbmRhcmRUek5hbWUgfHwgIWRheWxpZ2h0VHpOYW1lICkge1xcblxcdFxcdFxcdFxcdGNociA9IFxcXCJPXFxcIjtcXG5cXHRcXHRcXHRcXHRpZiAoIGxlbmd0aCA8IDQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGVuZ3RoID0gMTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyB2Li4udnZ2OiBcXFwie3Nob3J0UmVnaW9ufVxcXCIsIGVnLiBcXFwiUFRcXFwiLlxcblxcdFxcdC8vIHZ2dnY6IFxcXCJ7cmVnaW9uTmFtZX0ge1RpbWV9XFxcIiBvciBcXFwie3JlZ2lvbk5hbWV9IHtUaW1lfVxcXCIsXFxuXFx0XFx0Ly8gZS5nLiwgXFxcIlBhY2lmaWMgVGltZVxcXCJcXG5cXHRcXHQvLyBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xcblxcdFxcdGlmICggY2hyID09PSBcXFwidlxcXCIgKSB7XFxuXFx0XFx0XFx0Z2VuZXJpY1R6TmFtZSA9IGRhdGVHZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgXFxcImdlbmVyaWNcXFwiLCB0aW1lWm9uZSwgY2xkciApO1xcblxcblxcdFxcdFxcdC8vIEZhbGwgYmFjayB0byBcXFwiVlxcXCIgZm9ybWF0LlxcblxcdFxcdFxcdGlmICggIWdlbmVyaWNUek5hbWUgKSB7XFxuXFx0XFx0XFx0XFx0Y2hyID0gXFxcIlZcXFwiO1xcblxcdFxcdFxcdFxcdGxlbmd0aCA9IDQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRzd2l0Y2ggKCBjaHIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRXJhXFxuXFx0XFx0XFx0Y2FzZSBcXFwiR1xcXCI6XFxuXFx0XFx0XFx0XFx0cHJvcGVydGllcy5lcmFzID0gY2xkci5tYWluKFtcXG5cXHRcXHRcXHRcXHRcXHRcXFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9lcmFzXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRsZW5ndGggPD0gMyA/IFxcXCJlcmFBYmJyXFxcIiA6ICggbGVuZ3RoID09PSA0ID8gXFxcImVyYU5hbWVzXFxcIiA6IFxcXCJlcmFOYXJyb3dcXFwiIClcXG5cXHRcXHRcXHRcXHRdKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBZZWFyXFxuXFx0XFx0XFx0Y2FzZSBcXFwieVxcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUGxhaW4geWVhci5cXG5cXHRcXHRcXHRcXHRmb3JtYXROdW1iZXIgPSB0cnVlO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcIllcXFwiOlxcblxcblxcdFxcdFxcdFxcdC8vIFllYXIgaW4gXFxcIldlZWsgb2YgWWVhclxcXCJcXG5cXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLmZpcnN0RGF5ID0gZGF0ZUZpcnN0RGF5T2ZXZWVrKCBjbGRyICk7XFxuXFx0XFx0XFx0XFx0cHJvcGVydGllcy5taW5EYXlzID0gY2xkci5zdXBwbGVtZW50YWwud2Vla0RhdGEubWluRGF5cygpO1xcblxcdFxcdFxcdFxcdGZvcm1hdE51bWJlciA9IHRydWU7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwidVxcXCI6IC8vIEV4dGVuZGVkIHllYXIuIE5lZWQgdG8gYmUgaW1wbGVtZW50ZWQuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiVVxcXCI6IC8vIEN5Y2xpYyB5ZWFyIG5hbWUuIE5lZWQgdG8gYmUgaW1wbGVtZW50ZWQuXFxuXFx0XFx0XFx0XFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xcblxcdFxcdFxcdFxcdFxcdGZlYXR1cmU6IFxcXCJ5ZWFyIHBhdHRlcm4gYFxcXCIgKyBjaHIgKyBcXFwiYFxcXCJcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBRdWFydGVyXFxuXFx0XFx0XFx0Y2FzZSBcXFwiUVxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwicVxcXCI6XFxuXFx0XFx0XFx0XFx0aWYgKCBsZW5ndGggPiAyICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggIXByb3BlcnRpZXMucXVhcnRlcnMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHJvcGVydGllcy5xdWFydGVycyA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICFwcm9wZXJ0aWVzLnF1YXJ0ZXJzWyBjaHIgXSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLnF1YXJ0ZXJzWyBjaHIgXSA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLnF1YXJ0ZXJzWyBjaHIgXVsgbGVuZ3RoIF0gPSBjbGRyLm1haW4oW1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL3F1YXJ0ZXJzXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaHIgPT09IFxcXCJRXFxcIiA/IFxcXCJmb3JtYXRcXFwiIDogXFxcInN0YW5kLWFsb25lXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aWR0aHNbIGxlbmd0aCAtIDMgXVxcblxcdFxcdFxcdFxcdFxcdF0pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9ybWF0TnVtYmVyID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gTW9udGhcXG5cXHRcXHRcXHRjYXNlIFxcXCJNXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJMXFxcIjpcXG5cXHRcXHRcXHRcXHRpZiAoIGxlbmd0aCA+IDIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhcHJvcGVydGllcy5tb250aHMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHJvcGVydGllcy5tb250aHMgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhcHJvcGVydGllcy5tb250aHNbIGNociBdICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHByb3BlcnRpZXMubW9udGhzWyBjaHIgXSA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLm1vbnRoc1sgY2hyIF1bIGxlbmd0aCBdID0gY2xkci5tYWluKFtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9tb250aHNcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdGNociA9PT0gXFxcIk1cXFwiID8gXFxcImZvcm1hdFxcXCIgOiBcXFwic3RhbmQtYWxvbmVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdHdpZHRoc1sgbGVuZ3RoIC0gMyBdXFxuXFx0XFx0XFx0XFx0XFx0XSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3JtYXROdW1iZXIgPSB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBXZWVrIC0gV2VlayBvZiBZZWFyICh3KSBvciBXZWVrIG9mIE1vbnRoIChXKS5cXG5cXHRcXHRcXHRjYXNlIFxcXCJ3XFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJXXFxcIjpcXG5cXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLmZpcnN0RGF5ID0gZGF0ZUZpcnN0RGF5T2ZXZWVrKCBjbGRyICk7XFxuXFx0XFx0XFx0XFx0cHJvcGVydGllcy5taW5EYXlzID0gY2xkci5zdXBwbGVtZW50YWwud2Vla0RhdGEubWluRGF5cygpO1xcblxcdFxcdFxcdFxcdGZvcm1hdE51bWJlciA9IHRydWU7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gRGF5XFxuXFx0XFx0XFx0Y2FzZSBcXFwiZFxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiRFxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiRlxcXCI6XFxuXFx0XFx0XFx0XFx0Zm9ybWF0TnVtYmVyID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRjYXNlIFxcXCJnXFxcIjpcXG5cXG5cXHRcXHRcXHRcXHQvLyBNb2RpZmllZCBKdWxpYW4gZGF5LiBOZWVkIHRvIGJlIGltcGxlbWVudGVkLlxcblxcdFxcdFxcdFxcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcXG5cXHRcXHRcXHRcXHRcXHRmZWF0dXJlOiBcXFwiSnVsaWFuIGRheSBwYXR0ZXJuIGBnYFxcXCJcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBXZWVrIGRheVxcblxcdFxcdFxcdGNhc2UgXFxcImVcXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcImNcXFwiOlxcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoIDw9IDIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJvcGVydGllcy5maXJzdERheSA9IGRhdGVGaXJzdERheU9mV2VlayggY2xkciApO1xcblxcdFxcdFxcdFxcdFxcdGZvcm1hdE51bWJlciA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRjYXNlIFxcXCJFXFxcIjpcXG5cXHRcXHRcXHRcXHRpZiAoICFwcm9wZXJ0aWVzLmRheXMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJvcGVydGllcy5kYXlzID0ge307XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICggIXByb3BlcnRpZXMuZGF5c1sgY2hyIF0gKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJvcGVydGllcy5kYXlzWyBjaHIgXSA9IHt9O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIGxlbmd0aCA9PT0gNiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiBzaG9ydCBkYXkgbmFtZXMgYXJlIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCwgYWJicmV2aWF0ZWQgZGF5IG5hbWVzIGFyZVxcblxcdFxcdFxcdFxcdFxcdC8vIHVzZWQgaW5zdGVhZC5cXG5cXHRcXHRcXHRcXHRcXHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjbW9udGhzX2RheXNfcXVhcnRlcnNfZXJhc1xcblxcdFxcdFxcdFxcdFxcdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9jbGRyL3RyYWMvdGlja2V0LzY3OTBcXG5cXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLmRheXNbIGNociBdWyBsZW5ndGggXSA9IGNsZHIubWFpbihbXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5c1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2hyID09PSBcXFwiY1xcXCIgPyBcXFwic3RhbmQtYWxvbmVcXFwiIDogXFxcImZvcm1hdFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcInNob3J0XFxcIlxcblxcdFxcdFxcdFxcdFxcdFxcdF0pIHx8IGNsZHIubWFpbihbXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5c1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2hyID09PSBcXFwiY1xcXCIgPyBcXFwic3RhbmQtYWxvbmVcXFwiIDogXFxcImZvcm1hdFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImFiYnJldmlhdGVkXFxcIlxcblxcdFxcdFxcdFxcdFxcdFxcdF0pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJvcGVydGllcy5kYXlzWyBjaHIgXVsgbGVuZ3RoIF0gPSBjbGRyLm1haW4oW1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RheXNcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdGNociA9PT0gXFxcImNcXFwiID8gXFxcInN0YW5kLWFsb25lXFxcIiA6IFxcXCJmb3JtYXRcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdHdpZHRoc1sgbGVuZ3RoIDwgMyA/IDAgOiBsZW5ndGggLSAzIF1cXG5cXHRcXHRcXHRcXHRcXHRdKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gUGVyaW9kIChBTSBvciBQTSlcXG5cXHRcXHRcXHRjYXNlIFxcXCJhXFxcIjpcXG5cXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLmRheVBlcmlvZHMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0YW06IGNsZHIubWFpbihcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlQZXJpb2RzL2Zvcm1hdC93aWRlL2FtXFxcIlxcblxcdFxcdFxcdFxcdFxcdCksXFxuXFx0XFx0XFx0XFx0XFx0cG06IGNsZHIubWFpbihcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlQZXJpb2RzL2Zvcm1hdC93aWRlL3BtXFxcIlxcblxcdFxcdFxcdFxcdFxcdClcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIEhvdXJcXG5cXHRcXHRcXHRjYXNlIFxcXCJoXFxcIjogLy8gMS0xMlxcblxcdFxcdFxcdGNhc2UgXFxcIkhcXFwiOiAvLyAwLTIzXFxuXFx0XFx0XFx0Y2FzZSBcXFwiS1xcXCI6IC8vIDAtMTFcXG5cXHRcXHRcXHRjYXNlIFxcXCJrXFxcIjogLy8gMS0yNFxcblxcblxcdFxcdFxcdC8vIE1pbnV0ZVxcblxcdFxcdFxcdGNhc2UgXFxcIm1cXFwiOlxcblxcblxcdFxcdFxcdC8vIFNlY29uZFxcblxcdFxcdFxcdGNhc2UgXFxcInNcXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcIlNcXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcIkFcXFwiOlxcblxcdFxcdFxcdFxcdGZvcm1hdE51bWJlciA9IHRydWU7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gWm9uZVxcblxcdFxcdFxcdGNhc2UgXFxcInZcXFwiOlxcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoICE9PSAxICYmIGxlbmd0aCAhPT0gNCApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmVhdHVyZTogXFxcInRpbWV6b25lIHBhdHRlcm4gYFxcXCIgKyBwYXR0ZXJuICsgXFxcImBcXFwiXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHByb3BlcnRpZXMuZ2VuZXJpY1R6TmFtZSA9IGdlbmVyaWNUek5hbWU7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiVlxcXCI6XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBsZW5ndGggPT09IDEgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xcblxcdFxcdFxcdFxcdFxcdFxcdGZlYXR1cmU6IFxcXCJ0aW1lem9uZSBwYXR0ZXJuIGBcXFwiICsgcGF0dGVybiArIFxcXCJgXFxcIlxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRpbWVab25lICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggbGVuZ3RoID09PSAyICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHByb3BlcnRpZXMudGltZVpvbmVOYW1lID0gdGltZVpvbmU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0aW1lWm9uZU5hbWUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXhlbXBsYXJDaXR5ID0gY2xkci5tYWluKFtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwiZGF0ZXMvdGltZVpvbmVOYW1lcy96b25lXFxcIiwgdGltZVpvbmUsIFxcXCJleGVtcGxhckNpdHlcXFwiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsZW5ndGggPT09IDMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhZXhlbXBsYXJDaXR5ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGV4ZW1wbGFyQ2l0eSA9IGNsZHIubWFpbihbXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImRhdGVzL3RpbWVab25lTmFtZXMvem9uZS9FdGMvVW5rbm93bi9leGVtcGxhckNpdHlcXFwiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWVab25lTmFtZSA9IGV4ZW1wbGFyQ2l0eTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBleGVtcGxhckNpdHkgJiYgbGVuZ3RoID09PSA0ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWVab25lTmFtZSA9IGZvcm1hdE1lc3NhZ2UoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2xkci5tYWluKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcXCJkYXRlcy90aW1lWm9uZU5hbWVzL3JlZ2lvbkZvcm1hdFxcXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFsgZXhlbXBsYXJDaXR5IF1cXG5cXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRpbWVab25lTmFtZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggY3VycmVudCA9PT0gXFxcInZcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdGxlbmd0aCA9IDE7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRjYXNlIFxcXCJPXFxcIjpcXG5cXG5cXHRcXHRcXHRcXHQvLyBPOiBcXFwie2dtdEZvcm1hdH0rSDt7Z210Rm9ybWF0fS1IXFxcIiBvciBcXFwie2dtdFplcm9Gb3JtYXR9XFxcIiwgZWcuIFxcXCJHTVQtOFxcXCIgb3IgXFxcIkdNVFxcXCIuXFxuXFx0XFx0XFx0XFx0Ly8gT09PTzogXFxcIntnbXRGb3JtYXR9e2hvdXJGb3JtYXR9XFxcIiBvciBcXFwie2dtdFplcm9Gb3JtYXR9XFxcIiwgZWcuIFxcXCJHTVQtMDg6MDBcXFwiIG9yIFxcXCJHTVRcXFwiLlxcblxcdFxcdFxcdFxcdHByb3BlcnRpZXMuZ210Rm9ybWF0ID0gY2xkci5tYWluKCBcXFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9nbXRGb3JtYXRcXFwiICk7XFxuXFx0XFx0XFx0XFx0cHJvcGVydGllcy5nbXRaZXJvRm9ybWF0ID0gY2xkci5tYWluKCBcXFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9nbXRaZXJvRm9ybWF0XFxcIiApO1xcblxcblxcdFxcdFxcdFxcdC8vIFVub2ZmaWNpYWwgZGVkdWN0aW9uIG9mIHRoZSBob3VyRm9ybWF0IHZhcmlhdGlvbnMuXFxuXFx0XFx0XFx0XFx0Ly8gT2ZmaWNpYWwgc3BlYyBpcyBwZW5kaW5nIHJlc29sdXRpb246IGh0dHA6Ly91bmljb2RlLm9yZy9jbGRyL3RyYWMvdGlja2V0LzgyOTNcXG5cXHRcXHRcXHRcXHRhdXggPSBjbGRyLm1haW4oIFxcXCJkYXRlcy90aW1lWm9uZU5hbWVzL2hvdXJGb3JtYXRcXFwiICk7XFxuXFx0XFx0XFx0XFx0cHJvcGVydGllcy5ob3VyRm9ybWF0ID0gbGVuZ3RoIDwgNCA/XFxuXFx0XFx0XFx0XFx0XFx0WyBkYXRlVGltZXpvbmVIb3VyRm9ybWF0SCggYXV4ICksIGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIbSggYXV4LCBcXFwiSFxcXCIgKSBdIDpcXG5cXHRcXHRcXHRcXHRcXHRkYXRlVGltZXpvbmVIb3VyRm9ybWF0SG0oIGF1eCwgXFxcIkhIXFxcIiApO1xcblxcblxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRjYXNlIFxcXCJaXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJYXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJ4XFxcIjpcXG5cXHRcXHRcXHRcXHRzZXROdW1iZXJGb3JtYXR0ZXJQYXR0ZXJuKCAxICk7XFxuXFx0XFx0XFx0XFx0c2V0TnVtYmVyRm9ybWF0dGVyUGF0dGVybiggMiApO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGZvcm1hdE51bWJlciApIHtcXG5cXHRcXHRcXHRzZXROdW1iZXJGb3JtYXR0ZXJQYXR0ZXJuKCBsZW5ndGggKTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0cmV0dXJuIHByb3BlcnRpZXM7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgZGF0ZUZvcm1hdHRlckZuID0gZnVuY3Rpb24oIGRhdGVUb1BhcnRzRm9ybWF0dGVyICkge1xcblxcdHJldHVybiBmdW5jdGlvbiBkYXRlRm9ybWF0dGVyKCB2YWx1ZSApIHtcXG5cXHRcXHRyZXR1cm4gcGFydHNKb2luKCBkYXRlVG9QYXJ0c0Zvcm1hdHRlciggdmFsdWUgKSk7XFxuXFx0fTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIHBhcnNlUHJvcGVydGllcyggY2xkciApXFxuICpcXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXFxuICpcXG4gKiBAdGltZVpvbmUgW1N0cmluZ10gRklYTUUuXFxuICpcXG4gKiBSZXR1cm4gcGFyc2VyIHByb3BlcnRpZXMuXFxuICovXFxudmFyIGRhdGVQYXJzZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggY2xkciwgdGltZVpvbmUgKSB7XFxuXFx0dmFyIHByb3BlcnRpZXMgPSB7XFxuXFx0XFx0cHJlZmVycmVkVGltZURhdGE6IGNsZHIuc3VwcGxlbWVudGFsLnRpbWVEYXRhLnByZWZlcnJlZCgpXFxuXFx0fTtcXG5cXG5cXHRpZiAoIHRpbWVab25lICkge1xcblxcdFxcdHByb3BlcnRpZXMudGltZVpvbmVEYXRhID0gcnVudGltZUNhY2hlRGF0YUJpbmQoIFxcXCJpYW5hL1xcXCIgKyB0aW1lWm9uZSwge1xcblxcdFxcdFxcdG9mZnNldHM6IGNsZHIuZ2V0KFsgXFxcImdsb2JhbGl6ZS1pYW5hL3pvbmVEYXRhXFxcIiwgdGltZVpvbmUsIFxcXCJvZmZzZXRzXFxcIiBdKSxcXG5cXHRcXHRcXHR1bnRpbHM6IGNsZHIuZ2V0KFsgXFxcImdsb2JhbGl6ZS1pYW5hL3pvbmVEYXRhXFxcIiwgdGltZVpvbmUsIFxcXCJ1bnRpbHNcXFwiIF0pLFxcblxcdFxcdFxcdGlzZHN0czogY2xkci5nZXQoWyBcXFwiZ2xvYmFsaXplLWlhbmEvem9uZURhdGFcXFwiLCB0aW1lWm9uZSwgXFxcImlzZHN0c1xcXCIgXSlcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHByb3BlcnRpZXM7XFxufTtcXG5cXG5cXG52YXIgWm9uZWREYXRlVGltZSA9IChmdW5jdGlvbigpIHtcXG5mdW5jdGlvbiBkZWZpbmVQcml2YXRlUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7XFxuICAgIHZhbHVlOiB2YWx1ZVxcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIGdldFVudGlsc0luZGV4KG9yaWdpbmFsLCB1bnRpbHMpIHtcXG4gIHZhciBpbmRleCA9IDA7XFxuICB2YXIgb3JpZ2luYWxUaW1lID0gb3JpZ2luYWwuZ2V0VGltZSgpO1xcblxcbiAgLy8gVE9ETyBTaG91bGQgd2UgZG8gYmluYXJ5IHNlYXJjaCBmb3IgaW1wcm92ZWQgcGVyZm9ybWFuY2U/XFxuICB3aGlsZSAoaW5kZXggPCB1bnRpbHMubGVuZ3RoIC0gMSAmJiBvcmlnaW5hbFRpbWUgPj0gdW50aWxzW2luZGV4XSkge1xcbiAgICBpbmRleCsrO1xcbiAgfVxcbiAgcmV0dXJuIGluZGV4O1xcbn1cXG5cXG5mdW5jdGlvbiBzZXRXcmFwKGZuKSB7XFxuICB2YXIgb2Zmc2V0MSA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoKTtcXG4gIHZhciByZXQgPSBmbigpO1xcbiAgdGhpcy5vcmlnaW5hbC5zZXRUaW1lKG5ldyBEYXRlKHRoaXMuZ2V0VGltZSgpKSk7XFxuICB2YXIgb2Zmc2V0MiA9IHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoKTtcXG4gIGlmIChvZmZzZXQyIC0gb2Zmc2V0MSkge1xcbiAgICB0aGlzLm9yaWdpbmFsLnNldE1pbnV0ZXModGhpcy5vcmlnaW5hbC5nZXRNaW51dGVzKCkgKyBvZmZzZXQyIC0gb2Zmc2V0MSk7XFxuICB9XFxuICByZXR1cm4gcmV0O1xcbn1cXG5cXG52YXIgWm9uZWREYXRlVGltZSA9IGZ1bmN0aW9uKGRhdGUsIHRpbWVab25lRGF0YSkge1xcbiAgZGVmaW5lUHJpdmF0ZVByb3BlcnR5KHRoaXMsIFxcXCJvcmlnaW5hbFxcXCIsIG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKSk7XFxuICBkZWZpbmVQcml2YXRlUHJvcGVydHkodGhpcywgXFxcImxvY2FsXFxcIiwgbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpKTtcXG4gIGRlZmluZVByaXZhdGVQcm9wZXJ0eSh0aGlzLCBcXFwidGltZVpvbmVEYXRhXFxcIiwgdGltZVpvbmVEYXRhKTtcXG4gIGRlZmluZVByaXZhdGVQcm9wZXJ0eSh0aGlzLCBcXFwic2V0V3JhcFxcXCIsIHNldFdyYXApO1xcbiAgaWYgKCEodGltZVpvbmVEYXRhLnVudGlscyAmJiB0aW1lWm9uZURhdGEub2Zmc2V0cyAmJiB0aW1lWm9uZURhdGEuaXNkc3RzKSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkludmFsaWQgSUFOQSBkYXRhXFxcIik7XFxuICB9XFxuICB0aGlzLnNldFRpbWUodGhpcy5sb2NhbC5nZXRUaW1lKCkgLSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCAqIDEwMDApO1xcbn07XFxuXFxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcXG4gIHJldHVybiBuZXcgWm9uZWREYXRlVGltZSh0aGlzLm9yaWdpbmFsLCB0aGlzLnRpbWVab25lRGF0YSk7XFxufTtcXG5cXG4vLyBEYXRlIGZpZWxkIGdldHRlcnMuXFxuW1xcXCJnZXRGdWxsWWVhclxcXCIsIFxcXCJnZXRNb250aFxcXCIsIFxcXCJnZXREYXRlXFxcIiwgXFxcImdldERheVxcXCIsIFxcXCJnZXRIb3Vyc1xcXCIsIFxcXCJnZXRNaW51dGVzXFxcIixcXG5cXFwiZ2V0U2Vjb25kc1xcXCIsIFxcXCJnZXRNaWxsaXNlY29uZHNcXFwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xcbiAgLy8gQ29ycmVzcG9uZGluZyBVVEMgbWV0aG9kLCBlLmcuLCBcXFwiZ2V0VVRDRnVsbFllYXJcXFwiIGlmIG1ldGhvZCA9PT0gXFxcImdldEZ1bGxZZWFyXFxcIi5cXG4gIHZhciB1dGNNZXRob2QgPSBcXFwiZ2V0VVRDXFxcIiArIG1ldGhvZC5zdWJzdHIoMyk7XFxuICBab25lZERhdGVUaW1lLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB0aGlzLmxvY2FsW3V0Y01ldGhvZF0oKTtcXG4gIH07XFxufSk7XFxuXFxuLy8gTm90ZTogRGVmaW5lIC52YWx1ZU9mID0gLmdldFRpbWUgZm9yIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBsaWtlIGRhdGUxIC0gZGF0ZTIuXFxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUudmFsdWVPZiA9XFxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUuZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xcbiAgcmV0dXJuIHRoaXMubG9jYWwuZ2V0VGltZSgpICsgdGhpcy5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwO1xcbn07XFxuXFxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUuZ2V0VGltZXpvbmVPZmZzZXQgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBpbmRleCA9IGdldFVudGlsc0luZGV4KHRoaXMub3JpZ2luYWwsIHRoaXMudGltZVpvbmVEYXRhLnVudGlscyk7XFxuICByZXR1cm4gdGhpcy50aW1lWm9uZURhdGEub2Zmc2V0c1tpbmRleF07XFxufTtcXG5cXG4vLyBEYXRlIGZpZWxkIHNldHRlcnMuXFxuW1xcXCJzZXRGdWxsWWVhclxcXCIsIFxcXCJzZXRNb250aFxcXCIsIFxcXCJzZXREYXRlXFxcIiwgXFxcInNldEhvdXJzXFxcIiwgXFxcInNldE1pbnV0ZXNcXFwiLCBcXFwic2V0U2Vjb25kc1xcXCIsIFxcXCJzZXRNaWxsaXNlY29uZHNcXFwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xcbiAgLy8gQ29ycmVzcG9uZGluZyBVVEMgbWV0aG9kLCBlLmcuLCBcXFwic2V0VVRDRnVsbFllYXJcXFwiIGlmIG1ldGhvZCA9PT0gXFxcInNldEZ1bGxZZWFyXFxcIi5cXG4gIHZhciB1dGNNZXRob2QgPSBcXFwic2V0VVRDXFxcIiArIG1ldGhvZC5zdWJzdHIoMyk7XFxuICBab25lZERhdGVUaW1lLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgdmFyIGxvY2FsID0gdGhpcy5sb2NhbDtcXG4gICAgLy8gTm90ZSBzZXRXcmFwIGlzIG5lZWRlZCBmb3Igc2Vjb25kcyBhbmQgbWlsbGlzZWNvbmRzIGp1c3QgYmVjYXVzZVxcbiAgICAvLyBhYnModmFsdWUpIGNvdWxkIGJlID49IGEgbWludXRlLlxcbiAgICByZXR1cm4gdGhpcy5zZXRXcmFwKGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBsb2NhbFt1dGNNZXRob2RdKHZhbHVlKTtcXG4gICAgfSk7XFxuICB9O1xcbn0pO1xcblxcblpvbmVkRGF0ZVRpbWUucHJvdG90eXBlLnNldFRpbWUgPSBmdW5jdGlvbih0aW1lKSB7XFxuICByZXR1cm4gdGhpcy5sb2NhbC5zZXRUaW1lKHRpbWUpO1xcbn07XFxuXFxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUuaXNEU1QgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBpbmRleCA9IGdldFVudGlsc0luZGV4KHRoaXMub3JpZ2luYWwsIHRoaXMudGltZVpvbmVEYXRhLnVudGlscyk7XFxuICByZXR1cm4gQm9vbGVhbih0aGlzLnRpbWVab25lRGF0YS5pc2RzdHNbaW5kZXhdKTtcXG59O1xcblxcblpvbmVkRGF0ZVRpbWUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBpbmRleCA9IGdldFVudGlsc0luZGV4KHRoaXMub3JpZ2luYWwsIHRoaXMudGltZVpvbmVEYXRhLnVudGlscyk7XFxuICB2YXIgYWJicnMgPSB0aGlzLnRpbWVab25lRGF0YS5hYmJycztcXG4gIHJldHVybiB0aGlzLmxvY2FsLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvWiQvLCBcXFwiXFxcIikgKyBcXFwiIFxcXCIgK1xcbiAgICAoYWJicnMgJiYgYWJicnNbaW5kZXhdICsgXFxcIiBcXFwiIHx8ICh0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtMSkgKyBcXFwiIFxcXCIpICtcXG4gICAgKHRoaXMuaXNEU1QoKSA/IFxcXCIoZGF5bGlnaHQgc2F2aW5ncylcXFwiIDogXFxcIlxcXCIpO1xcbn07XFxuXFxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUudG9EYXRlID0gZnVuY3Rpb24oKSB7XFxuICByZXR1cm4gbmV3IERhdGUodGhpcy5nZXRUaW1lKCkpO1xcbn07XFxuXFxuLy8gVHlwZSBjYXN0IGdldHRlcnMuXFxuW1xcXCJ0b0lTT1N0cmluZ1xcXCIsIFxcXCJ0b0pTT05cXFwiLCBcXFwidG9VVENTdHJpbmdcXFwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xcbiAgWm9uZWREYXRlVGltZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gdGhpcy50b0RhdGUoKVttZXRob2RdKCk7XFxuICB9O1xcbn0pO1xcblxcbnJldHVybiBab25lZERhdGVUaW1lO1xcbn0oKSk7XFxuXFxuXFxuLyoqXFxuICogaXNMZWFwWWVhciggeWVhciApXFxuICpcXG4gKiBAeWVhciBbTnVtYmVyXVxcbiAqXFxuICogUmV0dXJucyBhbiBpbmRpY2F0aW9uIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB5ZWFyIGlzIGEgbGVhcCB5ZWFyLlxcbiAqL1xcbnZhciBkYXRlSXNMZWFwWWVhciA9IGZ1bmN0aW9uKCB5ZWFyICkge1xcblxcdHJldHVybiBuZXcgRGF0ZSggeWVhciwgMSwgMjkgKS5nZXRNb250aCgpID09PSAxO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogbGFzdERheU9mTW9udGgoIGRhdGUgKVxcbiAqXFxuICogQGRhdGUgW0RhdGVdXFxuICpcXG4gKiBSZXR1cm4gdGhlIGxhc3QgZGF5IG9mIHRoZSBnaXZlbiBkYXRlJ3MgbW9udGhcXG4gKi9cXG52YXIgZGF0ZUxhc3REYXlPZk1vbnRoID0gZnVuY3Rpb24oIGRhdGUgKSB7XFxuXFx0cmV0dXJuIG5ldyBEYXRlKCBkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIDAgKS5nZXREYXRlKCk7XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBzdGFydE9mIGNoYW5nZXMgdGhlIGlucHV0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGdpdmVuIHVuaXQuXFxuICpcXG4gKiBGb3IgZXhhbXBsZSwgc3RhcnRpbmcgYXQgdGhlIHN0YXJ0IG9mIGEgZGF5LCByZXNldHMgaG91cnMsIG1pbnV0ZXNcXG4gKiBzZWNvbmRzIGFuZCBtaWxsaXNlY29uZHMgdG8gMC4gU3RhcnRpbmcgYXQgdGhlIG1vbnRoIGRvZXMgdGhlIHNhbWUsIGJ1dFxcbiAqIGFsc28gc2V0cyB0aGUgZGF0ZSB0byAxLlxcbiAqXFxuICogUmV0dXJucyB0aGUgbW9kaWZpZWQgZGF0ZVxcbiAqL1xcbnZhciBkYXRlU3RhcnRPZiA9IGZ1bmN0aW9uKCBkYXRlLCB1bml0ICkge1xcblxcdGRhdGUgPSBkYXRlIGluc3RhbmNlb2YgWm9uZWREYXRlVGltZSA/IGRhdGUuY2xvbmUoKSA6IG5ldyBEYXRlKCBkYXRlLmdldFRpbWUoKSApO1xcblxcdHN3aXRjaCAoIHVuaXQgKSB7XFxuXFx0XFx0Y2FzZSBcXFwieWVhclxcXCI6XFxuXFx0XFx0XFx0ZGF0ZS5zZXRNb250aCggMCApO1xcblxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRjYXNlIFxcXCJtb250aFxcXCI6XFxuXFx0XFx0XFx0ZGF0ZS5zZXREYXRlKCAxICk7XFxuXFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdGNhc2UgXFxcImRheVxcXCI6XFxuXFx0XFx0XFx0ZGF0ZS5zZXRIb3VycyggMCApO1xcblxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRjYXNlIFxcXCJob3VyXFxcIjpcXG5cXHRcXHRcXHRkYXRlLnNldE1pbnV0ZXMoIDAgKTtcXG5cXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0Y2FzZSBcXFwibWludXRlXFxcIjpcXG5cXHRcXHRcXHRkYXRlLnNldFNlY29uZHMoIDAgKTtcXG5cXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0Y2FzZSBcXFwic2Vjb25kXFxcIjpcXG5cXHRcXHRcXHRkYXRlLnNldE1pbGxpc2Vjb25kcyggMCApO1xcblxcdH1cXG5cXHRyZXR1cm4gZGF0ZTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIERpZmZlcmVudGx5IGZyb20gbmF0aXZlIGRhdGUuc2V0RGF0ZSgpLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBkYXRlIHdob3NlXFxuICogZGF5IHJlbWFpbnMgaW5zaWRlIHRoZSBtb250aCBib3VuZGFyaWVzLiBGb3IgZXhhbXBsZTpcXG4gKlxcbiAqIHNldERhdGUoIEZlYkRhdGUsIDMxICk6IGEgXFxcIkZlYiAyOFxcXCIgZGF0ZS5cXG4gKiBzZXREYXRlKCBTZXBEYXRlLCAzMSApOiBhIFxcXCJTZXAgMzBcXFwiIGRhdGUuXFxuICovXFxudmFyIGRhdGVTZXREYXRlID0gZnVuY3Rpb24oIGRhdGUsIGRheSApIHtcXG5cXHR2YXIgbGFzdERheSA9IG5ldyBEYXRlKCBkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIDAgKS5nZXREYXRlKCk7XFxuXFxuXFx0ZGF0ZS5zZXREYXRlKCBkYXkgPCAxID8gMSA6IGRheSA8IGxhc3REYXkgPyBkYXkgOiBsYXN0RGF5ICk7XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBEaWZmZXJlbnRseSBmcm9tIG5hdGl2ZSBkYXRlLnNldE1vbnRoKCksIHRoaXMgZnVuY3Rpb24gYWRqdXN0cyBkYXRlIGlmXFxuICogbmVlZGVkLCBzbyBmaW5hbCBtb250aCBpcyBhbHdheXMgdGhlIG9uZSBzZXQuXFxuICpcXG4gKiBzZXRNb250aCggSmFuMzFEYXRlLCAxICk6IGEgXFxcIkZlYiAyOFxcXCIgZGF0ZS5cXG4gKiBzZXREYXRlKCBKYW4zMURhdGUsIDggKTogYSBcXFwiU2VwIDMwXFxcIiBkYXRlLlxcbiAqL1xcbnZhciBkYXRlU2V0TW9udGggPSBmdW5jdGlvbiggZGF0ZSwgbW9udGggKSB7XFxuXFx0dmFyIG9yaWdpbmFsRGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpO1xcblxcblxcdGRhdGUuc2V0RGF0ZSggMSApO1xcblxcdGRhdGUuc2V0TW9udGgoIG1vbnRoICk7XFxuXFx0ZGF0ZVNldERhdGUoIGRhdGUsIG9yaWdpbmFsRGF0ZSApO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIG91dE9mUmFuZ2UgPSBmdW5jdGlvbiggdmFsdWUsIGxvdywgaGlnaCApIHtcXG5cXHRyZXR1cm4gdmFsdWUgPCBsb3cgfHwgdmFsdWUgPiBoaWdoO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogcGFyc2UoIHZhbHVlLCB0b2tlbnMsIHByb3BlcnRpZXMgKVxcbiAqXFxuICogQHZhbHVlIFtTdHJpbmddIHN0cmluZyBkYXRlLlxcbiAqXFxuICogQHRva2VucyBbT2JqZWN0XSB0b2tlbnMgcmV0dXJuZWQgYnkgZGF0ZS90b2tlbml6ZXIuXFxuICpcXG4gKiBAcHJvcGVydGllcyBbT2JqZWN0XSBvdXRwdXQgcmV0dXJuZWQgYnkgZGF0ZS90b2tlbml6ZXItcHJvcGVydGllcy5cXG4gKlxcbiAqIHJlZjogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXFxuICovXFxudmFyIGRhdGVQYXJzZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgdG9rZW5zLCBwcm9wZXJ0aWVzICkge1xcblxcdHZhciBhbVBtLCBkYXksIGRheXNPZlllYXIsIG1vbnRoLCBlcmEsIGhvdXIsIGhvdXIxMiwgdGltZXpvbmVPZmZzZXQsIHZhbGlkLFxcblxcdFxcdFlFQVIgPSAwLFxcblxcdFxcdE1PTlRIID0gMSxcXG5cXHRcXHREQVkgPSAyLFxcblxcdFxcdEhPVVIgPSAzLFxcblxcdFxcdE1JTlVURSA9IDQsXFxuXFx0XFx0U0VDT05EID0gNSxcXG5cXHRcXHRNSUxMSVNFQ09ORFMgPSA2LFxcblxcdFxcdGRhdGUgPSBuZXcgRGF0ZSgpLFxcblxcdFxcdHRydW5jYXRlQXQgPSBbXSxcXG5cXHRcXHR1bml0cyA9IFsgXFxcInllYXJcXFwiLCBcXFwibW9udGhcXFwiLCBcXFwiZGF5XFxcIiwgXFxcImhvdXJcXFwiLCBcXFwibWludXRlXFxcIiwgXFxcInNlY29uZFxcXCIsIFxcXCJtaWxsaXNlY29uZHNcXFwiIF07XFxuXFxuXFx0Ly8gQ3JlYXRlIGdsb2JhbGl6ZSBkYXRlIHdpdGggZ2l2ZW4gdGltZXpvbmUgZGF0YS5cXG5cXHRpZiAoIHByb3BlcnRpZXMudGltZVpvbmVEYXRhICkge1xcblxcdFxcdGRhdGUgPSBuZXcgWm9uZWREYXRlVGltZSggZGF0ZSwgcHJvcGVydGllcy50aW1lWm9uZURhdGEoKSApO1xcblxcdH1cXG5cXG5cXHRpZiAoICF0b2tlbnMubGVuZ3RoICkge1xcblxcdFxcdHJldHVybiBudWxsO1xcblxcdH1cXG5cXG5cXHR2YWxpZCA9IHRva2Vucy5ldmVyeShmdW5jdGlvbiggdG9rZW4gKSB7XFxuXFx0XFx0dmFyIGNlbnR1cnksIGNociwgdmFsdWUsIGxlbmd0aDtcXG5cXG5cXHRcXHRpZiAoIHRva2VuLnR5cGUgPT09IFxcXCJsaXRlcmFsXFxcIiApIHtcXG5cXG5cXHRcXHRcXHQvLyBjb250aW51ZVxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjaHIgPSB0b2tlbi50eXBlLmNoYXJBdCggMCApO1xcblxcdFxcdGxlbmd0aCA9IHRva2VuLnR5cGUubGVuZ3RoO1xcblxcblxcdFxcdGlmICggY2hyID09PSBcXFwialxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gTG9jYWxlIHByZWZlcnJlZCBoSEtrLlxcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNUaW1lX0RhdGFcXG5cXHRcXHRcXHRjaHIgPSBwcm9wZXJ0aWVzLnByZWZlcnJlZFRpbWVEYXRhO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRzd2l0Y2ggKCBjaHIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gRXJhXFxuXFx0XFx0XFx0Y2FzZSBcXFwiR1xcXCI6XFxuXFx0XFx0XFx0XFx0dHJ1bmNhdGVBdC5wdXNoKCBZRUFSICk7XFxuXFx0XFx0XFx0XFx0ZXJhID0gK3Rva2VuLnZhbHVlO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIFllYXJcXG5cXHRcXHRcXHRjYXNlIFxcXCJ5XFxcIjpcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoID09PSAyICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDAsIDk5ICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBtaW1pYyBkb2pvL2RhdGUvbG9jYWxlOiBjaG9vc2UgY2VudHVyeSB0byBhcHBseSwgYWNjb3JkaW5nIHRvIGEgc2xpZGluZ1xcblxcdFxcdFxcdFxcdFxcdC8vIHdpbmRvdyBvZiA4MCB5ZWFycyBiZWZvcmUgYW5kIDIwIHllYXJzIGFmdGVyIHByZXNlbnQgeWVhci5cXG5cXHRcXHRcXHRcXHRcXHRjZW50dXJ5ID0gTWF0aC5mbG9vciggZGF0ZS5nZXRGdWxsWWVhcigpIC8gMTAwICkgKiAxMDA7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgKz0gY2VudHVyeTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlID4gZGF0ZS5nZXRGdWxsWWVhcigpICsgMjAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWUgLT0gMTAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZGF0ZS5zZXRGdWxsWWVhciggdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR0cnVuY2F0ZUF0LnB1c2goIFlFQVIgKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRjYXNlIFxcXCJZXFxcIjogLy8gWWVhciBpbiBcXFwiV2VlayBvZiBZZWFyXFxcIlxcblxcdFxcdFxcdFxcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcXG5cXHRcXHRcXHRcXHRcXHRmZWF0dXJlOiBcXFwieWVhciBwYXR0ZXJuIGBcXFwiICsgY2hyICsgXFxcImBcXFwiXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gUXVhcnRlciAoc2tpcClcXG5cXHRcXHRcXHRjYXNlIFxcXCJRXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJxXFxcIjpcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBNb250aFxcblxcdFxcdFxcdGNhc2UgXFxcIk1cXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcIkxcXFwiOlxcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoIDw9IDIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0gK3Rva2VuLnZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAxLCAxMiApICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2V0dGluZyB0aGUgbW9udGggbGF0ZXIgc28gdGhhdCB3ZSBoYXZlIHRoZSBjb3JyZWN0IHllYXIgYW5kIGNhbiBkZXRlcm1pbmVcXG5cXHRcXHRcXHRcXHQvLyB0aGUgY29ycmVjdCBsYXN0IGRheSBvZiBGZWJydWFyeSBpbiBjYXNlIG9mIGxlYXAgeWVhci5cXG5cXHRcXHRcXHRcXHRtb250aCA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdHRydW5jYXRlQXQucHVzaCggTU9OVEggKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBXZWVrIChza2lwKVxcblxcdFxcdFxcdGNhc2UgXFxcIndcXFwiOiAvLyBXZWVrIG9mIFllYXIuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiV1xcXCI6IC8vIFdlZWsgb2YgTW9udGguXFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gRGF5XFxuXFx0XFx0XFx0Y2FzZSBcXFwiZFxcXCI6XFxuXFx0XFx0XFx0XFx0ZGF5ID0gdG9rZW4udmFsdWU7XFxuXFx0XFx0XFx0XFx0dHJ1bmNhdGVBdC5wdXNoKCBEQVkgKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRjYXNlIFxcXCJEXFxcIjpcXG5cXHRcXHRcXHRcXHRkYXlzT2ZZZWFyID0gdG9rZW4udmFsdWU7XFxuXFx0XFx0XFx0XFx0dHJ1bmNhdGVBdC5wdXNoKCBEQVkgKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRjYXNlIFxcXCJGXFxcIjpcXG5cXG5cXHRcXHRcXHRcXHQvLyBEYXkgb2YgV2VlayBpbiBtb250aC4gZWcuIDJuZCBXZWQgaW4gSnVseS5cXG5cXHRcXHRcXHRcXHQvLyBTa2lwXFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gV2VlayBkYXlcXG5cXHRcXHRcXHRjYXNlIFxcXCJlXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJjXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJFXFxcIjpcXG5cXG5cXHRcXHRcXHRcXHQvLyBTa2lwLlxcblxcdFxcdFxcdFxcdC8vIHZhbHVlID0gYXJyYXlJbmRleE9mKCBkYXRlV2Vla0RheXMsIHRva2VuLnZhbHVlICk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gUGVyaW9kIChBTSBvciBQTSlcXG5cXHRcXHRcXHRjYXNlIFxcXCJhXFxcIjpcXG5cXHRcXHRcXHRcXHRhbVBtID0gdG9rZW4udmFsdWU7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gSG91clxcblxcdFxcdFxcdGNhc2UgXFxcImhcXFwiOiAvLyAxLTEyXFxuXFx0XFx0XFx0XFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcXG5cXHRcXHRcXHRcXHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAxLCAxMiApICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aG91ciA9IGhvdXIxMiA9IHRydWU7XFxuXFx0XFx0XFx0XFx0ZGF0ZS5zZXRIb3VycyggdmFsdWUgPT09IDEyID8gMCA6IHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0dHJ1bmNhdGVBdC5wdXNoKCBIT1VSICk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiS1xcXCI6IC8vIDAtMTFcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xcblxcdFxcdFxcdFxcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDAsIDExICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRob3VyID0gaG91cjEyID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRkYXRlLnNldEhvdXJzKCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdHRydW5jYXRlQXQucHVzaCggSE9VUiApO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcImtcXFwiOiAvLyAxLTI0XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcXG5cXHRcXHRcXHRcXHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAxLCAyNCApICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aG91ciA9IHRydWU7XFxuXFx0XFx0XFx0XFx0ZGF0ZS5zZXRIb3VycyggdmFsdWUgPT09IDI0ID8gMCA6IHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0dHJ1bmNhdGVBdC5wdXNoKCBIT1VSICk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiSFxcXCI6IC8vIDAtMjNcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xcblxcdFxcdFxcdFxcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDAsIDIzICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRob3VyID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRkYXRlLnNldEhvdXJzKCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdHRydW5jYXRlQXQucHVzaCggSE9VUiApO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIE1pbnV0ZVxcblxcdFxcdFxcdGNhc2UgXFxcIm1cXFwiOlxcblxcdFxcdFxcdFxcdHZhbHVlID0gdG9rZW4udmFsdWU7XFxuXFx0XFx0XFx0XFx0aWYgKCBvdXRPZlJhbmdlKCB2YWx1ZSwgMCwgNTkgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRhdGUuc2V0TWludXRlcyggdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR0cnVuY2F0ZUF0LnB1c2goIE1JTlVURSApO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIFNlY29uZFxcblxcdFxcdFxcdGNhc2UgXFxcInNcXFwiOlxcblxcdFxcdFxcdFxcdHZhbHVlID0gdG9rZW4udmFsdWU7XFxuXFx0XFx0XFx0XFx0aWYgKCBvdXRPZlJhbmdlKCB2YWx1ZSwgMCwgNTkgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRhdGUuc2V0U2Vjb25kcyggdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHR0cnVuY2F0ZUF0LnB1c2goIFNFQ09ORCApO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcIkFcXFwiOlxcblxcdFxcdFxcdFxcdGRhdGUuc2V0SG91cnMoIDAgKTtcXG5cXHRcXHRcXHRcXHRkYXRlLnNldE1pbnV0ZXMoIDAgKTtcXG5cXHRcXHRcXHRcXHRkYXRlLnNldFNlY29uZHMoIDAgKTtcXG5cXG5cXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0Y2FzZSBcXFwiU1xcXCI6XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBNYXRoLnJvdW5kKCB0b2tlbi52YWx1ZSAqIE1hdGgucG93KCAxMCwgMyAtIGxlbmd0aCApICk7XFxuXFx0XFx0XFx0XFx0ZGF0ZS5zZXRNaWxsaXNlY29uZHMoIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0dHJ1bmNhdGVBdC5wdXNoKCBNSUxMSVNFQ09ORFMgKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBab25lXFxuXFx0XFx0XFx0Y2FzZSBcXFwielxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiWlxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiT1xcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwidlxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiVlxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiWFxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwieFxcXCI6XFxuXFx0XFx0XFx0XFx0aWYgKCB0eXBlb2YgdG9rZW4udmFsdWUgPT09IFxcXCJudW1iZXJcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdHRpbWV6b25lT2Zmc2V0ID0gdG9rZW4udmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHR9KTtcXG5cXG5cXHRpZiAoICF2YWxpZCApIHtcXG5cXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHR9XFxuXFxuXFx0Ly8gMTItaG91ciBmb3JtYXQgbmVlZHMgQU0gb3IgUE0sIDI0LWhvdXIgZm9ybWF0IGRvZXNuJ3QsIGllLiByZXR1cm4gbnVsbFxcblxcdC8vIGlmIGFtUG0gJiYgIWhvdXIxMiB8fCAhYW1QbSAmJiBob3VyMTIuXFxuXFx0aWYgKCBob3VyICYmICEoICFhbVBtIF4gaG91cjEyICkgKSB7XFxuXFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0fVxcblxcblxcdGlmICggZXJhID09PSAwICkge1xcblxcblxcdFxcdC8vIDEgQkMgPSB5ZWFyIDBcXG5cXHRcXHRkYXRlLnNldEZ1bGxZZWFyKCBkYXRlLmdldEZ1bGxZZWFyKCkgKiAtMSArIDEgKTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBtb250aCAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdGRhdGVTZXRNb250aCggZGF0ZSwgbW9udGggLSAxICk7XFxuXFx0fVxcblxcblxcdGlmICggZGF5ICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0aWYgKCBvdXRPZlJhbmdlKCBkYXksIDEsIGRhdGVMYXN0RGF5T2ZNb250aCggZGF0ZSApICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0fVxcblxcdFxcdGRhdGUuc2V0RGF0ZSggZGF5ICk7XFxuXFx0fSBlbHNlIGlmICggZGF5c09mWWVhciAhPT0gdW5kZWZpbmVkICkge1xcblxcdFxcdGlmICggb3V0T2ZSYW5nZSggZGF5c09mWWVhciwgMSwgZGF0ZUlzTGVhcFllYXIoIGRhdGUuZ2V0RnVsbFllYXIoKSApID8gMzY2IDogMzY1ICkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0fVxcblxcdFxcdGRhdGUuc2V0TW9udGgoIDAgKTtcXG5cXHRcXHRkYXRlLnNldERhdGUoIGRheXNPZlllYXIgKTtcXG5cXHR9XFxuXFxuXFx0aWYgKCBob3VyMTIgJiYgYW1QbSA9PT0gXFxcInBtXFxcIiApIHtcXG5cXHRcXHRkYXRlLnNldEhvdXJzKCBkYXRlLmdldEhvdXJzKCkgKyAxMiApO1xcblxcdH1cXG5cXG5cXHRpZiAoIHRpbWV6b25lT2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0ZGF0ZS5zZXRNaW51dGVzKCBkYXRlLmdldE1pbnV0ZXMoKSArIHRpbWV6b25lT2Zmc2V0IC0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICk7XFxuXFx0fVxcblxcblxcdC8vIFRydW5jYXRlIGRhdGUgYXQgdGhlIG1vc3QgcHJlY2lzZSB1bml0IGRlZmluZWQuIEVnLlxcblxcdC8vIElmIHZhbHVlIGlzIFxcXCIxMi8zMVxcXCIsIGFuZCBwYXR0ZXJuIGlzIFxcXCJNTS9kZFxcXCI6XFxuXFx0Ly8gPT4gbmV3IERhdGUoIDxjdXJyZW50IFllYXI+LCAxMiwgMzEsIDAsIDAsIDAsIDAgKTtcXG5cXHR0cnVuY2F0ZUF0ID0gTWF0aC5tYXguYXBwbHkoIG51bGwsIHRydW5jYXRlQXQgKTtcXG5cXHRkYXRlID0gZGF0ZVN0YXJ0T2YoIGRhdGUsIHVuaXRzWyB0cnVuY2F0ZUF0IF0gKTtcXG5cXG5cXHQvLyBHZXQgZGF0ZSBiYWNrIGZyb20gZ2xvYmFsaXplIGRhdGUuXFxuXFx0aWYgKCBkYXRlIGluc3RhbmNlb2YgWm9uZWREYXRlVGltZSApIHtcXG5cXHRcXHRkYXRlID0gZGF0ZS50b0RhdGUoKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGRhdGU7XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiB0b2tlbml6ZXIoIHZhbHVlLCBudW1iZXJQYXJzZXIsIHByb3BlcnRpZXMgKVxcbiAqXFxuICogQHZhbHVlIFtTdHJpbmddIHN0cmluZyBkYXRlLlxcbiAqXFxuICogQG51bWJlclBhcnNlciBbRnVuY3Rpb25dXFxuICpcXG4gKiBAcHJvcGVydGllcyBbT2JqZWN0XSBvdXRwdXQgcmV0dXJuZWQgYnkgZGF0ZS90b2tlbml6ZXItcHJvcGVydGllcy5cXG4gKlxcbiAqIFJldHVybnMgYW4gQXJyYXkgb2YgdG9rZW5zLCBlZy4gdmFsdWUgXFxcIjUgbydjbG9jayBQTVxcXCIsIHBhdHRlcm4gXFxcImggJ28nJ2Nsb2NrJyBhXFxcIjpcXG4gKiBbe1xcbiAqICAgdHlwZTogXFxcImhcXFwiLFxcbiAqICAgbGV4ZW1lOiBcXFwiNVxcXCJcXG4gKiB9LCB7XFxuICogICB0eXBlOiBcXFwibGl0ZXJhbFxcXCIsXFxuICogICBsZXhlbWU6IFxcXCIgXFxcIlxcbiAqIH0sIHtcXG4gKiAgIHR5cGU6IFxcXCJsaXRlcmFsXFxcIixcXG4gKiAgIGxleGVtZTogXFxcIm8nY2xvY2tcXFwiXFxuICogfSwge1xcbiAqICAgdHlwZTogXFxcImxpdGVyYWxcXFwiLFxcbiAqICAgbGV4ZW1lOiBcXFwiIFxcXCJcXG4gKiB9LCB7XFxuICogICB0eXBlOiBcXFwiYVxcXCIsXFxuICogICBsZXhlbWU6IFxcXCJQTVxcXCIsXFxuICogICB2YWx1ZTogXFxcInBtXFxcIlxcbiAqIH1dXFxuICpcXG4gKiBPQlM6IGxleGVtZSdzIGFyZSBhbHdheXMgU3RyaW5nIGFuZCBtYXkgcmV0dXJuIGludmFsaWQgcmFuZ2VzIGRlcGVuZGluZyBvZiB0aGUgdG9rZW4gdHlwZS5cXG4gKiBFZy4gXFxcIjk5XFxcIiBmb3IgbW9udGggbnVtYmVyLlxcbiAqXFxuICogUmV0dXJuIGFuIGVtcHR5IEFycmF5IHdoZW4gbm90IHN1Y2Nlc3NmdWxseSBwYXJzZWQuXFxuICovXFxudmFyIGRhdGVUb2tlbml6ZXIgPSBmdW5jdGlvbiggdmFsdWUsIG51bWJlclBhcnNlciwgcHJvcGVydGllcyApIHtcXG5cXHR2YXIgZGlnaXRzUmUsIHZhbGlkLFxcblxcdFxcdHRva2VucyA9IFtdLFxcblxcdFxcdHdpZHRocyA9IFsgXFxcImFiYnJldmlhdGVkXFxcIiwgXFxcIndpZGVcXFwiLCBcXFwibmFycm93XFxcIiBdO1xcblxcblxcdGRpZ2l0c1JlID0gcHJvcGVydGllcy5kaWdpdHNSZTtcXG5cXHR2YWx1ZSA9IGxvb3NlTWF0Y2hpbmcoIHZhbHVlICk7XFxuXFxuXFx0dmFsaWQgPSBwcm9wZXJ0aWVzLnBhdHRlcm4ubWF0Y2goIGRhdGVQYXR0ZXJuUmUgKS5ldmVyeShmdW5jdGlvbiggY3VycmVudCApIHtcXG5cXHRcXHR2YXIgYXV4LCBjaHIsIGxlbmd0aCwgbnVtZXJpYywgdG9rZW5SZSxcXG5cXHRcXHRcXHR0b2tlbiA9IHt9O1xcblxcblxcdFxcdGZ1bmN0aW9uIGhvdXJGb3JtYXRQYXJzZSggdG9rZW5SZSwgbnVtYmVyUGFyc2VyICkge1xcblxcdFxcdFxcdHZhciBhdXgsIGlzUG9zaXRpdmUsXFxuXFx0XFx0XFx0XFx0bWF0Y2ggPSB2YWx1ZS5tYXRjaCggdG9rZW5SZSApO1xcblxcdFxcdFxcdG51bWJlclBhcnNlciA9IG51bWJlclBhcnNlciB8fCBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICt2YWx1ZTtcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdGlmICggIW1hdGNoICkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aXNQb3NpdGl2ZSA9IG1hdGNoWyAxIF07XFxuXFxuXFx0XFx0XFx0Ly8gaG91ckZvcm1hdCBjb250YWluaW5nIEggb25seSwgZS5nLiwgYCtIOy1IYFxcblxcdFxcdFxcdGlmICggbWF0Y2gubGVuZ3RoIDwgNiApIHtcXG5cXHRcXHRcXHRcXHRhdXggPSBpc1Bvc2l0aXZlID8gMSA6IDM7XFxuXFx0XFx0XFx0XFx0dG9rZW4udmFsdWUgPSBudW1iZXJQYXJzZXIoIG1hdGNoWyBhdXggXSApICogNjA7XFxuXFxuXFx0XFx0XFx0Ly8gaG91ckZvcm1hdCBjb250YWluaW5nIEggYW5kIG0sIGUuZy4sIGArSEhtbTstSEhtbWBcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRjaC5sZW5ndGggPCAxMCApIHtcXG5cXHRcXHRcXHRcXHRhdXggPSBpc1Bvc2l0aXZlID8gWyAxLCAzIF0gOiBbIDUsIDcgXTtcXG5cXHRcXHRcXHRcXHR0b2tlbi52YWx1ZSA9IG51bWJlclBhcnNlciggbWF0Y2hbIGF1eFsgMCBdIF0gKSAqIDYwICtcXG5cXHRcXHRcXHRcXHRcXHRudW1iZXJQYXJzZXIoIG1hdGNoWyBhdXhbIDEgXSBdICk7XFxuXFxuXFx0XFx0XFx0Ly8gaG91ckZvcm1hdCBjb250YWluaW5nIEgsIG0sIGFuZCBzIGUuZy4sIGArSEhtbXNzOy1ISG1tc3NgXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRhdXggPSBpc1Bvc2l0aXZlID8gWyAxLCAzLCA1IF0gOiBbIDcsIDksIDExIF07XFxuXFx0XFx0XFx0XFx0dG9rZW4udmFsdWUgPSBudW1iZXJQYXJzZXIoIG1hdGNoWyBhdXhbIDAgXSBdICkgKiA2MCArXFxuXFx0XFx0XFx0XFx0XFx0bnVtYmVyUGFyc2VyKCBtYXRjaFsgYXV4WyAxIF0gXSApICtcXG5cXHRcXHRcXHRcXHRcXHRudW1iZXJQYXJzZXIoIG1hdGNoWyBhdXhbIDIgXSBdICkgLyA2MDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBpc1Bvc2l0aXZlICkge1xcblxcdFxcdFxcdFxcdHRva2VuLnZhbHVlICo9IC0xO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gb25lRGlnaXRJZkxlbmd0aE9uZSgpIHtcXG5cXHRcXHRcXHRpZiAoIGxlbmd0aCA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcXFxkL1xcblxcdFxcdFxcdFxcdG51bWVyaWMgPSB0cnVlO1xcblxcdFxcdFxcdFxcdHJldHVybiB0b2tlblJlID0gZGlnaXRzUmU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBvbmVPclR3b0RpZ2l0c0lmTGVuZ3RoT25lKCkge1xcblxcdFxcdFxcdGlmICggbGVuZ3RoID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxcXGRcXFxcZD8vXFxuXFx0XFx0XFx0XFx0bnVtZXJpYyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcXFwiXihcXFwiICsgZGlnaXRzUmUuc291cmNlICsgXFxcIil7MSwyfVxcXCIgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIG9uZU9yVHdvRGlnaXRzSWZMZW5ndGhPbmVPclR3bygpIHtcXG5cXHRcXHRcXHRpZiAoIGxlbmd0aCA9PT0gMSB8fCBsZW5ndGggPT09IDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXFxcZFxcXFxkPy9cXG5cXHRcXHRcXHRcXHRudW1lcmljID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdG9rZW5SZSA9IG5ldyBSZWdFeHAoIFxcXCJeKFxcXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcXFwiKXsxLDJ9XFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdHdvRGlnaXRzSWZMZW5ndGhUd28oKSB7XFxuXFx0XFx0XFx0aWYgKCBsZW5ndGggPT09IDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXFxcZFxcXFxkL1xcblxcdFxcdFxcdFxcdG51bWVyaWMgPSB0cnVlO1xcblxcdFxcdFxcdFxcdHJldHVybiB0b2tlblJlID0gbmV3IFJlZ0V4cCggXFxcIl4oXFxcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFxcXCIpezJ9XFxcIiApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQnJ1dGUtZm9yY2UgdGVzdCBldmVyeSBsb2NhbGUgZW50cnkgaW4gYW4gYXR0ZW1wdCB0byBtYXRjaCB0aGUgZ2l2ZW4gdmFsdWUuXFxuXFx0XFx0Ly8gUmV0dXJuIHRoZSBmaXJzdCBmb3VuZCBvbmUgKGFuZCBzZXQgdG9rZW4gYWNjb3JkaW5nbHkpLCBvciBudWxsLlxcblxcdFxcdGZ1bmN0aW9uIGxvb2t1cCggcGF0aCApIHtcXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSBwcm9wZXJ0aWVzWyBwYXRoLmpvaW4oIFxcXCIvXFxcIiApIF07XFxuXFxuXFx0XFx0XFx0aWYgKCAhYXJyYXkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGFycmF5IG9mIHBhaXJzIFtrZXksIHZhbHVlXSBzb3J0ZWQgYnkgZGVzYyB2YWx1ZSBsZW5ndGguXFxuXFx0XFx0XFx0YXJyYXkuc29tZShmdW5jdGlvbiggaXRlbSApIHtcXG5cXHRcXHRcXHRcXHR2YXIgdmFsdWVSZSA9IGl0ZW1bIDEgXTtcXG5cXHRcXHRcXHRcXHRpZiAoIHZhbHVlUmUudGVzdCggdmFsdWUgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHR0b2tlbi52YWx1ZSA9IGl0ZW1bIDAgXTtcXG5cXHRcXHRcXHRcXHRcXHR0b2tlblJlID0gaXRlbVsgMSBdO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dG9rZW4udHlwZSA9IGN1cnJlbnQ7XFxuXFx0XFx0Y2hyID0gY3VycmVudC5jaGFyQXQoIDAgKTtcXG5cXHRcXHRsZW5ndGggPSBjdXJyZW50Lmxlbmd0aDtcXG5cXG5cXHRcXHRpZiAoIGNociA9PT0gXFxcIlpcXFwiICkge1xcblxcblxcdFxcdFxcdC8vIFouLlpaWjogc2FtZSBhcyBcXFwieHh4eFxcXCIuXFxuXFx0XFx0XFx0aWYgKCBsZW5ndGggPCA0ICkge1xcblxcdFxcdFxcdFxcdGNociA9IFxcXCJ4XFxcIjtcXG5cXHRcXHRcXHRcXHRsZW5ndGggPSA0O1xcblxcblxcdFxcdFxcdC8vIFpaWlo6IHNhbWUgYXMgXFxcIk9PT09cXFwiLlxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGxlbmd0aCA8IDUgKSB7XFxuXFx0XFx0XFx0XFx0Y2hyID0gXFxcIk9cXFwiO1xcblxcdFxcdFxcdFxcdGxlbmd0aCA9IDQ7XFxuXFxuXFx0XFx0XFx0Ly8gWlpaWlo6IHNhbWUgYXMgXFxcIlhYWFhYXFxcIlxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Y2hyID0gXFxcIlhcXFwiO1xcblxcdFxcdFxcdFxcdGxlbmd0aCA9IDU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGNociA9PT0gXFxcInpcXFwiICkge1xcblxcdFxcdFxcdGlmICggcHJvcGVydGllcy5zdGFuZGFyZE9yRGF5bGlnaHRUek5hbWUgKSB7XFxuXFx0XFx0XFx0XFx0dG9rZW4udmFsdWUgPSBudWxsO1xcblxcdFxcdFxcdFxcdHRva2VuUmUgPSBwcm9wZXJ0aWVzLnN0YW5kYXJkT3JEYXlsaWdodFR6TmFtZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIHYuLi52dnY6IFxcXCJ7c2hvcnRSZWdpb259XFxcIiwgZWcuIFxcXCJQVFxcXCIuXFxuXFx0XFx0Ly8gdnZ2djogXFxcIntyZWdpb25OYW1lfSB7VGltZX1cXFwiIG9yIFxcXCJ7cmVnaW9uTmFtZX0ge1RpbWV9XFxcIixcXG5cXHRcXHQvLyBlLmcuLCBcXFwiUGFjaWZpYyBUaW1lXFxcIlxcblxcdFxcdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXFxuXFx0XFx0aWYgKCBjaHIgPT09IFxcXCJ2XFxcIiApIHtcXG5cXHRcXHRcXHRpZiAoIHByb3BlcnRpZXMuZ2VuZXJpY1R6TmFtZSApIHtcXG5cXHRcXHRcXHRcXHR0b2tlbi52YWx1ZSA9IG51bGw7XFxuXFx0XFx0XFx0XFx0dG9rZW5SZSA9IHByb3BlcnRpZXMuZ2VuZXJpY1R6TmFtZTtcXG5cXG5cXHRcXHRcXHQvLyBGYWxsIGJhY2sgdG8gXFxcIlZcXFwiIGZvcm1hdC5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGNociA9IFxcXCJWXFxcIjtcXG5cXHRcXHRcXHRcXHRsZW5ndGggPSA0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBjaHIgPT09IFxcXCJWXFxcIiAmJiBwcm9wZXJ0aWVzLnRpbWVab25lTmFtZSApIHtcXG5cXHRcXHRcXHR0b2tlbi52YWx1ZSA9IGxlbmd0aCA9PT0gMiA/IHByb3BlcnRpZXMudGltZVpvbmVOYW1lIDogbnVsbDtcXG5cXHRcXHRcXHR0b2tlblJlID0gcHJvcGVydGllcy50aW1lWm9uZU5hbWVSZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0c3dpdGNoICggY2hyICkge1xcblxcblxcdFxcdFxcdC8vIEVyYVxcblxcdFxcdFxcdGNhc2UgXFxcIkdcXFwiOlxcblxcdFxcdFxcdFxcdGxvb2t1cChbXFxuXFx0XFx0XFx0XFx0XFx0XFxcImdyZWdvcmlhbi9lcmFzXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRsZW5ndGggPD0gMyA/IFxcXCJlcmFBYmJyXFxcIiA6ICggbGVuZ3RoID09PSA0ID8gXFxcImVyYU5hbWVzXFxcIiA6IFxcXCJlcmFOYXJyb3dcXFwiIClcXG5cXHRcXHRcXHRcXHRdKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBZZWFyXFxuXFx0XFx0XFx0Y2FzZSBcXFwieVxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiWVxcXCI6XFxuXFx0XFx0XFx0XFx0bnVtZXJpYyA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbnVtYmVyIGw9MTorLCBsPTI6ezJ9LCBsPTM6ezMsfSwgbD00Ons0LH0sIC4uLlxcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxcXGQrLy5cXG5cXHRcXHRcXHRcXHRcXHR0b2tlblJlID0gbmV3IFJlZ0V4cCggXFxcIl4oXFxcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFxcXCIpK1xcXCIgKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBsZW5ndGggPT09IDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTGVuaWVudCBwYXJzaW5nOiB0aGVyZSdzIG5vIHllYXIgcGF0dGVybiB0byBpbmRpY2F0ZSBub24temVyby1wYWRkZWQgMi1kaWdpdHNcXG5cXHRcXHRcXHRcXHRcXHQvLyB5ZWFyLCBzbyBwYXJzZXIgYWNjZXB0cyBib3RoIHplcm8tcGFkZGVkIGFuZCBub24temVyby1wYWRkZWQgZm9yIGB5eWAuXFxuXFx0XFx0XFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHRcXHRcXHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcXFxkXFxcXGQ/L1xcblxcdFxcdFxcdFxcdFxcdHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcXFwiXihcXFwiICsgZGlnaXRzUmUuc291cmNlICsgXFxcIil7MSwyfVxcXCIgKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxcXGR7bGVuZ3RoLH0vXFxuXFx0XFx0XFx0XFx0XFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFxcXCJeKFxcXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcXFwiKXtcXFwiICsgbGVuZ3RoICsgXFxcIix9XFxcIiApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBRdWFydGVyXFxuXFx0XFx0XFx0Y2FzZSBcXFwiUVxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwicVxcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbnVtYmVyIGw9MTp7MX0sIGw9Mjp7Mn0uXFxuXFx0XFx0XFx0XFx0Ly8gbG9va3VwIGw9My4uLlxcblxcdFxcdFxcdFxcdG9uZURpZ2l0SWZMZW5ndGhPbmUoKSB8fCB0d29EaWdpdHNJZkxlbmd0aFR3bygpIHx8XFxuXFx0XFx0XFx0XFx0XFx0bG9va3VwKFtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiZ3JlZ29yaWFuL3F1YXJ0ZXJzXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaHIgPT09IFxcXCJRXFxcIiA/IFxcXCJmb3JtYXRcXFwiIDogXFxcInN0YW5kLWFsb25lXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aWR0aHNbIGxlbmd0aCAtIDMgXVxcblxcdFxcdFxcdFxcdFxcdF0pO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIE1vbnRoXFxuXFx0XFx0XFx0Y2FzZSBcXFwiTVxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiTFxcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbnVtYmVyIGw9MTp7MSwyfSwgbD0yOnsyfS5cXG5cXHRcXHRcXHRcXHQvLyBsb29rdXAgbD0zLi4uXFxuXFx0XFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHRcXHQvLyBMZW5pZW50IHBhcnNpbmc6IHNrZWxldG9uIFxcXCJ5TWRcXFwiIChpLmUuLCBvbmUgTSkgbWF5IGluY2x1ZGUgTU0gZm9yIHRoZSBwYXR0ZXJuLFxcblxcdFxcdFxcdFxcdC8vIHRoZXJlZm9yZSBwYXJzZXIgYWNjZXB0cyBib3RoIHplcm8tcGFkZGVkIGFuZCBub24temVyby1wYWRkZWQgZm9yIE0gYW5kIE1NLlxcblxcdFxcdFxcdFxcdC8vIFNpbWlsYXIgZm9yIEwuXFxuXFx0XFx0XFx0XFx0b25lT3JUd29EaWdpdHNJZkxlbmd0aE9uZU9yVHdvKCkgfHwgbG9va3VwKFtcXG5cXHRcXHRcXHRcXHRcXHRcXFwiZ3JlZ29yaWFuL21vbnRoc1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0Y2hyID09PSBcXFwiTVxcXCIgPyBcXFwiZm9ybWF0XFxcIiA6IFxcXCJzdGFuZC1hbG9uZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0d2lkdGhzWyBsZW5ndGggLSAzIF1cXG5cXHRcXHRcXHRcXHRdKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBEYXlcXG5cXHRcXHRcXHRjYXNlIFxcXCJEXFxcIjpcXG5cXG5cXHRcXHRcXHRcXHQvLyBudW1iZXIge2wsM30uXFxuXFx0XFx0XFx0XFx0aWYgKCBsZW5ndGggPD0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBFcXVpdmFsZW50IHRvIC9cXFxcZHtsZW5ndGgsM30vXFxuXFx0XFx0XFx0XFx0XFx0bnVtZXJpYyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFxcXCJeKFxcXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcXFwiKXtcXFwiICsgbGVuZ3RoICsgXFxcIiwzfVxcXCIgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiV1xcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiRlxcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbnVtYmVyIGw9MTp7MX0uXFxuXFx0XFx0XFx0XFx0b25lRGlnaXRJZkxlbmd0aE9uZSgpO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIFdlZWsgZGF5XFxuXFx0XFx0XFx0Y2FzZSBcXFwiZVxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiY1xcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbnVtYmVyIGw9MTp7MX0sIGw9Mjp7Mn0uXFxuXFx0XFx0XFx0XFx0Ly8gbG9va3VwIGZvciBsZW5ndGggPj0zLlxcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoIDw9IDIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0b25lRGlnaXRJZkxlbmd0aE9uZSgpIHx8IHR3b0RpZ2l0c0lmTGVuZ3RoVHdvKCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRjYXNlIFxcXCJFXFxcIjpcXG5cXHRcXHRcXHRcXHRpZiAoIGxlbmd0aCA9PT0gNiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBOb3RlOiBpZiBzaG9ydCBkYXkgbmFtZXMgYXJlIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCwgYWJicmV2aWF0ZWQgZGF5XFxuXFx0XFx0XFx0XFx0XFx0Ly8gbmFtZXMgYXJlIHVzZWQgaW5zdGVhZCBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjbW9udGhzX2RheXNfcXVhcnRlcnNfZXJhc1xcblxcdFxcdFxcdFxcdFxcdGxvb2t1cChbXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcImdyZWdvcmlhbi9kYXlzXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRbIGNociA9PT0gXFxcImNcXFwiID8gXFxcInN0YW5kLWFsb25lXFxcIiA6IFxcXCJmb3JtYXRcXFwiIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcInNob3J0XFxcIlxcblxcdFxcdFxcdFxcdFxcdF0pIHx8IGxvb2t1cChbXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcImdyZWdvcmlhbi9kYXlzXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRbIGNociA9PT0gXFxcImNcXFwiID8gXFxcInN0YW5kLWFsb25lXFxcIiA6IFxcXCJmb3JtYXRcXFwiIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcImFiYnJldmlhdGVkXFxcIlxcblxcdFxcdFxcdFxcdFxcdF0pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0bG9va3VwKFtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiZ3JlZ29yaWFuL2RheXNcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFsgY2hyID09PSBcXFwiY1xcXCIgPyBcXFwic3RhbmQtYWxvbmVcXFwiIDogXFxcImZvcm1hdFxcXCIgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aWR0aHNbIGxlbmd0aCA8IDMgPyAwIDogbGVuZ3RoIC0gMyBdXFxuXFx0XFx0XFx0XFx0XFx0XSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIFBlcmlvZCAoQU0gb3IgUE0pXFxuXFx0XFx0XFx0Y2FzZSBcXFwiYVxcXCI6XFxuXFx0XFx0XFx0XFx0bG9va3VwKFtcXG5cXHRcXHRcXHRcXHRcXHRcXFwiZ3JlZ29yaWFuL2RheVBlcmlvZHMvZm9ybWF0L3dpZGVcXFwiXFxuXFx0XFx0XFx0XFx0XSk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gV2Vla1xcblxcdFxcdFxcdGNhc2UgXFxcIndcXFwiOlxcblxcblxcdFxcdFxcdFxcdC8vIG51bWJlciBsMTp7MSwyfSwgbDI6ezJ9LlxcblxcdFxcdFxcdFxcdG9uZU9yVHdvRGlnaXRzSWZMZW5ndGhPbmUoKSB8fCB0d29EaWdpdHNJZkxlbmd0aFR3bygpO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIERheSwgSG91ciwgTWludXRlLCBvciBTZWNvbmRcXG5cXHRcXHRcXHRjYXNlIFxcXCJkXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJoXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJIXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJLXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJrXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJqXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJtXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJzXFxcIjpcXG5cXG5cXHRcXHRcXHRcXHQvLyBudW1iZXIgbDE6ezEsMn0sIGwyOnsyfS5cXG5cXHRcXHRcXHRcXHQvL1xcblxcdFxcdFxcdFxcdC8vIExlbmllbnQgcGFyc2luZzpcXG5cXHRcXHRcXHRcXHQvLyAtIHNrZWxldG9uIFxcXCJobXNcXFwiIChpLmUuLCBvbmUgbSkgYWx3YXlzIGluY2x1ZGVzIG1tIGZvciB0aGUgcGF0dGVybiwgaS5lLiwgaXQnc1xcblxcdFxcdFxcdFxcdC8vICAgaW1wb3NzaWJsZSB0byB1c2UgYSBkaWZmZXJlbnQgc2tlbGV0b24gdG8gcGFyc2Ugbm9uLXplcm8tcGFkZGVkIG1pbnV0ZXMsXFxuXFx0XFx0XFx0XFx0Ly8gICB0aGVyZWZvcmUgcGFyc2VyIGFjY2VwdHMgYm90aCB6ZXJvLXBhZGRlZCBhbmQgbm9uLXplcm8tcGFkZGVkIGZvciBtLiBTaW1pbGFyXFxuXFx0XFx0XFx0XFx0Ly8gICBmb3Igc2Vjb25kcyBzLlxcblxcdFxcdFxcdFxcdC8vIC0gc2tlbGV0b24gXFxcImhtc1xcXCIgKGkuZS4sIG9uZSBoKSBtYXkgaW5jbHVkZSBoIG9yIGhoIGZvciB0aGUgcGF0dGVybiwgaS5lLiwgaXQnc1xcblxcdFxcdFxcdFxcdC8vICAgaW1wb3NzaWJsZSB0byB1c2UgYSBkaWZmZXJlbnQgc2tlbGV0b24gdG8gcGFyc2VyIG5vbi16ZXJvLXBhZGRlZCBob3VycyBmb3Igc29tZVxcblxcdFxcdFxcdFxcdC8vICAgbG9jYWxlcywgdGhlcmVmb3JlIHBhcnNlciBhY2NlcHRzIGJvdGggemVyby1wYWRkZWQgYW5kIG5vbi16ZXJvLXBhZGRlZCBmb3IgaC5cXG5cXHRcXHRcXHRcXHQvLyAgIFNpbWlsYXIgZm9yIGQgKGluIHNrZWxldG9uIHlNZCkuXFxuXFx0XFx0XFx0XFx0b25lT3JUd29EaWdpdHNJZkxlbmd0aE9uZU9yVHdvKCk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiU1xcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbnVtYmVyIHtsfS5cXG5cXG5cXHRcXHRcXHRcXHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcXFxke2xlbmd0aH0vXFxuXFx0XFx0XFx0XFx0bnVtZXJpYyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFxcXCJeKFxcXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcXFwiKXtcXFwiICsgbGVuZ3RoICsgXFxcIn1cXFwiICk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiQVxcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbnVtYmVyIHtsKzV9LlxcblxcblxcdFxcdFxcdFxcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxcXGR7bGVuZ3RoKzV9L1xcblxcdFxcdFxcdFxcdG51bWVyaWMgPSB0cnVlO1xcblxcdFxcdFxcdFxcdHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcXFwiXihcXFwiICsgZGlnaXRzUmUuc291cmNlICsgXFxcIil7XFxcIiArICggbGVuZ3RoICsgNSApICsgXFxcIn1cXFwiICk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gWm9uZVxcblxcdFxcdFxcdGNhc2UgXFxcInZcXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcIlZcXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcInpcXFwiOlxcblxcdFxcdFxcdFxcdGlmICggdG9rZW5SZSAmJiB0b2tlblJlLnRlc3QoIHZhbHVlICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICggY2hyID09PSBcXFwiVlxcXCIgJiYgbGVuZ3RoID09PSAyICkge1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0Y2FzZSBcXFwiT1xcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTzogXFxcIntnbXRGb3JtYXR9K0g7e2dtdEZvcm1hdH0tSFxcXCIgb3IgXFxcIntnbXRaZXJvRm9ybWF0fVxcXCIsIGVnLiBcXFwiR01ULThcXFwiIG9yIFxcXCJHTVRcXFwiLlxcblxcdFxcdFxcdFxcdC8vIE9PT086IFxcXCJ7Z210Rm9ybWF0fXtob3VyRm9ybWF0fVxcXCIgb3IgXFxcIntnbXRaZXJvRm9ybWF0fVxcXCIsIGVnLiBcXFwiR01ULTA4OjAwXFxcIiBvciBcXFwiR01UXFxcIi5cXG5cXHRcXHRcXHRcXHRpZiAoIHZhbHVlID09PSBwcm9wZXJ0aWVzWyBcXFwidGltZVpvbmVOYW1lcy9nbXRaZXJvRm9ybWF0XFxcIiBdICkge1xcblxcdFxcdFxcdFxcdFxcdHRva2VuLnZhbHVlID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR0b2tlblJlID0gcHJvcGVydGllc1sgXFxcInRpbWVab25lTmFtZXMvZ210WmVyb0Zvcm1hdFJlXFxcIiBdO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0YXV4ID0gcHJvcGVydGllc1sgXFxcInRpbWVab25lTmFtZXMvaG91ckZvcm1hdFxcXCIgXS5zb21lKGZ1bmN0aW9uKCBob3VyRm9ybWF0UmUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBob3VyRm9ybWF0UGFyc2UoIGhvdXJGb3JtYXRSZSwgbnVtYmVyUGFyc2VyICkgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG9rZW5SZSA9IGhvdXJGb3JtYXRSZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhYXV4ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiWFxcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2FtZSBhcyB4KiwgZXhjZXB0IGl0IHVzZXMgXFxcIlpcXFwiIGZvciB6ZXJvIG9mZnNldC5cXG5cXHRcXHRcXHRcXHRpZiAoIHZhbHVlID09PSBcXFwiWlxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG9rZW4udmFsdWUgPSAwO1xcblxcdFxcdFxcdFxcdFxcdHRva2VuUmUgPSAvXlovO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0Y2FzZSBcXFwieFxcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8geDogaG91ckZvcm1hdChcXFwiK0hIW21tXTstSEhbbW1dXFxcIilcXG5cXHRcXHRcXHRcXHQvLyB4eDogaG91ckZvcm1hdChcXFwiK0hIbW07LUhIbW1cXFwiKVxcblxcdFxcdFxcdFxcdC8vIHh4eDogaG91ckZvcm1hdChcXFwiK0hIOm1tOy1ISDptbVxcXCIpXFxuXFx0XFx0XFx0XFx0Ly8geHh4eDogaG91ckZvcm1hdChcXFwiK0hIbW1bc3NdOy1ISG1tW3NzXVxcXCIpXFxuXFx0XFx0XFx0XFx0Ly8geHh4eHg6IGhvdXJGb3JtYXQoXFxcIitISDptbVs6c3NdOy1ISDptbVs6c3NdXFxcIilcXG5cXHRcXHRcXHRcXHRhdXggPSBwcm9wZXJ0aWVzLnguc29tZShmdW5jdGlvbiggaG91ckZvcm1hdFJlICkge1xcblxcdFxcdFxcdFxcdFxcdGlmICggaG91ckZvcm1hdFBhcnNlKCBob3VyRm9ybWF0UmUgKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b2tlblJlID0gaG91ckZvcm1hdFJlO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRpZiAoICFhdXggKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcIidcXFwiOlxcblxcdFxcdFxcdFxcdHRva2VuLnR5cGUgPSBcXFwibGl0ZXJhbFxcXCI7XFxuXFx0XFx0XFx0XFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHJlZ2V4cEVzY2FwZSggcmVtb3ZlTGl0ZXJhbFF1b3RlcyggY3VycmVudCApICkgKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdHRva2VuLnR5cGUgPSBcXFwibGl0ZXJhbFxcXCI7XFxuXFx0XFx0XFx0XFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHJlZ2V4cEVzY2FwZSggY3VycmVudCApICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggIXRva2VuUmUgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBHZXQgbGV4ZW1lIGFuZCBjb25zdW1lIGl0LlxcblxcdFxcdHZhbHVlID0gdmFsdWUucmVwbGFjZSggdG9rZW5SZSwgZnVuY3Rpb24oIGxleGVtZSApIHtcXG5cXHRcXHRcXHR0b2tlbi5sZXhlbWUgPSBsZXhlbWU7XFxuXFx0XFx0XFx0aWYgKCBudW1lcmljICkge1xcblxcdFxcdFxcdFxcdHRva2VuLnZhbHVlID0gbnVtYmVyUGFyc2VyKCBsZXhlbWUgKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIFxcXCJcXFwiO1xcblxcdFxcdH0pO1xcblxcblxcdFxcdGlmICggIXRva2VuLmxleGVtZSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggbnVtZXJpYyAmJiBpc05hTiggdG9rZW4udmFsdWUgKSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRva2Vucy5wdXNoKCB0b2tlbiApO1xcblxcdFxcdHJldHVybiB0cnVlO1xcblxcdH0pO1xcblxcblxcdGlmICggdmFsdWUgIT09IFxcXCJcXFwiICkge1xcblxcdFxcdHZhbGlkID0gZmFsc2U7XFxuXFx0fVxcblxcblxcdHJldHVybiB2YWxpZCA/IHRva2VucyA6IFtdO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIGRhdGVQYXJzZXJGbiA9IGZ1bmN0aW9uKCBudW1iZXJQYXJzZXIsIHBhcnNlUHJvcGVydGllcywgdG9rZW5pemVyUHJvcGVydGllcyApIHtcXG5cXHRyZXR1cm4gZnVuY3Rpb24gZGF0ZVBhcnNlciggdmFsdWUgKSB7XFxuXFx0XFx0dmFyIHRva2VucztcXG5cXG5cXHRcXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdFxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXG5cXHRcXHR0b2tlbnMgPSBkYXRlVG9rZW5pemVyKCB2YWx1ZSwgbnVtYmVyUGFyc2VyLCB0b2tlbml6ZXJQcm9wZXJ0aWVzICk7XFxuXFx0XFx0cmV0dXJuIGRhdGVQYXJzZSggdmFsdWUsIHRva2VucywgcGFyc2VQcm9wZXJ0aWVzICkgfHwgbnVsbDtcXG5cXHR9O1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIG9iamVjdEZpbHRlciA9IGZ1bmN0aW9uKCBvYmplY3QsIHRlc3RSZSApIHtcXG5cXHR2YXIga2V5LFxcblxcdFxcdGNvcHkgPSB7fTtcXG5cXG5cXHRmb3IgKCBrZXkgaW4gb2JqZWN0ICkge1xcblxcdFxcdGlmICggdGVzdFJlLnRlc3QoIGtleSApICkge1xcblxcdFxcdFxcdGNvcHlbIGtleSBdID0gb2JqZWN0WyBrZXkgXTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBjb3B5O1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogdG9rZW5pemVyUHJvcGVydGllcyggcGF0dGVybiwgY2xkciApXFxuICpcXG4gKiBAcGF0dGVybiBbU3RyaW5nXSByYXcgcGF0dGVybi5cXG4gKlxcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cXG4gKlxcbiAqIFJldHVybiBPYmplY3Qgd2l0aCBkYXRhIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IHRva2VuaXplci5cXG4gKi9cXG52YXIgZGF0ZVRva2VuaXplclByb3BlcnRpZXMgPSBmdW5jdGlvbiggcGF0dGVybiwgY2xkciwgdGltZVpvbmUgKSB7XFxuXFx0dmFyIGRpZ2l0c1JlU291cmNlLFxcblxcdFxcdHByb3BlcnRpZXMgPSB7XFxuXFx0XFx0XFx0cGF0dGVybjogbG9vc2VNYXRjaGluZyggcGF0dGVybiApXFxuXFx0XFx0fSxcXG5cXHRcXHR0aW1lU2VwYXJhdG9yID0gbnVtYmVyU3ltYm9sKCBcXFwidGltZVNlcGFyYXRvclxcXCIsIGNsZHIgKSxcXG5cXHRcXHR3aWR0aHMgPSBbIFxcXCJhYmJyZXZpYXRlZFxcXCIsIFxcXCJ3aWRlXFxcIiwgXFxcIm5hcnJvd1xcXCIgXTtcXG5cXG5cXHRkaWdpdHNSZVNvdXJjZSA9IG51bWJlck51bWJlcmluZ1N5c3RlbURpZ2l0c01hcCggY2xkciApO1xcblxcdGRpZ2l0c1JlU291cmNlID0gZGlnaXRzUmVTb3VyY2UgPyBcXFwiW1xcXCIgKyBkaWdpdHNSZVNvdXJjZSArIFxcXCJdXFxcIiA6IFxcXCJcXFxcXFxcXGRcXFwiO1xcblxcdHByb3BlcnRpZXMuZGlnaXRzUmUgPSBuZXcgUmVnRXhwKCBkaWdpdHNSZVNvdXJjZSApO1xcblxcblxcdC8vIFRyYW5zZm9ybTpcXG5cXHQvLyAtIFxcXCIrSDstSFxcXCIgLT4gL1xcXFwrKFxcXFxkXFxcXGQ/KXwtKFxcXFxkXFxcXGQ/KS9cXG5cXHQvLyAtIFxcXCIrSEg7LUhIXFxcIiAtPiAvXFxcXCsoXFxcXGRcXFxcZCl8LShcXFxcZFxcXFxkKS9cXG5cXHQvLyAtIFxcXCIrSEhtbTstSEhtbVxcXCIgLT4gL1xcXFwrKFxcXFxkXFxcXGQpKFxcXFxkXFxcXGQpfC0oXFxcXGRcXFxcZCkoXFxcXGRcXFxcZCkvXFxuXFx0Ly8gLSBcXFwiK0hIOm1tOy1ISDptbVxcXCIgLT4gL1xcXFwrKFxcXFxkXFxcXGQpOihcXFxcZFxcXFxkKXwtKFxcXFxkXFxcXGQpOihcXFxcZFxcXFxkKS9cXG5cXHQvL1xcblxcdC8vIElmIGdtdEZvcm1hdCBpcyBHTVR7MH0sIHRoZSByZWdleHAgbXVzdCBmaWxsIHswfSBpbiBlYWNoIHNpZGUsIGUuZy46XFxuXFx0Ly8gLSBcXFwiK0g7LUhcXFwiIC0+IC9HTVRcXFxcKyhcXFxcZFxcXFxkPyl8R01ULShcXFxcZFxcXFxkPykvXFxuXFx0ZnVuY3Rpb24gaG91ckZvcm1hdFJlKCBob3VyRm9ybWF0LCBnbXRGb3JtYXQsIGRpZ2l0c1JlU291cmNlLCB0aW1lU2VwYXJhdG9yICkge1xcblxcdFxcdHZhciByZTtcXG5cXG5cXHRcXHRpZiAoICFkaWdpdHNSZVNvdXJjZSApIHtcXG5cXHRcXHRcXHRkaWdpdHNSZVNvdXJjZSA9IFxcXCJcXFxcXFxcXGRcXFwiO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoICFnbXRGb3JtYXQgKSB7XFxuXFx0XFx0XFx0Z210Rm9ybWF0ID0gXFxcInswfVxcXCI7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJlID0gaG91ckZvcm1hdFxcblxcdFxcdFxcdC5yZXBsYWNlKCBcXFwiK1xcXCIsIFxcXCJcXFxcXFxcXCtcXFwiIClcXG5cXG5cXHRcXHRcXHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gKFxcXFxcXFxcZFxcXFxcXFxcZClcXG5cXHRcXHRcXHQucmVwbGFjZSggL0hIfG1tfHNzL2csIFxcXCIoKFxcXCIgKyBkaWdpdHNSZVNvdXJjZSArIFxcXCIpezJ9KVxcXCIgKVxcblxcblxcdFxcdFxcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAoXFxcXFxcXFxkXFxcXFxcXFxkPylcXG5cXHRcXHRcXHQucmVwbGFjZSggL0h8bS9nLCBcXFwiKChcXFwiICsgZGlnaXRzUmVTb3VyY2UgKyBcXFwiKXsxLDJ9KVxcXCIgKTtcXG5cXG5cXHRcXHRpZiAoIHRpbWVTZXBhcmF0b3IgKSB7XFxuXFx0XFx0XFx0cmUgPSByZS5yZXBsYWNlKCAvOi9nLCB0aW1lU2VwYXJhdG9yICk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJlID0gcmUuc3BsaXQoIFxcXCI7XFxcIiApLm1hcChmdW5jdGlvbiggcGFydCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZ210Rm9ybWF0LnJlcGxhY2UoIFxcXCJ7MH1cXFwiLCBwYXJ0ICk7XFxuXFx0XFx0fSkuam9pbiggXFxcInxcXFwiICk7XFxuXFxuXFx0XFx0cmV0dXJuIG5ldyBSZWdFeHAoIFxcXCJeXFxcIiArIHJlICk7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHBvcHVsYXRlUHJvcGVydGllcyggcGF0aCwgdmFsdWUgKSB7XFxuXFxuXFx0XFx0Ly8gU2tpcFxcblxcdFxcdHZhciBza2lwUmUgPSAvKHRpbWVab25lTmFtZXNcXFxcL3pvbmV8c3VwcGxlbWVudGFsXFxcXC9tZXRhWm9uZXN8dGltZVpvbmVOYW1lc1xcXFwvbWV0YXpvbmV8dGltZVpvbmVOYW1lc1xcXFwvcmVnaW9uRm9ybWF0fHRpbWVab25lTmFtZXNcXFxcL2dtdEZvcm1hdCkvO1xcblxcdFxcdGlmICggc2tpcFJlLnRlc3QoIHBhdGggKSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggIXZhbHVlICkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gVGhlIGBkYXRlc2AgYW5kIGBjYWxlbmRhcnNgIHRyaW0ncyBwdXJwb3NlIGlzIHRvIHJlZHVjZSBwcm9wZXJ0aWVzJyBrZXkgc2l6ZSBvbmx5LlxcblxcdFxcdHBhdGggPSBwYXRoLnJlcGxhY2UoIC9eLipcXFxcL2RhdGVzXFxcXC8vLCBcXFwiXFxcIiApLnJlcGxhY2UoIC9jYWxlbmRhcnNcXFxcLy8sIFxcXCJcXFwiICk7XFxuXFxuXFx0XFx0Ly8gU3BlY2lmaWMgZmlsdGVyIGZvciBcXFwiZ3JlZ29yaWFuL2RheVBlcmlvZHMvZm9ybWF0L3dpZGVcXFwiLlxcblxcdFxcdGlmICggcGF0aCA9PT0gXFxcImdyZWdvcmlhbi9kYXlQZXJpb2RzL2Zvcm1hdC93aWRlXFxcIiApIHtcXG5cXHRcXHRcXHR2YWx1ZSA9IG9iamVjdEZpbHRlciggdmFsdWUsIC9eYW18XnBtLyApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBUcmFuc2Zvcm0gb2JqZWN0IGludG8gYXJyYXkgb2YgcGFpcnMgW2tleSwgL3ZhbHVlL10sIHNvcnQgYnkgZGVzYyB2YWx1ZSBsZW5ndGguXFxuXFx0XFx0aWYgKCBpc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xcblxcdFxcdFxcdHZhbHVlID0gT2JqZWN0LmtleXMoIHZhbHVlICkubWFwKGZ1bmN0aW9uKCBrZXkgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFsga2V5LCBuZXcgUmVnRXhwKCBcXFwiXlxcXCIgKyByZWdleHBFc2NhcGUoIGxvb3NlTWF0Y2hpbmcoIHZhbHVlWyBrZXkgXSApICkgKSBdO1xcblxcdFxcdFxcdH0pLnNvcnQoZnVuY3Rpb24oIGEsIGIgKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGJbIDEgXS5zb3VyY2UubGVuZ3RoIC0gYVsgMSBdLnNvdXJjZS5sZW5ndGg7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0Ly8gSWYgdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIi5cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHZhbHVlID0gbG9vc2VNYXRjaGluZyggdmFsdWUgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cHJvcGVydGllc1sgcGF0aCBdID0gdmFsdWU7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHJlZ2V4cFNvdXJjZVNvbWVUZXJtKCB0ZXJtcyApIHtcXG5cXHRcXHRyZXR1cm4gXFxcIihcXFwiICsgdGVybXMuZmlsdGVyKGZ1bmN0aW9uKCBpdGVtICkge1xcblxcdFxcdFxcdHJldHVybiBpdGVtO1xcblxcdFxcdH0pLnJlZHVjZShmdW5jdGlvbiggbWVtbywgaXRlbSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gbWVtbyArIFxcXCJ8XFxcIiArIGl0ZW07XFxuXFx0XFx0fSkgKyBcXFwiKVxcXCI7XFxuXFx0fVxcblxcblxcdGNsZHIub24oIFxcXCJnZXRcXFwiLCBwb3B1bGF0ZVByb3BlcnRpZXMgKTtcXG5cXG5cXHRwYXR0ZXJuLm1hdGNoKCBkYXRlUGF0dGVyblJlICkuZm9yRWFjaChmdW5jdGlvbiggY3VycmVudCApIHtcXG5cXHRcXHR2YXIgYXV4LCBjaHIsIGRheWxpZ2h0VHpOYW1lLCBnbXRGb3JtYXQsIGxlbmd0aCwgc3RhbmRhcmRUek5hbWU7XFxuXFxuXFx0XFx0Y2hyID0gY3VycmVudC5jaGFyQXQoIDAgKTtcXG5cXHRcXHRsZW5ndGggPSBjdXJyZW50Lmxlbmd0aDtcXG5cXG5cXHRcXHRpZiAoIGNociA9PT0gXFxcIlpcXFwiICkge1xcblxcdFxcdFxcdGlmICggbGVuZ3RoIDwgNSApIHtcXG5cXHRcXHRcXHRcXHRjaHIgPSBcXFwiT1xcXCI7XFxuXFx0XFx0XFx0XFx0bGVuZ3RoID0gNDtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGNociA9IFxcXCJYXFxcIjtcXG5cXHRcXHRcXHRcXHRsZW5ndGggPSA1O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gei4uLnp6ejogXFxcIntzaG9ydFJlZ2lvbn1cXFwiLCBlZy4gXFxcIlBTVFxcXCIgb3IgXFxcIlBEVFxcXCIuXFxuXFx0XFx0Ly8genp6ejogXFxcIntyZWdpb25OYW1lfSB7U3RhbmRhcmQgVGltZX1cXFwiIG9yIFxcXCJ7cmVnaW9uTmFtZX0ge0RheWxpZ2h0IFRpbWV9XFxcIixcXG5cXHRcXHQvLyAgICAgICBlLmcuLCBcXFwiUGFjaWZpYyBTdGFuZGFyZCBUaW1lXFxcIiBvciBcXFwiUGFjaWZpYyBEYXlsaWdodCBUaW1lXFxcIi5cXG5cXHRcXHQvLyBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xcblxcdFxcdGlmICggY2hyID09PSBcXFwielxcXCIgKSB7XFxuXFx0XFx0XFx0c3RhbmRhcmRUek5hbWUgPSBkYXRlR2V0VGltZVpvbmVOYW1lKCBsZW5ndGgsIFxcXCJzdGFuZGFyZFxcXCIsIHRpbWVab25lLCBjbGRyICk7XFxuXFx0XFx0XFx0ZGF5bGlnaHRUek5hbWUgPSBkYXRlR2V0VGltZVpvbmVOYW1lKCBsZW5ndGgsIFxcXCJkYXlsaWdodFxcXCIsIHRpbWVab25lLCBjbGRyICk7XFxuXFx0XFx0XFx0aWYgKCBzdGFuZGFyZFR6TmFtZSApIHtcXG5cXHRcXHRcXHRcXHRzdGFuZGFyZFR6TmFtZSA9IHJlZ2V4cEVzY2FwZSggbG9vc2VNYXRjaGluZyggc3RhbmRhcmRUek5hbWUgKSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIGRheWxpZ2h0VHpOYW1lICkge1xcblxcdFxcdFxcdFxcdGRheWxpZ2h0VHpOYW1lID0gcmVnZXhwRXNjYXBlKCBsb29zZU1hdGNoaW5nKCBkYXlsaWdodFR6TmFtZSApICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggc3RhbmRhcmRUek5hbWUgfHwgZGF5bGlnaHRUek5hbWUgKSB7XFxuXFx0XFx0XFx0XFx0cHJvcGVydGllcy5zdGFuZGFyZE9yRGF5bGlnaHRUek5hbWUgPSBuZXcgUmVnRXhwKFxcblxcdFxcdFxcdFxcdFxcdFxcXCJeXFxcIiArIHJlZ2V4cFNvdXJjZVNvbWVUZXJtKFsgc3RhbmRhcmRUek5hbWUsIGRheWxpZ2h0VHpOYW1lIF0pXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRmFsbCB0aHJvdWdoIHRoZSBcXFwiT1xcXCIgZm9ybWF0IGluIGNhc2Ugb25lIG5hbWUgaXMgbWlzc2luZy5cXG5cXHRcXHRcXHRpZiAoICFzdGFuZGFyZFR6TmFtZSB8fCAhZGF5bGlnaHRUek5hbWUgKSB7XFxuXFx0XFx0XFx0XFx0Y2hyID0gXFxcIk9cXFwiO1xcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoIDwgNCApIHtcXG5cXHRcXHRcXHRcXHRcXHRsZW5ndGggPSAxO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIHYuLi52dnY6IFxcXCJ7c2hvcnRSZWdpb259XFxcIiwgZWcuIFxcXCJQVFxcXCIuXFxuXFx0XFx0Ly8gdnZ2djogXFxcIntyZWdpb25OYW1lfSB7VGltZX1cXFwiIG9yIFxcXCJ7cmVnaW9uTmFtZX0ge1RpbWV9XFxcIixcXG5cXHRcXHQvLyBlLmcuLCBcXFwiUGFjaWZpYyBUaW1lXFxcIlxcblxcdFxcdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXFxuXFx0XFx0aWYgKCBjaHIgPT09IFxcXCJ2XFxcIiApIHtcXG5cXHRcXHRcXHRpZiAoIGxlbmd0aCAhPT0gMSAmJiBsZW5ndGggIT09IDQgKSB7XFxuXFx0XFx0XFx0XFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xcblxcdFxcdFxcdFxcdFxcdGZlYXR1cmU6IFxcXCJ0aW1lem9uZSBwYXR0ZXJuIGBcXFwiICsgcGF0dGVybiArIFxcXCJgXFxcIlxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgZ2VuZXJpY1R6TmFtZSA9IGRhdGVHZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgXFxcImdlbmVyaWNcXFwiLCB0aW1lWm9uZSwgY2xkciApO1xcblxcdFxcdFxcdGlmICggZ2VuZXJpY1R6TmFtZSApIHtcXG5cXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLmdlbmVyaWNUek5hbWUgPSBuZXcgUmVnRXhwKFxcblxcdFxcdFxcdFxcdFxcdFxcXCJeXFxcIiArIHJlZ2V4cEVzY2FwZSggbG9vc2VNYXRjaGluZyggZ2VuZXJpY1R6TmFtZSApIClcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdGNociA9IFxcXCJPXFxcIjtcXG5cXG5cXHRcXHRcXHQvLyBGYWxsIGJhY2sgdG8gXFxcIlZcXFwiIGZvcm1hdC5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGNociA9IFxcXCJWXFxcIjtcXG5cXHRcXHRcXHRcXHRsZW5ndGggPSA0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0c3dpdGNoICggY2hyICkge1xcblxcblxcdFxcdFxcdC8vIEVyYVxcblxcdFxcdFxcdGNhc2UgXFxcIkdcXFwiOlxcblxcdFxcdFxcdFxcdGNsZHIubWFpbihbXFxuXFx0XFx0XFx0XFx0XFx0XFxcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZXJhc1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0bGVuZ3RoIDw9IDMgPyBcXFwiZXJhQWJiclxcXCIgOiAoIGxlbmd0aCA9PT0gNCA/IFxcXCJlcmFOYW1lc1xcXCIgOiBcXFwiZXJhTmFycm93XFxcIiApXFxuXFx0XFx0XFx0XFx0XSk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gWWVhclxcblxcdFxcdFxcdGNhc2UgXFxcInVcXFwiOiAvLyBFeHRlbmRlZCB5ZWFyLiBOZWVkIHRvIGJlIGltcGxlbWVudGVkLlxcblxcdFxcdFxcdGNhc2UgXFxcIlVcXFwiOiAvLyBDeWNsaWMgeWVhciBuYW1lLiBOZWVkIHRvIGJlIGltcGxlbWVudGVkLlxcblxcdFxcdFxcdFxcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcXG5cXHRcXHRcXHRcXHRcXHRmZWF0dXJlOiBcXFwieWVhciBwYXR0ZXJuIGBcXFwiICsgY2hyICsgXFxcImBcXFwiXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gUXVhcnRlclxcblxcdFxcdFxcdGNhc2UgXFxcIlFcXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcInFcXFwiOlxcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoID4gMiApIHtcXG5cXHRcXHRcXHRcXHRcXHRjbGRyLm1haW4oW1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL3F1YXJ0ZXJzXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaHIgPT09IFxcXCJRXFxcIiA/IFxcXCJmb3JtYXRcXFwiIDogXFxcInN0YW5kLWFsb25lXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aWR0aHNbIGxlbmd0aCAtIDMgXVxcblxcdFxcdFxcdFxcdFxcdF0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBNb250aFxcblxcdFxcdFxcdGNhc2UgXFxcIk1cXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcIkxcXFwiOlxcblxcblxcdFxcdFxcdFxcdC8vIG51bWJlciBsPTE6ezEsMn0sIGw9Mjp7Mn0uXFxuXFx0XFx0XFx0XFx0Ly8gbG9va3VwIGw9My4uLlxcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoID4gMiApIHtcXG5cXHRcXHRcXHRcXHRcXHRjbGRyLm1haW4oW1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL21vbnRoc1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2hyID09PSBcXFwiTVxcXCIgPyBcXFwiZm9ybWF0XFxcIiA6IFxcXCJzdGFuZC1hbG9uZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0d2lkdGhzWyBsZW5ndGggLSAzIF1cXG5cXHRcXHRcXHRcXHRcXHRdKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gRGF5XFxuXFx0XFx0XFx0Y2FzZSBcXFwiZ1xcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTW9kaWZpZWQgSnVsaWFuIGRheS4gTmVlZCB0byBiZSBpbXBsZW1lbnRlZC5cXG5cXHRcXHRcXHRcXHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XFxuXFx0XFx0XFx0XFx0XFx0ZmVhdHVyZTogXFxcIkp1bGlhbiBkYXkgcGF0dGVybiBgZ2BcXFwiXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gV2VlayBkYXlcXG5cXHRcXHRcXHRjYXNlIFxcXCJlXFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJjXFxcIjpcXG5cXG5cXHRcXHRcXHRcXHQvLyBsb29rdXAgZm9yIGxlbmd0aCA+PTMuXFxuXFx0XFx0XFx0XFx0aWYgKCBsZW5ndGggPD0gMiApIHtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdGNhc2UgXFxcIkVcXFwiOlxcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoID09PSA2ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE5vdGU6IGlmIHNob3J0IGRheSBuYW1lcyBhcmUgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkLCBhYmJyZXZpYXRlZCBkYXlcXG5cXHRcXHRcXHRcXHRcXHQvLyBuYW1lcyBhcmUgdXNlZCBpbnN0ZWFkIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNtb250aHNfZGF5c19xdWFydGVyc19lcmFzXFxuXFx0XFx0XFx0XFx0XFx0Y2xkci5tYWluKFtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlzXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRbIGNociA9PT0gXFxcImNcXFwiID8gXFxcInN0YW5kLWFsb25lXFxcIiA6IFxcXCJmb3JtYXRcXFwiIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcInNob3J0XFxcIlxcblxcdFxcdFxcdFxcdFxcdF0pIHx8IGNsZHIubWFpbihbXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5c1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0WyBjaHIgPT09IFxcXCJjXFxcIiA/IFxcXCJzdGFuZC1hbG9uZVxcXCIgOiBcXFwiZm9ybWF0XFxcIiBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJhYmJyZXZpYXRlZFxcXCJcXG5cXHRcXHRcXHRcXHRcXHRdKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGNsZHIubWFpbihbXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5c1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0WyBjaHIgPT09IFxcXCJjXFxcIiA/IFxcXCJzdGFuZC1hbG9uZVxcXCIgOiBcXFwiZm9ybWF0XFxcIiBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdHdpZHRoc1sgbGVuZ3RoIDwgMyA/IDAgOiBsZW5ndGggLSAzIF1cXG5cXHRcXHRcXHRcXHRcXHRdKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gUGVyaW9kIChBTSBvciBQTSlcXG5cXHRcXHRcXHRjYXNlIFxcXCJhXFxcIjpcXG5cXHRcXHRcXHRcXHRjbGRyLm1haW4oXFxuXFx0XFx0XFx0XFx0XFx0XFxcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5UGVyaW9kcy9mb3JtYXQvd2lkZVxcXCJcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIFpvbmVcXG5cXHRcXHRcXHRjYXNlIFxcXCJWXFxcIjpcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGxlbmd0aCA9PT0gMSApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmVhdHVyZTogXFxcInRpbWV6b25lIHBhdHRlcm4gYFxcXCIgKyBwYXR0ZXJuICsgXFxcImBcXFwiXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggdGltZVpvbmUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsZW5ndGggPT09IDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU2tpcCBsb29zZU1hdGNoaW5nIHByb2Nlc3Npbmcgc2luY2UgdGltZVpvbmUgaXMgYSBjYW5vbmljYWwgcG9zaXggdmFsdWUuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cHJvcGVydGllcy50aW1lWm9uZU5hbWUgPSB0aW1lWm9uZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLnRpbWVab25lTmFtZVJlID0gbmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgcmVnZXhwRXNjYXBlKCB0aW1lWm9uZSApICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0aW1lWm9uZU5hbWUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXhlbXBsYXJDaXR5ID0gY2xkci5tYWluKFtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwiZGF0ZXMvdGltZVpvbmVOYW1lcy96b25lXFxcIiwgdGltZVpvbmUsIFxcXCJleGVtcGxhckNpdHlcXFwiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsZW5ndGggPT09IDMgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhZXhlbXBsYXJDaXR5ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGV4ZW1wbGFyQ2l0eSA9IGNsZHIubWFpbihbXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImRhdGVzL3RpbWVab25lTmFtZXMvem9uZS9FdGMvVW5rbm93bi9leGVtcGxhckNpdHlcXFwiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWVab25lTmFtZSA9IGV4ZW1wbGFyQ2l0eTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBleGVtcGxhckNpdHkgJiYgbGVuZ3RoID09PSA0ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWVab25lTmFtZSA9IGZvcm1hdE1lc3NhZ2UoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2xkci5tYWluKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcXCJkYXRlcy90aW1lWm9uZU5hbWVzL3JlZ2lvbkZvcm1hdFxcXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFsgZXhlbXBsYXJDaXR5IF1cXG5cXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRpbWVab25lTmFtZSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aW1lWm9uZU5hbWUgPSBsb29zZU1hdGNoaW5nKCB0aW1lWm9uZU5hbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLnRpbWVab25lTmFtZVJlID0gbmV3IFJlZ0V4cChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwiXlxcXCIgKyByZWdleHBFc2NhcGUoIHRpbWVab25lTmFtZSApXFxuXFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggY3VycmVudCA9PT0gXFxcInZcXFwiICkge1xcblxcdFxcdFxcdFxcdFxcdGxlbmd0aCA9IDE7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRjYXNlIFxcXCJ6XFxcIjpcXG5cXHRcXHRcXHRjYXNlIFxcXCJPXFxcIjpcXG5cXHRcXHRcXHRcXHRnbXRGb3JtYXQgPSBjbGRyLm1haW4oIFxcXCJkYXRlcy90aW1lWm9uZU5hbWVzL2dtdEZvcm1hdFxcXCIgKTtcXG5cXHRcXHRcXHRcXHRjbGRyLm1haW4oIFxcXCJkYXRlcy90aW1lWm9uZU5hbWVzL2dtdFplcm9Gb3JtYXRcXFwiICk7XFxuXFx0XFx0XFx0XFx0Y2xkci5tYWluKCBcXFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9ob3VyRm9ybWF0XFxcIiApO1xcblxcdFxcdFxcdFxcdHByb3BlcnRpZXNbIFxcXCJ0aW1lWm9uZU5hbWVzL2dtdFplcm9Gb3JtYXRSZVxcXCIgXSA9XFxuXFx0XFx0XFx0XFx0XFx0bmV3IFJlZ0V4cCggXFxcIl5cXFwiICsgcmVnZXhwRXNjYXBlKCBwcm9wZXJ0aWVzWyBcXFwidGltZVpvbmVOYW1lcy9nbXRaZXJvRm9ybWF0XFxcIiBdICkgKTtcXG5cXHRcXHRcXHRcXHRhdXggPSBwcm9wZXJ0aWVzWyBcXFwidGltZVpvbmVOYW1lcy9ob3VyRm9ybWF0XFxcIiBdO1xcblxcdFxcdFxcdFxcdHByb3BlcnRpZXNbIFxcXCJ0aW1lWm9uZU5hbWVzL2hvdXJGb3JtYXRcXFwiIF0gPSAoXFxuXFx0XFx0XFx0XFx0XFx0bGVuZ3RoIDwgNCA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0WyBkYXRlVGltZXpvbmVIb3VyRm9ybWF0SG0oIGF1eCwgXFxcIkhcXFwiICksIGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIKCBhdXggKSBdIDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRbIGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIbSggYXV4LCBcXFwiSEhcXFwiICkgXVxcblxcdFxcdFxcdFxcdCkubWFwKGZ1bmN0aW9uKCBob3VyRm9ybWF0ICkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBob3VyRm9ybWF0UmUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0aG91ckZvcm1hdCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbXRGb3JtYXQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlnaXRzUmVTb3VyY2UsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZVNlcGFyYXRvclxcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdGNhc2UgXFxcIlhcXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcInhcXFwiOlxcblxcblxcdFxcdFxcdFxcdC8vIHg6IGhvdXJGb3JtYXQoXFxcIitISFttbV07LUhIW21tXVxcXCIpXFxuXFx0XFx0XFx0XFx0Ly8geHg6IGhvdXJGb3JtYXQoXFxcIitISG1tOy1ISG1tXFxcIilcXG5cXHRcXHRcXHRcXHQvLyB4eHg6IGhvdXJGb3JtYXQoXFxcIitISDptbTstSEg6bW1cXFwiKVxcblxcdFxcdFxcdFxcdC8vIHh4eHg6IGhvdXJGb3JtYXQoXFxcIitISG1tW3NzXTstSEhtbVtzc11cXFwiKVxcblxcdFxcdFxcdFxcdC8vIHh4eHh4OiBob3VyRm9ybWF0KFxcXCIrSEg6bW1bOnNzXTstSEg6bW1bOnNzXVxcXCIpXFxuXFx0XFx0XFx0XFx0cHJvcGVydGllcy54ID0gW1xcblxcdFxcdFxcdFxcdFxcdFsgXFxcIitISG1tOy1ISG1tXFxcIiwgXFxcIitISDstSEhcXFwiIF0sXFxuXFx0XFx0XFx0XFx0XFx0WyBcXFwiK0hIbW07LUhIbW1cXFwiIF0sXFxuXFx0XFx0XFx0XFx0XFx0WyBcXFwiK0hIOm1tOy1ISDptbVxcXCIgXSxcXG5cXHRcXHRcXHRcXHRcXHRbIFxcXCIrSEhtbXNzOy1ISG1tc3NcXFwiLCBcXFwiK0hIbW07LUhIbW1cXFwiIF0sXFxuXFx0XFx0XFx0XFx0XFx0WyBcXFwiK0hIOm1tOnNzOy1ISDptbTpzc1xcXCIsIFxcXCIrSEg6bW07LUhIOm1tXFxcIiBdXFxuXFx0XFx0XFx0XFx0XVsgbGVuZ3RoIC0gMSBdLm1hcChmdW5jdGlvbiggaG91ckZvcm1hdCApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gaG91ckZvcm1hdFJlKCBob3VyRm9ybWF0ICk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdGNsZHIub2ZmKCBcXFwiZ2V0XFxcIiwgcG9wdWxhdGVQcm9wZXJ0aWVzICk7XFxuXFxuXFx0cmV0dXJuIHByb3BlcnRpZXM7XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBkYXlPZldlZWsoIGRhdGUsIGZpcnN0RGF5IClcXG4gKlxcbiAqIEBkYXRlXFxuICpcXG4gKiBAZmlyc3REYXkgdGhlIHJlc3VsdCBvZiBgZGF0ZUZpcnN0RGF5T2ZXZWVrKCBjbGRyIClgXFxuICpcXG4gKiBSZXR1cm4gdGhlIGRheSBvZiB0aGUgd2VlayBub3JtYWxpemVkIGJ5IHRoZSB0ZXJyaXRvcnkncyBmaXJzdERheSBbMC02XS5cXG4gKiBFZyBmb3IgXFxcIm1vblxcXCI6XFxuICogLSByZXR1cm4gMCBpZiB0ZXJyaXRvcnkgaXMgR0IsIG9yIEJSLCBvciBERSwgb3IgRlIgKHdlZWsgc3RhcnRzIG9uIFxcXCJtb25cXFwiKTtcXG4gKiAtIHJldHVybiAxIGlmIHRlcnJpdG9yeSBpcyBVUyAod2VlayBzdGFydHMgb24gXFxcInN1blxcXCIpO1xcbiAqIC0gcmV0dXJuIDIgaWYgdGVycml0b3J5IGlzIEVHICh3ZWVrIHN0YXJ0cyBvbiBcXFwic2F0XFxcIik7XFxuICovXFxudmFyIGRhdGVEYXlPZldlZWsgPSBmdW5jdGlvbiggZGF0ZSwgZmlyc3REYXkgKSB7XFxuXFx0cmV0dXJuICggZGF0ZS5nZXREYXkoKSAtIGZpcnN0RGF5ICsgNyApICUgNztcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIGRpc3RhbmNlSW5EYXlzKCBmcm9tLCB0byApXFxuICpcXG4gKiBSZXR1cm4gdGhlIGRpc3RhbmNlIGluIGRheXMgYmV0d2VlbiBmcm9tIGFuZCB0byBEYXRlcy5cXG4gKi9cXG52YXIgZGF0ZURpc3RhbmNlSW5EYXlzID0gZnVuY3Rpb24oIGZyb20sIHRvICkge1xcblxcdHZhciBpbkRheXMgPSA4NjRlNTtcXG5cXHRyZXR1cm4gKCB0by5nZXRUaW1lKCkgLSBmcm9tLmdldFRpbWUoKSApIC8gaW5EYXlzO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogZGF5T2ZZZWFyXFxuICpcXG4gKiBSZXR1cm4gdGhlIGRpc3RhbmNlIGluIGRheXMgb2YgdGhlIGRhdGUgdG8gdGhlIGJlZ2luIG9mIHRoZSB5ZWFyIFswLWRdLlxcbiAqL1xcbnZhciBkYXRlRGF5T2ZZZWFyID0gZnVuY3Rpb24oIGRhdGUgKSB7XFxuXFx0cmV0dXJuIE1hdGguZmxvb3IoIGRhdGVEaXN0YW5jZUluRGF5cyggZGF0ZVN0YXJ0T2YoIGRhdGUsIFxcXCJ5ZWFyXFxcIiApLCBkYXRlICkgKTtcXG59O1xcblxcblxcblxcblxcbi8vIEludmVydCBrZXkgYW5kIHZhbHVlcywgZS5nLiwge1xcXCJ5ZWFyXFxcIjogXFxcInlZXFxcIn0gPT0+IHtcXFwieVxcXCI6IFxcXCJ5ZWFyXFxcIiwgXFxcIllcXFwiOiBcXFwieWVhclxcXCJ9XFxudmFyIGRhdGVGaWVsZHNNYXAgPSBvYmplY3RJbnZlcnQoe1xcblxcdFxcXCJlcmFcXFwiOiBcXFwiR1xcXCIsXFxuXFx0XFxcInllYXJcXFwiOiBcXFwieVlcXFwiLFxcblxcdFxcXCJxdWFydGVyXFxcIjogXFxcInFRXFxcIixcXG5cXHRcXFwibW9udGhcXFwiOiBcXFwiTUxcXFwiLFxcblxcdFxcXCJ3ZWVrXFxcIjogXFxcIndXXFxcIixcXG5cXHRcXFwiZGF5XFxcIjogXFxcImRERlxcXCIsXFxuXFx0XFxcIndlZWtkYXlcXFwiOiBcXFwiZWNFXFxcIixcXG5cXHRcXFwiZGF5cGVyaW9kXFxcIjogXFxcImFcXFwiLFxcblxcdFxcXCJob3VyXFxcIjogXFxcImhIa0tcXFwiLFxcblxcdFxcXCJtaW51dGVcXFwiOiBcXFwibVxcXCIsXFxuXFx0XFxcInNlY29uZFxcXCI6IFxcXCJzU0FcXFwiLFxcblxcdFxcXCJ6b25lXFxcIjogXFxcInp2Vk94WFxcXCJcXG59LCBmdW5jdGlvbiggb2JqZWN0LCBrZXksIHZhbHVlICkge1xcblxcdHZhbHVlLnNwbGl0KCBcXFwiXFxcIiApLmZvckVhY2goZnVuY3Rpb24oIHN5bWJvbCApIHtcXG5cXHRcXHRvYmplY3RbIHN5bWJvbCBdID0ga2V5O1xcblxcdH0pO1xcblxcdHJldHVybiBvYmplY3Q7XFxufSk7XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogbWlsbGlzZWNvbmRzSW5EYXlcXG4gKi9cXG52YXIgZGF0ZU1pbGxpc2Vjb25kc0luRGF5ID0gZnVuY3Rpb24oIGRhdGUgKSB7XFxuXFxuXFx0Ly8gVE9ETyBIYW5kbGUgZGF5bGlnaHQgc2F2aW5ncyBkaXNjb250aW51aXRpZXNcXG5cXHRyZXR1cm4gZGF0ZSAtIGRhdGVTdGFydE9mKCBkYXRlLCBcXFwiZGF5XFxcIiApO1xcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogaG91ckZvcm1hdCggZGF0ZSwgZm9ybWF0LCB0aW1lU2VwYXJhdG9yLCBmb3JtYXROdW1iZXIgKVxcbiAqXFxuICogUmV0dXJuIGRhdGUncyB0aW1lem9uZSBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBmb3JtYXQgcGFzc2VkLlxcbiAqIEVnIGZvciBmb3JtYXQgd2hlbiB0aW1lem9uZSBvZmZzZXQgaXMgMTgwOlxcbiAqIC0gXFxcIitIOy1IXFxcIjogLTNcXG4gKiAtIFxcXCIrSEhtbTstSEhtbVxcXCI6IC0wMzAwXFxuICogLSBcXFwiK0hIOm1tOy1ISDptbVxcXCI6IC0wMzowMFxcbiAqIC0gXFxcIitISDptbTpzczstSEg6bW06c3NcXFwiOiAtMDM6MDA6MDBcXG4gKi9cXG52YXIgZGF0ZVRpbWV6b25lSG91ckZvcm1hdCA9IGZ1bmN0aW9uKCBkYXRlLCBmb3JtYXQsIHRpbWVTZXBhcmF0b3IsIGZvcm1hdE51bWJlciApIHtcXG5cXHR2YXIgYWJzT2Zmc2V0LFxcblxcdFxcdG9mZnNldCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcXG5cXG5cXHRhYnNPZmZzZXQgPSBNYXRoLmFicyggb2Zmc2V0ICk7XFxuXFx0Zm9ybWF0TnVtYmVyID0gZm9ybWF0TnVtYmVyIHx8IHtcXG5cXHRcXHQxOiBmdW5jdGlvbiggdmFsdWUgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHN0cmluZ1BhZCggdmFsdWUsIDEgKTtcXG5cXHRcXHR9LFxcblxcdFxcdDI6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcXG5cXHRcXHRcXHRyZXR1cm4gc3RyaW5nUGFkKCB2YWx1ZSwgMiApO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdHJldHVybiBmb3JtYXRcXG5cXG5cXHRcXHQvLyBQaWNrIHRoZSBjb3JyZWN0IHNpZ24gc2lkZSAoKyBvciAtKS5cXG5cXHRcXHQuc3BsaXQoIFxcXCI7XFxcIiApWyBvZmZzZXQgPiAwID8gMSA6IDAgXVxcblxcblxcdFxcdC8vIExvY2FsaXplIHRpbWUgc2VwYXJhdG9yXFxuXFx0XFx0LnJlcGxhY2UoIFxcXCI6XFxcIiwgdGltZVNlcGFyYXRvciApXFxuXFxuXFx0XFx0Ly8gVXBkYXRlIGhvdXJzIG9mZnNldC5cXG5cXHRcXHQucmVwbGFjZSggL0hIPy8sIGZ1bmN0aW9uKCBtYXRjaCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZm9ybWF0TnVtYmVyWyBtYXRjaC5sZW5ndGggXSggTWF0aC5mbG9vciggYWJzT2Zmc2V0IC8gNjAgKSApO1xcblxcdFxcdH0pXFxuXFxuXFx0XFx0Ly8gVXBkYXRlIG1pbnV0ZXMgb2Zmc2V0IGFuZCByZXR1cm4uXFxuXFx0XFx0LnJlcGxhY2UoIC9tbS8sIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJldHVybiBmb3JtYXROdW1iZXJbIDIgXSggTWF0aC5mbG9vciggYWJzT2Zmc2V0ICUgNjAgKSApO1xcblxcdFxcdH0pXFxuXFxuXFx0XFx0Ly8gVXBkYXRlIG1pbnV0ZXMgb2Zmc2V0IGFuZCByZXR1cm4uXFxuXFx0XFx0LnJlcGxhY2UoIC9zcy8sIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJldHVybiBmb3JtYXROdW1iZXJbIDIgXSggTWF0aC5mbG9vciggYWJzT2Zmc2V0ICUgMSAqIDYwICkgKTtcXG5cXHRcXHR9KTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIGZvcm1hdCggZGF0ZSwgcHJvcGVydGllcyApXFxuICpcXG4gKiBAZGF0ZSBbRGF0ZSBpbnN0YW5jZV0uXFxuICpcXG4gKiBAcHJvcGVydGllc1xcbiAqXFxuICogVE9ETyBTdXBwb3J0IG90aGVyIGNhbGVuZGFyIHR5cGVzLlxcbiAqXFxuICogRGlzY2xvc3VyZTogdGhpcyBmdW5jdGlvbiBib3Jyb3dzIGV4Y2VycHRzIG9mIGRvam8vZGF0ZS9sb2NhbGUuXFxuICovXFxudmFyIGRhdGVGb3JtYXQgPSBmdW5jdGlvbiggZGF0ZSwgbnVtYmVyRm9ybWF0dGVycywgcHJvcGVydGllcyApIHtcXG5cXHR2YXIgcGFydHMgPSBbXTtcXG5cXG5cXHR2YXIgdGltZVNlcGFyYXRvciA9IHByb3BlcnRpZXMudGltZVNlcGFyYXRvcjtcXG5cXG5cXHQvLyBjcmVhdGUgZ2xvYmFsaXplIGRhdGUgd2l0aCBnaXZlbiB0aW1lem9uZSBkYXRhXFxuXFx0aWYgKCBwcm9wZXJ0aWVzLnRpbWVab25lRGF0YSApIHtcXG5cXHRcXHRkYXRlID0gbmV3IFpvbmVkRGF0ZVRpbWUoIGRhdGUsIHByb3BlcnRpZXMudGltZVpvbmVEYXRhKCkgKTtcXG5cXHR9XFxuXFxuXFx0cHJvcGVydGllcy5wYXR0ZXJuLnJlcGxhY2UoIGRhdGVQYXR0ZXJuUmUsIGZ1bmN0aW9uKCBjdXJyZW50ICkge1xcblxcdFxcdHZhciBhdXgsIGRhdGVGaWVsZCwgdHlwZSwgdmFsdWUsXFxuXFx0XFx0XFx0Y2hyID0gY3VycmVudC5jaGFyQXQoIDAgKSxcXG5cXHRcXHRcXHRsZW5ndGggPSBjdXJyZW50Lmxlbmd0aDtcXG5cXG5cXHRcXHRpZiAoIGNociA9PT0gXFxcImpcXFwiICkge1xcblxcblxcdFxcdFxcdC8vIExvY2FsZSBwcmVmZXJyZWQgaEhLay5cXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjVGltZV9EYXRhXFxuXFx0XFx0XFx0Y2hyID0gcHJvcGVydGllcy5wcmVmZXJyZWRUaW1lO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGNociA9PT0gXFxcIlpcXFwiICkge1xcblxcblxcdFxcdFxcdC8vIFouLlpaWjogc2FtZSBhcyBcXFwieHh4eFxcXCIuXFxuXFx0XFx0XFx0aWYgKCBsZW5ndGggPCA0ICkge1xcblxcdFxcdFxcdFxcdGNociA9IFxcXCJ4XFxcIjtcXG5cXHRcXHRcXHRcXHRsZW5ndGggPSA0O1xcblxcblxcdFxcdFxcdC8vIFpaWlo6IHNhbWUgYXMgXFxcIk9PT09cXFwiLlxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGxlbmd0aCA8IDUgKSB7XFxuXFx0XFx0XFx0XFx0Y2hyID0gXFxcIk9cXFwiO1xcblxcdFxcdFxcdFxcdGxlbmd0aCA9IDQ7XFxuXFxuXFx0XFx0XFx0Ly8gWlpaWlo6IHNhbWUgYXMgXFxcIlhYWFhYXFxcIlxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Y2hyID0gXFxcIlhcXFwiO1xcblxcdFxcdFxcdFxcdGxlbmd0aCA9IDU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyB6Li4uenp6OiBcXFwie3Nob3J0UmVnaW9ufVxcXCIsIGUuZy4sIFxcXCJQU1RcXFwiIG9yIFxcXCJQRFRcXFwiLlxcblxcdFxcdC8vIHp6eno6IFxcXCJ7cmVnaW9uTmFtZX0ge1N0YW5kYXJkIFRpbWV9XFxcIiBvciBcXFwie3JlZ2lvbk5hbWV9IHtEYXlsaWdodCBUaW1lfVxcXCIsXFxuXFx0XFx0Ly8gICAgICAgZS5nLiwgXFxcIlBhY2lmaWMgU3RhbmRhcmQgVGltZVxcXCIgb3IgXFxcIlBhY2lmaWMgRGF5bGlnaHQgVGltZVxcXCIuXFxuXFx0XFx0aWYgKCBjaHIgPT09IFxcXCJ6XFxcIiApIHtcXG5cXHRcXHRcXHRpZiAoIGRhdGUuaXNEU1QgKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBkYXRlLmlzRFNUKCkgPyBwcm9wZXJ0aWVzLmRheWxpZ2h0VHpOYW1lIDogcHJvcGVydGllcy5zdGFuZGFyZFR6TmFtZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRmFsbCBiYWNrIHRvIFxcXCJPXFxcIiBmb3JtYXQuXFxuXFx0XFx0XFx0aWYgKCAhdmFsdWUgKSB7XFxuXFx0XFx0XFx0XFx0Y2hyID0gXFxcIk9cXFwiO1xcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoIDwgNCApIHtcXG5cXHRcXHRcXHRcXHRcXHRsZW5ndGggPSAxO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHN3aXRjaCAoIGNociApIHtcXG5cXG5cXHRcXHRcXHQvLyBFcmFcXG5cXHRcXHRcXHRjYXNlIFxcXCJHXFxcIjpcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IHByb3BlcnRpZXMuZXJhc1sgZGF0ZS5nZXRGdWxsWWVhcigpIDwgMCA/IDAgOiAxIF07XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gWWVhclxcblxcdFxcdFxcdGNhc2UgXFxcInlcXFwiOlxcblxcblxcdFxcdFxcdFxcdC8vIFBsYWluIHllYXIuXFxuXFx0XFx0XFx0XFx0Ly8gVGhlIGxlbmd0aCBzcGVjaWZpZXMgdGhlIHBhZGRpbmcsIGJ1dCBmb3IgdHdvIGxldHRlcnMgaXQgYWxzbyBzcGVjaWZpZXMgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gbWF4aW11bSBsZW5ndGguXFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XFxuXFx0XFx0XFx0XFx0aWYgKCBsZW5ndGggPT09IDIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBTdHJpbmcoIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSArdmFsdWUuc3Vic3RyKCB2YWx1ZS5sZW5ndGggLSAyICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcIllcXFwiOlxcblxcblxcdFxcdFxcdFxcdC8vIFllYXIgaW4gXFxcIldlZWsgb2YgWWVhclxcXCJcXG5cXHRcXHRcXHRcXHQvLyBUaGUgbGVuZ3RoIHNwZWNpZmllcyB0aGUgcGFkZGluZywgYnV0IGZvciB0d28gbGV0dGVycyBpdCBhbHNvIHNwZWNpZmllcyB0aGVcXG5cXHRcXHRcXHRcXHQvLyBtYXhpbXVtIGxlbmd0aC5cXG5cXHRcXHRcXHRcXHQvLyB5ZWFySW5XZWVrb2ZZZWFyID0gZGF0ZSArIERheXNJbkFXZWVrIC0gKGRheU9mV2VlayAtIGZpcnN0RGF5KSAtIG1pbkRheXNcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IG5ldyBEYXRlKCBkYXRlLmdldFRpbWUoKSApO1xcblxcdFxcdFxcdFxcdHZhbHVlLnNldERhdGUoXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUuZ2V0RGF0ZSgpICsgNyAtXFxuXFx0XFx0XFx0XFx0XFx0ZGF0ZURheU9mV2VlayggZGF0ZSwgcHJvcGVydGllcy5maXJzdERheSApIC1cXG5cXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLmZpcnN0RGF5IC1cXG5cXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLm1pbkRheXNcXG5cXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdHZhbHVlID0gdmFsdWUuZ2V0RnVsbFllYXIoKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGxlbmd0aCA9PT0gMiApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IFN0cmluZyggdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA9ICt2YWx1ZS5zdWJzdHIoIHZhbHVlLmxlbmd0aCAtIDIgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gUXVhcnRlclxcblxcdFxcdFxcdGNhc2UgXFxcIlFcXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcInFcXFwiOlxcblxcdFxcdFxcdFxcdHZhbHVlID0gTWF0aC5jZWlsKCAoIGRhdGUuZ2V0TW9udGgoKSArIDEgKSAvIDMgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGxlbmd0aCA+IDIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBwcm9wZXJ0aWVzLnF1YXJ0ZXJzWyBjaHIgXVsgbGVuZ3RoIF1bIHZhbHVlIF07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIE1vbnRoXFxuXFx0XFx0XFx0Y2FzZSBcXFwiTVxcXCI6XFxuXFx0XFx0XFx0Y2FzZSBcXFwiTFxcXCI6XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoID4gMiApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IHByb3BlcnRpZXMubW9udGhzWyBjaHIgXVsgbGVuZ3RoIF1bIHZhbHVlIF07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIFdlZWtcXG5cXHRcXHRcXHRjYXNlIFxcXCJ3XFxcIjpcXG5cXG5cXHRcXHRcXHRcXHQvLyBXZWVrIG9mIFllYXIuXFxuXFx0XFx0XFx0XFx0Ly8gd295ID0gY2VpbCggKCBkb3kgKyBkb3cgb2YgMS8xICkgLyA3ICkgLSBtaW5EYXlzU3R1ZmYgPyAxIDogMC5cXG5cXHRcXHRcXHRcXHQvLyBUT0RPIHNob3VsZCBwYWQgb24gd3c/IE5vdCBkb2N1bWVudGVkLCBidXQgSSBndWVzcyBzby5cXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGRhdGVEYXlPZldlZWsoIGRhdGVTdGFydE9mKCBkYXRlLCBcXFwieWVhclxcXCIgKSwgcHJvcGVydGllcy5maXJzdERheSApO1xcblxcdFxcdFxcdFxcdHZhbHVlID0gTWF0aC5jZWlsKCAoIGRhdGVEYXlPZlllYXIoIGRhdGUgKSArIHZhbHVlICkgLyA3ICkgLVxcblxcdFxcdFxcdFxcdFxcdCggNyAtIHZhbHVlID49IHByb3BlcnRpZXMubWluRGF5cyA/IDAgOiAxICk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiV1xcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV2VlayBvZiBNb250aC5cXG5cXHRcXHRcXHRcXHQvLyB3b20gPSBjZWlsKCAoIGRvbSArIGRvdyBvZiBgMS9tb250aGAgKSAvIDcgKSAtIG1pbkRheXNTdHVmZiA/IDEgOiAwLlxcblxcdFxcdFxcdFxcdHZhbHVlID0gZGF0ZURheU9mV2VlayggZGF0ZVN0YXJ0T2YoIGRhdGUsIFxcXCJtb250aFxcXCIgKSwgcHJvcGVydGllcy5maXJzdERheSApO1xcblxcdFxcdFxcdFxcdHZhbHVlID0gTWF0aC5jZWlsKCAoIGRhdGUuZ2V0RGF0ZSgpICsgdmFsdWUgKSAvIDcgKSAtXFxuXFx0XFx0XFx0XFx0XFx0KCA3IC0gdmFsdWUgPj0gcHJvcGVydGllcy5taW5EYXlzID8gMCA6IDEgKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBEYXlcXG5cXHRcXHRcXHRjYXNlIFxcXCJkXFxcIjpcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGRhdGUuZ2V0RGF0ZSgpO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcIkRcXFwiOlxcblxcdFxcdFxcdFxcdHZhbHVlID0gZGF0ZURheU9mWWVhciggZGF0ZSApICsgMTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRjYXNlIFxcXCJGXFxcIjpcXG5cXG5cXHRcXHRcXHRcXHQvLyBEYXkgb2YgV2VlayBpbiBtb250aC4gZWcuIDJuZCBXZWQgaW4gSnVseS5cXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IE1hdGguZmxvb3IoIGRhdGUuZ2V0RGF0ZSgpIC8gNyApICsgMTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBXZWVrIGRheVxcblxcdFxcdFxcdGNhc2UgXFxcImVcXFwiOlxcblxcdFxcdFxcdGNhc2UgXFxcImNcXFwiOlxcblxcdFxcdFxcdFxcdGlmICggbGVuZ3RoIDw9IDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmFuZ2UgaXMgWzEtN10gKGRlZHVjZWQgYnkgZXhhbXBsZSBwcm92aWRlZCBvbiBkb2N1bWVudGF0aW9uKVxcblxcdFxcdFxcdFxcdFxcdC8vIFRPRE8gU2hvdWxkIHBhZCB3aXRoIHplcm9zIChub3Qgc3BlY2lmaWVkIGluIHRoZSBkb2NzKT9cXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IGRhdGVEYXlPZldlZWsoIGRhdGUsIHByb3BlcnRpZXMuZmlyc3REYXkgKSArIDE7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRjYXNlIFxcXCJFXFxcIjpcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGRhdGVXZWVrRGF5c1sgZGF0ZS5nZXREYXkoKSBdO1xcblxcdFxcdFxcdFxcdHZhbHVlID0gcHJvcGVydGllcy5kYXlzWyBjaHIgXVsgbGVuZ3RoIF1bIHZhbHVlIF07XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gUGVyaW9kIChBTSBvciBQTSlcXG5cXHRcXHRcXHRjYXNlIFxcXCJhXFxcIjpcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IHByb3BlcnRpZXMuZGF5UGVyaW9kc1sgZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBcXFwiYW1cXFwiIDogXFxcInBtXFxcIiBdO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIEhvdXJcXG5cXHRcXHRcXHRjYXNlIFxcXCJoXFxcIjogLy8gMS0xMlxcblxcdFxcdFxcdFxcdHZhbHVlID0gKCBkYXRlLmdldEhvdXJzKCkgJSAxMiApIHx8IDEyO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcIkhcXFwiOiAvLyAwLTIzXFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBkYXRlLmdldEhvdXJzKCk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiS1xcXCI6IC8vIDAtMTFcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGRhdGUuZ2V0SG91cnMoKSAlIDEyO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcImtcXFwiOiAvLyAxLTI0XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBkYXRlLmdldEhvdXJzKCkgfHwgMjQ7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gTWludXRlXFxuXFx0XFx0XFx0Y2FzZSBcXFwibVxcXCI6XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBkYXRlLmdldE1pbnV0ZXMoKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBTZWNvbmRcXG5cXHRcXHRcXHRjYXNlIFxcXCJzXFxcIjpcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGRhdGUuZ2V0U2Vjb25kcygpO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcIlNcXFwiOlxcblxcdFxcdFxcdFxcdHZhbHVlID0gTWF0aC5yb3VuZCggZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAqIE1hdGgucG93KCAxMCwgbGVuZ3RoIC0gMyApICk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBcXFwiQVxcXCI6XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBNYXRoLnJvdW5kKCBkYXRlTWlsbGlzZWNvbmRzSW5EYXkoIGRhdGUgKSAqIE1hdGgucG93KCAxMCwgbGVuZ3RoIC0gMyApICk7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gWm9uZVxcblxcdFxcdFxcdGNhc2UgXFxcInpcXFwiOlxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcInZcXFwiOlxcblxcblxcdFxcdFxcdFxcdC8vIHYuLi52dnY6IFxcXCJ7c2hvcnRSZWdpb259XFxcIiwgZWcuIFxcXCJQVFxcXCIuXFxuXFx0XFx0XFx0XFx0Ly8gdnZ2djogXFxcIntyZWdpb25OYW1lfSB7VGltZX1cXFwiLFxcblxcdFxcdFxcdFxcdC8vICAgICAgIGUuZy4sIFxcXCJQYWNpZmljIFRpbWVcXFwiLlxcblxcdFxcdFxcdFxcdGlmICggcHJvcGVydGllcy5nZW5lcmljVHpOYW1lICkge1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0gcHJvcGVydGllcy5nZW5lcmljVHpOYW1lO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvKiBmYWxscyB0aHJvdWdoICovXFxuXFx0XFx0XFx0Y2FzZSBcXFwiVlxcXCI6XFxuXFxuXFx0XFx0XFx0XFx0Ly9WVlZWOiBcXFwie2V4cGxhckNpdHl9IHtUaW1lfVxcXCIsIGUuZy4sIFxcXCJMb3MgQW5nZWxlcyBUaW1lXFxcIlxcblxcdFxcdFxcdFxcdGlmICggcHJvcGVydGllcy50aW1lWm9uZU5hbWUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBwcm9wZXJ0aWVzLnRpbWVab25lTmFtZTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50ID09PSBcXFwidlxcXCIgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGVuZ3RoID0gMTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0LyogZmFsbHMgdGhyb3VnaCAqL1xcblxcdFxcdFxcdGNhc2UgXFxcIk9cXFwiOlxcblxcblxcdFxcdFxcdFxcdC8vIE86IFxcXCJ7Z210Rm9ybWF0fStIO3tnbXRGb3JtYXR9LUhcXFwiIG9yIFxcXCJ7Z210WmVyb0Zvcm1hdH1cXFwiLCBlZy4gXFxcIkdNVC04XFxcIiBvciBcXFwiR01UXFxcIi5cXG5cXHRcXHRcXHRcXHQvLyBPT09POiBcXFwie2dtdEZvcm1hdH17aG91ckZvcm1hdH1cXFwiIG9yIFxcXCJ7Z210WmVyb0Zvcm1hdH1cXFwiLCBlZy4gXFxcIkdNVC0wODowMFxcXCIgb3IgXFxcIkdNVFxcXCIuXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgPT09IDAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBwcm9wZXJ0aWVzLmdtdFplcm9Gb3JtYXQ7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiBPLi5PT08gYW5kIHRpbWV6b25lIG9mZnNldCBoYXMgbm9uLXplcm8gbWludXRlcywgc2hvdyBtaW51dGVzLlxcblxcdFxcdFxcdFxcdFxcdGlmICggbGVuZ3RoIDwgNCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhdXggPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YXV4ID0gcHJvcGVydGllcy5ob3VyRm9ybWF0WyBhdXggJSA2MCAtIGF1eCAlIDEgPT09IDAgPyAwIDogMSBdO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YXV4ID0gcHJvcGVydGllcy5ob3VyRm9ybWF0O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IGRhdGVUaW1lem9uZUhvdXJGb3JtYXQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRhdXgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZVNlcGFyYXRvcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRudW1iZXJGb3JtYXR0ZXJzXFxuXFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IHByb3BlcnRpZXMuZ210Rm9ybWF0LnJlcGxhY2UoIC9cXFxcezBcXFxcfS8sIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgXFxcIlhcXFwiOlxcblxcblxcdFxcdFxcdFxcdC8vIFNhbWUgYXMgeCosIGV4Y2VwdCBpdCB1c2VzIFxcXCJaXFxcIiBmb3IgemVybyBvZmZzZXQuXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgPT09IDAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBcXFwiWlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qIGZhbGxzIHRocm91Z2ggKi9cXG5cXHRcXHRcXHRjYXNlIFxcXCJ4XFxcIjpcXG5cXG5cXHRcXHRcXHRcXHQvLyB4OiBob3VyRm9ybWF0KFxcXCIrSEhbbW1dOy1ISFttbV1cXFwiKVxcblxcdFxcdFxcdFxcdC8vIHh4OiBob3VyRm9ybWF0KFxcXCIrSEhtbTstSEhtbVxcXCIpXFxuXFx0XFx0XFx0XFx0Ly8geHh4OiBob3VyRm9ybWF0KFxcXCIrSEg6bW07LUhIOm1tXFxcIilcXG5cXHRcXHRcXHRcXHQvLyB4eHh4OiBob3VyRm9ybWF0KFxcXCIrSEhtbVtzc107LUhIbW1bc3NdXFxcIilcXG5cXHRcXHRcXHRcXHQvLyB4eHh4eDogaG91ckZvcm1hdChcXFwiK0hIOm1tWzpzc107LUhIOm1tWzpzc11cXFwiKVxcblxcdFxcdFxcdFxcdGF1eCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB4IGFuZCB0aW1lem9uZSBvZmZzZXQgaGFzIG5vbi16ZXJvIG1pbnV0ZXMsIHVzZSB4eCAoaS5lLiwgc2hvdyBtaW51dGVzKS5cXG5cXHRcXHRcXHRcXHRpZiAoIGxlbmd0aCA9PT0gMSAmJiBhdXggJSA2MCAtIGF1eCAlIDEgIT09IDAgKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGVuZ3RoICs9IDE7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIElmICh4eHh4IG9yIHh4eHh4KSBhbmQgdGltZXpvbmUgb2Zmc2V0IGhhcyB6ZXJvIHNlY29uZHMsIHVzZSB4eCBvciB4eHhcXG5cXHRcXHRcXHRcXHQvLyByZXNwZWN0aXZlbHkgKGkuZS4sIGRvbid0IHNob3cgb3B0aW9uYWwgc2Vjb25kcykuXFxuXFx0XFx0XFx0XFx0aWYgKCAoIGxlbmd0aCA9PT0gNCB8fCBsZW5ndGggPT09IDUgKSAmJiBhdXggJSAxID09PSAwICkge1xcblxcdFxcdFxcdFxcdFxcdGxlbmd0aCAtPSAyO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IFtcXG5cXHRcXHRcXHRcXHRcXHRcXFwiK0hIOy1ISFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFxcIitISG1tOy1ISG1tXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXFwiK0hIOm1tOy1ISDptbVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFxcIitISG1tc3M7LUhIbW1zc1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFxcIitISDptbTpzczstSEg6bW06c3NcXFwiXFxuXFx0XFx0XFx0XFx0XVsgbGVuZ3RoIC0gMSBdO1xcblxcblxcdFxcdFxcdFxcdHZhbHVlID0gZGF0ZVRpbWV6b25lSG91ckZvcm1hdCggZGF0ZSwgdmFsdWUsIFxcXCI6XFxcIiApO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdC8vIHRpbWVTZXBhcmF0b3JcXG5cXHRcXHRcXHRjYXNlIFxcXCI6XFxcIjpcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IHRpbWVTZXBhcmF0b3I7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Ly8gJyBsaXRlcmFscy5cXG5cXHRcXHRcXHRjYXNlIFxcXCInXFxcIjpcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IHJlbW92ZUxpdGVyYWxRdW90ZXMoIGN1cnJlbnQgKTtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHQvLyBBbnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgYSBsaXRlcmFsLCBpbmNsdWRpbmcgWyAsOi8uQCNdLCBjaGluZXNlLCBqYXBvbmVzZSwgYW5kXFxuXFx0XFx0XFx0Ly8gYXJhYmljIGNoYXJhY3RlcnMuXFxuXFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGN1cnJlbnQ7XFxuXFxuXFx0XFx0fVxcblxcdFxcdGlmICggdHlwZW9mIHZhbHVlID09PSBcXFwibnVtYmVyXFxcIiApIHtcXG5cXHRcXHRcXHR2YWx1ZSA9IG51bWJlckZvcm1hdHRlcnNbIGxlbmd0aCBdKCB2YWx1ZSApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRkYXRlRmllbGQgPSBkYXRlRmllbGRzTWFwWyBjaHIgXTtcXG5cXHRcXHR0eXBlID0gZGF0ZUZpZWxkID8gZGF0ZUZpZWxkIDogXFxcImxpdGVyYWxcXFwiO1xcblxcblxcdFxcdHBhcnRzUHVzaCggcGFydHMsIHR5cGUsIHZhbHVlICk7XFxuXFx0fSk7XFxuXFxuXFx0cmV0dXJuIHBhcnRzO1xcblxcbn07XFxuXFxuXFxuXFxuXFxudmFyIGRhdGVUb1BhcnRzRm9ybWF0dGVyRm4gPSBmdW5jdGlvbiggbnVtYmVyRm9ybWF0dGVycywgcHJvcGVydGllcyApIHtcXG5cXHRyZXR1cm4gZnVuY3Rpb24gZGF0ZVRvUGFydHNGb3JtYXR0ZXIoIHZhbHVlICkge1xcblxcdFxcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcXFwidmFsdWVcXFwiICk7XFxuXFx0XFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlRGF0ZSggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gZGF0ZUZvcm1hdCggdmFsdWUsIG51bWJlckZvcm1hdHRlcnMsIHByb3BlcnRpZXMgKTtcXG5cXHR9O1xcblxcbn07XFxuXFxuXFxuXFxuXFxuZnVuY3Rpb24gb3B0aW9uc0hhc1N0eWxlKCBvcHRpb25zICkge1xcblxcdHJldHVybiBvcHRpb25zLnNrZWxldG9uICE9PSB1bmRlZmluZWQgfHxcXG5cXHRcXHRvcHRpb25zLmRhdGUgIT09IHVuZGVmaW5lZCB8fFxcblxcdFxcdG9wdGlvbnMudGltZSAhPT0gdW5kZWZpbmVkIHx8XFxuXFx0XFx0b3B0aW9ucy5kYXRldGltZSAhPT0gdW5kZWZpbmVkIHx8XFxuXFx0XFx0b3B0aW9ucy5yYXcgIT09IHVuZGVmaW5lZDtcXG59XFxuXFxuZnVuY3Rpb24gdmFsaWRhdGVSZXF1aXJlZENsZHIoIHBhdGgsIHZhbHVlICkge1xcblxcdHZhbGlkYXRlQ2xkciggcGF0aCwgdmFsdWUsIHtcXG5cXHRcXHRza2lwOiBbXFxuXFx0XFx0XFx0L2RhdGVzXFxcXC9jYWxlbmRhcnNcXFxcL2dyZWdvcmlhblxcXFwvZGF0ZVRpbWVGb3JtYXRzXFxcXC9hdmFpbGFibGVGb3JtYXRzLyxcXG5cXHRcXHRcXHQvZGF0ZXNcXFxcL2NhbGVuZGFyc1xcXFwvZ3JlZ29yaWFuXFxcXC9kYXlzXFxcXC8uKlxcXFwvc2hvcnQvLFxcblxcdFxcdFxcdC9kYXRlc1xcXFwvdGltZVpvbmVOYW1lc1xcXFwvem9uZS8sXFxuXFx0XFx0XFx0L2RhdGVzXFxcXC90aW1lWm9uZU5hbWVzXFxcXC9tZXRhem9uZS8sXFxuXFx0XFx0XFx0L2dsb2JhbGl6ZS1pYW5hLyxcXG5cXHRcXHRcXHQvc3VwcGxlbWVudGFsXFxcXC9tZXRhWm9uZXMvLFxcblxcdFxcdFxcdC9zdXBwbGVtZW50YWxcXFxcL3RpbWVEYXRhXFxcXC8oPyEwMDEpLyxcXG5cXHRcXHRcXHQvc3VwcGxlbWVudGFsXFxcXC93ZWVrRGF0YVxcXFwvKD8hMDAxKS9cXG5cXHRcXHRdXFxuXFx0fSk7XFxufVxcblxcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uc1ByZXNldCggb3B0aW9ucyApIHtcXG5cXHR2YWxpZGF0ZU9wdGlvbnNQcmVzZXRFYWNoKCBcXFwiZGF0ZVxcXCIsIG9wdGlvbnMgKTtcXG5cXHR2YWxpZGF0ZU9wdGlvbnNQcmVzZXRFYWNoKCBcXFwidGltZVxcXCIsIG9wdGlvbnMgKTtcXG5cXHR2YWxpZGF0ZU9wdGlvbnNQcmVzZXRFYWNoKCBcXFwiZGF0ZXRpbWVcXFwiLCBvcHRpb25zICk7XFxufVxcblxcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uc1ByZXNldEVhY2goIHR5cGUsIG9wdGlvbnMgKSB7XFxuXFx0dmFyIHZhbHVlID0gb3B0aW9uc1sgdHlwZSBdO1xcblxcdHZhbGlkYXRlKFxcblxcdFxcdFxcXCJFX0lOVkFMSURfT1BUSU9OU1xcXCIsXFxuXFx0XFx0XFxcIkludmFsaWQgYHt7dHlwZX06IFxcXFxcXFwie3ZhbHVlfVxcXFxcXFwifWAuXFxcIixcXG5cXHRcXHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IFsgXFxcInNob3J0XFxcIiwgXFxcIm1lZGl1bVxcXCIsIFxcXCJsb25nXFxcIiwgXFxcImZ1bGxcXFwiIF0uaW5kZXhPZiggdmFsdWUgKSAhPT0gLTEsXFxuXFx0XFx0eyB0eXBlOiB0eXBlLCB2YWx1ZTogdmFsdWUgfVxcblxcdCk7XFxufVxcblxcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uc1NrZWxldG9uKCBwYXR0ZXJuLCBza2VsZXRvbiApIHtcXG5cXHR2YWxpZGF0ZShcXG5cXHRcXHRcXFwiRV9JTlZBTElEX09QVElPTlNcXFwiLFxcblxcdFxcdFxcXCJJbnZhbGlkIGB7c2tlbGV0b246IFxcXFxcXFwie3ZhbHVlfVxcXFxcXFwifWAgYmFzZWQgb24gcHJvdmlkZWQgQ0xEUi5cXFwiLFxcblxcdFxcdHNrZWxldG9uID09PSB1bmRlZmluZWQgfHwgKCB0eXBlb2YgcGF0dGVybiA9PT0gXFxcInN0cmluZ1xcXCIgJiYgcGF0dGVybiApLFxcblxcdFxcdHsgdHlwZTogXFxcInNrZWxldG9uXFxcIiwgdmFsdWU6IHNrZWxldG9uIH1cXG5cXHQpO1xcbn1cXG5cXG5mdW5jdGlvbiB2YWxpZGF0ZVJlcXVpcmVkSWFuYSggdGltZVpvbmUgKSB7XFxuXFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXRoLCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRpZiAoICEvZ2xvYmFsaXplLWlhbmEvLnRlc3QoIHBhdGggKSApIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhbGlkYXRlKFxcblxcdFxcdFxcdFxcXCJFX01JU1NJTkdfSUFOQV9UWlxcXCIsXFxuXFx0XFx0XFx0XFxcIk1pc3NpbmcgcmVxdWlyZWQgSUFOQSB0aW1lem9uZSBjb250ZW50IGZvciBge3RpbWVab25lfWA6IGB7cGF0aH1gLlxcXCIsXFxuXFx0XFx0XFx0dmFsdWUsXFxuXFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdHBhdGg6IHBhdGgucmVwbGFjZSggL2dsb2JhbGl6ZS1pYW5hXFxcXC8vLCBcXFwiXFxcIiApLFxcblxcdFxcdFxcdFxcdHRpbWVab25lOiB0aW1lWm9uZVxcblxcdFxcdFxcdH1cXG5cXHRcXHQpO1xcblxcdH07XFxufVxcblxcbi8qKlxcbiAqIC5sb2FkVGltZVpvbmUoIGpzb24gKVxcbiAqXFxuICogQGpzb24gW0pTT05dXFxuICpcXG4gKiBMb2FkIElBTkEgdGltZXpvbmUgZGF0YS5cXG4gKi9cXG5HbG9iYWxpemUubG9hZFRpbWVab25lID0gZnVuY3Rpb24oIGpzb24gKSB7XFxuXFx0dmFyIGN1c3RvbURhdGEgPSB7XFxuXFx0XFx0XFx0XFxcImdsb2JhbGl6ZS1pYW5hXFxcIjoganNvblxcblxcdFxcdH07XFxuXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSgganNvbiwgXFxcImpzb25cXFwiICk7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIGpzb24sIFxcXCJqc29uXFxcIiApO1xcblxcblxcdENsZHIubG9hZCggY3VzdG9tRGF0YSApO1xcbn07XFxuXFxuLyoqXFxuICogLmRhdGVGb3JtYXR0ZXIoIG9wdGlvbnMgKVxcbiAqXFxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGRhdGUvZXhwYW5kX3BhdHRlcm4gZm9yIG1vcmUgaW5mby5cXG4gKlxcbiAqIFJldHVybiBhIGRhdGUgZm9ybWF0dGVyIGZ1bmN0aW9uIChvZiB0aGUgZm9ybSBiZWxvdykgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCB0aGVcXG4gKiBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cXG4gKlxcbiAqIGZuKCB2YWx1ZSApXFxuICpcXG4gKiBAdmFsdWUgW0RhdGVdXFxuICpcXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYSBkYXRlIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gYGZvcm1hdGAgYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlXFxuICogbG9jYWxlLlxcbiAqL1xcbkdsb2JhbGl6ZS5kYXRlRm9ybWF0dGVyID1cXG5HbG9iYWxpemUucHJvdG90eXBlLmRhdGVGb3JtYXR0ZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcXG5cXHR2YXIgYXJncywgZGF0ZVRvUGFydHNGb3JtYXR0ZXIsIHJldHVybkZuO1xcblxcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcXFwib3B0aW9uc1xcXCIgKTtcXG5cXG5cXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXHRpZiAoICFvcHRpb25zSGFzU3R5bGUoIG9wdGlvbnMgKSApIHtcXG5cXHRcXHRvcHRpb25zLnNrZWxldG9uID0gXFxcInlNZFxcXCI7XFxuXFx0fVxcblxcdGFyZ3MgPSBbIG9wdGlvbnMgXTtcXG5cXG5cXHRkYXRlVG9QYXJ0c0Zvcm1hdHRlciA9IHRoaXMuZGF0ZVRvUGFydHNGb3JtYXR0ZXIoIG9wdGlvbnMgKTtcXG5cXHRyZXR1cm5GbiA9IGRhdGVGb3JtYXR0ZXJGbiggZGF0ZVRvUGFydHNGb3JtYXR0ZXIgKTtcXG5cXHRydW50aW1lQmluZCggYXJncywgdGhpcy5jbGRyLCByZXR1cm5GbiwgWyBkYXRlVG9QYXJ0c0Zvcm1hdHRlciBdICk7XFxuXFxuXFx0cmV0dXJuIHJldHVybkZuO1xcbn07XFxuXFxuLyoqXFxuICogLmRhdGVUb1BhcnRzRm9ybWF0dGVyKCBvcHRpb25zIClcXG4gKlxcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSBkYXRlL2V4cGFuZF9wYXR0ZXJuIGZvciBtb3JlIGluZm8uXFxuICpcXG4gKiBSZXR1cm4gYSBkYXRlIGZvcm1hdHRlciBmdW5jdGlvbiAob2YgdGhlIGZvcm0gYmVsb3cpIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgdGhlXFxuICogZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXFxuICpcXG4gKiBmbiggdmFsdWUgKVxcbiAqXFxuICogQHZhbHVlIFtEYXRlXVxcbiAqXFxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgZGF0ZSB0byBwYXJ0cyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGBmb3JtYXRgXFxuICogYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlXFxuICogbG9jYWxlLlxcbiAqL1xcbkdsb2JhbGl6ZS5kYXRlVG9QYXJ0c0Zvcm1hdHRlciA9XFxuR2xvYmFsaXplLnByb3RvdHlwZS5kYXRlVG9QYXJ0c0Zvcm1hdHRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xcblxcdHZhciBhcmdzLCBjbGRyLCBudW1iZXJGb3JtYXR0ZXJzLCBwYWQsIHBhdHRlcm4sIHByb3BlcnRpZXMsIHJldHVybkZuLFxcblxcdFxcdHRpbWVab25lLCBpYW5hTGlzdGVuZXI7XFxuXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFxcXCJvcHRpb25zXFxcIiApO1xcblxcblxcdGNsZHIgPSB0aGlzLmNsZHI7XFxuXFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFx0aWYgKCAhb3B0aW9uc0hhc1N0eWxlKCBvcHRpb25zICkgKSB7XFxuXFx0XFx0b3B0aW9ucy5za2VsZXRvbiA9IFxcXCJ5TWRcXFwiO1xcblxcdH1cXG5cXG5cXHR2YWxpZGF0ZU9wdGlvbnNQcmVzZXQoIG9wdGlvbnMgKTtcXG5cXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcXG5cXG5cXHR0aW1lWm9uZSA9IG9wdGlvbnMudGltZVpvbmU7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB0aW1lWm9uZSwgXFxcIm9wdGlvbnMudGltZVpvbmVcXFwiICk7XFxuXFxuXFx0YXJncyA9IFsgb3B0aW9ucyBdO1xcblxcblxcdGNsZHIub24oIFxcXCJnZXRcXFwiLCB2YWxpZGF0ZVJlcXVpcmVkQ2xkciApO1xcblxcdGlmICggdGltZVpvbmUgKSB7XFxuXFx0XFx0aWFuYUxpc3RlbmVyID0gdmFsaWRhdGVSZXF1aXJlZElhbmEoIHRpbWVab25lICk7XFxuXFx0XFx0Y2xkci5vbiggXFxcImdldFxcXCIsIGlhbmFMaXN0ZW5lciApO1xcblxcdH1cXG5cXHR0cnkge1xcblxcdFxcdHBhdHRlcm4gPSBkYXRlRXhwYW5kUGF0dGVybiggb3B0aW9ucywgY2xkciApO1xcblxcdFxcdHZhbGlkYXRlT3B0aW9uc1NrZWxldG9uKCBwYXR0ZXJuLCBvcHRpb25zLnNrZWxldG9uICk7XFxuXFx0XFx0cHJvcGVydGllcyA9IGRhdGVGb3JtYXRQcm9wZXJ0aWVzKCBwYXR0ZXJuLCBjbGRyLCB0aW1lWm9uZSApO1xcblxcdH0gZmluYWxseSB7XFxuXFx0XFx0Y2xkci5vZmYoIFxcXCJnZXRcXFwiLCB2YWxpZGF0ZVJlcXVpcmVkQ2xkciApO1xcblxcdFxcdGlmICggaWFuYUxpc3RlbmVyICkge1xcblxcdFxcdFxcdGNsZHIub2ZmKCBcXFwiZ2V0XFxcIiwgaWFuYUxpc3RlbmVyICk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBDcmVhdGUgbmVlZGVkIG51bWJlciBmb3JtYXR0ZXJzLlxcblxcdG51bWJlckZvcm1hdHRlcnMgPSBwcm9wZXJ0aWVzLm51bWJlckZvcm1hdHRlcnM7XFxuXFx0ZGVsZXRlIHByb3BlcnRpZXMubnVtYmVyRm9ybWF0dGVycztcXG5cXHRmb3IgKCBwYWQgaW4gbnVtYmVyRm9ybWF0dGVycyApIHtcXG5cXHRcXHRudW1iZXJGb3JtYXR0ZXJzWyBwYWQgXSA9IHRoaXMubnVtYmVyRm9ybWF0dGVyKHtcXG5cXHRcXHRcXHRyYXc6IG51bWJlckZvcm1hdHRlcnNbIHBhZCBdXFxuXFx0XFx0fSk7XFxuXFx0fVxcblxcblxcdHJldHVybkZuID0gZGF0ZVRvUGFydHNGb3JtYXR0ZXJGbiggbnVtYmVyRm9ybWF0dGVycywgcHJvcGVydGllcyApO1xcblxcblxcdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBudW1iZXJGb3JtYXR0ZXJzLCBwcm9wZXJ0aWVzIF0gKTtcXG5cXG5cXHRyZXR1cm4gcmV0dXJuRm47XFxufTtcXG5cXG4vKipcXG4gKiAuZGF0ZVBhcnNlciggb3B0aW9ucyApXFxuICpcXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgZGF0ZS9leHBhbmRfcGF0dGVybiBmb3IgbW9yZSBpbmZvLlxcbiAqXFxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYSBzdHJpbmcgZGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGBmb3JtYXRzYCBhbmQgdGhlXFxuICogZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXFxuICovXFxuR2xvYmFsaXplLmRhdGVQYXJzZXIgPVxcbkdsb2JhbGl6ZS5wcm90b3R5cGUuZGF0ZVBhcnNlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xcblxcdHZhciBhcmdzLCBjbGRyLCBudW1iZXJQYXJzZXIsIHBhcnNlUHJvcGVydGllcywgcGF0dGVybiwgcmV0dXJuRm4sIHRpbWVab25lLFxcblxcdFxcdHRva2VuaXplclByb3BlcnRpZXM7XFxuXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFxcXCJvcHRpb25zXFxcIiApO1xcblxcblxcdGNsZHIgPSB0aGlzLmNsZHI7XFxuXFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFx0aWYgKCAhb3B0aW9uc0hhc1N0eWxlKCBvcHRpb25zICkgKSB7XFxuXFx0XFx0b3B0aW9ucy5za2VsZXRvbiA9IFxcXCJ5TWRcXFwiO1xcblxcdH1cXG5cXG5cXHR2YWxpZGF0ZU9wdGlvbnNQcmVzZXQoIG9wdGlvbnMgKTtcXG5cXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcXG5cXG5cXHR0aW1lWm9uZSA9IG9wdGlvbnMudGltZVpvbmU7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB0aW1lWm9uZSwgXFxcIm9wdGlvbnMudGltZVpvbmVcXFwiICk7XFxuXFxuXFx0YXJncyA9IFsgb3B0aW9ucyBdO1xcblxcblxcdHRyeSB7XFxuXFx0XFx0Y2xkci5vbiggXFxcImdldFxcXCIsIHZhbGlkYXRlUmVxdWlyZWRDbGRyICk7XFxuXFx0XFx0aWYgKCB0aW1lWm9uZSApIHtcXG5cXHRcXHRcXHRjbGRyLm9uKCBcXFwiZ2V0XFxcIiwgdmFsaWRhdGVSZXF1aXJlZElhbmEoIHRpbWVab25lICkgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cGF0dGVybiA9IGRhdGVFeHBhbmRQYXR0ZXJuKCBvcHRpb25zLCBjbGRyICk7XFxuXFx0XFx0dmFsaWRhdGVPcHRpb25zU2tlbGV0b24oIHBhdHRlcm4sIG9wdGlvbnMuc2tlbGV0b24gKTtcXG5cXHRcXHR0b2tlbml6ZXJQcm9wZXJ0aWVzID0gZGF0ZVRva2VuaXplclByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIsIHRpbWVab25lICk7XFxuXFx0XFx0cGFyc2VQcm9wZXJ0aWVzID0gZGF0ZVBhcnNlUHJvcGVydGllcyggY2xkciwgdGltZVpvbmUgKTtcXG5cXHR9IGZpbmFsbHkge1xcblxcdFxcdGNsZHIub2ZmKCBcXFwiZ2V0XFxcIiwgdmFsaWRhdGVSZXF1aXJlZENsZHIgKTtcXG5cXHRcXHRpZiAoIHRpbWVab25lICkge1xcblxcdFxcdFxcdGNsZHIub2ZmKCBcXFwiZ2V0XFxcIiwgdmFsaWRhdGVSZXF1aXJlZElhbmEoIHRpbWVab25lICkgKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdG51bWJlclBhcnNlciA9IHRoaXMubnVtYmVyUGFyc2VyKHsgcmF3OiBcXFwiMFxcXCIgfSk7XFxuXFxuXFx0cmV0dXJuRm4gPSBkYXRlUGFyc2VyRm4oIG51bWJlclBhcnNlciwgcGFyc2VQcm9wZXJ0aWVzLCB0b2tlbml6ZXJQcm9wZXJ0aWVzICk7XFxuXFxuXFx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbIG51bWJlclBhcnNlciwgcGFyc2VQcm9wZXJ0aWVzLCB0b2tlbml6ZXJQcm9wZXJ0aWVzIF0gKTtcXG5cXG5cXHRyZXR1cm4gcmV0dXJuRm47XFxufTtcXG5cXG4vKipcXG4gKiAuZm9ybWF0RGF0ZSggdmFsdWUsIG9wdGlvbnMgKVxcbiAqXFxuICogQHZhbHVlIFtEYXRlXVxcbiAqXFxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGRhdGUvZXhwYW5kX3BhdHRlcm4gZm9yIG1vcmUgaW5mby5cXG4gKlxcbiAqIEZvcm1hdHMgYSBkYXRlIG9yIG51bWJlciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgc3RyaW5nIGFuZCB0aGUgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXFxuICovXFxuR2xvYmFsaXplLmZvcm1hdERhdGUgPVxcbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZURhdGUoIHZhbHVlLCBcXFwidmFsdWVcXFwiICk7XFxuXFxuXFx0cmV0dXJuIHRoaXMuZGF0ZUZvcm1hdHRlciggb3B0aW9ucyApKCB2YWx1ZSApO1xcbn07XFxuXFxuLyoqXFxuICogLmZvcm1hdERhdGVUb1BhcnRzKCB2YWx1ZSwgb3B0aW9ucyApXFxuICpcXG4gKiBAdmFsdWUgW0RhdGVdXFxuICpcXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgZGF0ZS9leHBhbmRfcGF0dGVybiBmb3IgbW9yZSBpbmZvLlxcbiAqXFxuICogRm9ybWF0cyBhIGRhdGUgb3IgbnVtYmVyIHRvIHBhcnRzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgdGhlIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxcbiAqL1xcbkdsb2JhbGl6ZS5mb3JtYXREYXRlVG9QYXJ0cyA9XFxuR2xvYmFsaXplLnByb3RvdHlwZS5mb3JtYXREYXRlVG9QYXJ0cyA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZURhdGUoIHZhbHVlLCBcXFwidmFsdWVcXFwiICk7XFxuXFxuXFx0cmV0dXJuIHRoaXMuZGF0ZVRvUGFydHNGb3JtYXR0ZXIoIG9wdGlvbnMgKSggdmFsdWUgKTtcXG59O1xcblxcbi8qKlxcbiAqIC5wYXJzZURhdGUoIHZhbHVlLCBvcHRpb25zIClcXG4gKlxcbiAqIEB2YWx1ZSBbU3RyaW5nXVxcbiAqXFxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGRhdGUvZXhwYW5kX3BhdHRlcm4gZm9yIG1vcmUgaW5mby5cXG4gKlxcbiAqIFJldHVybiBhIERhdGUgaW5zdGFuY2Ugb3IgbnVsbC5cXG4gKi9cXG5HbG9iYWxpemUucGFyc2VEYXRlID1cXG5HbG9iYWxpemUucHJvdG90eXBlLnBhcnNlRGF0ZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXG5cXHRyZXR1cm4gdGhpcy5kYXRlUGFyc2VyKCBvcHRpb25zICkoIHZhbHVlICk7XFxufTtcXG5cXG5yZXR1cm4gR2xvYmFsaXplO1xcblxcblxcblxcblxcbn0pKTtcXG5cIiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(29))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL21lc3NhZ2UuanM/MWRiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXGdsb2JhbGl6ZVxcXFxkaXN0XFxcXGdsb2JhbGl6ZVxcXFxtZXNzYWdlLmpzXCIpKSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n")},function(module,exports){eval('module.exports = "/**\\n * Globalize v1.5.0\\n *\\n * http://github.com/jquery/globalize\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2020-03-25T12:19Z\\n */\\n/*!\\n * Globalize v1.5.0 2020-03-25T12:19Z Released under the MIT license\\n * http://git.io/TrdQbw\\n */\\n(function( root, factory ) {\\n\\n\\t// UMD returnExports\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\n\\t\\t// AMD\\n\\t\\tdefine([\\n\\t\\t\\t\\"cldr\\",\\n\\t\\t\\t\\"../globalize\\",\\n\\t\\t\\t\\"cldr/event\\"\\n\\t\\t], factory );\\n\\t} else if ( typeof exports === \\"object\\" ) {\\n\\n\\t\\t// Node, CommonJS\\n\\t\\tmodule.exports = factory( require( \\"cldrjs\\" ), require( \\"../globalize\\" ) );\\n\\t} else {\\n\\n\\t\\t// Extend global\\n\\t\\tfactory( root.Cldr, root.Globalize );\\n\\t}\\n}(this, function( Cldr, Globalize ) {\\n\\nvar alwaysArray = Globalize._alwaysArray,\\n\\tcreateError = Globalize._createError,\\n\\tisPlainObject = Globalize._isPlainObject,\\n\\truntimeBind = Globalize._runtimeBind,\\n\\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\\n\\tvalidate = Globalize._validate,\\n\\tvalidateParameterPresence = Globalize._validateParameterPresence,\\n\\tvalidateParameterType = Globalize._validateParameterType,\\n\\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\\nvar MessageFormat;\\n/* jshint ignore:start */\\nMessageFormat = (function() {\\nMessageFormat._parse = (function() {\\n\\n  /*\\n   * Generated by PEG.js 0.8.0.\\n   *\\n   * http://pegjs.majda.cz/\\n   */\\n\\n  function peg$subclass(child, parent) {\\n    function ctor() { this.constructor = child; }\\n    ctor.prototype = parent.prototype;\\n    child.prototype = new ctor();\\n  }\\n\\n  function SyntaxError(message, expected, found, offset, line, column) {\\n    this.message  = message;\\n    this.expected = expected;\\n    this.found    = found;\\n    this.offset   = offset;\\n    this.line     = line;\\n    this.column   = column;\\n\\n    this.name     = \\"SyntaxError\\";\\n  }\\n\\n  peg$subclass(SyntaxError, Error);\\n\\n  function parse(input) {\\n    var options = arguments.length > 1 ? arguments[1] : {},\\n\\n        peg$FAILED = {},\\n\\n        peg$startRuleFunctions = { start: peg$parsestart },\\n        peg$startRuleFunction  = peg$parsestart,\\n\\n        peg$c0 = [],\\n        peg$c1 = function(st) {\\n              return { type: \'messageFormatPattern\', statements: st };\\n            },\\n        peg$c2 = peg$FAILED,\\n        peg$c3 = \\"{\\",\\n        peg$c4 = { type: \\"literal\\", value: \\"{\\", description: \\"\\\\\\"{\\\\\\"\\" },\\n        peg$c5 = null,\\n        peg$c6 = \\",\\",\\n        peg$c7 = { type: \\"literal\\", value: \\",\\", description: \\"\\\\\\",\\\\\\"\\" },\\n        peg$c8 = \\"}\\",\\n        peg$c9 = { type: \\"literal\\", value: \\"}\\", description: \\"\\\\\\"}\\\\\\"\\" },\\n        peg$c10 = function(argIdx, efmt) {\\n              var res = {\\n                type: \\"messageFormatElement\\",\\n                argumentIndex: argIdx\\n              };\\n              if (efmt && efmt.length) {\\n                res.elementFormat = efmt[1];\\n              } else {\\n                res.output = true;\\n              }\\n              return res;\\n            },\\n        peg$c11 = \\"plural\\",\\n        peg$c12 = { type: \\"literal\\", value: \\"plural\\", description: \\"\\\\\\"plural\\\\\\"\\" },\\n        peg$c13 = function(t, s) {\\n              return { type: \\"elementFormat\\", key: t, val: s };\\n            },\\n        peg$c14 = \\"selectordinal\\",\\n        peg$c15 = { type: \\"literal\\", value: \\"selectordinal\\", description: \\"\\\\\\"selectordinal\\\\\\"\\" },\\n        peg$c16 = \\"select\\",\\n        peg$c17 = { type: \\"literal\\", value: \\"select\\", description: \\"\\\\\\"select\\\\\\"\\" },\\n        peg$c18 = function(t, p) {\\n              return { type: \\"elementFormat\\", key: t, val: p };\\n            },\\n        peg$c19 = function(op, pf) {\\n              return { type: \\"pluralFormatPattern\\", pluralForms: pf, offset: op || 0 };\\n            },\\n        peg$c20 = \\"offset\\",\\n        peg$c21 = { type: \\"literal\\", value: \\"offset\\", description: \\"\\\\\\"offset\\\\\\"\\" },\\n        peg$c22 = \\":\\",\\n        peg$c23 = { type: \\"literal\\", value: \\":\\", description: \\"\\\\\\":\\\\\\"\\" },\\n        peg$c24 = function(d) { return d; },\\n        peg$c25 = function(k, mfp) {\\n              return { key: k, val: mfp };\\n            },\\n        peg$c26 = function(i) { return i; },\\n        peg$c27 = \\"=\\",\\n        peg$c28 = { type: \\"literal\\", value: \\"=\\", description: \\"\\\\\\"=\\\\\\"\\" },\\n        peg$c29 = function(pf) { return { type: \\"selectFormatPattern\\", pluralForms: pf }; },\\n        peg$c30 = function(p) { return p; },\\n        peg$c31 = \\"#\\",\\n        peg$c32 = { type: \\"literal\\", value: \\"#\\", description: \\"\\\\\\"#\\\\\\"\\" },\\n        peg$c33 = function() { return {type: \'octothorpe\'}; },\\n        peg$c34 = function(s) { return { type: \\"string\\", val: s.join(\'\') }; },\\n        peg$c35 = { type: \\"other\\", description: \\"identifier\\" },\\n        peg$c36 = /^[0-9a-zA-Z$_]/,\\n        peg$c37 = { type: \\"class\\", value: \\"[0-9a-zA-Z$_]\\", description: \\"[0-9a-zA-Z$_]\\" },\\n        peg$c38 = /^[^ \\\\t\\\\n\\\\r,.+={}]/,\\n        peg$c39 = { type: \\"class\\", value: \\"[^ \\\\\\\\t\\\\\\\\n\\\\\\\\r,.+={}]\\", description: \\"[^ \\\\\\\\t\\\\\\\\n\\\\\\\\r,.+={}]\\" },\\n        peg$c40 = function(s) { return s; },\\n        peg$c41 = function(chars) { return chars.join(\'\'); },\\n        peg$c42 = /^[^{}#\\\\\\\\\\\\0-\\\\x1F \\\\t\\\\n\\\\r]/,\\n        peg$c43 = { type: \\"class\\", value: \\"[^{}#\\\\\\\\\\\\\\\\\\\\\\\\0-\\\\\\\\x1F \\\\\\\\t\\\\\\\\n\\\\\\\\r]\\", description: \\"[^{}#\\\\\\\\\\\\\\\\\\\\\\\\0-\\\\\\\\x1F \\\\\\\\t\\\\\\\\n\\\\\\\\r]\\" },\\n        peg$c44 = function(x) { return x; },\\n        peg$c45 = \\"\\\\\\\\\\\\\\\\\\",\\n        peg$c46 = { type: \\"literal\\", value: \\"\\\\\\\\\\\\\\\\\\", description: \\"\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\" },\\n        peg$c47 = function() { return \\"\\\\\\\\\\"; },\\n        peg$c48 = \\"\\\\\\\\#\\",\\n        peg$c49 = { type: \\"literal\\", value: \\"\\\\\\\\#\\", description: \\"\\\\\\"\\\\\\\\\\\\\\\\#\\\\\\"\\" },\\n        peg$c50 = function() { return \\"#\\"; },\\n        peg$c51 = \\"\\\\\\\\{\\",\\n        peg$c52 = { type: \\"literal\\", value: \\"\\\\\\\\{\\", description: \\"\\\\\\"\\\\\\\\\\\\\\\\{\\\\\\"\\" },\\n        peg$c53 = function() { return \\"\\\\u007B\\"; },\\n        peg$c54 = \\"\\\\\\\\}\\",\\n        peg$c55 = { type: \\"literal\\", value: \\"\\\\\\\\}\\", description: \\"\\\\\\"\\\\\\\\\\\\\\\\}\\\\\\"\\" },\\n        peg$c56 = function() { return \\"\\\\u007D\\"; },\\n        peg$c57 = \\"\\\\\\\\u\\",\\n        peg$c58 = { type: \\"literal\\", value: \\"\\\\\\\\u\\", description: \\"\\\\\\"\\\\\\\\\\\\\\\\u\\\\\\"\\" },\\n        peg$c59 = function(h1, h2, h3, h4) {\\n              return String.fromCharCode(parseInt(\\"0x\\" + h1 + h2 + h3 + h4));\\n            },\\n        peg$c60 = /^[0-9]/,\\n        peg$c61 = { type: \\"class\\", value: \\"[0-9]\\", description: \\"[0-9]\\" },\\n        peg$c62 = function(ds) {\\n            //the number might start with 0 but must not be interpreted as an octal number\\n            //Hence, the base is passed to parseInt explicitely\\n            return parseInt((ds.join(\'\')), 10);\\n          },\\n        peg$c63 = /^[0-9a-fA-F]/,\\n        peg$c64 = { type: \\"class\\", value: \\"[0-9a-fA-F]\\", description: \\"[0-9a-fA-F]\\" },\\n        peg$c65 = { type: \\"other\\", description: \\"whitespace\\" },\\n        peg$c66 = function(w) { return w.join(\'\'); },\\n        peg$c67 = /^[ \\\\t\\\\n\\\\r]/,\\n        peg$c68 = { type: \\"class\\", value: \\"[ \\\\\\\\t\\\\\\\\n\\\\\\\\r]\\", description: \\"[ \\\\\\\\t\\\\\\\\n\\\\\\\\r]\\" },\\n\\n        peg$currPos          = 0,\\n        peg$reportedPos      = 0,\\n        peg$cachedPos        = 0,\\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\\n        peg$maxFailPos       = 0,\\n        peg$maxFailExpected  = [],\\n        peg$silentFails      = 0,\\n\\n        peg$result;\\n\\n    if (\\"startRule\\" in options) {\\n      if (!(options.startRule in peg$startRuleFunctions)) {\\n        throw new Error(\\"Can\'t start parsing from rule \\\\\\"\\" + options.startRule + \\"\\\\\\".\\");\\n      }\\n\\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\\n    }\\n\\n    function text() {\\n      return input.substring(peg$reportedPos, peg$currPos);\\n    }\\n\\n    function offset() {\\n      return peg$reportedPos;\\n    }\\n\\n    function line() {\\n      return peg$computePosDetails(peg$reportedPos).line;\\n    }\\n\\n    function column() {\\n      return peg$computePosDetails(peg$reportedPos).column;\\n    }\\n\\n    function expected(description) {\\n      throw peg$buildException(\\n        null,\\n        [{ type: \\"other\\", description: description }],\\n        peg$reportedPos\\n      );\\n    }\\n\\n    function error(message) {\\n      throw peg$buildException(message, null, peg$reportedPos);\\n    }\\n\\n    function peg$computePosDetails(pos) {\\n      function advance(details, startPos, endPos) {\\n        var p, ch;\\n\\n        for (p = startPos; p < endPos; p++) {\\n          ch = input.charAt(p);\\n          if (ch === \\"\\\\n\\") {\\n            if (!details.seenCR) { details.line++; }\\n            details.column = 1;\\n            details.seenCR = false;\\n          } else if (ch === \\"\\\\r\\" || ch === \\"\\\\u2028\\" || ch === \\"\\\\u2029\\") {\\n            details.line++;\\n            details.column = 1;\\n            details.seenCR = true;\\n          } else {\\n            details.column++;\\n            details.seenCR = false;\\n          }\\n        }\\n      }\\n\\n      if (peg$cachedPos !== pos) {\\n        if (peg$cachedPos > pos) {\\n          peg$cachedPos = 0;\\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\\n        }\\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\\n        peg$cachedPos = pos;\\n      }\\n\\n      return peg$cachedPosDetails;\\n    }\\n\\n    function peg$fail(expected) {\\n      if (peg$currPos < peg$maxFailPos) { return; }\\n\\n      if (peg$currPos > peg$maxFailPos) {\\n        peg$maxFailPos = peg$currPos;\\n        peg$maxFailExpected = [];\\n      }\\n\\n      peg$maxFailExpected.push(expected);\\n    }\\n\\n    function peg$buildException(message, expected, pos) {\\n      function cleanupExpected(expected) {\\n        var i = 1;\\n\\n        expected.sort(function(a, b) {\\n          if (a.description < b.description) {\\n            return -1;\\n          } else if (a.description > b.description) {\\n            return 1;\\n          } else {\\n            return 0;\\n          }\\n        });\\n\\n        while (i < expected.length) {\\n          if (expected[i - 1] === expected[i]) {\\n            expected.splice(i, 1);\\n          } else {\\n            i++;\\n          }\\n        }\\n      }\\n\\n      function buildMessage(expected, found) {\\n        function stringEscape(s) {\\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\\n\\n          return s\\n            .replace(/\\\\\\\\/g,   \'\\\\\\\\\\\\\\\\\')\\n            .replace(/\\"/g,    \'\\\\\\\\\\"\')\\n            .replace(/\\\\x08/g, \'\\\\\\\\b\')\\n            .replace(/\\\\t/g,   \'\\\\\\\\t\')\\n            .replace(/\\\\n/g,   \'\\\\\\\\n\')\\n            .replace(/\\\\f/g,   \'\\\\\\\\f\')\\n            .replace(/\\\\r/g,   \'\\\\\\\\r\')\\n            .replace(/[\\\\x00-\\\\x07\\\\x0B\\\\x0E\\\\x0F]/g, function(ch) { return \'\\\\\\\\x0\' + hex(ch); })\\n            .replace(/[\\\\x10-\\\\x1F\\\\x80-\\\\xFF]/g,    function(ch) { return \'\\\\\\\\x\'  + hex(ch); })\\n            .replace(/[\\\\u0180-\\\\u0FFF]/g,         function(ch) { return \'\\\\\\\\u0\' + hex(ch); })\\n            .replace(/[\\\\u1080-\\\\uFFFF]/g,         function(ch) { return \'\\\\\\\\u\'  + hex(ch); });\\n        }\\n\\n        var expectedDescs = new Array(expected.length),\\n            expectedDesc, foundDesc, i;\\n\\n        for (i = 0; i < expected.length; i++) {\\n          expectedDescs[i] = expected[i].description;\\n        }\\n\\n        expectedDesc = expected.length > 1\\n          ? expectedDescs.slice(0, -1).join(\\", \\")\\n              + \\" or \\"\\n              + expectedDescs[expected.length - 1]\\n          : expectedDescs[0];\\n\\n        foundDesc = found ? \\"\\\\\\"\\" + stringEscape(found) + \\"\\\\\\"\\" : \\"end of input\\";\\n\\n        return \\"Expected \\" + expectedDesc + \\" but \\" + foundDesc + \\" found.\\";\\n      }\\n\\n      var posDetails = peg$computePosDetails(pos),\\n          found      = pos < input.length ? input.charAt(pos) : null;\\n\\n      if (expected !== null) {\\n        cleanupExpected(expected);\\n      }\\n\\n      return new SyntaxError(\\n        message !== null ? message : buildMessage(expected, found),\\n        expected,\\n        found,\\n        pos,\\n        posDetails.line,\\n        posDetails.column\\n      );\\n    }\\n\\n    function peg$parsestart() {\\n      var s0;\\n\\n      s0 = peg$parsemessageFormatPattern();\\n\\n      return s0;\\n    }\\n\\n    function peg$parsemessageFormatPattern() {\\n      var s0, s1, s2;\\n\\n      s0 = peg$currPos;\\n      s1 = [];\\n      s2 = peg$parsemessageFormatElement();\\n      if (s2 === peg$FAILED) {\\n        s2 = peg$parsestring();\\n        if (s2 === peg$FAILED) {\\n          s2 = peg$parseoctothorpe();\\n        }\\n      }\\n      while (s2 !== peg$FAILED) {\\n        s1.push(s2);\\n        s2 = peg$parsemessageFormatElement();\\n        if (s2 === peg$FAILED) {\\n          s2 = peg$parsestring();\\n          if (s2 === peg$FAILED) {\\n            s2 = peg$parseoctothorpe();\\n          }\\n        }\\n      }\\n      if (s1 !== peg$FAILED) {\\n        peg$reportedPos = s0;\\n        s1 = peg$c1(s1);\\n      }\\n      s0 = s1;\\n\\n      return s0;\\n    }\\n\\n    function peg$parsemessageFormatElement() {\\n      var s0, s1, s2, s3, s4, s5, s6;\\n\\n      s0 = peg$currPos;\\n      if (input.charCodeAt(peg$currPos) === 123) {\\n        s1 = peg$c3;\\n        peg$currPos++;\\n      } else {\\n        s1 = peg$FAILED;\\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\\n      }\\n      if (s1 !== peg$FAILED) {\\n        s2 = peg$parse_();\\n        if (s2 !== peg$FAILED) {\\n          s3 = peg$parseid();\\n          if (s3 !== peg$FAILED) {\\n            s4 = peg$currPos;\\n            if (input.charCodeAt(peg$currPos) === 44) {\\n              s5 = peg$c6;\\n              peg$currPos++;\\n            } else {\\n              s5 = peg$FAILED;\\n              if (peg$silentFails === 0) { peg$fail(peg$c7); }\\n            }\\n            if (s5 !== peg$FAILED) {\\n              s6 = peg$parseelementFormat();\\n              if (s6 !== peg$FAILED) {\\n                s5 = [s5, s6];\\n                s4 = s5;\\n              } else {\\n                peg$currPos = s4;\\n                s4 = peg$c2;\\n              }\\n            } else {\\n              peg$currPos = s4;\\n              s4 = peg$c2;\\n            }\\n            if (s4 === peg$FAILED) {\\n              s4 = peg$c5;\\n            }\\n            if (s4 !== peg$FAILED) {\\n              s5 = peg$parse_();\\n              if (s5 !== peg$FAILED) {\\n                if (input.charCodeAt(peg$currPos) === 125) {\\n                  s6 = peg$c8;\\n                  peg$currPos++;\\n                } else {\\n                  s6 = peg$FAILED;\\n                  if (peg$silentFails === 0) { peg$fail(peg$c9); }\\n                }\\n                if (s6 !== peg$FAILED) {\\n                  peg$reportedPos = s0;\\n                  s1 = peg$c10(s3, s4);\\n                  s0 = s1;\\n                } else {\\n                  peg$currPos = s0;\\n                  s0 = peg$c2;\\n                }\\n              } else {\\n                peg$currPos = s0;\\n                s0 = peg$c2;\\n              }\\n            } else {\\n              peg$currPos = s0;\\n              s0 = peg$c2;\\n            }\\n          } else {\\n            peg$currPos = s0;\\n            s0 = peg$c2;\\n          }\\n        } else {\\n          peg$currPos = s0;\\n          s0 = peg$c2;\\n        }\\n      } else {\\n        peg$currPos = s0;\\n        s0 = peg$c2;\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parseelementFormat() {\\n      var s0, s1, s2, s3, s4, s5, s6, s7;\\n\\n      s0 = peg$currPos;\\n      s1 = peg$parse_();\\n      if (s1 !== peg$FAILED) {\\n        if (input.substr(peg$currPos, 6) === peg$c11) {\\n          s2 = peg$c11;\\n          peg$currPos += 6;\\n        } else {\\n          s2 = peg$FAILED;\\n          if (peg$silentFails === 0) { peg$fail(peg$c12); }\\n        }\\n        if (s2 !== peg$FAILED) {\\n          s3 = peg$parse_();\\n          if (s3 !== peg$FAILED) {\\n            if (input.charCodeAt(peg$currPos) === 44) {\\n              s4 = peg$c6;\\n              peg$currPos++;\\n            } else {\\n              s4 = peg$FAILED;\\n              if (peg$silentFails === 0) { peg$fail(peg$c7); }\\n            }\\n            if (s4 !== peg$FAILED) {\\n              s5 = peg$parse_();\\n              if (s5 !== peg$FAILED) {\\n                s6 = peg$parsepluralFormatPattern();\\n                if (s6 !== peg$FAILED) {\\n                  s7 = peg$parse_();\\n                  if (s7 !== peg$FAILED) {\\n                    peg$reportedPos = s0;\\n                    s1 = peg$c13(s2, s6);\\n                    s0 = s1;\\n                  } else {\\n                    peg$currPos = s0;\\n                    s0 = peg$c2;\\n                  }\\n                } else {\\n                  peg$currPos = s0;\\n                  s0 = peg$c2;\\n                }\\n              } else {\\n                peg$currPos = s0;\\n                s0 = peg$c2;\\n              }\\n            } else {\\n              peg$currPos = s0;\\n              s0 = peg$c2;\\n            }\\n          } else {\\n            peg$currPos = s0;\\n            s0 = peg$c2;\\n          }\\n        } else {\\n          peg$currPos = s0;\\n          s0 = peg$c2;\\n        }\\n      } else {\\n        peg$currPos = s0;\\n        s0 = peg$c2;\\n      }\\n      if (s0 === peg$FAILED) {\\n        s0 = peg$currPos;\\n        s1 = peg$parse_();\\n        if (s1 !== peg$FAILED) {\\n          if (input.substr(peg$currPos, 13) === peg$c14) {\\n            s2 = peg$c14;\\n            peg$currPos += 13;\\n          } else {\\n            s2 = peg$FAILED;\\n            if (peg$silentFails === 0) { peg$fail(peg$c15); }\\n          }\\n          if (s2 !== peg$FAILED) {\\n            s3 = peg$parse_();\\n            if (s3 !== peg$FAILED) {\\n              if (input.charCodeAt(peg$currPos) === 44) {\\n                s4 = peg$c6;\\n                peg$currPos++;\\n              } else {\\n                s4 = peg$FAILED;\\n                if (peg$silentFails === 0) { peg$fail(peg$c7); }\\n              }\\n              if (s4 !== peg$FAILED) {\\n                s5 = peg$parse_();\\n                if (s5 !== peg$FAILED) {\\n                  s6 = peg$parsepluralFormatPattern();\\n                  if (s6 !== peg$FAILED) {\\n                    s7 = peg$parse_();\\n                    if (s7 !== peg$FAILED) {\\n                      peg$reportedPos = s0;\\n                      s1 = peg$c13(s2, s6);\\n                      s0 = s1;\\n                    } else {\\n                      peg$currPos = s0;\\n                      s0 = peg$c2;\\n                    }\\n                  } else {\\n                    peg$currPos = s0;\\n                    s0 = peg$c2;\\n                  }\\n                } else {\\n                  peg$currPos = s0;\\n                  s0 = peg$c2;\\n                }\\n              } else {\\n                peg$currPos = s0;\\n                s0 = peg$c2;\\n              }\\n            } else {\\n              peg$currPos = s0;\\n              s0 = peg$c2;\\n            }\\n          } else {\\n            peg$currPos = s0;\\n            s0 = peg$c2;\\n          }\\n        } else {\\n          peg$currPos = s0;\\n          s0 = peg$c2;\\n        }\\n        if (s0 === peg$FAILED) {\\n          s0 = peg$currPos;\\n          s1 = peg$parse_();\\n          if (s1 !== peg$FAILED) {\\n            if (input.substr(peg$currPos, 6) === peg$c16) {\\n              s2 = peg$c16;\\n              peg$currPos += 6;\\n            } else {\\n              s2 = peg$FAILED;\\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\\n            }\\n            if (s2 !== peg$FAILED) {\\n              s3 = peg$parse_();\\n              if (s3 !== peg$FAILED) {\\n                if (input.charCodeAt(peg$currPos) === 44) {\\n                  s4 = peg$c6;\\n                  peg$currPos++;\\n                } else {\\n                  s4 = peg$FAILED;\\n                  if (peg$silentFails === 0) { peg$fail(peg$c7); }\\n                }\\n                if (s4 !== peg$FAILED) {\\n                  s5 = peg$parse_();\\n                  if (s5 !== peg$FAILED) {\\n                    s6 = peg$parseselectFormatPattern();\\n                    if (s6 !== peg$FAILED) {\\n                      s7 = peg$parse_();\\n                      if (s7 !== peg$FAILED) {\\n                        peg$reportedPos = s0;\\n                        s1 = peg$c13(s2, s6);\\n                        s0 = s1;\\n                      } else {\\n                        peg$currPos = s0;\\n                        s0 = peg$c2;\\n                      }\\n                    } else {\\n                      peg$currPos = s0;\\n                      s0 = peg$c2;\\n                    }\\n                  } else {\\n                    peg$currPos = s0;\\n                    s0 = peg$c2;\\n                  }\\n                } else {\\n                  peg$currPos = s0;\\n                  s0 = peg$c2;\\n                }\\n              } else {\\n                peg$currPos = s0;\\n                s0 = peg$c2;\\n              }\\n            } else {\\n              peg$currPos = s0;\\n              s0 = peg$c2;\\n            }\\n          } else {\\n            peg$currPos = s0;\\n            s0 = peg$c2;\\n          }\\n          if (s0 === peg$FAILED) {\\n            s0 = peg$currPos;\\n            s1 = peg$parse_();\\n            if (s1 !== peg$FAILED) {\\n              s2 = peg$parseid();\\n              if (s2 !== peg$FAILED) {\\n                s3 = [];\\n                s4 = peg$parseargStylePattern();\\n                while (s4 !== peg$FAILED) {\\n                  s3.push(s4);\\n                  s4 = peg$parseargStylePattern();\\n                }\\n                if (s3 !== peg$FAILED) {\\n                  peg$reportedPos = s0;\\n                  s1 = peg$c18(s2, s3);\\n                  s0 = s1;\\n                } else {\\n                  peg$currPos = s0;\\n                  s0 = peg$c2;\\n                }\\n              } else {\\n                peg$currPos = s0;\\n                s0 = peg$c2;\\n              }\\n            } else {\\n              peg$currPos = s0;\\n              s0 = peg$c2;\\n            }\\n          }\\n        }\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parsepluralFormatPattern() {\\n      var s0, s1, s2, s3;\\n\\n      s0 = peg$currPos;\\n      s1 = peg$parseoffsetPattern();\\n      if (s1 === peg$FAILED) {\\n        s1 = peg$c5;\\n      }\\n      if (s1 !== peg$FAILED) {\\n        s2 = [];\\n        s3 = peg$parsepluralForm();\\n        if (s3 !== peg$FAILED) {\\n          while (s3 !== peg$FAILED) {\\n            s2.push(s3);\\n            s3 = peg$parsepluralForm();\\n          }\\n        } else {\\n          s2 = peg$c2;\\n        }\\n        if (s2 !== peg$FAILED) {\\n          peg$reportedPos = s0;\\n          s1 = peg$c19(s1, s2);\\n          s0 = s1;\\n        } else {\\n          peg$currPos = s0;\\n          s0 = peg$c2;\\n        }\\n      } else {\\n        peg$currPos = s0;\\n        s0 = peg$c2;\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parseoffsetPattern() {\\n      var s0, s1, s2, s3, s4, s5, s6, s7;\\n\\n      s0 = peg$currPos;\\n      s1 = peg$parse_();\\n      if (s1 !== peg$FAILED) {\\n        if (input.substr(peg$currPos, 6) === peg$c20) {\\n          s2 = peg$c20;\\n          peg$currPos += 6;\\n        } else {\\n          s2 = peg$FAILED;\\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\\n        }\\n        if (s2 !== peg$FAILED) {\\n          s3 = peg$parse_();\\n          if (s3 !== peg$FAILED) {\\n            if (input.charCodeAt(peg$currPos) === 58) {\\n              s4 = peg$c22;\\n              peg$currPos++;\\n            } else {\\n              s4 = peg$FAILED;\\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\\n            }\\n            if (s4 !== peg$FAILED) {\\n              s5 = peg$parse_();\\n              if (s5 !== peg$FAILED) {\\n                s6 = peg$parsedigits();\\n                if (s6 !== peg$FAILED) {\\n                  s7 = peg$parse_();\\n                  if (s7 !== peg$FAILED) {\\n                    peg$reportedPos = s0;\\n                    s1 = peg$c24(s6);\\n                    s0 = s1;\\n                  } else {\\n                    peg$currPos = s0;\\n                    s0 = peg$c2;\\n                  }\\n                } else {\\n                  peg$currPos = s0;\\n                  s0 = peg$c2;\\n                }\\n              } else {\\n                peg$currPos = s0;\\n                s0 = peg$c2;\\n              }\\n            } else {\\n              peg$currPos = s0;\\n              s0 = peg$c2;\\n            }\\n          } else {\\n            peg$currPos = s0;\\n            s0 = peg$c2;\\n          }\\n        } else {\\n          peg$currPos = s0;\\n          s0 = peg$c2;\\n        }\\n      } else {\\n        peg$currPos = s0;\\n        s0 = peg$c2;\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parsepluralForm() {\\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\\n\\n      s0 = peg$currPos;\\n      s1 = peg$parse_();\\n      if (s1 !== peg$FAILED) {\\n        s2 = peg$parsepluralKey();\\n        if (s2 !== peg$FAILED) {\\n          s3 = peg$parse_();\\n          if (s3 !== peg$FAILED) {\\n            if (input.charCodeAt(peg$currPos) === 123) {\\n              s4 = peg$c3;\\n              peg$currPos++;\\n            } else {\\n              s4 = peg$FAILED;\\n              if (peg$silentFails === 0) { peg$fail(peg$c4); }\\n            }\\n            if (s4 !== peg$FAILED) {\\n              s5 = peg$parse_();\\n              if (s5 !== peg$FAILED) {\\n                s6 = peg$parsemessageFormatPattern();\\n                if (s6 !== peg$FAILED) {\\n                  s7 = peg$parse_();\\n                  if (s7 !== peg$FAILED) {\\n                    if (input.charCodeAt(peg$currPos) === 125) {\\n                      s8 = peg$c8;\\n                      peg$currPos++;\\n                    } else {\\n                      s8 = peg$FAILED;\\n                      if (peg$silentFails === 0) { peg$fail(peg$c9); }\\n                    }\\n                    if (s8 !== peg$FAILED) {\\n                      peg$reportedPos = s0;\\n                      s1 = peg$c25(s2, s6);\\n                      s0 = s1;\\n                    } else {\\n                      peg$currPos = s0;\\n                      s0 = peg$c2;\\n                    }\\n                  } else {\\n                    peg$currPos = s0;\\n                    s0 = peg$c2;\\n                  }\\n                } else {\\n                  peg$currPos = s0;\\n                  s0 = peg$c2;\\n                }\\n              } else {\\n                peg$currPos = s0;\\n                s0 = peg$c2;\\n              }\\n            } else {\\n              peg$currPos = s0;\\n              s0 = peg$c2;\\n            }\\n          } else {\\n            peg$currPos = s0;\\n            s0 = peg$c2;\\n          }\\n        } else {\\n          peg$currPos = s0;\\n          s0 = peg$c2;\\n        }\\n      } else {\\n        peg$currPos = s0;\\n        s0 = peg$c2;\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parsepluralKey() {\\n      var s0, s1, s2;\\n\\n      s0 = peg$currPos;\\n      s1 = peg$parseid();\\n      if (s1 !== peg$FAILED) {\\n        peg$reportedPos = s0;\\n        s1 = peg$c26(s1);\\n      }\\n      s0 = s1;\\n      if (s0 === peg$FAILED) {\\n        s0 = peg$currPos;\\n        if (input.charCodeAt(peg$currPos) === 61) {\\n          s1 = peg$c27;\\n          peg$currPos++;\\n        } else {\\n          s1 = peg$FAILED;\\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\\n        }\\n        if (s1 !== peg$FAILED) {\\n          s2 = peg$parsedigits();\\n          if (s2 !== peg$FAILED) {\\n            peg$reportedPos = s0;\\n            s1 = peg$c24(s2);\\n            s0 = s1;\\n          } else {\\n            peg$currPos = s0;\\n            s0 = peg$c2;\\n          }\\n        } else {\\n          peg$currPos = s0;\\n          s0 = peg$c2;\\n        }\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parseselectFormatPattern() {\\n      var s0, s1, s2;\\n\\n      s0 = peg$currPos;\\n      s1 = [];\\n      s2 = peg$parseselectForm();\\n      if (s2 !== peg$FAILED) {\\n        while (s2 !== peg$FAILED) {\\n          s1.push(s2);\\n          s2 = peg$parseselectForm();\\n        }\\n      } else {\\n        s1 = peg$c2;\\n      }\\n      if (s1 !== peg$FAILED) {\\n        peg$reportedPos = s0;\\n        s1 = peg$c29(s1);\\n      }\\n      s0 = s1;\\n\\n      return s0;\\n    }\\n\\n    function peg$parseselectForm() {\\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\\n\\n      s0 = peg$currPos;\\n      s1 = peg$parse_();\\n      if (s1 !== peg$FAILED) {\\n        s2 = peg$parseid();\\n        if (s2 !== peg$FAILED) {\\n          s3 = peg$parse_();\\n          if (s3 !== peg$FAILED) {\\n            if (input.charCodeAt(peg$currPos) === 123) {\\n              s4 = peg$c3;\\n              peg$currPos++;\\n            } else {\\n              s4 = peg$FAILED;\\n              if (peg$silentFails === 0) { peg$fail(peg$c4); }\\n            }\\n            if (s4 !== peg$FAILED) {\\n              s5 = peg$parse_();\\n              if (s5 !== peg$FAILED) {\\n                s6 = peg$parsemessageFormatPattern();\\n                if (s6 !== peg$FAILED) {\\n                  s7 = peg$parse_();\\n                  if (s7 !== peg$FAILED) {\\n                    if (input.charCodeAt(peg$currPos) === 125) {\\n                      s8 = peg$c8;\\n                      peg$currPos++;\\n                    } else {\\n                      s8 = peg$FAILED;\\n                      if (peg$silentFails === 0) { peg$fail(peg$c9); }\\n                    }\\n                    if (s8 !== peg$FAILED) {\\n                      peg$reportedPos = s0;\\n                      s1 = peg$c25(s2, s6);\\n                      s0 = s1;\\n                    } else {\\n                      peg$currPos = s0;\\n                      s0 = peg$c2;\\n                    }\\n                  } else {\\n                    peg$currPos = s0;\\n                    s0 = peg$c2;\\n                  }\\n                } else {\\n                  peg$currPos = s0;\\n                  s0 = peg$c2;\\n                }\\n              } else {\\n                peg$currPos = s0;\\n                s0 = peg$c2;\\n              }\\n            } else {\\n              peg$currPos = s0;\\n              s0 = peg$c2;\\n            }\\n          } else {\\n            peg$currPos = s0;\\n            s0 = peg$c2;\\n          }\\n        } else {\\n          peg$currPos = s0;\\n          s0 = peg$c2;\\n        }\\n      } else {\\n        peg$currPos = s0;\\n        s0 = peg$c2;\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parseargStylePattern() {\\n      var s0, s1, s2, s3, s4, s5;\\n\\n      s0 = peg$currPos;\\n      s1 = peg$parse_();\\n      if (s1 !== peg$FAILED) {\\n        if (input.charCodeAt(peg$currPos) === 44) {\\n          s2 = peg$c6;\\n          peg$currPos++;\\n        } else {\\n          s2 = peg$FAILED;\\n          if (peg$silentFails === 0) { peg$fail(peg$c7); }\\n        }\\n        if (s2 !== peg$FAILED) {\\n          s3 = peg$parse_();\\n          if (s3 !== peg$FAILED) {\\n            s4 = peg$parseid();\\n            if (s4 !== peg$FAILED) {\\n              s5 = peg$parse_();\\n              if (s5 !== peg$FAILED) {\\n                peg$reportedPos = s0;\\n                s1 = peg$c30(s4);\\n                s0 = s1;\\n              } else {\\n                peg$currPos = s0;\\n                s0 = peg$c2;\\n              }\\n            } else {\\n              peg$currPos = s0;\\n              s0 = peg$c2;\\n            }\\n          } else {\\n            peg$currPos = s0;\\n            s0 = peg$c2;\\n          }\\n        } else {\\n          peg$currPos = s0;\\n          s0 = peg$c2;\\n        }\\n      } else {\\n        peg$currPos = s0;\\n        s0 = peg$c2;\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parseoctothorpe() {\\n      var s0, s1;\\n\\n      s0 = peg$currPos;\\n      if (input.charCodeAt(peg$currPos) === 35) {\\n        s1 = peg$c31;\\n        peg$currPos++;\\n      } else {\\n        s1 = peg$FAILED;\\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\\n      }\\n      if (s1 !== peg$FAILED) {\\n        peg$reportedPos = s0;\\n        s1 = peg$c33();\\n      }\\n      s0 = s1;\\n\\n      return s0;\\n    }\\n\\n    function peg$parsestring() {\\n      var s0, s1, s2;\\n\\n      s0 = peg$currPos;\\n      s1 = [];\\n      s2 = peg$parsechars();\\n      if (s2 === peg$FAILED) {\\n        s2 = peg$parsewhitespace();\\n      }\\n      if (s2 !== peg$FAILED) {\\n        while (s2 !== peg$FAILED) {\\n          s1.push(s2);\\n          s2 = peg$parsechars();\\n          if (s2 === peg$FAILED) {\\n            s2 = peg$parsewhitespace();\\n          }\\n        }\\n      } else {\\n        s1 = peg$c2;\\n      }\\n      if (s1 !== peg$FAILED) {\\n        peg$reportedPos = s0;\\n        s1 = peg$c34(s1);\\n      }\\n      s0 = s1;\\n\\n      return s0;\\n    }\\n\\n    function peg$parseid() {\\n      var s0, s1, s2, s3, s4, s5, s6;\\n\\n      peg$silentFails++;\\n      s0 = peg$currPos;\\n      s1 = peg$parse_();\\n      if (s1 !== peg$FAILED) {\\n        s2 = peg$currPos;\\n        s3 = peg$currPos;\\n        if (peg$c36.test(input.charAt(peg$currPos))) {\\n          s4 = input.charAt(peg$currPos);\\n          peg$currPos++;\\n        } else {\\n          s4 = peg$FAILED;\\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\\n        }\\n        if (s4 !== peg$FAILED) {\\n          s5 = [];\\n          if (peg$c38.test(input.charAt(peg$currPos))) {\\n            s6 = input.charAt(peg$currPos);\\n            peg$currPos++;\\n          } else {\\n            s6 = peg$FAILED;\\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\\n          }\\n          while (s6 !== peg$FAILED) {\\n            s5.push(s6);\\n            if (peg$c38.test(input.charAt(peg$currPos))) {\\n              s6 = input.charAt(peg$currPos);\\n              peg$currPos++;\\n            } else {\\n              s6 = peg$FAILED;\\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\\n            }\\n          }\\n          if (s5 !== peg$FAILED) {\\n            s4 = [s4, s5];\\n            s3 = s4;\\n          } else {\\n            peg$currPos = s3;\\n            s3 = peg$c2;\\n          }\\n        } else {\\n          peg$currPos = s3;\\n          s3 = peg$c2;\\n        }\\n        if (s3 !== peg$FAILED) {\\n          s3 = input.substring(s2, peg$currPos);\\n        }\\n        s2 = s3;\\n        if (s2 !== peg$FAILED) {\\n          s3 = peg$parse_();\\n          if (s3 !== peg$FAILED) {\\n            peg$reportedPos = s0;\\n            s1 = peg$c40(s2);\\n            s0 = s1;\\n          } else {\\n            peg$currPos = s0;\\n            s0 = peg$c2;\\n          }\\n        } else {\\n          peg$currPos = s0;\\n          s0 = peg$c2;\\n        }\\n      } else {\\n        peg$currPos = s0;\\n        s0 = peg$c2;\\n      }\\n      peg$silentFails--;\\n      if (s0 === peg$FAILED) {\\n        s1 = peg$FAILED;\\n        if (peg$silentFails === 0) { peg$fail(peg$c35); }\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parsechars() {\\n      var s0, s1, s2;\\n\\n      s0 = peg$currPos;\\n      s1 = [];\\n      s2 = peg$parsechar();\\n      if (s2 !== peg$FAILED) {\\n        while (s2 !== peg$FAILED) {\\n          s1.push(s2);\\n          s2 = peg$parsechar();\\n        }\\n      } else {\\n        s1 = peg$c2;\\n      }\\n      if (s1 !== peg$FAILED) {\\n        peg$reportedPos = s0;\\n        s1 = peg$c41(s1);\\n      }\\n      s0 = s1;\\n\\n      return s0;\\n    }\\n\\n    function peg$parsechar() {\\n      var s0, s1, s2, s3, s4, s5;\\n\\n      s0 = peg$currPos;\\n      if (peg$c42.test(input.charAt(peg$currPos))) {\\n        s1 = input.charAt(peg$currPos);\\n        peg$currPos++;\\n      } else {\\n        s1 = peg$FAILED;\\n        if (peg$silentFails === 0) { peg$fail(peg$c43); }\\n      }\\n      if (s1 !== peg$FAILED) {\\n        peg$reportedPos = s0;\\n        s1 = peg$c44(s1);\\n      }\\n      s0 = s1;\\n      if (s0 === peg$FAILED) {\\n        s0 = peg$currPos;\\n        if (input.substr(peg$currPos, 2) === peg$c45) {\\n          s1 = peg$c45;\\n          peg$currPos += 2;\\n        } else {\\n          s1 = peg$FAILED;\\n          if (peg$silentFails === 0) { peg$fail(peg$c46); }\\n        }\\n        if (s1 !== peg$FAILED) {\\n          peg$reportedPos = s0;\\n          s1 = peg$c47();\\n        }\\n        s0 = s1;\\n        if (s0 === peg$FAILED) {\\n          s0 = peg$currPos;\\n          if (input.substr(peg$currPos, 2) === peg$c48) {\\n            s1 = peg$c48;\\n            peg$currPos += 2;\\n          } else {\\n            s1 = peg$FAILED;\\n            if (peg$silentFails === 0) { peg$fail(peg$c49); }\\n          }\\n          if (s1 !== peg$FAILED) {\\n            peg$reportedPos = s0;\\n            s1 = peg$c50();\\n          }\\n          s0 = s1;\\n          if (s0 === peg$FAILED) {\\n            s0 = peg$currPos;\\n            if (input.substr(peg$currPos, 2) === peg$c51) {\\n              s1 = peg$c51;\\n              peg$currPos += 2;\\n            } else {\\n              s1 = peg$FAILED;\\n              if (peg$silentFails === 0) { peg$fail(peg$c52); }\\n            }\\n            if (s1 !== peg$FAILED) {\\n              peg$reportedPos = s0;\\n              s1 = peg$c53();\\n            }\\n            s0 = s1;\\n            if (s0 === peg$FAILED) {\\n              s0 = peg$currPos;\\n              if (input.substr(peg$currPos, 2) === peg$c54) {\\n                s1 = peg$c54;\\n                peg$currPos += 2;\\n              } else {\\n                s1 = peg$FAILED;\\n                if (peg$silentFails === 0) { peg$fail(peg$c55); }\\n              }\\n              if (s1 !== peg$FAILED) {\\n                peg$reportedPos = s0;\\n                s1 = peg$c56();\\n              }\\n              s0 = s1;\\n              if (s0 === peg$FAILED) {\\n                s0 = peg$currPos;\\n                if (input.substr(peg$currPos, 2) === peg$c57) {\\n                  s1 = peg$c57;\\n                  peg$currPos += 2;\\n                } else {\\n                  s1 = peg$FAILED;\\n                  if (peg$silentFails === 0) { peg$fail(peg$c58); }\\n                }\\n                if (s1 !== peg$FAILED) {\\n                  s2 = peg$parsehexDigit();\\n                  if (s2 !== peg$FAILED) {\\n                    s3 = peg$parsehexDigit();\\n                    if (s3 !== peg$FAILED) {\\n                      s4 = peg$parsehexDigit();\\n                      if (s4 !== peg$FAILED) {\\n                        s5 = peg$parsehexDigit();\\n                        if (s5 !== peg$FAILED) {\\n                          peg$reportedPos = s0;\\n                          s1 = peg$c59(s2, s3, s4, s5);\\n                          s0 = s1;\\n                        } else {\\n                          peg$currPos = s0;\\n                          s0 = peg$c2;\\n                        }\\n                      } else {\\n                        peg$currPos = s0;\\n                        s0 = peg$c2;\\n                      }\\n                    } else {\\n                      peg$currPos = s0;\\n                      s0 = peg$c2;\\n                    }\\n                  } else {\\n                    peg$currPos = s0;\\n                    s0 = peg$c2;\\n                  }\\n                } else {\\n                  peg$currPos = s0;\\n                  s0 = peg$c2;\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parsedigits() {\\n      var s0, s1, s2;\\n\\n      s0 = peg$currPos;\\n      s1 = [];\\n      if (peg$c60.test(input.charAt(peg$currPos))) {\\n        s2 = input.charAt(peg$currPos);\\n        peg$currPos++;\\n      } else {\\n        s2 = peg$FAILED;\\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\\n      }\\n      if (s2 !== peg$FAILED) {\\n        while (s2 !== peg$FAILED) {\\n          s1.push(s2);\\n          if (peg$c60.test(input.charAt(peg$currPos))) {\\n            s2 = input.charAt(peg$currPos);\\n            peg$currPos++;\\n          } else {\\n            s2 = peg$FAILED;\\n            if (peg$silentFails === 0) { peg$fail(peg$c61); }\\n          }\\n        }\\n      } else {\\n        s1 = peg$c2;\\n      }\\n      if (s1 !== peg$FAILED) {\\n        peg$reportedPos = s0;\\n        s1 = peg$c62(s1);\\n      }\\n      s0 = s1;\\n\\n      return s0;\\n    }\\n\\n    function peg$parsehexDigit() {\\n      var s0;\\n\\n      if (peg$c63.test(input.charAt(peg$currPos))) {\\n        s0 = input.charAt(peg$currPos);\\n        peg$currPos++;\\n      } else {\\n        s0 = peg$FAILED;\\n        if (peg$silentFails === 0) { peg$fail(peg$c64); }\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parse_() {\\n      var s0, s1, s2;\\n\\n      peg$silentFails++;\\n      s0 = peg$currPos;\\n      s1 = [];\\n      s2 = peg$parsewhitespace();\\n      while (s2 !== peg$FAILED) {\\n        s1.push(s2);\\n        s2 = peg$parsewhitespace();\\n      }\\n      if (s1 !== peg$FAILED) {\\n        peg$reportedPos = s0;\\n        s1 = peg$c66(s1);\\n      }\\n      s0 = s1;\\n      peg$silentFails--;\\n      if (s0 === peg$FAILED) {\\n        s1 = peg$FAILED;\\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\\n      }\\n\\n      return s0;\\n    }\\n\\n    function peg$parsewhitespace() {\\n      var s0;\\n\\n      if (peg$c67.test(input.charAt(peg$currPos))) {\\n        s0 = input.charAt(peg$currPos);\\n        peg$currPos++;\\n      } else {\\n        s0 = peg$FAILED;\\n        if (peg$silentFails === 0) { peg$fail(peg$c68); }\\n      }\\n\\n      return s0;\\n    }\\n\\n    peg$result = peg$startRuleFunction();\\n\\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\\n      return peg$result;\\n    } else {\\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\\n        peg$fail({ type: \\"end\\", description: \\"end of input\\" });\\n      }\\n\\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\\n    }\\n  }\\n\\n  return {\\n    SyntaxError: SyntaxError,\\n    parse:       parse\\n  };\\n}()).parse;\\n\\n\\n/** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript\\n *  @author Alex Sexton - @SlexAxton\\n *  @version 0.3.0-1\\n *  @copyright 2012-2015 Alex Sexton, Eemeli Aro, and Contributors\\n *  @license To use or fork, MIT. To contribute back, Dojo CLA  */\\n\\n\\n/** Utility function for quoting an Object\'s key value iff required\\n *  @private  */\\nfunction propname(key, obj) {\\n  if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key)) {\\n    return obj ? obj + \'.\' + key : key;\\n  } else {\\n    var jkey = JSON.stringify(key);\\n    return obj ? obj + \'[\' + jkey + \']\' : jkey;\\n  }\\n};\\n\\n\\n/** Create a new message formatter\\n *\\n *  @class\\n *  @global\\n *  @param {string|string[]} [locale=\\"en\\"] - The locale to use, with fallbacks\\n *  @param {function} [pluralFunc] - Optional custom pluralization function\\n *  @param {function[]} [formatters] - Optional custom formatting functions  */\\nfunction MessageFormat(locale, pluralFunc, formatters) {\\n  this.lc = [locale];  \\n  this.runtime.pluralFuncs = {};\\n  this.runtime.pluralFuncs[this.lc[0]] = pluralFunc;\\n  this.runtime.fmt = {};\\n  if (formatters) for (var f in formatters) {\\n    this.runtime.fmt[f] = formatters[f];\\n  }\\n}\\n\\n\\n\\n\\n/** Parse an input string to its AST\\n *\\n *  Precompiled from `lib/messageformat-parser.pegjs` by\\n *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object\\n *  to enable testing.\\n *\\n *  @private  */\\n\\n\\n\\n/** Pluralization functions from\\n *  {@link http://github.com/eemeli/make-plural.js make-plural}\\n *\\n *  @memberof MessageFormat\\n *  @type Object.<string,function>  */\\nMessageFormat.plurals = {};\\n\\n\\n/** Default number formatting functions in the style of ICU\'s\\n *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}\\n *  implemented using the\\n *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}\\n *  object defined by ECMA-402.\\n *\\n *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so\\n *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.\\n *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these\\n *  functions to be available for inclusion in the output.\\n *\\n *  @see MessageFormat#setIntlSupport\\n *\\n *  @namespace\\n *  @memberof MessageFormat\\n *  @property {function} number - Represent a number as an integer, percent or currency value\\n *  @property {function} date - Represent a date as a full/long/default/short string\\n *  @property {function} time - Represent a time as a full/long/default/short string\\n *\\n *  @example\\n *  > var MessageFormat = require(\'messageformat\');\\n *  > var mf = (new MessageFormat(\'en\')).setIntlSupport(true);\\n *  > mf.currency = \'EUR\';\\n *  > var mfunc = mf.compile(\\"The total is {V,number,currency}.\\");\\n *  > mfunc({V:5.5})\\n *  \\"The total is 5.50.\\"\\n *\\n *  @example\\n *  > var MessageFormat = require(\'messageformat\');\\n *  > var mf = new MessageFormat(\'en\', null, {number: MessageFormat.number});\\n *  > mf.currency = \'EUR\';\\n *  > var mfunc = mf.compile(\\"The total is {V,number,currency}.\\");\\n *  > mfunc({V:5.5})\\n *  \\"The total is 5.50.\\"  */\\nMessageFormat.formatters = {};\\n\\n/** Enable or disable support for the default formatters, which require the\\n *  `Intl` object. Note that this can\'t be autodetected, as the environment\\n *  in which the formatted text is compiled into Javascript functions is not\\n *  necessarily the same environment in which they will get executed.\\n *\\n *  @see MessageFormat.formatters\\n *\\n *  @memberof MessageFormat\\n *  @param {boolean} [enable=true]\\n *  @returns {Object} The MessageFormat instance, to allow for chaining\\n *  @example\\n *  > var Intl = require(\'intl\');\\n *  > var MessageFormat = require(\'messageformat\');\\n *  > var mf = (new MessageFormat(\'en\')).setIntlSupport(true);\\n *  > mf.currency = \'EUR\';\\n *  > mf.compile(\\"The total is {V,number,currency}.\\")({V:5.5});\\n *  \\"The total is 5.50.\\"  */\\n\\n\\n\\n/** A set of utility functions that are called by the compiled Javascript\\n *  functions, these are included locally in the output of {@link\\n *  MessageFormat#compile compile()}.\\n *\\n *  @namespace\\n *  @memberof MessageFormat  */\\nMessageFormat.prototype.runtime = {\\n\\n  /** Utility function for `#` in plural rules\\n   *\\n   *  @param {number} value - The value to operate on\\n   *  @param {number} [offset=0] - An optional offset, set by the surrounding context  */\\n  number: function(value, offset) {\\n    if (isNaN(value)) throw new Error(\\"\'\\" + value + \\"\' isn\'t a number.\\");\\n    return value - (offset || 0);\\n  },\\n\\n  /** Utility function for `{N, plural|selectordinal, ...}`\\n   *\\n   *  @param {number} value - The key to use to find a pluralization rule\\n   *  @param {number} offset - An offset to apply to `value`\\n   *  @param {function} lcfunc - A locale function from `pluralFuncs`\\n   *  @param {Object.<string,string>} data - The object from which results are looked up\\n   *  @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules\\n   *  @returns {string} The result of the pluralization  */\\n  plural: function(value, offset, lcfunc, data, isOrdinal) {\\n    if ({}.hasOwnProperty.call(data, value)) return data[value]();\\n    if (offset) value -= offset;\\n    var key = lcfunc(value, isOrdinal);\\n    if (key in data) return data[key]();\\n    return data.other();\\n  },\\n\\n  /** Utility function for `{N, select, ...}`\\n   *\\n   *  @param {number} value - The key to use to find a selection\\n   *  @param {Object.<string,string>} data - The object from which results are looked up\\n   *  @returns {string} The result of the select statement  */\\n  select: function(value, data) {\\n    if ({}.hasOwnProperty.call(data, value)) return data[value]();\\n    return data.other()\\n  },\\n\\n  /** Pluralization functions included in compiled output\\n   *  @instance\\n   *  @type Object.<string,function>  */\\n  pluralFuncs: {},\\n\\n  /** Custom formatting functions called by `{var, fn[, args]*}` syntax\\n   *\\n   *  For examples, see {@link MessageFormat.formatters}\\n   *\\n   *  @instance\\n   *  @see MessageFormat.formatters\\n   *  @type Object.<string,function>  */\\n  fmt: {},\\n\\n  /** Custom stringifier to clean up browser inconsistencies\\n   *  @instance  */\\n  toString: function () {\\n    var _stringify = function(o, level) {\\n      if (typeof o != \'object\') {\\n        var funcStr = o.toString().replace(/^(function )\\\\w*/, \'$1\');\\n        var indent = /([ \\\\t]*)\\\\S.*$/.exec(funcStr);\\n        return indent ? funcStr.replace(new RegExp(\'^\' + indent[1], \'mg\'), \'\') : funcStr;\\n      }\\n      var s = [];\\n      for (var i in o) if (i != \'toString\') {\\n        if (level == 0) s.push(\'var \' + i + \' = \' + _stringify(o[i], level + 1) + \';\\\\n\');\\n        else s.push(propname(i) + \': \' + _stringify(o[i], level + 1));\\n      }\\n      if (level == 0) return s.join(\'\');\\n      if (s.length == 0) return \'{}\';\\n      var indent = \'  \'; while (--level) indent += \'  \';\\n      return \'{\\\\n\' + s.join(\',\\\\n\').replace(/^/gm, indent) + \'\\\\n}\';\\n    };\\n    return _stringify(this, 0);\\n  }\\n};\\n\\n\\n/** Recursively map an AST to its resulting string\\n *\\n *  @memberof MessageFormat\\n *\\n *  @param ast - the Ast node for which the JS code should be generated\\n *\\n *  @private  */\\nMessageFormat.prototype._precompile = function(ast, data) {\\n  data = data || { keys: {}, offset: {} };\\n  var r = [], i, tmp, args = [];\\n\\n  switch ( ast.type ) {\\n    case \'messageFormatPattern\':\\n      for ( i = 0; i < ast.statements.length; ++i ) {\\n        r.push(this._precompile( ast.statements[i], data ));\\n      }\\n      tmp = r.join(\' + \') || \'\\"\\"\';\\n      return data.pf_count ? tmp : \'function(d) { return \' + tmp + \'; }\';\\n\\n    case \'messageFormatElement\':\\n      data.pf_count = data.pf_count || 0;\\n      if ( ast.output ) {\\n        return propname(ast.argumentIndex, \'d\');\\n      }\\n      else {\\n        data.keys[data.pf_count] = ast.argumentIndex;\\n        return this._precompile( ast.elementFormat, data );\\n      }\\n      return \'\';\\n\\n    case \'elementFormat\':\\n      args = [ propname(data.keys[data.pf_count], \'d\') ];\\n      switch (ast.key) {\\n        case \'select\':\\n          args.push(this._precompile(ast.val, data));\\n          return \'select(\' + args.join(\', \') + \')\';\\n        case \'selectordinal\':\\n          args = args.concat([ 0, propname(this.lc[0], \'pluralFuncs\'), this._precompile(ast.val, data), 1 ]);\\n          return \'plural(\' + args.join(\', \') + \')\';\\n        case \'plural\':\\n          data.offset[data.pf_count || 0] = ast.val.offset || 0;\\n          args = args.concat([ data.offset[data.pf_count] || 0, propname(this.lc[0], \'pluralFuncs\'), this._precompile(ast.val, data) ]);\\n          return \'plural(\' + args.join(\', \') + \')\';\\n        default:\\n          if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && (ast.key in MessageFormat.formatters)) {\\n            tmp = MessageFormat.formatters[ast.key];\\n            this.runtime.fmt[ast.key] = (typeof tmp(this) == \'function\') ? tmp(this) : tmp;\\n          }\\n          args.push(JSON.stringify(this.lc));\\n          if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));\\n          return \'fmt.\' + ast.key + \'(\' + args.join(\', \') + \')\';\\n      }\\n\\n    case \'pluralFormatPattern\':\\n    case \'selectFormatPattern\':\\n      data.pf_count = data.pf_count || 0;\\n      if (ast.type == \'selectFormatPattern\') data.offset[data.pf_count] = 0;\\n      var needOther = true;\\n      for (i = 0; i < ast.pluralForms.length; ++i) {\\n        var key = ast.pluralForms[i].key;\\n        if (key === \'other\') needOther = false;\\n        var data_copy = JSON.parse(JSON.stringify(data));\\n        data_copy.pf_count++;\\n        r.push(propname(key) + \': function() { return \' + this._precompile(ast.pluralForms[i].val, data_copy) + \';}\');\\n      }\\n      if (needOther) throw new Error(\\"No \'other\' form found in \\" + ast.type + \\" \\" + data.pf_count);\\n      return \'{ \' + r.join(\', \') + \' }\';\\n\\n    case \'string\':\\n      return JSON.stringify(ast.val || \\"\\");\\n\\n    case \'octothorpe\':\\n      if (!data.pf_count) return \'\\"#\\"\';\\n      args = [ propname(data.keys[data.pf_count-1], \'d\') ];\\n      if (data.offset[data.pf_count-1]) args.push(data.offset[data.pf_count-1]);\\n      return \'number(\' + args.join(\', \') + \')\';\\n\\n    default:\\n      throw new Error( \'Bad AST type: \' + ast.type );\\n  }\\n};\\n\\n/** Compile messages into an executable function with clean string\\n *  representation.\\n *\\n *  If `messages` is a single string including ICU MessageFormat declarations,\\n *  `opt` is ignored and the returned function takes a single Object parameter\\n *  `d` representing each of the input\'s defined variables. The returned\\n *  function will be defined in a local scope that includes all the required\\n *  runtime variables.\\n *\\n *  If `messages` is a map of keys to strings, or a map of namespace keys to\\n *  such key/string maps, the returned function will fill the specified global\\n *  with javascript functions matching the structure of the input. In such use,\\n *  the output of `compile()` is expected to be serialized using `.toString()`,\\n *  and will include definitions of the runtime functions. If `opt.global` is\\n *  null, calling the output function will return the object itself.\\n *\\n *  Together, the input parameters should match the following patterns:\\n *  ```js\\n *  messages = \\"string\\" || { key0: \\"string0\\", key1: \\"string1\\", ... } || {\\n *    ns0: { key0: \\"string0\\", key1: \\"string1\\", ...  },\\n *    ns1: { key0: \\"string0\\", key1: \\"string1\\", ...  },\\n *    ...\\n *  }\\n *\\n *  opt = null || {\\n *    locale: null || {\\n *      ns0: \\"lc0\\" || [ \\"lc0\\", ... ],\\n *      ns1: \\"lc1\\" || [ \\"lc1\\", ... ],\\n *      ...\\n *    },\\n *    global: null || \\"module.exports\\" || \\"exports\\" || \\"i18n\\" || ...\\n *  }\\n *  ```\\n *\\n *  @memberof MessageFormat\\n *  @param {string|Object}\\n *      messages - The input message(s) to be compiled, in ICU MessageFormat\\n *  @param {Object} [opt={}] - Options controlling output for non-simple intput\\n *  @param {Object} [opt.locale] - The locales to use for the messages, with a\\n *      structure matching that of `messages`\\n *  @param {string} [opt.global=\\"\\"] - The global variable that the output\\n *      function should use, or a null string for none. \\"exports\\" and\\n *      \\"module.exports\\" are recognised as special cases.\\n *  @returns {function} The first match found for the given locale(s)\\n *\\n *  @example\\n * > var MessageFormat = require(\'messageformat\'),\\n * ...   mf = new MessageFormat(\'en\'),\\n * ...   mfunc0 = mf.compile(\'A {TYPE} example.\');\\n * > mfunc0({TYPE:\'simple\'})\\n * \'A simple example.\'\\n * > mfunc0.toString()\\n * \'function (d) { return \\"A \\" + d.TYPE + \\" example.\\"; }\'\\n *\\n *  @example\\n * > var msgSet = { a: \'A {TYPE} example.\',\\n * ...              b: \'This has {COUNT, plural, one{one member} other{# members}}.\' },\\n * ...   mfuncSet = mf.compile(msgSet);\\n * > mfuncSet().a({TYPE:\'more complex\'})\\n * \'A more complex example.\'\\n * > mfuncSet().b({COUNT:2})\\n * \'This has 2 members.\'\\n *\\n * > console.log(mfuncSet.toString())\\n * function anonymous() {\\n * var number = function (value, offset) {\\n *   if (isNaN(value)) throw new Error(\\"\'\\" + value + \\"\' isn\'t a number.\\");\\n *   return value - (offset || 0);\\n * };\\n * var plural = function (value, offset, lcfunc, data, isOrdinal) {\\n *   if ({}.hasOwnProperty.call(data, value)) return data[value]();\\n *   if (offset) value -= offset;\\n *   var key = lcfunc(value, isOrdinal);\\n *   if (key in data) return data[key]();\\n *   return data.other();\\n * };\\n * var select = function (value, data) {\\n *   if ({}.hasOwnProperty.call(data, value)) return data[value]();\\n *   return data.other()\\n * };\\n * var pluralFuncs = {\\n *   en: function (n, ord) {\\n *     var s = String(n).split(\'.\'), v0 = !s[1], t0 = Number(s[0]) == n,\\n *         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\\n *     if (ord) return (n10 == 1 && n100 != 11) ? \'one\'\\n *         : (n10 == 2 && n100 != 12) ? \'two\'\\n *         : (n10 == 3 && n100 != 13) ? \'few\'\\n *         : \'other\';\\n *     return (n == 1 && v0) ? \'one\' : \'other\';\\n *   }\\n * };\\n * var fmt = {};\\n *\\n * return {\\n *   a: function(d) { return \\"A \\" + d.TYPE + \\" example.\\"; },\\n *   b: function(d) { return \\"This has \\" + plural(d.COUNT, 0, pluralFuncs.en, { one: function() { return \\"one member\\";}, other: function() { return number(d.COUNT)+\\" members\\";} }) + \\".\\"; }\\n * }\\n * }\\n *\\n *  @example\\n * > mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;\\n * > var multiSet = { en: { a: \'A {TYPE} example.\',\\n * ...                      b: \'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.\' },\\n * ...                fi: { a: \'{TYPE} esimerkki.\',\\n * ...                      b: \'Tm on {COUNT, selectordinal, other{#.}} esimerkki.\' } },\\n * ...   multiSetLocales = { en: \'en\', fi: \'fi\' },\\n * ...   mfuncSet = mf.compile(multiSet, { locale: multiSetLocales, global: \'i18n\' });\\n * > mfuncSet(this);\\n * > i18n.en.b({COUNT:3})\\n * \'This is the 3rd example.\'\\n * > i18n.fi.b({COUNT:3})\\n * \'Tm on 3. esimerkki.\'  */\\nMessageFormat.prototype.compile = function ( messages, opt ) {\\n  var r = {}, lc0 = this.lc,\\n      compileMsg = function(self, msg) {\\n        try {\\n          var ast = MessageFormat._parse(msg);\\n          return self._precompile(ast);\\n        } catch (e) {\\n          throw new Error((ast ? \'Precompiler\' : \'Parser\') + \' error: \' + e.toString());\\n        }\\n      },\\n      stringify = function(r, level) {\\n        if (!level) level = 0;\\n        if (typeof r != \'object\') return r;\\n        var o = [], indent = \'\';\\n        for (var i = 0; i < level; ++i) indent += \'  \';\\n        for (var k in r) o.push(\'\\\\n\' + indent + \'  \' + propname(k) + \': \' + stringify(r[k], level + 1));\\n        return \'{\' + o.join(\',\') + \'\\\\n\' + indent + \'}\';\\n      };\\n\\n  if (typeof messages == \'string\') {\\n    var f = new Function(\\n        \'number, plural, select, pluralFuncs, fmt\',\\n        \'return \' + compileMsg(this, messages));\\n    return f(this.runtime.number, this.runtime.plural, this.runtime.select,\\n        this.runtime.pluralFuncs, this.runtime.fmt);\\n  }\\n\\n  opt = opt || {};\\n\\n  for (var ns in messages) {\\n    if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;\\n    if (typeof messages[ns] == \'string\') {\\n      try { r[ns] = compileMsg(this, messages[ns]); }\\n      catch (e) { e.message = e.message.replace(\':\', \' with `\' + ns + \'`:\'); throw e; }\\n    } else {\\n      r[ns] = {};\\n      for (var key in messages[ns]) {\\n        try { r[ns][key] = compileMsg(this, messages[ns][key]); }\\n        catch (e) { e.message = e.message.replace(\':\', \' with `\' + key + \'` in `\' + ns + \'`:\'); throw e; }\\n      }\\n    }\\n  }\\n\\n  this.lc = lc0;\\n  var s = this.runtime.toString() + \'\\\\n\';\\n  switch (opt.global || \'\') {\\n    case \'exports\':\\n      var o = [];\\n      for (var k in r) o.push(propname(k, \'exports\') + \' = \' + stringify(r[k]));\\n      return new Function(s + o.join(\';\\\\n\'));\\n    case \'module.exports\':\\n      return new Function(s + \'module.exports = \' + stringify(r));\\n    case \'\':\\n      return new Function(s + \'return \' + stringify(r));\\n    default:\\n      return new Function(\'G\', s + propname(opt.global, \'G\') + \' = \' + stringify(r));\\n  }\\n};\\n\\n\\nreturn MessageFormat;\\n}());\\n/* jshint ignore:end */\\n\\n\\nvar createErrorPluralModulePresence = function() {\\n\\treturn createError( \\"E_MISSING_PLURAL_MODULE\\", \\"Plural module not loaded.\\" );\\n};\\n\\n\\n\\n\\nvar validateMessageBundle = function( cldr ) {\\n\\tvalidate(\\n\\t\\t\\"E_MISSING_MESSAGE_BUNDLE\\",\\n\\t\\t\\"Missing message bundle for locale `{locale}`.\\",\\n\\t\\tcldr.attributes.bundle && cldr.get( \\"globalize-messages/{bundle}\\" ) !== undefined,\\n\\t\\t{\\n\\t\\t\\tlocale: cldr.locale\\n\\t\\t}\\n\\t);\\n};\\n\\n\\n\\n\\nvar validateMessagePresence = function( path, value ) {\\n\\tpath = path.join( \\"/\\" );\\n\\tvalidate( \\"E_MISSING_MESSAGE\\", \\"Missing required message content `{path}`.\\",\\n\\t\\tvalue !== undefined, { path: path } );\\n};\\n\\n\\n\\n\\nvar validateMessageType = function( path, value ) {\\n\\tpath = path.join( \\"/\\" );\\n\\tvalidate(\\n\\t\\t\\"E_INVALID_MESSAGE\\",\\n\\t\\t\\"Invalid message content `{path}`. {expected} expected.\\",\\n\\t\\ttypeof value === \\"string\\",\\n\\t\\t{\\n\\t\\t\\texpected: \\"a string\\",\\n\\t\\t\\tpath: path\\n\\t\\t}\\n\\t);\\n};\\n\\n\\n\\n\\nvar validateParameterTypeMessageVariables = function( value, name ) {\\n\\tvalidateParameterType(\\n\\t\\tvalue,\\n\\t\\tname,\\n\\t\\tvalue === undefined || isPlainObject( value ) || Array.isArray( value ),\\n\\t\\t\\"Array or Plain Object\\"\\n\\t);\\n};\\n\\n\\n\\n\\nvar messageFormatterFn = function( formatter ) {\\n\\treturn function messageFormatter( variables ) {\\n\\t\\tif ( typeof variables === \\"number\\" || typeof variables === \\"string\\" ) {\\n\\t\\t\\tvariables = [].slice.call( arguments, 0 );\\n\\t\\t}\\n\\t\\tvalidateParameterTypeMessageVariables( variables, \\"variables\\" );\\n\\t\\treturn formatter( variables );\\n\\t};\\n};\\n\\n\\n\\n\\nvar messageFormatterRuntimeBind = function( cldr, messageformatter ) {\\n\\tvar locale = cldr.locale,\\n\\t\\torigToString = messageformatter.toString;\\n\\n\\tmessageformatter.toString = function() {\\n\\t\\tvar argNames, argValues, output,\\n\\t\\t\\targs = {};\\n\\n\\t\\t// Properly adjust SlexAxton/messageformat.js compiled variables with Globalize variables:\\n\\t\\toutput = origToString.call( messageformatter );\\n\\n\\t\\tif ( /number\\\\(/.test( output ) ) {\\n\\t\\t\\targs.number = \\"messageFormat.number\\";\\n\\t\\t}\\n\\n\\t\\tif ( /plural\\\\(/.test( output ) ) {\\n\\t\\t\\targs.plural = \\"messageFormat.plural\\";\\n\\t\\t}\\n\\n\\t\\tif ( /select\\\\(/.test( output ) ) {\\n\\t\\t\\targs.select = \\"messageFormat.select\\";\\n\\t\\t}\\n\\n\\t\\toutput.replace( /pluralFuncs(\\\\[([^\\\\]]+)\\\\]|\\\\.([a-zA-Z]+))/, function( match ) {\\n\\t\\t\\targs.pluralFuncs = \\"{\\" +\\n\\t\\t\\t\\t\\"\\\\\\"\\" + locale + \\"\\\\\\": Globalize(\\\\\\"\\" + locale + \\"\\\\\\").pluralGenerator()\\" +\\n\\t\\t\\t\\t\\"}\\";\\n\\t\\t\\treturn match;\\n\\t\\t});\\n\\n\\t\\targNames = Object.keys( args ).join( \\", \\" );\\n\\t\\targValues = Object.keys( args ).map(function( key ) {\\n\\t\\t\\treturn args[ key ];\\n\\t\\t}).join( \\", \\" );\\n\\n\\t\\treturn \\"(function( \\" + argNames + \\" ) {\\\\n\\" +\\n\\t\\t\\t\\"  return \\" + output + \\"\\\\n\\" +\\n\\t\\t\\t\\"})(\\" + argValues + \\")\\";\\n\\t};\\n\\n\\treturn messageformatter;\\n};\\n\\n\\n\\n\\nvar slice = [].slice;\\n\\n/**\\n * .loadMessages( json )\\n *\\n * @json [JSON]\\n *\\n * Load translation data.\\n */\\nGlobalize.loadMessages = function( json ) {\\n\\tvar locale,\\n\\t\\tcustomData = {\\n\\t\\t\\t\\"globalize-messages\\": json,\\n\\t\\t\\t\\"main\\": {}\\n\\t\\t};\\n\\n\\tvalidateParameterPresence( json, \\"json\\" );\\n\\tvalidateParameterTypePlainObject( json, \\"json\\" );\\n\\n\\t// Set available bundles by populating customData main dataset.\\n\\tfor ( locale in json ) {\\n\\t\\tif ( json.hasOwnProperty( locale ) ) {\\n\\t\\t\\tcustomData.main[ locale ] = {};\\n\\t\\t}\\n\\t}\\n\\n\\tCldr.load( customData );\\n};\\n\\n/**\\n * .messageFormatter( path )\\n *\\n * @path [String or Array]\\n *\\n * Format a message given its path.\\n */\\nGlobalize.messageFormatter =\\nGlobalize.prototype.messageFormatter = function( path ) {\\n\\tvar cldr, formatter, message, pluralGenerator, returnFn,\\n\\t\\targs = slice.call( arguments, 0 );\\n\\n\\tvalidateParameterPresence( path, \\"path\\" );\\n\\tvalidateParameterType( path, \\"path\\", typeof path === \\"string\\" || Array.isArray( path ),\\n\\t\\t\\"a String nor an Array\\" );\\n\\n\\tpath = alwaysArray( path );\\n\\tcldr = this.cldr;\\n\\n\\tvalidateDefaultLocale( cldr );\\n\\tvalidateMessageBundle( cldr );\\n\\n\\tmessage = cldr.get( [ \\"globalize-messages/{bundle}\\" ].concat( path ) );\\n\\tvalidateMessagePresence( path, message );\\n\\n\\t// If message is an Array, concatenate it.\\n\\tif ( Array.isArray( message ) ) {\\n\\t\\tmessage = message.join( \\" \\" );\\n\\t}\\n\\tvalidateMessageType( path, message );\\n\\n\\t// Is plural module present? Yes, use its generator. Nope, use an error generator.\\n\\tpluralGenerator = this.plural !== undefined ?\\n\\t\\tthis.pluralGenerator() :\\n\\t\\tcreateErrorPluralModulePresence;\\n\\n\\tformatter = new MessageFormat( cldr.locale, pluralGenerator ).compile( message );\\n\\n\\treturnFn = messageFormatterFn( formatter );\\n\\n\\truntimeBind( args, cldr, returnFn,\\n\\t\\t[ messageFormatterRuntimeBind( cldr, formatter ), pluralGenerator ] );\\n\\n\\treturn returnFn;\\n};\\n\\n/**\\n * .formatMessage( path [, variables] )\\n *\\n * @path [String or Array]\\n *\\n * @variables [Number, String, Array or Object]\\n *\\n * Format a message given its path.\\n */\\nGlobalize.formatMessage =\\nGlobalize.prototype.formatMessage = function( path /* , variables */ ) {\\n\\treturn this.messageFormatter( path ).apply( {}, slice.call( arguments, 1 ) );\\n};\\n\\nreturn Globalize;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL21lc3NhZ2UuanM/MWFjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqXFxuICogR2xvYmFsaXplIHYxLjUuMFxcbiAqXFxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxcbiAqXFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDIwLTAzLTI1VDEyOjE5WlxcbiAqL1xcbi8qIVxcbiAqIEdsb2JhbGl6ZSB2MS41LjAgMjAyMC0wMy0yNVQxMjoxOVogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICogaHR0cDovL2dpdC5pby9UcmRRYndcXG4gKi9cXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XFxuXFxuXFx0Ly8gVU1EIHJldHVybkV4cG9ydHNcXG5cXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZGVmaW5lLmFtZCApIHtcXG5cXG5cXHRcXHQvLyBBTURcXG5cXHRcXHRkZWZpbmUoW1xcblxcdFxcdFxcdFxcXCJjbGRyXFxcIixcXG5cXHRcXHRcXHRcXFwiLi4vZ2xvYmFsaXplXFxcIixcXG5cXHRcXHRcXHRcXFwiY2xkci9ldmVudFxcXCJcXG5cXHRcXHRdLCBmYWN0b3J5ICk7XFxuXFx0fSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09IFxcXCJvYmplY3RcXFwiICkge1xcblxcblxcdFxcdC8vIE5vZGUsIENvbW1vbkpTXFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcXFwiY2xkcmpzXFxcIiApLCByZXF1aXJlKCBcXFwiLi4vZ2xvYmFsaXplXFxcIiApICk7XFxuXFx0fSBlbHNlIHtcXG5cXG5cXHRcXHQvLyBFeHRlbmQgZ2xvYmFsXFxuXFx0XFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xcblxcdH1cXG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XFxuXFxudmFyIGFsd2F5c0FycmF5ID0gR2xvYmFsaXplLl9hbHdheXNBcnJheSxcXG5cXHRjcmVhdGVFcnJvciA9IEdsb2JhbGl6ZS5fY3JlYXRlRXJyb3IsXFxuXFx0aXNQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5faXNQbGFpbk9iamVjdCxcXG5cXHRydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXFxuXFx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gR2xvYmFsaXplLl92YWxpZGF0ZURlZmF1bHRMb2NhbGUsXFxuXFx0dmFsaWRhdGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlLFxcblxcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UsXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGUsXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0O1xcbnZhciBNZXNzYWdlRm9ybWF0O1xcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cXG5NZXNzYWdlRm9ybWF0ID0gKGZ1bmN0aW9uKCkge1xcbk1lc3NhZ2VGb3JtYXQuX3BhcnNlID0gKGZ1bmN0aW9uKCkge1xcblxcbiAgLypcXG4gICAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC44LjAuXFxuICAgKlxcbiAgICogaHR0cDovL3BlZ2pzLm1hamRhLmN6L1xcbiAgICovXFxuXFxuICBmdW5jdGlvbiBwZWckc3ViY2xhc3MoY2hpbGQsIHBhcmVudCkge1xcbiAgICBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cXG4gICAgY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gU3ludGF4RXJyb3IobWVzc2FnZSwgZXhwZWN0ZWQsIGZvdW5kLCBvZmZzZXQsIGxpbmUsIGNvbHVtbikge1xcbiAgICB0aGlzLm1lc3NhZ2UgID0gbWVzc2FnZTtcXG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xcbiAgICB0aGlzLmZvdW5kICAgID0gZm91bmQ7XFxuICAgIHRoaXMub2Zmc2V0ICAgPSBvZmZzZXQ7XFxuICAgIHRoaXMubGluZSAgICAgPSBsaW5lO1xcbiAgICB0aGlzLmNvbHVtbiAgID0gY29sdW1uO1xcblxcbiAgICB0aGlzLm5hbWUgICAgID0gXFxcIlN5bnRheEVycm9yXFxcIjtcXG4gIH1cXG5cXG4gIHBlZyRzdWJjbGFzcyhTeW50YXhFcnJvciwgRXJyb3IpO1xcblxcbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHt9LFxcblxcbiAgICAgICAgcGVnJEZBSUxFRCA9IHt9LFxcblxcbiAgICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgc3RhcnQ6IHBlZyRwYXJzZXN0YXJ0IH0sXFxuICAgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gID0gcGVnJHBhcnNlc3RhcnQsXFxuXFxuICAgICAgICBwZWckYzAgPSBbXSxcXG4gICAgICAgIHBlZyRjMSA9IGZ1bmN0aW9uKHN0KSB7XFxuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnbWVzc2FnZUZvcm1hdFBhdHRlcm4nLCBzdGF0ZW1lbnRzOiBzdCB9O1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICBwZWckYzIgPSBwZWckRkFJTEVELFxcbiAgICAgICAgcGVnJGMzID0gXFxcIntcXFwiLFxcbiAgICAgICAgcGVnJGM0ID0geyB0eXBlOiBcXFwibGl0ZXJhbFxcXCIsIHZhbHVlOiBcXFwie1xcXCIsIGRlc2NyaXB0aW9uOiBcXFwiXFxcXFxcXCJ7XFxcXFxcXCJcXFwiIH0sXFxuICAgICAgICBwZWckYzUgPSBudWxsLFxcbiAgICAgICAgcGVnJGM2ID0gXFxcIixcXFwiLFxcbiAgICAgICAgcGVnJGM3ID0geyB0eXBlOiBcXFwibGl0ZXJhbFxcXCIsIHZhbHVlOiBcXFwiLFxcXCIsIGRlc2NyaXB0aW9uOiBcXFwiXFxcXFxcXCIsXFxcXFxcXCJcXFwiIH0sXFxuICAgICAgICBwZWckYzggPSBcXFwifVxcXCIsXFxuICAgICAgICBwZWckYzkgPSB7IHR5cGU6IFxcXCJsaXRlcmFsXFxcIiwgdmFsdWU6IFxcXCJ9XFxcIiwgZGVzY3JpcHRpb246IFxcXCJcXFxcXFxcIn1cXFxcXFxcIlxcXCIgfSxcXG4gICAgICAgIHBlZyRjMTAgPSBmdW5jdGlvbihhcmdJZHgsIGVmbXQpIHtcXG4gICAgICAgICAgICAgIHZhciByZXMgPSB7XFxuICAgICAgICAgICAgICAgIHR5cGU6IFxcXCJtZXNzYWdlRm9ybWF0RWxlbWVudFxcXCIsXFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50SW5kZXg6IGFyZ0lkeFxcbiAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgIGlmIChlZm10ICYmIGVmbXQubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIHJlcy5lbGVtZW50Rm9ybWF0ID0gZWZtdFsxXTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJlcy5vdXRwdXQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgcGVnJGMxMSA9IFxcXCJwbHVyYWxcXFwiLFxcbiAgICAgICAgcGVnJGMxMiA9IHsgdHlwZTogXFxcImxpdGVyYWxcXFwiLCB2YWx1ZTogXFxcInBsdXJhbFxcXCIsIGRlc2NyaXB0aW9uOiBcXFwiXFxcXFxcXCJwbHVyYWxcXFxcXFxcIlxcXCIgfSxcXG4gICAgICAgIHBlZyRjMTMgPSBmdW5jdGlvbih0LCBzKSB7XFxuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcXFwiZWxlbWVudEZvcm1hdFxcXCIsIGtleTogdCwgdmFsOiBzIH07XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgIHBlZyRjMTQgPSBcXFwic2VsZWN0b3JkaW5hbFxcXCIsXFxuICAgICAgICBwZWckYzE1ID0geyB0eXBlOiBcXFwibGl0ZXJhbFxcXCIsIHZhbHVlOiBcXFwic2VsZWN0b3JkaW5hbFxcXCIsIGRlc2NyaXB0aW9uOiBcXFwiXFxcXFxcXCJzZWxlY3RvcmRpbmFsXFxcXFxcXCJcXFwiIH0sXFxuICAgICAgICBwZWckYzE2ID0gXFxcInNlbGVjdFxcXCIsXFxuICAgICAgICBwZWckYzE3ID0geyB0eXBlOiBcXFwibGl0ZXJhbFxcXCIsIHZhbHVlOiBcXFwic2VsZWN0XFxcIiwgZGVzY3JpcHRpb246IFxcXCJcXFxcXFxcInNlbGVjdFxcXFxcXFwiXFxcIiB9LFxcbiAgICAgICAgcGVnJGMxOCA9IGZ1bmN0aW9uKHQsIHApIHtcXG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFxcXCJlbGVtZW50Rm9ybWF0XFxcIiwga2V5OiB0LCB2YWw6IHAgfTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgcGVnJGMxOSA9IGZ1bmN0aW9uKG9wLCBwZikge1xcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXFxcInBsdXJhbEZvcm1hdFBhdHRlcm5cXFwiLCBwbHVyYWxGb3JtczogcGYsIG9mZnNldDogb3AgfHwgMCB9O1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICBwZWckYzIwID0gXFxcIm9mZnNldFxcXCIsXFxuICAgICAgICBwZWckYzIxID0geyB0eXBlOiBcXFwibGl0ZXJhbFxcXCIsIHZhbHVlOiBcXFwib2Zmc2V0XFxcIiwgZGVzY3JpcHRpb246IFxcXCJcXFxcXFxcIm9mZnNldFxcXFxcXFwiXFxcIiB9LFxcbiAgICAgICAgcGVnJGMyMiA9IFxcXCI6XFxcIixcXG4gICAgICAgIHBlZyRjMjMgPSB7IHR5cGU6IFxcXCJsaXRlcmFsXFxcIiwgdmFsdWU6IFxcXCI6XFxcIiwgZGVzY3JpcHRpb246IFxcXCJcXFxcXFxcIjpcXFxcXFxcIlxcXCIgfSxcXG4gICAgICAgIHBlZyRjMjQgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9LFxcbiAgICAgICAgcGVnJGMyNSA9IGZ1bmN0aW9uKGssIG1mcCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrLCB2YWw6IG1mcCB9O1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICBwZWckYzI2ID0gZnVuY3Rpb24oaSkgeyByZXR1cm4gaTsgfSxcXG4gICAgICAgIHBlZyRjMjcgPSBcXFwiPVxcXCIsXFxuICAgICAgICBwZWckYzI4ID0geyB0eXBlOiBcXFwibGl0ZXJhbFxcXCIsIHZhbHVlOiBcXFwiPVxcXCIsIGRlc2NyaXB0aW9uOiBcXFwiXFxcXFxcXCI9XFxcXFxcXCJcXFwiIH0sXFxuICAgICAgICBwZWckYzI5ID0gZnVuY3Rpb24ocGYpIHsgcmV0dXJuIHsgdHlwZTogXFxcInNlbGVjdEZvcm1hdFBhdHRlcm5cXFwiLCBwbHVyYWxGb3JtczogcGYgfTsgfSxcXG4gICAgICAgIHBlZyRjMzAgPSBmdW5jdGlvbihwKSB7IHJldHVybiBwOyB9LFxcbiAgICAgICAgcGVnJGMzMSA9IFxcXCIjXFxcIixcXG4gICAgICAgIHBlZyRjMzIgPSB7IHR5cGU6IFxcXCJsaXRlcmFsXFxcIiwgdmFsdWU6IFxcXCIjXFxcIiwgZGVzY3JpcHRpb246IFxcXCJcXFxcXFxcIiNcXFxcXFxcIlxcXCIgfSxcXG4gICAgICAgIHBlZyRjMzMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHt0eXBlOiAnb2N0b3Rob3JwZSd9OyB9LFxcbiAgICAgICAgcGVnJGMzNCA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHsgdHlwZTogXFxcInN0cmluZ1xcXCIsIHZhbDogcy5qb2luKCcnKSB9OyB9LFxcbiAgICAgICAgcGVnJGMzNSA9IHsgdHlwZTogXFxcIm90aGVyXFxcIiwgZGVzY3JpcHRpb246IFxcXCJpZGVudGlmaWVyXFxcIiB9LFxcbiAgICAgICAgcGVnJGMzNiA9IC9eWzAtOWEtekEtWiRfXS8sXFxuICAgICAgICBwZWckYzM3ID0geyB0eXBlOiBcXFwiY2xhc3NcXFwiLCB2YWx1ZTogXFxcIlswLTlhLXpBLVokX11cXFwiLCBkZXNjcmlwdGlvbjogXFxcIlswLTlhLXpBLVokX11cXFwiIH0sXFxuICAgICAgICBwZWckYzM4ID0gL15bXiBcXFxcdFxcXFxuXFxcXHIsLis9e31dLyxcXG4gICAgICAgIHBlZyRjMzkgPSB7IHR5cGU6IFxcXCJjbGFzc1xcXCIsIHZhbHVlOiBcXFwiW14gXFxcXFxcXFx0XFxcXFxcXFxuXFxcXFxcXFxyLC4rPXt9XVxcXCIsIGRlc2NyaXB0aW9uOiBcXFwiW14gXFxcXFxcXFx0XFxcXFxcXFxuXFxcXFxcXFxyLC4rPXt9XVxcXCIgfSxcXG4gICAgICAgIHBlZyRjNDAgPSBmdW5jdGlvbihzKSB7IHJldHVybiBzOyB9LFxcbiAgICAgICAgcGVnJGM0MSA9IGZ1bmN0aW9uKGNoYXJzKSB7IHJldHVybiBjaGFycy5qb2luKCcnKTsgfSxcXG4gICAgICAgIHBlZyRjNDIgPSAvXltee30jXFxcXFxcXFxcXFxcMC1cXFxceDFGfyBcXFxcdFxcXFxuXFxcXHJdLyxcXG4gICAgICAgIHBlZyRjNDMgPSB7IHR5cGU6IFxcXCJjbGFzc1xcXCIsIHZhbHVlOiBcXFwiW157fSNcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwwLVxcXFxcXFxceDFGfyBcXFxcXFxcXHRcXFxcXFxcXG5cXFxcXFxcXHJdXFxcIiwgZGVzY3JpcHRpb246IFxcXCJbXnt9I1xcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXDAtXFxcXFxcXFx4MUZ/IFxcXFxcXFxcdFxcXFxcXFxcblxcXFxcXFxccl1cXFwiIH0sXFxuICAgICAgICBwZWckYzQ0ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfSxcXG4gICAgICAgIHBlZyRjNDUgPSBcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCIsXFxuICAgICAgICBwZWckYzQ2ID0geyB0eXBlOiBcXFwibGl0ZXJhbFxcXCIsIHZhbHVlOiBcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCIsIGRlc2NyaXB0aW9uOiBcXFwiXFxcXFxcXCJcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwiXFxcIiB9LFxcbiAgICAgICAgcGVnJGM0NyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXFxcIlxcXFxcXFxcXFxcIjsgfSxcXG4gICAgICAgIHBlZyRjNDggPSBcXFwiXFxcXFxcXFwjXFxcIixcXG4gICAgICAgIHBlZyRjNDkgPSB7IHR5cGU6IFxcXCJsaXRlcmFsXFxcIiwgdmFsdWU6IFxcXCJcXFxcXFxcXCNcXFwiLCBkZXNjcmlwdGlvbjogXFxcIlxcXFxcXFwiXFxcXFxcXFxcXFxcXFxcXCNcXFxcXFxcIlxcXCIgfSxcXG4gICAgICAgIHBlZyRjNTAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFxcXCIjXFxcIjsgfSxcXG4gICAgICAgIHBlZyRjNTEgPSBcXFwiXFxcXFxcXFx7XFxcIixcXG4gICAgICAgIHBlZyRjNTIgPSB7IHR5cGU6IFxcXCJsaXRlcmFsXFxcIiwgdmFsdWU6IFxcXCJcXFxcXFxcXHtcXFwiLCBkZXNjcmlwdGlvbjogXFxcIlxcXFxcXFwiXFxcXFxcXFxcXFxcXFxcXHtcXFxcXFxcIlxcXCIgfSxcXG4gICAgICAgIHBlZyRjNTMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFxcXCJcXFxcdTAwN0JcXFwiOyB9LFxcbiAgICAgICAgcGVnJGM1NCA9IFxcXCJcXFxcXFxcXH1cXFwiLFxcbiAgICAgICAgcGVnJGM1NSA9IHsgdHlwZTogXFxcImxpdGVyYWxcXFwiLCB2YWx1ZTogXFxcIlxcXFxcXFxcfVxcXCIsIGRlc2NyaXB0aW9uOiBcXFwiXFxcXFxcXCJcXFxcXFxcXFxcXFxcXFxcfVxcXFxcXFwiXFxcIiB9LFxcbiAgICAgICAgcGVnJGM1NiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXFxcIlxcXFx1MDA3RFxcXCI7IH0sXFxuICAgICAgICBwZWckYzU3ID0gXFxcIlxcXFxcXFxcdVxcXCIsXFxuICAgICAgICBwZWckYzU4ID0geyB0eXBlOiBcXFwibGl0ZXJhbFxcXCIsIHZhbHVlOiBcXFwiXFxcXFxcXFx1XFxcIiwgZGVzY3JpcHRpb246IFxcXCJcXFxcXFxcIlxcXFxcXFxcXFxcXFxcXFx1XFxcXFxcXCJcXFwiIH0sXFxuICAgICAgICBwZWckYzU5ID0gZnVuY3Rpb24oaDEsIGgyLCBoMywgaDQpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KFxcXCIweFxcXCIgKyBoMSArIGgyICsgaDMgKyBoNCkpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICBwZWckYzYwID0gL15bMC05XS8sXFxuICAgICAgICBwZWckYzYxID0geyB0eXBlOiBcXFwiY2xhc3NcXFwiLCB2YWx1ZTogXFxcIlswLTldXFxcIiwgZGVzY3JpcHRpb246IFxcXCJbMC05XVxcXCIgfSxcXG4gICAgICAgIHBlZyRjNjIgPSBmdW5jdGlvbihkcykge1xcbiAgICAgICAgICAgIC8vdGhlIG51bWJlciBtaWdodCBzdGFydCB3aXRoIDAgYnV0IG11c3Qgbm90IGJlIGludGVycHJldGVkIGFzIGFuIG9jdGFsIG51bWJlclxcbiAgICAgICAgICAgIC8vSGVuY2UsIHRoZSBiYXNlIGlzIHBhc3NlZCB0byBwYXJzZUludCBleHBsaWNpdGVseVxcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCgoZHMuam9pbignJykpLCAxMCk7XFxuICAgICAgICAgIH0sXFxuICAgICAgICBwZWckYzYzID0gL15bMC05YS1mQS1GXS8sXFxuICAgICAgICBwZWckYzY0ID0geyB0eXBlOiBcXFwiY2xhc3NcXFwiLCB2YWx1ZTogXFxcIlswLTlhLWZBLUZdXFxcIiwgZGVzY3JpcHRpb246IFxcXCJbMC05YS1mQS1GXVxcXCIgfSxcXG4gICAgICAgIHBlZyRjNjUgPSB7IHR5cGU6IFxcXCJvdGhlclxcXCIsIGRlc2NyaXB0aW9uOiBcXFwid2hpdGVzcGFjZVxcXCIgfSxcXG4gICAgICAgIHBlZyRjNjYgPSBmdW5jdGlvbih3KSB7IHJldHVybiB3LmpvaW4oJycpOyB9LFxcbiAgICAgICAgcGVnJGM2NyA9IC9eWyBcXFxcdFxcXFxuXFxcXHJdLyxcXG4gICAgICAgIHBlZyRjNjggPSB7IHR5cGU6IFxcXCJjbGFzc1xcXCIsIHZhbHVlOiBcXFwiWyBcXFxcXFxcXHRcXFxcXFxcXG5cXFxcXFxcXHJdXFxcIiwgZGVzY3JpcHRpb246IFxcXCJbIFxcXFxcXFxcdFxcXFxcXFxcblxcXFxcXFxccl1cXFwiIH0sXFxuXFxuICAgICAgICBwZWckY3VyclBvcyAgICAgICAgICA9IDAsXFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgICAgICA9IDAsXFxuICAgICAgICBwZWckY2FjaGVkUG9zICAgICAgICA9IDAsXFxuICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH0sXFxuICAgICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXFxuICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxcblxcbiAgICAgICAgcGVnJHJlc3VsdDtcXG5cXG4gICAgaWYgKFxcXCJzdGFydFJ1bGVcXFwiIGluIG9wdGlvbnMpIHtcXG4gICAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFxcXFxcIlxcXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFxcXCJcXFxcXFxcIi5cXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uc1tvcHRpb25zLnN0YXJ0UnVsZV07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gdGV4dCgpIHtcXG4gICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRyZXBvcnRlZFBvcywgcGVnJGN1cnJQb3MpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG9mZnNldCgpIHtcXG4gICAgICByZXR1cm4gcGVnJHJlcG9ydGVkUG9zO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGxpbmUoKSB7XFxuICAgICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmxpbmU7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY29sdW1uKCkge1xcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5jb2x1bW47XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24pIHtcXG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24oXFxuICAgICAgICBudWxsLFxcbiAgICAgICAgW3sgdHlwZTogXFxcIm90aGVyXFxcIiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH1dLFxcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zXFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XFxuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIG51bGwsIHBlZyRyZXBvcnRlZFBvcyk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xcbiAgICAgIGZ1bmN0aW9uIGFkdmFuY2UoZGV0YWlscywgc3RhcnRQb3MsIGVuZFBvcykge1xcbiAgICAgICAgdmFyIHAsIGNoO1xcblxcbiAgICAgICAgZm9yIChwID0gc3RhcnRQb3M7IHAgPCBlbmRQb3M7IHArKykge1xcbiAgICAgICAgICBjaCA9IGlucHV0LmNoYXJBdChwKTtcXG4gICAgICAgICAgaWYgKGNoID09PSBcXFwiXFxcXG5cXFwiKSB7XFxuICAgICAgICAgICAgaWYgKCFkZXRhaWxzLnNlZW5DUikgeyBkZXRhaWxzLmxpbmUrKzsgfVxcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcXG4gICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcXFwiXFxcXHJcXFwiIHx8IGNoID09PSBcXFwiXFxcXHUyMDI4XFxcIiB8fCBjaCA9PT0gXFxcIlxcXFx1MjAyOVxcXCIpIHtcXG4gICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcXG4gICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XFxuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSB0cnVlO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XFxuICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocGVnJGNhY2hlZFBvcyAhPT0gcG9zKSB7XFxuICAgICAgICBpZiAocGVnJGNhY2hlZFBvcyA+IHBvcykge1xcbiAgICAgICAgICBwZWckY2FjaGVkUG9zID0gMDtcXG4gICAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTtcXG4gICAgICAgIHBlZyRjYWNoZWRQb3MgPSBwb3M7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwZWckY2FjaGVkUG9zRGV0YWlscztcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZCkge1xcbiAgICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7IHJldHVybjsgfVxcblxcbiAgICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7XFxuICAgICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xcbiAgICAgIH1cXG5cXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7XFxuICAgICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7XFxuICAgICAgICB2YXIgaSA9IDE7XFxuXFxuICAgICAgICBleHBlY3RlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcXG4gICAgICAgICAgaWYgKGEuZGVzY3JpcHRpb24gPCBiLmRlc2NyaXB0aW9uKSB7XFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGEuZGVzY3JpcHRpb24gPiBiLmRlc2NyaXB0aW9uKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDE7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgd2hpbGUgKGkgPCBleHBlY3RlZC5sZW5ndGgpIHtcXG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2kgLSAxXSA9PT0gZXhwZWN0ZWRbaV0pIHtcXG4gICAgICAgICAgICBleHBlY3RlZC5zcGxpY2UoaSwgMSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaSsrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpIHtcXG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XFxuICAgICAgICAgIGZ1bmN0aW9uIGhleChjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxcblxcbiAgICAgICAgICByZXR1cm4gc1xcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXFxcXC9nLCAgICdcXFxcXFxcXFxcXFxcXFxcJylcXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcIi9nLCAgICAnXFxcXFxcXFxcXFwiJylcXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXHgwOC9nLCAnXFxcXFxcXFxiJylcXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXHQvZywgICAnXFxcXFxcXFx0JylcXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXG4vZywgICAnXFxcXFxcXFxuJylcXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXGYvZywgICAnXFxcXFxcXFxmJylcXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXHIvZywgICAnXFxcXFxcXFxyJylcXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcXFx4MDAtXFxcXHgwN1xcXFx4MEJcXFxceDBFXFxcXHgwRl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcXFxcXHgwJyArIGhleChjaCk7IH0pXFxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXFxceDEwLVxcXFx4MUZcXFxceDgwLVxcXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXFxcXFx4JyAgKyBoZXgoY2gpOyB9KVxcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxcXHUwMTgwLVxcXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFxcXFxcdTAnICsgaGV4KGNoKTsgfSlcXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcXFx1MTA4MC1cXFxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcXFxcXHUnICArIGhleChjaCk7IH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGV4cGVjdGVkRGVzY3MgPSBuZXcgQXJyYXkoZXhwZWN0ZWQubGVuZ3RoKSxcXG4gICAgICAgICAgICBleHBlY3RlZERlc2MsIGZvdW5kRGVzYywgaTtcXG5cXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICBleHBlY3RlZERlc2NzW2ldID0gZXhwZWN0ZWRbaV0uZGVzY3JpcHRpb247XFxuICAgICAgICB9XFxuXFxuICAgICAgICBleHBlY3RlZERlc2MgPSBleHBlY3RlZC5sZW5ndGggPiAxXFxuICAgICAgICAgID8gZXhwZWN0ZWREZXNjcy5zbGljZSgwLCAtMSkuam9pbihcXFwiLCBcXFwiKVxcbiAgICAgICAgICAgICAgKyBcXFwiIG9yIFxcXCJcXG4gICAgICAgICAgICAgICsgZXhwZWN0ZWREZXNjc1tleHBlY3RlZC5sZW5ndGggLSAxXVxcbiAgICAgICAgICA6IGV4cGVjdGVkRGVzY3NbMF07XFxuXFxuICAgICAgICBmb3VuZERlc2MgPSBmb3VuZCA/IFxcXCJcXFxcXFxcIlxcXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXFxcIlxcXFxcXFwiXFxcIiA6IFxcXCJlbmQgb2YgaW5wdXRcXFwiO1xcblxcbiAgICAgICAgcmV0dXJuIFxcXCJFeHBlY3RlZCBcXFwiICsgZXhwZWN0ZWREZXNjICsgXFxcIiBidXQgXFxcIiArIGZvdW5kRGVzYyArIFxcXCIgZm91bmQuXFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSxcXG4gICAgICAgICAgZm91bmQgICAgICA9IHBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwb3MpIDogbnVsbDtcXG5cXG4gICAgICBpZiAoZXhwZWN0ZWQgIT09IG51bGwpIHtcXG4gICAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXFxuICAgICAgICBtZXNzYWdlICE9PSBudWxsID8gbWVzc2FnZSA6IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxcbiAgICAgICAgZXhwZWN0ZWQsXFxuICAgICAgICBmb3VuZCxcXG4gICAgICAgIHBvcyxcXG4gICAgICAgIHBvc0RldGFpbHMubGluZSxcXG4gICAgICAgIHBvc0RldGFpbHMuY29sdW1uXFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzdGFydCgpIHtcXG4gICAgICB2YXIgczA7XFxuXFxuICAgICAgczAgPSBwZWckcGFyc2VtZXNzYWdlRm9ybWF0UGF0dGVybigpO1xcblxcbiAgICAgIHJldHVybiBzMDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwZWckcGFyc2VtZXNzYWdlRm9ybWF0UGF0dGVybigpIHtcXG4gICAgICB2YXIgczAsIHMxLCBzMjtcXG5cXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgIHMxID0gW107XFxuICAgICAgczIgPSBwZWckcGFyc2VtZXNzYWdlRm9ybWF0RWxlbWVudCgpO1xcbiAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgczIgPSBwZWckcGFyc2VzdHJpbmcoKTtcXG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZW9jdG90aG9ycGUoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBzMS5wdXNoKHMyKTtcXG4gICAgICAgIHMyID0gcGVnJHBhcnNlbWVzc2FnZUZvcm1hdEVsZW1lbnQoKTtcXG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZXN0cmluZygpO1xcbiAgICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICBzMiA9IHBlZyRwYXJzZW9jdG90aG9ycGUoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xcbiAgICAgICAgczEgPSBwZWckYzEoczEpO1xcbiAgICAgIH1cXG4gICAgICBzMCA9IHMxO1xcblxcbiAgICAgIHJldHVybiBzMDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwZWckcGFyc2VtZXNzYWdlRm9ybWF0RWxlbWVudCgpIHtcXG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczY7XFxuXFxuICAgICAgczAgPSBwZWckY3VyclBvcztcXG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xcbiAgICAgICAgczEgPSBwZWckYzM7XFxuICAgICAgICBwZWckY3VyclBvcysrO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XFxuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNCk7IH1cXG4gICAgICB9XFxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZWlkKCk7XFxuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgIHM0ID0gcGVnJGN1cnJQb3M7XFxuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xcbiAgICAgICAgICAgICAgczUgPSBwZWckYzY7XFxuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XFxuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNyk7IH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZWVsZW1lbnRGb3JtYXQoKTtcXG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICBzNSA9IFtzNSwgczZdO1xcbiAgICAgICAgICAgICAgICBzNCA9IHM1O1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNDtcXG4gICAgICAgICAgICAgICAgczQgPSBwZWckYzI7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczQ7XFxuICAgICAgICAgICAgICBzNCA9IHBlZyRjMjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHM0ID09PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICBzNCA9IHBlZyRjNTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyNSkge1xcbiAgICAgICAgICAgICAgICAgIHM2ID0gcGVnJGM4O1xcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5KTsgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMxMChzMywgczQpO1xcbiAgICAgICAgICAgICAgICAgIHMwID0gczE7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XFxuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgczAgPSBwZWckYzI7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XFxuICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHMwO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWVsZW1lbnRGb3JtYXQoKSB7XFxuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcXG5cXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNikgPT09IHBlZyRjMTEpIHtcXG4gICAgICAgICAgczIgPSBwZWckYzExO1xcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA2O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTIpOyB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcXG4gICAgICAgICAgICAgIHM0ID0gcGVnJGM2O1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcpOyB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VwbHVyYWxGb3JtYXRQYXR0ZXJuKCk7XFxuICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xcbiAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XFxuICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTMoczIsIHM2KTtcXG4gICAgICAgICAgICAgICAgICAgIHMwID0gczE7XFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XFxuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XFxuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgczAgPSBwZWckYzI7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XFxuICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICB9XFxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgICAgczEgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTMpID09PSBwZWckYzE0KSB7XFxuICAgICAgICAgICAgczIgPSBwZWckYzE0O1xcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDEzO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcXG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTUpOyB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XFxuICAgICAgICAgICAgICAgIHM0ID0gcGVnJGM2O1xcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNyk7IH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VwbHVyYWxGb3JtYXRQYXR0ZXJuKCk7XFxuICAgICAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzEzKHMyLCBzNik7XFxuICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNikgPT09IHBlZyRjMTYpIHtcXG4gICAgICAgICAgICAgIHMyID0gcGVnJGMxNjtcXG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDY7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcXG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNyk7IH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XFxuICAgICAgICAgICAgICAgICAgczQgPSBwZWckYzY7XFxuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XFxuICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcpOyB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZXNlbGVjdEZvcm1hdFBhdHRlcm4oKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzEzKHMyLCBzNik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XFxuICAgICAgICAgICAgczEgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICBzMiA9IHBlZyRwYXJzZWlkKCk7XFxuICAgICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgczMgPSBbXTtcXG4gICAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VhcmdTdHlsZVBhdHRlcm4oKTtcXG4gICAgICAgICAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICAgICAgczMucHVzaChzNCk7XFxuICAgICAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VhcmdTdHlsZVBhdHRlcm4oKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTgoczIsIHMzKTtcXG4gICAgICAgICAgICAgICAgICBzMCA9IHMxO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XFxuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XFxuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzMDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwZWckcGFyc2VwbHVyYWxGb3JtYXRQYXR0ZXJuKCkge1xcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcXG5cXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgIHMxID0gcGVnJHBhcnNlb2Zmc2V0UGF0dGVybigpO1xcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgczEgPSBwZWckYzU7XFxuICAgICAgfVxcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgczIgPSBbXTtcXG4gICAgICAgIHMzID0gcGVnJHBhcnNlcGx1cmFsRm9ybSgpO1xcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgIHMyLnB1c2goczMpO1xcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlcGx1cmFsRm9ybSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzMiA9IHBlZyRjMjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcXG4gICAgICAgICAgczEgPSBwZWckYzE5KHMxLCBzMik7XFxuICAgICAgICAgIHMwID0gczE7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gczA7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlb2Zmc2V0UGF0dGVybigpIHtcXG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3O1xcblxcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XFxuICAgICAgczEgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA2KSA9PT0gcGVnJGMyMCkge1xcbiAgICAgICAgICBzMiA9IHBlZyRjMjA7XFxuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDY7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XFxuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMSk7IH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OCkge1xcbiAgICAgICAgICAgICAgczQgPSBwZWckYzIyO1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIzKTsgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xcbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlZGlnaXRzKCk7XFxuICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xcbiAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XFxuICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjQoczYpO1xcbiAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gczA7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlcGx1cmFsRm9ybSgpIHtcXG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzODtcXG5cXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgczIgPSBwZWckcGFyc2VwbHVyYWxLZXkoKTtcXG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjMpIHtcXG4gICAgICAgICAgICAgIHM0ID0gcGVnJGMzO1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQpOyB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VtZXNzYWdlRm9ybWF0UGF0dGVybigpO1xcbiAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTI1KSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJGM4O1xcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgczggPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOSk7IH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzI1KHMyLCBzNik7XFxuICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gczA7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlcGx1cmFsS2V5KCkge1xcbiAgICAgIHZhciBzMCwgczEsIHMyO1xcblxcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XFxuICAgICAgczEgPSBwZWckcGFyc2VpZCgpO1xcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XFxuICAgICAgICBzMSA9IHBlZyRjMjYoczEpO1xcbiAgICAgIH1cXG4gICAgICBzMCA9IHMxO1xcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcXG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjEpIHtcXG4gICAgICAgICAgczEgPSBwZWckYzI3O1xcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjgpOyB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgczIgPSBwZWckcGFyc2VkaWdpdHMoKTtcXG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XFxuICAgICAgICAgICAgczEgPSBwZWckYzI0KHMyKTtcXG4gICAgICAgICAgICBzMCA9IHMxO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XFxuICAgICAgICAgICAgczAgPSBwZWckYzI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XFxuICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gczA7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc2VsZWN0Rm9ybWF0UGF0dGVybigpIHtcXG4gICAgICB2YXIgczAsIHMxLCBzMjtcXG5cXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgIHMxID0gW107XFxuICAgICAgczIgPSBwZWckcGFyc2VzZWxlY3RGb3JtKCk7XFxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgczEucHVzaChzMik7XFxuICAgICAgICAgIHMyID0gcGVnJHBhcnNlc2VsZWN0Rm9ybSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzMSA9IHBlZyRjMjtcXG4gICAgICB9XFxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcXG4gICAgICAgIHMxID0gcGVnJGMyOShzMSk7XFxuICAgICAgfVxcbiAgICAgIHMwID0gczE7XFxuXFxuICAgICAgcmV0dXJuIHMwO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXNlbGVjdEZvcm0oKSB7XFxuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczg7XFxuXFxuICAgICAgczAgPSBwZWckY3VyclBvcztcXG4gICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgIHMyID0gcGVnJHBhcnNlaWQoKTtcXG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjMpIHtcXG4gICAgICAgICAgICAgIHM0ID0gcGVnJGMzO1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQpOyB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VtZXNzYWdlRm9ybWF0UGF0dGVybigpO1xcbiAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTI1KSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJGM4O1xcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgczggPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOSk7IH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzI1KHMyLCBzNik7XFxuICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gczA7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlYXJnU3R5bGVQYXR0ZXJuKCkge1xcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xcblxcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XFxuICAgICAgczEgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XFxuICAgICAgICAgIHMyID0gcGVnJGM2O1xcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNyk7IH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcXG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VpZCgpO1xcbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XFxuICAgICAgICAgICAgICAgIHMxID0gcGVnJGMzMChzNCk7XFxuICAgICAgICAgICAgICAgIHMwID0gczE7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gczA7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlb2N0b3Rob3JwZSgpIHtcXG4gICAgICB2YXIgczAsIHMxO1xcblxcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XFxuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNSkge1xcbiAgICAgICAgczEgPSBwZWckYzMxO1xcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMyKTsgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xcbiAgICAgICAgczEgPSBwZWckYzMzKCk7XFxuICAgICAgfVxcbiAgICAgIHMwID0gczE7XFxuXFxuICAgICAgcmV0dXJuIHMwO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXN0cmluZygpIHtcXG4gICAgICB2YXIgczAsIHMxLCBzMjtcXG5cXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgIHMxID0gW107XFxuICAgICAgczIgPSBwZWckcGFyc2VjaGFycygpO1xcbiAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgczIgPSBwZWckcGFyc2V3aGl0ZXNwYWNlKCk7XFxuICAgICAgfVxcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgIHMxLnB1c2goczIpO1xcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZWNoYXJzKCk7XFxuICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgIHMyID0gcGVnJHBhcnNld2hpdGVzcGFjZSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHMxID0gcGVnJGMyO1xcbiAgICAgIH1cXG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xcbiAgICAgICAgczEgPSBwZWckYzM0KHMxKTtcXG4gICAgICB9XFxuICAgICAgczAgPSBzMTtcXG5cXG4gICAgICByZXR1cm4gczA7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlaWQoKSB7XFxuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xcblxcbiAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XFxuICAgICAgczEgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xcbiAgICAgICAgczMgPSBwZWckY3VyclBvcztcXG4gICAgICAgIGlmIChwZWckYzM2LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcXG4gICAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzcpOyB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgczUgPSBbXTtcXG4gICAgICAgICAgaWYgKHBlZyRjMzgudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xcbiAgICAgICAgICAgIHM2ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcXG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcXG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzkpOyB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgd2hpbGUgKHM2ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgczUucHVzaChzNik7XFxuICAgICAgICAgICAgaWYgKHBlZyRjMzgudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xcbiAgICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM5KTsgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICBzNCA9IFtzNCwgczVdO1xcbiAgICAgICAgICAgIHMzID0gczQ7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcXG4gICAgICAgICAgICBzMyA9IHBlZyRjMjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcXG4gICAgICAgICAgczMgPSBwZWckYzI7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgczMgPSBpbnB1dC5zdWJzdHJpbmcoczIsIHBlZyRjdXJyUG9zKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHMyID0gczM7XFxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XFxuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xcbiAgICAgICAgICAgIHMxID0gcGVnJGM0MChzMik7XFxuICAgICAgICAgICAgczAgPSBzMTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgIH1cXG4gICAgICBwZWckc2lsZW50RmFpbHMtLTtcXG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcXG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNSk7IH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHMwO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWNoYXJzKCkge1xcbiAgICAgIHZhciBzMCwgczEsIHMyO1xcblxcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XFxuICAgICAgczEgPSBbXTtcXG4gICAgICBzMiA9IHBlZyRwYXJzZWNoYXIoKTtcXG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcXG4gICAgICAgICAgczIgPSBwZWckcGFyc2VjaGFyKCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHMxID0gcGVnJGMyO1xcbiAgICAgIH1cXG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xcbiAgICAgICAgczEgPSBwZWckYzQxKHMxKTtcXG4gICAgICB9XFxuICAgICAgczAgPSBzMTtcXG5cXG4gICAgICByZXR1cm4gczA7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlY2hhcigpIHtcXG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcXG5cXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgIGlmIChwZWckYzQyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcXG4gICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcXG4gICAgICAgIHBlZyRjdXJyUG9zKys7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcXG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Myk7IH1cXG4gICAgICB9XFxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcXG4gICAgICAgIHMxID0gcGVnJGM0NChzMSk7XFxuICAgICAgfVxcbiAgICAgIHMwID0gczE7XFxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjNDUpIHtcXG4gICAgICAgICAgczEgPSBwZWckYzQ1O1xcbiAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDYpOyB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XFxuICAgICAgICAgIHMxID0gcGVnJGM0NygpO1xcbiAgICAgICAgfVxcbiAgICAgICAgczAgPSBzMTtcXG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM0OCkge1xcbiAgICAgICAgICAgIHMxID0gcGVnJGM0ODtcXG4gICAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcXG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDkpOyB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XFxuICAgICAgICAgICAgczEgPSBwZWckYzUwKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgczAgPSBzMTtcXG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcXG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM1MSkge1xcbiAgICAgICAgICAgICAgczEgPSBwZWckYzUxO1xcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUyKTsgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgczEgPSBwZWckYzUzKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHMwID0gczE7XFxuICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjNTQpIHtcXG4gICAgICAgICAgICAgICAgczEgPSBwZWckYzU0O1xcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTUpOyB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XFxuICAgICAgICAgICAgICAgIHMxID0gcGVnJGM1NigpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgczAgPSBzMTtcXG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM1Nykge1xcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGM1NztcXG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcXG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTgpOyB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICAgICAgczIgPSBwZWckcGFyc2VoZXhEaWdpdCgpO1xcbiAgICAgICAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckcGFyc2VoZXhEaWdpdCgpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlaGV4RGlnaXQoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VoZXhEaWdpdCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjNTkoczIsIHMzLCBzNCwgczUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcXG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzMDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwZWckcGFyc2VkaWdpdHMoKSB7XFxuICAgICAgdmFyIHMwLCBzMSwgczI7XFxuXFxuICAgICAgczAgPSBwZWckY3VyclBvcztcXG4gICAgICBzMSA9IFtdO1xcbiAgICAgIGlmIChwZWckYzYwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcXG4gICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcXG4gICAgICAgIHBlZyRjdXJyUG9zKys7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcXG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2MSk7IH1cXG4gICAgICB9XFxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgICAgczEucHVzaChzMik7XFxuICAgICAgICAgIGlmIChwZWckYzYwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcXG4gICAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XFxuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XFxuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYxKTsgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHMxID0gcGVnJGMyO1xcbiAgICAgIH1cXG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xcbiAgICAgICAgczEgPSBwZWckYzYyKHMxKTtcXG4gICAgICB9XFxuICAgICAgczAgPSBzMTtcXG5cXG4gICAgICByZXR1cm4gczA7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlaGV4RGlnaXQoKSB7XFxuICAgICAgdmFyIHMwO1xcblxcbiAgICAgIGlmIChwZWckYzYzLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcXG4gICAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcXG4gICAgICAgIHBlZyRjdXJyUG9zKys7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcXG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2NCk7IH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHMwO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZV8oKSB7XFxuICAgICAgdmFyIHMwLCBzMSwgczI7XFxuXFxuICAgICAgcGVnJHNpbGVudEZhaWxzKys7XFxuICAgICAgczAgPSBwZWckY3VyclBvcztcXG4gICAgICBzMSA9IFtdO1xcbiAgICAgIHMyID0gcGVnJHBhcnNld2hpdGVzcGFjZSgpO1xcbiAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xcbiAgICAgICAgczEucHVzaChzMik7XFxuICAgICAgICBzMiA9IHBlZyRwYXJzZXdoaXRlc3BhY2UoKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcXG4gICAgICAgIHMxID0gcGVnJGM2NihzMSk7XFxuICAgICAgfVxcbiAgICAgIHMwID0gczE7XFxuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XFxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XFxuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XFxuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjUpOyB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzMDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBwZWckcGFyc2V3aGl0ZXNwYWNlKCkge1xcbiAgICAgIHZhciBzMDtcXG5cXG4gICAgICBpZiAocGVnJGM2Ny50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XFxuICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XFxuICAgICAgICBwZWckY3VyclBvcysrO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XFxuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjgpOyB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzMDtcXG4gICAgfVxcblxcbiAgICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7XFxuXFxuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcXG4gICAgICByZXR1cm4gcGVnJHJlc3VsdDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xcbiAgICAgICAgcGVnJGZhaWwoeyB0eXBlOiBcXFwiZW5kXFxcIiwgZGVzY3JpcHRpb246IFxcXCJlbmQgb2YgaW5wdXRcXFwiIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obnVsbCwgcGVnJG1heEZhaWxFeHBlY3RlZCwgcGVnJG1heEZhaWxQb3MpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4ge1xcbiAgICBTeW50YXhFcnJvcjogU3ludGF4RXJyb3IsXFxuICAgIHBhcnNlOiAgICAgICBwYXJzZVxcbiAgfTtcXG59KCkpLnBhcnNlO1xcblxcblxcbi8qKiBAZmlsZSBtZXNzYWdlZm9ybWF0LmpzIC0gSUNVIFBsdXJhbEZvcm1hdCArIFNlbGVjdEZvcm1hdCBmb3IgSmF2YVNjcmlwdFxcbiAqICBAYXV0aG9yIEFsZXggU2V4dG9uIC0gQFNsZXhBeHRvblxcbiAqICBAdmVyc2lvbiAwLjMuMC0xXFxuICogIEBjb3B5cmlnaHQgMjAxMi0yMDE1IEFsZXggU2V4dG9uLCBFZW1lbGkgQXJvLCBhbmQgQ29udHJpYnV0b3JzXFxuICogIEBsaWNlbnNlIFRvIHVzZSBvciBmb3JrLCBNSVQuIFRvIGNvbnRyaWJ1dGUgYmFjaywgRG9qbyBDTEEgICovXFxuXFxuXFxuLyoqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHF1b3RpbmcgYW4gT2JqZWN0J3Mga2V5IHZhbHVlIGlmZiByZXF1aXJlZFxcbiAqICBAcHJpdmF0ZSAgKi9cXG5mdW5jdGlvbiBwcm9wbmFtZShrZXksIG9iaikge1xcbiAgaWYgKC9eW0EtWl8kXVswLTlBLVpfJF0qJC9pLnRlc3Qoa2V5KSkge1xcbiAgICByZXR1cm4gb2JqID8gb2JqICsgJy4nICsga2V5IDoga2V5O1xcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGprZXkgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xcbiAgICByZXR1cm4gb2JqID8gb2JqICsgJ1snICsgamtleSArICddJyA6IGprZXk7XFxuICB9XFxufTtcXG5cXG5cXG4vKiogQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgZm9ybWF0dGVyXFxuICpcXG4gKiAgQGNsYXNzXFxuICogIEBnbG9iYWxcXG4gKiAgQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFtsb2NhbGU9XFxcImVuXFxcIl0gLSBUaGUgbG9jYWxlIHRvIHVzZSwgd2l0aCBmYWxsYmFja3NcXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gW3BsdXJhbEZ1bmNdIC0gT3B0aW9uYWwgY3VzdG9tIHBsdXJhbGl6YXRpb24gZnVuY3Rpb25cXG4gKiAgQHBhcmFtIHtmdW5jdGlvbltdfSBbZm9ybWF0dGVyc10gLSBPcHRpb25hbCBjdXN0b20gZm9ybWF0dGluZyBmdW5jdGlvbnMgICovXFxuZnVuY3Rpb24gTWVzc2FnZUZvcm1hdChsb2NhbGUsIHBsdXJhbEZ1bmMsIGZvcm1hdHRlcnMpIHtcXG4gIHRoaXMubGMgPSBbbG9jYWxlXTsgIFxcbiAgdGhpcy5ydW50aW1lLnBsdXJhbEZ1bmNzID0ge307XFxuICB0aGlzLnJ1bnRpbWUucGx1cmFsRnVuY3NbdGhpcy5sY1swXV0gPSBwbHVyYWxGdW5jO1xcbiAgdGhpcy5ydW50aW1lLmZtdCA9IHt9O1xcbiAgaWYgKGZvcm1hdHRlcnMpIGZvciAodmFyIGYgaW4gZm9ybWF0dGVycykge1xcbiAgICB0aGlzLnJ1bnRpbWUuZm10W2ZdID0gZm9ybWF0dGVyc1tmXTtcXG4gIH1cXG59XFxuXFxuXFxuXFxuXFxuLyoqIFBhcnNlIGFuIGlucHV0IHN0cmluZyB0byBpdHMgQVNUXFxuICpcXG4gKiAgUHJlY29tcGlsZWQgZnJvbSBgbGliL21lc3NhZ2Vmb3JtYXQtcGFyc2VyLnBlZ2pzYCBieVxcbiAqICB7QGxpbmsgaHR0cDovL3BlZ2pzLm9yZy8gUEVHLmpzfS4gSW5jbHVkZWQgaW4gTWVzc2FnZUZvcm1hdCBvYmplY3RcXG4gKiAgdG8gZW5hYmxlIHRlc3RpbmcuXFxuICpcXG4gKiAgQHByaXZhdGUgICovXFxuXFxuXFxuXFxuLyoqIFBsdXJhbGl6YXRpb24gZnVuY3Rpb25zIGZyb21cXG4gKiAge0BsaW5rIGh0dHA6Ly9naXRodWIuY29tL2VlbWVsaS9tYWtlLXBsdXJhbC5qcyBtYWtlLXBsdXJhbH1cXG4gKlxcbiAqICBAbWVtYmVyb2YgTWVzc2FnZUZvcm1hdFxcbiAqICBAdHlwZSBPYmplY3QuPHN0cmluZyxmdW5jdGlvbj4gICovXFxuTWVzc2FnZUZvcm1hdC5wbHVyYWxzID0ge307XFxuXFxuXFxuLyoqIERlZmF1bHQgbnVtYmVyIGZvcm1hdHRpbmcgZnVuY3Rpb25zIGluIHRoZSBzdHlsZSBvZiBJQ1Unc1xcbiAqICB7QGxpbmsgaHR0cDovL2ljdS1wcm9qZWN0Lm9yZy9hcGlyZWYvaWN1NGovY29tL2libS9pY3UvdGV4dC9NZXNzYWdlRm9ybWF0Lmh0bWwgc2ltcGxlQXJnIHN5bnRheH1cXG4gKiAgaW1wbGVtZW50ZWQgdXNpbmcgdGhlXFxuICogIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnRsIEludGx9XFxuICogIG9iamVjdCBkZWZpbmVkIGJ5IEVDTUEtNDAyLlxcbiAqXFxuICogICoqTm90ZSoqOiBJbnRsIGlzIG5vdCBkZWZpbmVkIGluIGRlZmF1bHQgTm9kZSB1bnRpbCAwLjExLjE1IC8gMC4xMi4wLCBzb1xcbiAqICBlYXJsaWVyIHZlcnNpb25zIHJlcXVpcmUgYSB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaW50bCBwb2x5ZmlsbH0uXFxuICogIFRoZXJlZm9yZSB7QGxpbmsgTWVzc2FnZUZvcm1hdC53aXRoSW50bFN1cHBvcnR9IG5lZWRzIHRvIGJlIHRydWUgZm9yIHRoZXNlXFxuICogIGZ1bmN0aW9ucyB0byBiZSBhdmFpbGFibGUgZm9yIGluY2x1c2lvbiBpbiB0aGUgb3V0cHV0LlxcbiAqXFxuICogIEBzZWUgTWVzc2FnZUZvcm1hdCNzZXRJbnRsU3VwcG9ydFxcbiAqXFxuICogIEBuYW1lc3BhY2VcXG4gKiAgQG1lbWJlcm9mIE1lc3NhZ2VGb3JtYXRcXG4gKiAgQHByb3BlcnR5IHtmdW5jdGlvbn0gbnVtYmVyIC0gUmVwcmVzZW50IGEgbnVtYmVyIGFzIGFuIGludGVnZXIsIHBlcmNlbnQgb3IgY3VycmVuY3kgdmFsdWVcXG4gKiAgQHByb3BlcnR5IHtmdW5jdGlvbn0gZGF0ZSAtIFJlcHJlc2VudCBhIGRhdGUgYXMgYSBmdWxsL2xvbmcvZGVmYXVsdC9zaG9ydCBzdHJpbmdcXG4gKiAgQHByb3BlcnR5IHtmdW5jdGlvbn0gdGltZSAtIFJlcHJlc2VudCBhIHRpbWUgYXMgYSBmdWxsL2xvbmcvZGVmYXVsdC9zaG9ydCBzdHJpbmdcXG4gKlxcbiAqICBAZXhhbXBsZVxcbiAqICA+IHZhciBNZXNzYWdlRm9ybWF0ID0gcmVxdWlyZSgnbWVzc2FnZWZvcm1hdCcpO1xcbiAqICA+IHZhciBtZiA9IChuZXcgTWVzc2FnZUZvcm1hdCgnZW4nKSkuc2V0SW50bFN1cHBvcnQodHJ1ZSk7XFxuICogID4gbWYuY3VycmVuY3kgPSAnRVVSJztcXG4gKiAgPiB2YXIgbWZ1bmMgPSBtZi5jb21waWxlKFxcXCJUaGUgdG90YWwgaXMge1YsbnVtYmVyLGN1cnJlbmN5fS5cXFwiKTtcXG4gKiAgPiBtZnVuYyh7Vjo1LjV9KVxcbiAqICBcXFwiVGhlIHRvdGFsIGlzIOKCrDUuNTAuXFxcIlxcbiAqXFxuICogIEBleGFtcGxlXFxuICogID4gdmFyIE1lc3NhZ2VGb3JtYXQgPSByZXF1aXJlKCdtZXNzYWdlZm9ybWF0Jyk7XFxuICogID4gdmFyIG1mID0gbmV3IE1lc3NhZ2VGb3JtYXQoJ2VuJywgbnVsbCwge251bWJlcjogTWVzc2FnZUZvcm1hdC5udW1iZXJ9KTtcXG4gKiAgPiBtZi5jdXJyZW5jeSA9ICdFVVInO1xcbiAqICA+IHZhciBtZnVuYyA9IG1mLmNvbXBpbGUoXFxcIlRoZSB0b3RhbCBpcyB7VixudW1iZXIsY3VycmVuY3l9LlxcXCIpO1xcbiAqICA+IG1mdW5jKHtWOjUuNX0pXFxuICogIFxcXCJUaGUgdG90YWwgaXMg4oKsNS41MC5cXFwiICAqL1xcbk1lc3NhZ2VGb3JtYXQuZm9ybWF0dGVycyA9IHt9O1xcblxcbi8qKiBFbmFibGUgb3IgZGlzYWJsZSBzdXBwb3J0IGZvciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXJzLCB3aGljaCByZXF1aXJlIHRoZVxcbiAqICBgSW50bGAgb2JqZWN0LiBOb3RlIHRoYXQgdGhpcyBjYW4ndCBiZSBhdXRvZGV0ZWN0ZWQsIGFzIHRoZSBlbnZpcm9ubWVudFxcbiAqICBpbiB3aGljaCB0aGUgZm9ybWF0dGVkIHRleHQgaXMgY29tcGlsZWQgaW50byBKYXZhc2NyaXB0IGZ1bmN0aW9ucyBpcyBub3RcXG4gKiAgbmVjZXNzYXJpbHkgdGhlIHNhbWUgZW52aXJvbm1lbnQgaW4gd2hpY2ggdGhleSB3aWxsIGdldCBleGVjdXRlZC5cXG4gKlxcbiAqICBAc2VlIE1lc3NhZ2VGb3JtYXQuZm9ybWF0dGVyc1xcbiAqXFxuICogIEBtZW1iZXJvZiBNZXNzYWdlRm9ybWF0XFxuICogIEBwYXJhbSB7Ym9vbGVhbn0gW2VuYWJsZT10cnVlXVxcbiAqICBAcmV0dXJucyB7T2JqZWN0fSBUaGUgTWVzc2FnZUZvcm1hdCBpbnN0YW5jZSwgdG8gYWxsb3cgZm9yIGNoYWluaW5nXFxuICogIEBleGFtcGxlXFxuICogID4gdmFyIEludGwgPSByZXF1aXJlKCdpbnRsJyk7XFxuICogID4gdmFyIE1lc3NhZ2VGb3JtYXQgPSByZXF1aXJlKCdtZXNzYWdlZm9ybWF0Jyk7XFxuICogID4gdmFyIG1mID0gKG5ldyBNZXNzYWdlRm9ybWF0KCdlbicpKS5zZXRJbnRsU3VwcG9ydCh0cnVlKTtcXG4gKiAgPiBtZi5jdXJyZW5jeSA9ICdFVVInO1xcbiAqICA+IG1mLmNvbXBpbGUoXFxcIlRoZSB0b3RhbCBpcyB7VixudW1iZXIsY3VycmVuY3l9LlxcXCIpKHtWOjUuNX0pO1xcbiAqICBcXFwiVGhlIHRvdGFsIGlzIOKCrDUuNTAuXFxcIiAgKi9cXG5cXG5cXG5cXG4vKiogQSBzZXQgb2YgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBhcmUgY2FsbGVkIGJ5IHRoZSBjb21waWxlZCBKYXZhc2NyaXB0XFxuICogIGZ1bmN0aW9ucywgdGhlc2UgYXJlIGluY2x1ZGVkIGxvY2FsbHkgaW4gdGhlIG91dHB1dCBvZiB7QGxpbmtcXG4gKiAgTWVzc2FnZUZvcm1hdCNjb21waWxlIGNvbXBpbGUoKX0uXFxuICpcXG4gKiAgQG5hbWVzcGFjZVxcbiAqICBAbWVtYmVyb2YgTWVzc2FnZUZvcm1hdCAgKi9cXG5NZXNzYWdlRm9ybWF0LnByb3RvdHlwZS5ydW50aW1lID0ge1xcblxcbiAgLyoqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGAjYCBpbiBwbHVyYWwgcnVsZXNcXG4gICAqXFxuICAgKiAgQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIG9wZXJhdGUgb25cXG4gICAqICBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIEFuIG9wdGlvbmFsIG9mZnNldCwgc2V0IGJ5IHRoZSBzdXJyb3VuZGluZyBjb250ZXh0ICAqL1xcbiAgbnVtYmVyOiBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XFxuICAgIGlmIChpc05hTih2YWx1ZSkpIHRocm93IG5ldyBFcnJvcihcXFwiJ1xcXCIgKyB2YWx1ZSArIFxcXCInIGlzbid0IGEgbnVtYmVyLlxcXCIpO1xcbiAgICByZXR1cm4gdmFsdWUgLSAob2Zmc2V0IHx8IDApO1xcbiAgfSxcXG5cXG4gIC8qKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBge04sIHBsdXJhbHxzZWxlY3RvcmRpbmFsLCAuLi59YFxcbiAgICpcXG4gICAqICBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUga2V5IHRvIHVzZSB0byBmaW5kIGEgcGx1cmFsaXphdGlvbiBydWxlXFxuICAgKiAgQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIEFuIG9mZnNldCB0byBhcHBseSB0byBgdmFsdWVgXFxuICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gbGNmdW5jIC0gQSBsb2NhbGUgZnVuY3Rpb24gZnJvbSBgcGx1cmFsRnVuY3NgXFxuICAgKiAgQHBhcmFtIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBkYXRhIC0gVGhlIG9iamVjdCBmcm9tIHdoaWNoIHJlc3VsdHMgYXJlIGxvb2tlZCB1cFxcbiAgICogIEBwYXJhbSB7P2Jvb2xlYW59IGlzT3JkaW5hbCAtIElmIHRydWUsIHVzZSBvcmRpbmFsIHJhdGhlciB0aGFuIGNhcmRpbmFsIHJ1bGVzXFxuICAgKiAgQHJldHVybnMge3N0cmluZ30gVGhlIHJlc3VsdCBvZiB0aGUgcGx1cmFsaXphdGlvbiAgKi9cXG4gIHBsdXJhbDogZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbGNmdW5jLCBkYXRhLCBpc09yZGluYWwpIHtcXG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgdmFsdWUpKSByZXR1cm4gZGF0YVt2YWx1ZV0oKTtcXG4gICAgaWYgKG9mZnNldCkgdmFsdWUgLT0gb2Zmc2V0O1xcbiAgICB2YXIga2V5ID0gbGNmdW5jKHZhbHVlLCBpc09yZGluYWwpO1xcbiAgICBpZiAoa2V5IGluIGRhdGEpIHJldHVybiBkYXRhW2tleV0oKTtcXG4gICAgcmV0dXJuIGRhdGEub3RoZXIoKTtcXG4gIH0sXFxuXFxuICAvKiogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYHtOLCBzZWxlY3QsIC4uLn1gXFxuICAgKlxcbiAgICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBrZXkgdG8gdXNlIHRvIGZpbmQgYSBzZWxlY3Rpb25cXG4gICAqICBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IGRhdGEgLSBUaGUgb2JqZWN0IGZyb20gd2hpY2ggcmVzdWx0cyBhcmUgbG9va2VkIHVwXFxuICAgKiAgQHJldHVybnMge3N0cmluZ30gVGhlIHJlc3VsdCBvZiB0aGUgc2VsZWN0IHN0YXRlbWVudCAgKi9cXG4gIHNlbGVjdDogZnVuY3Rpb24odmFsdWUsIGRhdGEpIHtcXG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgdmFsdWUpKSByZXR1cm4gZGF0YVt2YWx1ZV0oKTtcXG4gICAgcmV0dXJuIGRhdGEub3RoZXIoKVxcbiAgfSxcXG5cXG4gIC8qKiBQbHVyYWxpemF0aW9uIGZ1bmN0aW9ucyBpbmNsdWRlZCBpbiBjb21waWxlZCBvdXRwdXRcXG4gICAqICBAaW5zdGFuY2VcXG4gICAqICBAdHlwZSBPYmplY3QuPHN0cmluZyxmdW5jdGlvbj4gICovXFxuICBwbHVyYWxGdW5jczoge30sXFxuXFxuICAvKiogQ3VzdG9tIGZvcm1hdHRpbmcgZnVuY3Rpb25zIGNhbGxlZCBieSBge3ZhciwgZm5bLCBhcmdzXSp9YCBzeW50YXhcXG4gICAqXFxuICAgKiAgRm9yIGV4YW1wbGVzLCBzZWUge0BsaW5rIE1lc3NhZ2VGb3JtYXQuZm9ybWF0dGVyc31cXG4gICAqXFxuICAgKiAgQGluc3RhbmNlXFxuICAgKiAgQHNlZSBNZXNzYWdlRm9ybWF0LmZvcm1hdHRlcnNcXG4gICAqICBAdHlwZSBPYmplY3QuPHN0cmluZyxmdW5jdGlvbj4gICovXFxuICBmbXQ6IHt9LFxcblxcbiAgLyoqIEN1c3RvbSBzdHJpbmdpZmllciB0byBjbGVhbiB1cCBicm93c2VyIGluY29uc2lzdGVuY2llc1xcbiAgICogIEBpbnN0YW5jZSAgKi9cXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBfc3RyaW5naWZ5ID0gZnVuY3Rpb24obywgbGV2ZWwpIHtcXG4gICAgICBpZiAodHlwZW9mIG8gIT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHZhciBmdW5jU3RyID0gby50b1N0cmluZygpLnJlcGxhY2UoL14oZnVuY3Rpb24gKVxcXFx3Ki8sICckMScpO1xcbiAgICAgICAgdmFyIGluZGVudCA9IC8oWyBcXFxcdF0qKVxcXFxTLiokLy5leGVjKGZ1bmNTdHIpO1xcbiAgICAgICAgcmV0dXJuIGluZGVudCA/IGZ1bmNTdHIucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIGluZGVudFsxXSwgJ21nJyksICcnKSA6IGZ1bmNTdHI7XFxuICAgICAgfVxcbiAgICAgIHZhciBzID0gW107XFxuICAgICAgZm9yICh2YXIgaSBpbiBvKSBpZiAoaSAhPSAndG9TdHJpbmcnKSB7XFxuICAgICAgICBpZiAobGV2ZWwgPT0gMCkgcy5wdXNoKCd2YXIgJyArIGkgKyAnID0gJyArIF9zdHJpbmdpZnkob1tpXSwgbGV2ZWwgKyAxKSArICc7XFxcXG4nKTtcXG4gICAgICAgIGVsc2Ugcy5wdXNoKHByb3BuYW1lKGkpICsgJzogJyArIF9zdHJpbmdpZnkob1tpXSwgbGV2ZWwgKyAxKSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChsZXZlbCA9PSAwKSByZXR1cm4gcy5qb2luKCcnKTtcXG4gICAgICBpZiAocy5sZW5ndGggPT0gMCkgcmV0dXJuICd7fSc7XFxuICAgICAgdmFyIGluZGVudCA9ICcgICc7IHdoaWxlICgtLWxldmVsKSBpbmRlbnQgKz0gJyAgJztcXG4gICAgICByZXR1cm4gJ3tcXFxcbicgKyBzLmpvaW4oJyxcXFxcbicpLnJlcGxhY2UoL14vZ20sIGluZGVudCkgKyAnXFxcXG59JztcXG4gICAgfTtcXG4gICAgcmV0dXJuIF9zdHJpbmdpZnkodGhpcywgMCk7XFxuICB9XFxufTtcXG5cXG5cXG4vKiogUmVjdXJzaXZlbHkgbWFwIGFuIEFTVCB0byBpdHMgcmVzdWx0aW5nIHN0cmluZ1xcbiAqXFxuICogIEBtZW1iZXJvZiBNZXNzYWdlRm9ybWF0XFxuICpcXG4gKiAgQHBhcmFtIGFzdCAtIHRoZSBBc3Qgbm9kZSBmb3Igd2hpY2ggdGhlIEpTIGNvZGUgc2hvdWxkIGJlIGdlbmVyYXRlZFxcbiAqXFxuICogIEBwcml2YXRlICAqL1xcbk1lc3NhZ2VGb3JtYXQucHJvdG90eXBlLl9wcmVjb21waWxlID0gZnVuY3Rpb24oYXN0LCBkYXRhKSB7XFxuICBkYXRhID0gZGF0YSB8fCB7IGtleXM6IHt9LCBvZmZzZXQ6IHt9IH07XFxuICB2YXIgciA9IFtdLCBpLCB0bXAsIGFyZ3MgPSBbXTtcXG5cXG4gIHN3aXRjaCAoIGFzdC50eXBlICkge1xcbiAgICBjYXNlICdtZXNzYWdlRm9ybWF0UGF0dGVybic6XFxuICAgICAgZm9yICggaSA9IDA7IGkgPCBhc3Quc3RhdGVtZW50cy5sZW5ndGg7ICsraSApIHtcXG4gICAgICAgIHIucHVzaCh0aGlzLl9wcmVjb21waWxlKCBhc3Quc3RhdGVtZW50c1tpXSwgZGF0YSApKTtcXG4gICAgICB9XFxuICAgICAgdG1wID0gci5qb2luKCcgKyAnKSB8fCAnXFxcIlxcXCInO1xcbiAgICAgIHJldHVybiBkYXRhLnBmX2NvdW50ID8gdG1wIDogJ2Z1bmN0aW9uKGQpIHsgcmV0dXJuICcgKyB0bXAgKyAnOyB9JztcXG5cXG4gICAgY2FzZSAnbWVzc2FnZUZvcm1hdEVsZW1lbnQnOlxcbiAgICAgIGRhdGEucGZfY291bnQgPSBkYXRhLnBmX2NvdW50IHx8IDA7XFxuICAgICAgaWYgKCBhc3Qub3V0cHV0ICkge1xcbiAgICAgICAgcmV0dXJuIHByb3BuYW1lKGFzdC5hcmd1bWVudEluZGV4LCAnZCcpO1xcbiAgICAgIH1cXG4gICAgICBlbHNlIHtcXG4gICAgICAgIGRhdGEua2V5c1tkYXRhLnBmX2NvdW50XSA9IGFzdC5hcmd1bWVudEluZGV4O1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWNvbXBpbGUoIGFzdC5lbGVtZW50Rm9ybWF0LCBkYXRhICk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiAnJztcXG5cXG4gICAgY2FzZSAnZWxlbWVudEZvcm1hdCc6XFxuICAgICAgYXJncyA9IFsgcHJvcG5hbWUoZGF0YS5rZXlzW2RhdGEucGZfY291bnRdLCAnZCcpIF07XFxuICAgICAgc3dpdGNoIChhc3Qua2V5KSB7XFxuICAgICAgICBjYXNlICdzZWxlY3QnOlxcbiAgICAgICAgICBhcmdzLnB1c2godGhpcy5fcHJlY29tcGlsZShhc3QudmFsLCBkYXRhKSk7XFxuICAgICAgICAgIHJldHVybiAnc2VsZWN0KCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKSc7XFxuICAgICAgICBjYXNlICdzZWxlY3RvcmRpbmFsJzpcXG4gICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFsgMCwgcHJvcG5hbWUodGhpcy5sY1swXSwgJ3BsdXJhbEZ1bmNzJyksIHRoaXMuX3ByZWNvbXBpbGUoYXN0LnZhbCwgZGF0YSksIDEgXSk7XFxuICAgICAgICAgIHJldHVybiAncGx1cmFsKCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKSc7XFxuICAgICAgICBjYXNlICdwbHVyYWwnOlxcbiAgICAgICAgICBkYXRhLm9mZnNldFtkYXRhLnBmX2NvdW50IHx8IDBdID0gYXN0LnZhbC5vZmZzZXQgfHwgMDtcXG4gICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFsgZGF0YS5vZmZzZXRbZGF0YS5wZl9jb3VudF0gfHwgMCwgcHJvcG5hbWUodGhpcy5sY1swXSwgJ3BsdXJhbEZ1bmNzJyksIHRoaXMuX3ByZWNvbXBpbGUoYXN0LnZhbCwgZGF0YSkgXSk7XFxuICAgICAgICAgIHJldHVybiAncGx1cmFsKCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKSc7XFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICBpZiAodGhpcy53aXRoSW50bFN1cHBvcnQgJiYgIShhc3Qua2V5IGluIHRoaXMucnVudGltZS5mbXQpICYmIChhc3Qua2V5IGluIE1lc3NhZ2VGb3JtYXQuZm9ybWF0dGVycykpIHtcXG4gICAgICAgICAgICB0bXAgPSBNZXNzYWdlRm9ybWF0LmZvcm1hdHRlcnNbYXN0LmtleV07XFxuICAgICAgICAgICAgdGhpcy5ydW50aW1lLmZtdFthc3Qua2V5XSA9ICh0eXBlb2YgdG1wKHRoaXMpID09ICdmdW5jdGlvbicpID8gdG1wKHRoaXMpIDogdG1wO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGFyZ3MucHVzaChKU09OLnN0cmluZ2lmeSh0aGlzLmxjKSk7XFxuICAgICAgICAgIGlmIChhc3QudmFsICYmIGFzdC52YWwubGVuZ3RoKSBhcmdzLnB1c2goSlNPTi5zdHJpbmdpZnkoYXN0LnZhbC5sZW5ndGggPT0gMSA/IGFzdC52YWxbMF0gOiBhc3QudmFsKSk7XFxuICAgICAgICAgIHJldHVybiAnZm10LicgKyBhc3Qua2V5ICsgJygnICsgYXJncy5qb2luKCcsICcpICsgJyknO1xcbiAgICAgIH1cXG5cXG4gICAgY2FzZSAncGx1cmFsRm9ybWF0UGF0dGVybic6XFxuICAgIGNhc2UgJ3NlbGVjdEZvcm1hdFBhdHRlcm4nOlxcbiAgICAgIGRhdGEucGZfY291bnQgPSBkYXRhLnBmX2NvdW50IHx8IDA7XFxuICAgICAgaWYgKGFzdC50eXBlID09ICdzZWxlY3RGb3JtYXRQYXR0ZXJuJykgZGF0YS5vZmZzZXRbZGF0YS5wZl9jb3VudF0gPSAwO1xcbiAgICAgIHZhciBuZWVkT3RoZXIgPSB0cnVlO1xcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhc3QucGx1cmFsRm9ybXMubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciBrZXkgPSBhc3QucGx1cmFsRm9ybXNbaV0ua2V5O1xcbiAgICAgICAgaWYgKGtleSA9PT0gJ290aGVyJykgbmVlZE90aGVyID0gZmFsc2U7XFxuICAgICAgICB2YXIgZGF0YV9jb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XFxuICAgICAgICBkYXRhX2NvcHkucGZfY291bnQrKztcXG4gICAgICAgIHIucHVzaChwcm9wbmFtZShrZXkpICsgJzogZnVuY3Rpb24oKSB7IHJldHVybiAnICsgdGhpcy5fcHJlY29tcGlsZShhc3QucGx1cmFsRm9ybXNbaV0udmFsLCBkYXRhX2NvcHkpICsgJzt9Jyk7XFxuICAgICAgfVxcbiAgICAgIGlmIChuZWVkT3RoZXIpIHRocm93IG5ldyBFcnJvcihcXFwiTm8gJ290aGVyJyBmb3JtIGZvdW5kIGluIFxcXCIgKyBhc3QudHlwZSArIFxcXCIgXFxcIiArIGRhdGEucGZfY291bnQpO1xcbiAgICAgIHJldHVybiAneyAnICsgci5qb2luKCcsICcpICsgJyB9JztcXG5cXG4gICAgY2FzZSAnc3RyaW5nJzpcXG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXN0LnZhbCB8fCBcXFwiXFxcIik7XFxuXFxuICAgIGNhc2UgJ29jdG90aG9ycGUnOlxcbiAgICAgIGlmICghZGF0YS5wZl9jb3VudCkgcmV0dXJuICdcXFwiI1xcXCInO1xcbiAgICAgIGFyZ3MgPSBbIHByb3BuYW1lKGRhdGEua2V5c1tkYXRhLnBmX2NvdW50LTFdLCAnZCcpIF07XFxuICAgICAgaWYgKGRhdGEub2Zmc2V0W2RhdGEucGZfY291bnQtMV0pIGFyZ3MucHVzaChkYXRhLm9mZnNldFtkYXRhLnBmX2NvdW50LTFdKTtcXG4gICAgICByZXR1cm4gJ251bWJlcignICsgYXJncy5qb2luKCcsICcpICsgJyknO1xcblxcbiAgICBkZWZhdWx0OlxcbiAgICAgIHRocm93IG5ldyBFcnJvciggJ0JhZCBBU1QgdHlwZTogJyArIGFzdC50eXBlICk7XFxuICB9XFxufTtcXG5cXG4vKiogQ29tcGlsZSBtZXNzYWdlcyBpbnRvIGFuIGV4ZWN1dGFibGUgZnVuY3Rpb24gd2l0aCBjbGVhbiBzdHJpbmdcXG4gKiAgcmVwcmVzZW50YXRpb24uXFxuICpcXG4gKiAgSWYgYG1lc3NhZ2VzYCBpcyBhIHNpbmdsZSBzdHJpbmcgaW5jbHVkaW5nIElDVSBNZXNzYWdlRm9ybWF0IGRlY2xhcmF0aW9ucyxcXG4gKiAgYG9wdGAgaXMgaWdub3JlZCBhbmQgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHRha2VzIGEgc2luZ2xlIE9iamVjdCBwYXJhbWV0ZXJcXG4gKiAgYGRgIHJlcHJlc2VudGluZyBlYWNoIG9mIHRoZSBpbnB1dCdzIGRlZmluZWQgdmFyaWFibGVzLiBUaGUgcmV0dXJuZWRcXG4gKiAgZnVuY3Rpb24gd2lsbCBiZSBkZWZpbmVkIGluIGEgbG9jYWwgc2NvcGUgdGhhdCBpbmNsdWRlcyBhbGwgdGhlIHJlcXVpcmVkXFxuICogIHJ1bnRpbWUgdmFyaWFibGVzLlxcbiAqXFxuICogIElmIGBtZXNzYWdlc2AgaXMgYSBtYXAgb2Yga2V5cyB0byBzdHJpbmdzLCBvciBhIG1hcCBvZiBuYW1lc3BhY2Uga2V5cyB0b1xcbiAqICBzdWNoIGtleS9zdHJpbmcgbWFwcywgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgZmlsbCB0aGUgc3BlY2lmaWVkIGdsb2JhbFxcbiAqICB3aXRoIGphdmFzY3JpcHQgZnVuY3Rpb25zIG1hdGNoaW5nIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGlucHV0LiBJbiBzdWNoIHVzZSxcXG4gKiAgdGhlIG91dHB1dCBvZiBgY29tcGlsZSgpYCBpcyBleHBlY3RlZCB0byBiZSBzZXJpYWxpemVkIHVzaW5nIGAudG9TdHJpbmcoKWAsXFxuICogIGFuZCB3aWxsIGluY2x1ZGUgZGVmaW5pdGlvbnMgb2YgdGhlIHJ1bnRpbWUgZnVuY3Rpb25zLiBJZiBgb3B0Lmdsb2JhbGAgaXNcXG4gKiAgbnVsbCwgY2FsbGluZyB0aGUgb3V0cHV0IGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBvYmplY3QgaXRzZWxmLlxcbiAqXFxuICogIFRvZ2V0aGVyLCB0aGUgaW5wdXQgcGFyYW1ldGVycyBzaG91bGQgbWF0Y2ggdGhlIGZvbGxvd2luZyBwYXR0ZXJuczpcXG4gKiAgYGBganNcXG4gKiAgbWVzc2FnZXMgPSBcXFwic3RyaW5nXFxcIiB8fCB7IGtleTA6IFxcXCJzdHJpbmcwXFxcIiwga2V5MTogXFxcInN0cmluZzFcXFwiLCAuLi4gfSB8fCB7XFxuICogICAgbnMwOiB7IGtleTA6IFxcXCJzdHJpbmcwXFxcIiwga2V5MTogXFxcInN0cmluZzFcXFwiLCAuLi4gIH0sXFxuICogICAgbnMxOiB7IGtleTA6IFxcXCJzdHJpbmcwXFxcIiwga2V5MTogXFxcInN0cmluZzFcXFwiLCAuLi4gIH0sXFxuICogICAgLi4uXFxuICogIH1cXG4gKlxcbiAqICBvcHQgPSBudWxsIHx8IHtcXG4gKiAgICBsb2NhbGU6IG51bGwgfHwge1xcbiAqICAgICAgbnMwOiBcXFwibGMwXFxcIiB8fCBbIFxcXCJsYzBcXFwiLCAuLi4gXSxcXG4gKiAgICAgIG5zMTogXFxcImxjMVxcXCIgfHwgWyBcXFwibGMxXFxcIiwgLi4uIF0sXFxuICogICAgICAuLi5cXG4gKiAgICB9LFxcbiAqICAgIGdsb2JhbDogbnVsbCB8fCBcXFwibW9kdWxlLmV4cG9ydHNcXFwiIHx8IFxcXCJleHBvcnRzXFxcIiB8fCBcXFwiaTE4blxcXCIgfHwgLi4uXFxuICogIH1cXG4gKiAgYGBgXFxuICpcXG4gKiAgQG1lbWJlcm9mIE1lc3NhZ2VGb3JtYXRcXG4gKiAgQHBhcmFtIHtzdHJpbmd8T2JqZWN0fVxcbiAqICAgICAgbWVzc2FnZXMgLSBUaGUgaW5wdXQgbWVzc2FnZShzKSB0byBiZSBjb21waWxlZCwgaW4gSUNVIE1lc3NhZ2VGb3JtYXRcXG4gKiAgQHBhcmFtIHtPYmplY3R9IFtvcHQ9e31dIC0gT3B0aW9ucyBjb250cm9sbGluZyBvdXRwdXQgZm9yIG5vbi1zaW1wbGUgaW50cHV0XFxuICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0LmxvY2FsZV0gLSBUaGUgbG9jYWxlcyB0byB1c2UgZm9yIHRoZSBtZXNzYWdlcywgd2l0aCBhXFxuICogICAgICBzdHJ1Y3R1cmUgbWF0Y2hpbmcgdGhhdCBvZiBgbWVzc2FnZXNgXFxuICogIEBwYXJhbSB7c3RyaW5nfSBbb3B0Lmdsb2JhbD1cXFwiXFxcIl0gLSBUaGUgZ2xvYmFsIHZhcmlhYmxlIHRoYXQgdGhlIG91dHB1dFxcbiAqICAgICAgZnVuY3Rpb24gc2hvdWxkIHVzZSwgb3IgYSBudWxsIHN0cmluZyBmb3Igbm9uZS4gXFxcImV4cG9ydHNcXFwiIGFuZFxcbiAqICAgICAgXFxcIm1vZHVsZS5leHBvcnRzXFxcIiBhcmUgcmVjb2duaXNlZCBhcyBzcGVjaWFsIGNhc2VzLlxcbiAqICBAcmV0dXJucyB7ZnVuY3Rpb259IFRoZSBmaXJzdCBtYXRjaCBmb3VuZCBmb3IgdGhlIGdpdmVuIGxvY2FsZShzKVxcbiAqXFxuICogIEBleGFtcGxlXFxuICogPiB2YXIgTWVzc2FnZUZvcm1hdCA9IHJlcXVpcmUoJ21lc3NhZ2Vmb3JtYXQnKSxcXG4gKiAuLi4gICBtZiA9IG5ldyBNZXNzYWdlRm9ybWF0KCdlbicpLFxcbiAqIC4uLiAgIG1mdW5jMCA9IG1mLmNvbXBpbGUoJ0Ege1RZUEV9IGV4YW1wbGUuJyk7XFxuICogPiBtZnVuYzAoe1RZUEU6J3NpbXBsZSd9KVxcbiAqICdBIHNpbXBsZSBleGFtcGxlLidcXG4gKiA+IG1mdW5jMC50b1N0cmluZygpXFxuICogJ2Z1bmN0aW9uIChkKSB7IHJldHVybiBcXFwiQSBcXFwiICsgZC5UWVBFICsgXFxcIiBleGFtcGxlLlxcXCI7IH0nXFxuICpcXG4gKiAgQGV4YW1wbGVcXG4gKiA+IHZhciBtc2dTZXQgPSB7IGE6ICdBIHtUWVBFfSBleGFtcGxlLicsXFxuICogLi4uICAgICAgICAgICAgICBiOiAnVGhpcyBoYXMge0NPVU5ULCBwbHVyYWwsIG9uZXtvbmUgbWVtYmVyfSBvdGhlcnsjIG1lbWJlcnN9fS4nIH0sXFxuICogLi4uICAgbWZ1bmNTZXQgPSBtZi5jb21waWxlKG1zZ1NldCk7XFxuICogPiBtZnVuY1NldCgpLmEoe1RZUEU6J21vcmUgY29tcGxleCd9KVxcbiAqICdBIG1vcmUgY29tcGxleCBleGFtcGxlLidcXG4gKiA+IG1mdW5jU2V0KCkuYih7Q09VTlQ6Mn0pXFxuICogJ1RoaXMgaGFzIDIgbWVtYmVycy4nXFxuICpcXG4gKiA+IGNvbnNvbGUubG9nKG1mdW5jU2V0LnRvU3RyaW5nKCkpXFxuICogZnVuY3Rpb24gYW5vbnltb3VzKCkge1xcbiAqIHZhciBudW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCkge1xcbiAqICAgaWYgKGlzTmFOKHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKFxcXCInXFxcIiArIHZhbHVlICsgXFxcIicgaXNuJ3QgYSBudW1iZXIuXFxcIik7XFxuICogICByZXR1cm4gdmFsdWUgLSAob2Zmc2V0IHx8IDApO1xcbiAqIH07XFxuICogdmFyIHBsdXJhbCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBsY2Z1bmMsIGRhdGEsIGlzT3JkaW5hbCkge1xcbiAqICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgdmFsdWUpKSByZXR1cm4gZGF0YVt2YWx1ZV0oKTtcXG4gKiAgIGlmIChvZmZzZXQpIHZhbHVlIC09IG9mZnNldDtcXG4gKiAgIHZhciBrZXkgPSBsY2Z1bmModmFsdWUsIGlzT3JkaW5hbCk7XFxuICogICBpZiAoa2V5IGluIGRhdGEpIHJldHVybiBkYXRhW2tleV0oKTtcXG4gKiAgIHJldHVybiBkYXRhLm90aGVyKCk7XFxuICogfTtcXG4gKiB2YXIgc2VsZWN0ID0gZnVuY3Rpb24gKHZhbHVlLCBkYXRhKSB7XFxuICogICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCB2YWx1ZSkpIHJldHVybiBkYXRhW3ZhbHVlXSgpO1xcbiAqICAgcmV0dXJuIGRhdGEub3RoZXIoKVxcbiAqIH07XFxuICogdmFyIHBsdXJhbEZ1bmNzID0ge1xcbiAqICAgZW46IGZ1bmN0aW9uIChuLCBvcmQpIHtcXG4gKiAgICAgdmFyIHMgPSBTdHJpbmcobikuc3BsaXQoJy4nKSwgdjAgPSAhc1sxXSwgdDAgPSBOdW1iZXIoc1swXSkgPT0gbixcXG4gKiAgICAgICAgIG4xMCA9IHQwICYmIHNbMF0uc2xpY2UoLTEpLCBuMTAwID0gdDAgJiYgc1swXS5zbGljZSgtMik7XFxuICogICAgIGlmIChvcmQpIHJldHVybiAobjEwID09IDEgJiYgbjEwMCAhPSAxMSkgPyAnb25lJ1xcbiAqICAgICAgICAgOiAobjEwID09IDIgJiYgbjEwMCAhPSAxMikgPyAndHdvJ1xcbiAqICAgICAgICAgOiAobjEwID09IDMgJiYgbjEwMCAhPSAxMykgPyAnZmV3J1xcbiAqICAgICAgICAgOiAnb3RoZXInO1xcbiAqICAgICByZXR1cm4gKG4gPT0gMSAmJiB2MCkgPyAnb25lJyA6ICdvdGhlcic7XFxuICogICB9XFxuICogfTtcXG4gKiB2YXIgZm10ID0ge307XFxuICpcXG4gKiByZXR1cm4ge1xcbiAqICAgYTogZnVuY3Rpb24oZCkgeyByZXR1cm4gXFxcIkEgXFxcIiArIGQuVFlQRSArIFxcXCIgZXhhbXBsZS5cXFwiOyB9LFxcbiAqICAgYjogZnVuY3Rpb24oZCkgeyByZXR1cm4gXFxcIlRoaXMgaGFzIFxcXCIgKyBwbHVyYWwoZC5DT1VOVCwgMCwgcGx1cmFsRnVuY3MuZW4sIHsgb25lOiBmdW5jdGlvbigpIHsgcmV0dXJuIFxcXCJvbmUgbWVtYmVyXFxcIjt9LCBvdGhlcjogZnVuY3Rpb24oKSB7IHJldHVybiBudW1iZXIoZC5DT1VOVCkrXFxcIiBtZW1iZXJzXFxcIjt9IH0pICsgXFxcIi5cXFwiOyB9XFxuICogfVxcbiAqIH1cXG4gKlxcbiAqICBAZXhhbXBsZVxcbiAqID4gbWYucnVudGltZS5wbHVyYWxGdW5jcy5maSA9IE1lc3NhZ2VGb3JtYXQucGx1cmFscy5maTtcXG4gKiA+IHZhciBtdWx0aVNldCA9IHsgZW46IHsgYTogJ0Ege1RZUEV9IGV4YW1wbGUuJyxcXG4gKiAuLi4gICAgICAgICAgICAgICAgICAgICAgYjogJ1RoaXMgaXMgdGhlIHtDT1VOVCwgc2VsZWN0b3JkaW5hbCwgb25leyNzdH0gdHdveyNuZH0gZmV3eyNyZH0gb3RoZXJ7I3RofX0gZXhhbXBsZS4nIH0sXFxuICogLi4uICAgICAgICAgICAgICAgIGZpOiB7IGE6ICd7VFlQRX0gZXNpbWVya2tpLicsXFxuICogLi4uICAgICAgICAgICAgICAgICAgICAgIGI6ICdUw6Rtw6Qgb24ge0NPVU5ULCBzZWxlY3RvcmRpbmFsLCBvdGhlcnsjLn19IGVzaW1lcmtraS4nIH0gfSxcXG4gKiAuLi4gICBtdWx0aVNldExvY2FsZXMgPSB7IGVuOiAnZW4nLCBmaTogJ2ZpJyB9LFxcbiAqIC4uLiAgIG1mdW5jU2V0ID0gbWYuY29tcGlsZShtdWx0aVNldCwgeyBsb2NhbGU6IG11bHRpU2V0TG9jYWxlcywgZ2xvYmFsOiAnaTE4bicgfSk7XFxuICogPiBtZnVuY1NldCh0aGlzKTtcXG4gKiA+IGkxOG4uZW4uYih7Q09VTlQ6M30pXFxuICogJ1RoaXMgaXMgdGhlIDNyZCBleGFtcGxlLidcXG4gKiA+IGkxOG4uZmkuYih7Q09VTlQ6M30pXFxuICogJ1TDpG3DpCBvbiAzLiBlc2ltZXJra2kuJyAgKi9cXG5NZXNzYWdlRm9ybWF0LnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKCBtZXNzYWdlcywgb3B0ICkge1xcbiAgdmFyIHIgPSB7fSwgbGMwID0gdGhpcy5sYyxcXG4gICAgICBjb21waWxlTXNnID0gZnVuY3Rpb24oc2VsZiwgbXNnKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICB2YXIgYXN0ID0gTWVzc2FnZUZvcm1hdC5fcGFyc2UobXNnKTtcXG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3ByZWNvbXBpbGUoYXN0KTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChhc3QgPyAnUHJlY29tcGlsZXInIDogJ1BhcnNlcicpICsgJyBlcnJvcjogJyArIGUudG9TdHJpbmcoKSk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBzdHJpbmdpZnkgPSBmdW5jdGlvbihyLCBsZXZlbCkge1xcbiAgICAgICAgaWYgKCFsZXZlbCkgbGV2ZWwgPSAwO1xcbiAgICAgICAgaWYgKHR5cGVvZiByICE9ICdvYmplY3QnKSByZXR1cm4gcjtcXG4gICAgICAgIHZhciBvID0gW10sIGluZGVudCA9ICcnO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbDsgKytpKSBpbmRlbnQgKz0gJyAgJztcXG4gICAgICAgIGZvciAodmFyIGsgaW4gcikgby5wdXNoKCdcXFxcbicgKyBpbmRlbnQgKyAnICAnICsgcHJvcG5hbWUoaykgKyAnOiAnICsgc3RyaW5naWZ5KHJba10sIGxldmVsICsgMSkpO1xcbiAgICAgICAgcmV0dXJuICd7JyArIG8uam9pbignLCcpICsgJ1xcXFxuJyArIGluZGVudCArICd9JztcXG4gICAgICB9O1xcblxcbiAgaWYgKHR5cGVvZiBtZXNzYWdlcyA9PSAnc3RyaW5nJykge1xcbiAgICB2YXIgZiA9IG5ldyBGdW5jdGlvbihcXG4gICAgICAgICdudW1iZXIsIHBsdXJhbCwgc2VsZWN0LCBwbHVyYWxGdW5jcywgZm10JyxcXG4gICAgICAgICdyZXR1cm4gJyArIGNvbXBpbGVNc2codGhpcywgbWVzc2FnZXMpKTtcXG4gICAgcmV0dXJuIGYodGhpcy5ydW50aW1lLm51bWJlciwgdGhpcy5ydW50aW1lLnBsdXJhbCwgdGhpcy5ydW50aW1lLnNlbGVjdCxcXG4gICAgICAgIHRoaXMucnVudGltZS5wbHVyYWxGdW5jcywgdGhpcy5ydW50aW1lLmZtdCk7XFxuICB9XFxuXFxuICBvcHQgPSBvcHQgfHwge307XFxuXFxuICBmb3IgKHZhciBucyBpbiBtZXNzYWdlcykge1xcbiAgICBpZiAob3B0LmxvY2FsZSkgdGhpcy5sYyA9IG9wdC5sb2NhbGVbbnNdICYmIFtdLmNvbmNhdChvcHQubG9jYWxlW25zXSkgfHwgbGMwO1xcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2VzW25zXSA9PSAnc3RyaW5nJykge1xcbiAgICAgIHRyeSB7IHJbbnNdID0gY29tcGlsZU1zZyh0aGlzLCBtZXNzYWdlc1tuc10pOyB9XFxuICAgICAgY2F0Y2ggKGUpIHsgZS5tZXNzYWdlID0gZS5tZXNzYWdlLnJlcGxhY2UoJzonLCAnIHdpdGggYCcgKyBucyArICdgOicpOyB0aHJvdyBlOyB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcltuc10gPSB7fTtcXG4gICAgICBmb3IgKHZhciBrZXkgaW4gbWVzc2FnZXNbbnNdKSB7XFxuICAgICAgICB0cnkgeyByW25zXVtrZXldID0gY29tcGlsZU1zZyh0aGlzLCBtZXNzYWdlc1tuc11ba2V5XSk7IH1cXG4gICAgICAgIGNhdGNoIChlKSB7IGUubWVzc2FnZSA9IGUubWVzc2FnZS5yZXBsYWNlKCc6JywgJyB3aXRoIGAnICsga2V5ICsgJ2AgaW4gYCcgKyBucyArICdgOicpOyB0aHJvdyBlOyB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICB0aGlzLmxjID0gbGMwO1xcbiAgdmFyIHMgPSB0aGlzLnJ1bnRpbWUudG9TdHJpbmcoKSArICdcXFxcbic7XFxuICBzd2l0Y2ggKG9wdC5nbG9iYWwgfHwgJycpIHtcXG4gICAgY2FzZSAnZXhwb3J0cyc6XFxuICAgICAgdmFyIG8gPSBbXTtcXG4gICAgICBmb3IgKHZhciBrIGluIHIpIG8ucHVzaChwcm9wbmFtZShrLCAnZXhwb3J0cycpICsgJyA9ICcgKyBzdHJpbmdpZnkocltrXSkpO1xcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24ocyArIG8uam9pbignO1xcXFxuJykpO1xcbiAgICBjYXNlICdtb2R1bGUuZXhwb3J0cyc6XFxuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihzICsgJ21vZHVsZS5leHBvcnRzID0gJyArIHN0cmluZ2lmeShyKSk7XFxuICAgIGNhc2UgJyc6XFxuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihzICsgJ3JldHVybiAnICsgc3RyaW5naWZ5KHIpKTtcXG4gICAgZGVmYXVsdDpcXG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdHJywgcyArIHByb3BuYW1lKG9wdC5nbG9iYWwsICdHJykgKyAnID0gJyArIHN0cmluZ2lmeShyKSk7XFxuICB9XFxufTtcXG5cXG5cXG5yZXR1cm4gTWVzc2FnZUZvcm1hdDtcXG59KCkpO1xcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXFxuXFxuXFxudmFyIGNyZWF0ZUVycm9yUGx1cmFsTW9kdWxlUHJlc2VuY2UgPSBmdW5jdGlvbigpIHtcXG5cXHRyZXR1cm4gY3JlYXRlRXJyb3IoIFxcXCJFX01JU1NJTkdfUExVUkFMX01PRFVMRVxcXCIsIFxcXCJQbHVyYWwgbW9kdWxlIG5vdCBsb2FkZWQuXFxcIiApO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIHZhbGlkYXRlTWVzc2FnZUJ1bmRsZSA9IGZ1bmN0aW9uKCBjbGRyICkge1xcblxcdHZhbGlkYXRlKFxcblxcdFxcdFxcXCJFX01JU1NJTkdfTUVTU0FHRV9CVU5ETEVcXFwiLFxcblxcdFxcdFxcXCJNaXNzaW5nIG1lc3NhZ2UgYnVuZGxlIGZvciBsb2NhbGUgYHtsb2NhbGV9YC5cXFwiLFxcblxcdFxcdGNsZHIuYXR0cmlidXRlcy5idW5kbGUgJiYgY2xkci5nZXQoIFxcXCJnbG9iYWxpemUtbWVzc2FnZXMve2J1bmRsZX1cXFwiICkgIT09IHVuZGVmaW5lZCxcXG5cXHRcXHR7XFxuXFx0XFx0XFx0bG9jYWxlOiBjbGRyLmxvY2FsZVxcblxcdFxcdH1cXG5cXHQpO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIHZhbGlkYXRlTWVzc2FnZVByZXNlbmNlID0gZnVuY3Rpb24oIHBhdGgsIHZhbHVlICkge1xcblxcdHBhdGggPSBwYXRoLmpvaW4oIFxcXCIvXFxcIiApO1xcblxcdHZhbGlkYXRlKCBcXFwiRV9NSVNTSU5HX01FU1NBR0VcXFwiLCBcXFwiTWlzc2luZyByZXF1aXJlZCBtZXNzYWdlIGNvbnRlbnQgYHtwYXRofWAuXFxcIixcXG5cXHRcXHR2YWx1ZSAhPT0gdW5kZWZpbmVkLCB7IHBhdGg6IHBhdGggfSApO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIHZhbGlkYXRlTWVzc2FnZVR5cGUgPSBmdW5jdGlvbiggcGF0aCwgdmFsdWUgKSB7XFxuXFx0cGF0aCA9IHBhdGguam9pbiggXFxcIi9cXFwiICk7XFxuXFx0dmFsaWRhdGUoXFxuXFx0XFx0XFxcIkVfSU5WQUxJRF9NRVNTQUdFXFxcIixcXG5cXHRcXHRcXFwiSW52YWxpZCBtZXNzYWdlIGNvbnRlbnQgYHtwYXRofWAuIHtleHBlY3RlZH0gZXhwZWN0ZWQuXFxcIixcXG5cXHRcXHR0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiLFxcblxcdFxcdHtcXG5cXHRcXHRcXHRleHBlY3RlZDogXFxcImEgc3RyaW5nXFxcIixcXG5cXHRcXHRcXHRwYXRoOiBwYXRoXFxuXFx0XFx0fVxcblxcdCk7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJUeXBlTWVzc2FnZVZhcmlhYmxlcyA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXFxuXFx0XFx0dmFsdWUsXFxuXFx0XFx0bmFtZSxcXG5cXHRcXHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzUGxhaW5PYmplY3QoIHZhbHVlICkgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKSxcXG5cXHRcXHRcXFwiQXJyYXkgb3IgUGxhaW4gT2JqZWN0XFxcIlxcblxcdCk7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgbWVzc2FnZUZvcm1hdHRlckZuID0gZnVuY3Rpb24oIGZvcm1hdHRlciApIHtcXG5cXHRyZXR1cm4gZnVuY3Rpb24gbWVzc2FnZUZvcm1hdHRlciggdmFyaWFibGVzICkge1xcblxcdFxcdGlmICggdHlwZW9mIHZhcmlhYmxlcyA9PT0gXFxcIm51bWJlclxcXCIgfHwgdHlwZW9mIHZhcmlhYmxlcyA9PT0gXFxcInN0cmluZ1xcXCIgKSB7XFxuXFx0XFx0XFx0dmFyaWFibGVzID0gW10uc2xpY2UuY2FsbCggYXJndW1lbnRzLCAwICk7XFxuXFx0XFx0fVxcblxcdFxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU1lc3NhZ2VWYXJpYWJsZXMoIHZhcmlhYmxlcywgXFxcInZhcmlhYmxlc1xcXCIgKTtcXG5cXHRcXHRyZXR1cm4gZm9ybWF0dGVyKCB2YXJpYWJsZXMgKTtcXG5cXHR9O1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIG1lc3NhZ2VGb3JtYXR0ZXJSdW50aW1lQmluZCA9IGZ1bmN0aW9uKCBjbGRyLCBtZXNzYWdlZm9ybWF0dGVyICkge1xcblxcdHZhciBsb2NhbGUgPSBjbGRyLmxvY2FsZSxcXG5cXHRcXHRvcmlnVG9TdHJpbmcgPSBtZXNzYWdlZm9ybWF0dGVyLnRvU3RyaW5nO1xcblxcblxcdG1lc3NhZ2Vmb3JtYXR0ZXIudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHR2YXIgYXJnTmFtZXMsIGFyZ1ZhbHVlcywgb3V0cHV0LFxcblxcdFxcdFxcdGFyZ3MgPSB7fTtcXG5cXG5cXHRcXHQvLyBQcm9wZXJseSBhZGp1c3QgU2xleEF4dG9uL21lc3NhZ2Vmb3JtYXQuanMgY29tcGlsZWQgdmFyaWFibGVzIHdpdGggR2xvYmFsaXplIHZhcmlhYmxlczpcXG5cXHRcXHRvdXRwdXQgPSBvcmlnVG9TdHJpbmcuY2FsbCggbWVzc2FnZWZvcm1hdHRlciApO1xcblxcblxcdFxcdGlmICggL251bWJlclxcXFwoLy50ZXN0KCBvdXRwdXQgKSApIHtcXG5cXHRcXHRcXHRhcmdzLm51bWJlciA9IFxcXCJtZXNzYWdlRm9ybWF0Lm51bWJlclxcXCI7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggL3BsdXJhbFxcXFwoLy50ZXN0KCBvdXRwdXQgKSApIHtcXG5cXHRcXHRcXHRhcmdzLnBsdXJhbCA9IFxcXCJtZXNzYWdlRm9ybWF0LnBsdXJhbFxcXCI7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggL3NlbGVjdFxcXFwoLy50ZXN0KCBvdXRwdXQgKSApIHtcXG5cXHRcXHRcXHRhcmdzLnNlbGVjdCA9IFxcXCJtZXNzYWdlRm9ybWF0LnNlbGVjdFxcXCI7XFxuXFx0XFx0fVxcblxcblxcdFxcdG91dHB1dC5yZXBsYWNlKCAvcGx1cmFsRnVuY3MoXFxcXFsoW15cXFxcXV0rKVxcXFxdfFxcXFwuKFthLXpBLVpdKykpLywgZnVuY3Rpb24oIG1hdGNoICkge1xcblxcdFxcdFxcdGFyZ3MucGx1cmFsRnVuY3MgPSBcXFwie1xcXCIgK1xcblxcdFxcdFxcdFxcdFxcXCJcXFxcXFxcIlxcXCIgKyBsb2NhbGUgKyBcXFwiXFxcXFxcXCI6IEdsb2JhbGl6ZShcXFxcXFxcIlxcXCIgKyBsb2NhbGUgKyBcXFwiXFxcXFxcXCIpLnBsdXJhbEdlbmVyYXRvcigpXFxcIiArXFxuXFx0XFx0XFx0XFx0XFxcIn1cXFwiO1xcblxcdFxcdFxcdHJldHVybiBtYXRjaDtcXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHRhcmdOYW1lcyA9IE9iamVjdC5rZXlzKCBhcmdzICkuam9pbiggXFxcIiwgXFxcIiApO1xcblxcdFxcdGFyZ1ZhbHVlcyA9IE9iamVjdC5rZXlzKCBhcmdzICkubWFwKGZ1bmN0aW9uKCBrZXkgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGFyZ3NbIGtleSBdO1xcblxcdFxcdH0pLmpvaW4oIFxcXCIsIFxcXCIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gXFxcIihmdW5jdGlvbiggXFxcIiArIGFyZ05hbWVzICsgXFxcIiApIHtcXFxcblxcXCIgK1xcblxcdFxcdFxcdFxcXCIgIHJldHVybiBcXFwiICsgb3V0cHV0ICsgXFxcIlxcXFxuXFxcIiArXFxuXFx0XFx0XFx0XFxcIn0pKFxcXCIgKyBhcmdWYWx1ZXMgKyBcXFwiKVxcXCI7XFxuXFx0fTtcXG5cXG5cXHRyZXR1cm4gbWVzc2FnZWZvcm1hdHRlcjtcXG59O1xcblxcblxcblxcblxcbnZhciBzbGljZSA9IFtdLnNsaWNlO1xcblxcbi8qKlxcbiAqIC5sb2FkTWVzc2FnZXMoIGpzb24gKVxcbiAqXFxuICogQGpzb24gW0pTT05dXFxuICpcXG4gKiBMb2FkIHRyYW5zbGF0aW9uIGRhdGEuXFxuICovXFxuR2xvYmFsaXplLmxvYWRNZXNzYWdlcyA9IGZ1bmN0aW9uKCBqc29uICkge1xcblxcdHZhciBsb2NhbGUsXFxuXFx0XFx0Y3VzdG9tRGF0YSA9IHtcXG5cXHRcXHRcXHRcXFwiZ2xvYmFsaXplLW1lc3NhZ2VzXFxcIjoganNvbixcXG5cXHRcXHRcXHRcXFwibWFpblxcXCI6IHt9XFxuXFx0XFx0fTtcXG5cXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCBqc29uLCBcXFwianNvblxcXCIgKTtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCgganNvbiwgXFxcImpzb25cXFwiICk7XFxuXFxuXFx0Ly8gU2V0IGF2YWlsYWJsZSBidW5kbGVzIGJ5IHBvcHVsYXRpbmcgY3VzdG9tRGF0YSBtYWluIGRhdGFzZXQuXFxuXFx0Zm9yICggbG9jYWxlIGluIGpzb24gKSB7XFxuXFx0XFx0aWYgKCBqc29uLmhhc093blByb3BlcnR5KCBsb2NhbGUgKSApIHtcXG5cXHRcXHRcXHRjdXN0b21EYXRhLm1haW5bIGxvY2FsZSBdID0ge307XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRDbGRyLmxvYWQoIGN1c3RvbURhdGEgKTtcXG59O1xcblxcbi8qKlxcbiAqIC5tZXNzYWdlRm9ybWF0dGVyKCBwYXRoIClcXG4gKlxcbiAqIEBwYXRoIFtTdHJpbmcgb3IgQXJyYXldXFxuICpcXG4gKiBGb3JtYXQgYSBtZXNzYWdlIGdpdmVuIGl0cyBwYXRoLlxcbiAqL1xcbkdsb2JhbGl6ZS5tZXNzYWdlRm9ybWF0dGVyID1cXG5HbG9iYWxpemUucHJvdG90eXBlLm1lc3NhZ2VGb3JtYXR0ZXIgPSBmdW5jdGlvbiggcGF0aCApIHtcXG5cXHR2YXIgY2xkciwgZm9ybWF0dGVyLCBtZXNzYWdlLCBwbHVyYWxHZW5lcmF0b3IsIHJldHVybkZuLFxcblxcdFxcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKTtcXG5cXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCBwYXRoLCBcXFwicGF0aFxcXCIgKTtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoIHBhdGgsIFxcXCJwYXRoXFxcIiwgdHlwZW9mIHBhdGggPT09IFxcXCJzdHJpbmdcXFwiIHx8IEFycmF5LmlzQXJyYXkoIHBhdGggKSxcXG5cXHRcXHRcXFwiYSBTdHJpbmcgbm9yIGFuIEFycmF5XFxcIiApO1xcblxcblxcdHBhdGggPSBhbHdheXNBcnJheSggcGF0aCApO1xcblxcdGNsZHIgPSB0aGlzLmNsZHI7XFxuXFxuXFx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XFxuXFx0dmFsaWRhdGVNZXNzYWdlQnVuZGxlKCBjbGRyICk7XFxuXFxuXFx0bWVzc2FnZSA9IGNsZHIuZ2V0KCBbIFxcXCJnbG9iYWxpemUtbWVzc2FnZXMve2J1bmRsZX1cXFwiIF0uY29uY2F0KCBwYXRoICkgKTtcXG5cXHR2YWxpZGF0ZU1lc3NhZ2VQcmVzZW5jZSggcGF0aCwgbWVzc2FnZSApO1xcblxcblxcdC8vIElmIG1lc3NhZ2UgaXMgYW4gQXJyYXksIGNvbmNhdGVuYXRlIGl0LlxcblxcdGlmICggQXJyYXkuaXNBcnJheSggbWVzc2FnZSApICkge1xcblxcdFxcdG1lc3NhZ2UgPSBtZXNzYWdlLmpvaW4oIFxcXCIgXFxcIiApO1xcblxcdH1cXG5cXHR2YWxpZGF0ZU1lc3NhZ2VUeXBlKCBwYXRoLCBtZXNzYWdlICk7XFxuXFxuXFx0Ly8gSXMgcGx1cmFsIG1vZHVsZSBwcmVzZW50PyBZZXMsIHVzZSBpdHMgZ2VuZXJhdG9yLiBOb3BlLCB1c2UgYW4gZXJyb3IgZ2VuZXJhdG9yLlxcblxcdHBsdXJhbEdlbmVyYXRvciA9IHRoaXMucGx1cmFsICE9PSB1bmRlZmluZWQgP1xcblxcdFxcdHRoaXMucGx1cmFsR2VuZXJhdG9yKCkgOlxcblxcdFxcdGNyZWF0ZUVycm9yUGx1cmFsTW9kdWxlUHJlc2VuY2U7XFxuXFxuXFx0Zm9ybWF0dGVyID0gbmV3IE1lc3NhZ2VGb3JtYXQoIGNsZHIubG9jYWxlLCBwbHVyYWxHZW5lcmF0b3IgKS5jb21waWxlKCBtZXNzYWdlICk7XFxuXFxuXFx0cmV0dXJuRm4gPSBtZXNzYWdlRm9ybWF0dGVyRm4oIGZvcm1hdHRlciApO1xcblxcblxcdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbixcXG5cXHRcXHRbIG1lc3NhZ2VGb3JtYXR0ZXJSdW50aW1lQmluZCggY2xkciwgZm9ybWF0dGVyICksIHBsdXJhbEdlbmVyYXRvciBdICk7XFxuXFxuXFx0cmV0dXJuIHJldHVybkZuO1xcbn07XFxuXFxuLyoqXFxuICogLmZvcm1hdE1lc3NhZ2UoIHBhdGggWywgdmFyaWFibGVzXSApXFxuICpcXG4gKiBAcGF0aCBbU3RyaW5nIG9yIEFycmF5XVxcbiAqXFxuICogQHZhcmlhYmxlcyBbTnVtYmVyLCBTdHJpbmcsIEFycmF5IG9yIE9iamVjdF1cXG4gKlxcbiAqIEZvcm1hdCBhIG1lc3NhZ2UgZ2l2ZW4gaXRzIHBhdGguXFxuICovXFxuR2xvYmFsaXplLmZvcm1hdE1lc3NhZ2UgPVxcbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0TWVzc2FnZSA9IGZ1bmN0aW9uKCBwYXRoIC8qICwgdmFyaWFibGVzICovICkge1xcblxcdHJldHVybiB0aGlzLm1lc3NhZ2VGb3JtYXR0ZXIoIHBhdGggKS5hcHBseSgge30sIHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApICk7XFxufTtcXG5cXG5yZXR1cm4gR2xvYmFsaXplO1xcblxcblxcblxcblxcbn0pKTtcXG5cIiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(31))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3BsdXJhbC5qcz8xNzg2Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcZ2xvYmFsaXplXFxcXGRpc3RcXFxcZ2xvYmFsaXplXFxcXHBsdXJhbC5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n")},function(module,exports){eval("module.exports = \"/**\\n * Globalize v1.5.0\\n *\\n * http://github.com/jquery/globalize\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2020-03-25T12:19Z\\n */\\n/*!\\n * Globalize v1.5.0 2020-03-25T12:19Z Released under the MIT license\\n * http://git.io/TrdQbw\\n */\\n(function( root, factory ) {\\n\\n\\t// UMD returnExports\\n\\tif ( typeof define === \\\"function\\\" && define.amd ) {\\n\\n\\t\\t// AMD\\n\\t\\tdefine([\\n\\t\\t\\t\\\"cldr\\\",\\n\\t\\t\\t\\\"../globalize\\\",\\n\\t\\t\\t\\\"cldr/event\\\",\\n\\t\\t\\t\\\"cldr/supplemental\\\"\\n\\t\\t], factory );\\n\\t} else if ( typeof exports === \\\"object\\\" ) {\\n\\n\\t\\t// Node, CommonJS\\n\\t\\tmodule.exports = factory( require( \\\"cldrjs\\\" ), require( \\\"../globalize\\\" ) );\\n\\t} else {\\n\\n\\t\\t// Global\\n\\t\\tfactory( root.Cldr, root.Globalize );\\n\\t}\\n}(this, function( Cldr, Globalize ) {\\n\\nvar runtimeBind = Globalize._runtimeBind,\\n\\tvalidateCldr = Globalize._validateCldr,\\n\\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\\n\\tvalidateParameterPresence = Globalize._validateParameterPresence,\\n\\tvalidateParameterType = Globalize._validateParameterType,\\n\\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;\\nvar MakePlural;\\n/* jshint ignore:start */\\nMakePlural = (function() {\\n'use strict';\\n\\nvar _toArray = function (arr) { return Array.isArray(arr) ? arr : Array.from(arr); };\\n\\nvar _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };\\n\\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };\\n\\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\\n\\n\\n/**\\n * make-plural.js -- https://github.com/eemeli/make-plural.js/\\n * Copyright (c) 2014-2015 by Eemeli Aro <eemeli@gmail.com>\\n *\\n * Permission to use, copy, modify, and/or distribute this software for any\\n * purpose with or without fee is hereby granted, provided that the above\\n * copyright notice and this permission notice appear in all copies.\\n *\\n * The software is provided \\\"as is\\\" and the author disclaims all warranties\\n * with regard to this software including all implied warranties of\\n * merchantability and fitness. In no event shall the author be liable for\\n * any special, direct, indirect, or consequential damages or any damages\\n * whatsoever resulting from loss of use, data or profits, whether in an\\n * action of contract, negligence or other tortious action, arising out of\\n * or in connection with the use or performance of this software.\\n */\\n\\nvar Parser = (function () {\\n    function Parser() {\\n        _classCallCheck(this, Parser);\\n    }\\n\\n    _createClass(Parser, [{\\n        key: 'parse',\\n        value: function parse(cond) {\\n            var _this = this;\\n\\n            if (cond === 'i = 0 or n = 1') {\\n                return 'n >= 0 && n <= 1';\\n            }if (cond === 'i = 0,1') {\\n                return 'n >= 0 && n < 2';\\n            }if (cond === 'i = 1 and v = 0') {\\n                this.v0 = 1;\\n                return 'n == 1 && v0';\\n            }\\n            return cond.replace(/([tv]) (!?)= 0/g, function (m, sym, noteq) {\\n                var sn = sym + '0';\\n                _this[sn] = 1;\\n                return noteq ? '!' + sn : sn;\\n            }).replace(/\\\\b[fintv]\\\\b/g, function (m) {\\n                _this[m] = 1;\\n                return m;\\n            }).replace(/([fin]) % (10+)/g, function (m, sym, num) {\\n                var sn = sym + num;\\n                _this[sn] = 1;\\n                return sn;\\n            }).replace(/n10+ = 0/g, 't0 && $&').replace(/(\\\\w+ (!?)= )([0-9.]+,[0-9.,]+)/g, function (m, se, noteq, x) {\\n                if (m === 'n = 0,1') return '(n == 0 || n == 1)';\\n                if (noteq) return se + x.split(',').join(' && ' + se);\\n                return '(' + se + x.split(',').join(' || ' + se) + ')';\\n            }).replace(/(\\\\w+) (!?)= ([0-9]+)\\\\.\\\\.([0-9]+)/g, function (m, sym, noteq, x0, x1) {\\n                if (Number(x0) + 1 === Number(x1)) {\\n                    if (noteq) return '' + sym + ' != ' + x0 + ' && ' + sym + ' != ' + x1;\\n                    return '(' + sym + ' == ' + x0 + ' || ' + sym + ' == ' + x1 + ')';\\n                }\\n                if (noteq) return '(' + sym + ' < ' + x0 + ' || ' + sym + ' > ' + x1 + ')';\\n                if (sym === 'n') {\\n                    _this.t0 = 1;return '(t0 && n >= ' + x0 + ' && n <= ' + x1 + ')';\\n                }\\n                return '(' + sym + ' >= ' + x0 + ' && ' + sym + ' <= ' + x1 + ')';\\n            }).replace(/ and /g, ' && ').replace(/ or /g, ' || ').replace(/ = /g, ' == ');\\n        }\\n    }, {\\n        key: 'vars',\\n        value: (function (_vars) {\\n            function vars() {\\n                return _vars.apply(this, arguments);\\n            }\\n\\n            vars.toString = function () {\\n                return _vars.toString();\\n            };\\n\\n            return vars;\\n        })(function () {\\n            var vars = [];\\n            if (this.i) vars.push('i = s[0]');\\n            if (this.f || this.v) vars.push('f = s[1] || \\\\'\\\\'');\\n            if (this.t) vars.push('t = (s[1] || \\\\'\\\\').replace(/0+$/, \\\\'\\\\')');\\n            if (this.v) vars.push('v = f.length');\\n            if (this.v0) vars.push('v0 = !s[1]');\\n            if (this.t0 || this.n10 || this.n100) vars.push('t0 = Number(s[0]) == n');\\n            for (var k in this) {\\n                if (/^.10+$/.test(k)) {\\n                    var k0 = k[0] === 'n' ? 't0 && s[0]' : k[0];\\n                    vars.push('' + k + ' = ' + k0 + '.slice(-' + k.substr(2).length + ')');\\n                }\\n            }if (!vars.length) return '';\\n            return 'var ' + ['s = String(n).split(\\\\'.\\\\')'].concat(vars).join(', ');\\n        })\\n    }]);\\n\\n    return Parser;\\n})();\\n\\n\\n\\nvar MakePlural = (function () {\\n    function MakePlural(lc) {\\n        var _ref = arguments[1] === undefined ? MakePlural : arguments[1];\\n\\n        var cardinals = _ref.cardinals;\\n        var ordinals = _ref.ordinals;\\n\\n        _classCallCheck(this, MakePlural);\\n\\n        if (!cardinals && !ordinals) throw new Error('At least one type of plural is required');\\n        this.lc = lc;\\n        this.categories = { cardinal: [], ordinal: [] };\\n        this.parser = new Parser();\\n        \\n        this.fn = this.buildFunction(cardinals, ordinals);\\n        this.fn._obj = this;\\n        this.fn.categories = this.categories;\\n        \\n        this.fn.toString = this.fnToString.bind(this);\\n        return this.fn;\\n    }\\n\\n    _createClass(MakePlural, [{\\n        key: 'compile',\\n        value: function compile(type, req) {\\n            var cases = [];\\n            var rules = MakePlural.rules[type][this.lc];\\n            if (!rules) {\\n                if (req) throw new Error('Locale \\\"' + this.lc + '\\\" ' + type + ' rules not found');\\n                this.categories[type] = ['other'];\\n                return '\\\\'other\\\\'';\\n            }\\n            for (var r in rules) {\\n                var _rules$r$trim$split = rules[r].trim().split(/\\\\s*@\\\\w*/);\\n\\n                var _rules$r$trim$split2 = _toArray(_rules$r$trim$split);\\n\\n                var cond = _rules$r$trim$split2[0];\\n                var examples = _rules$r$trim$split2.slice(1);\\n                var cat = r.replace('pluralRule-count-', '');\\n                if (cond) cases.push([this.parser.parse(cond), cat]);\\n                \\n            }\\n            this.categories[type] = cases.map(function (c) {\\n                return c[1];\\n            }).concat('other');\\n            if (cases.length === 1) {\\n                return '(' + cases[0][0] + ') ? \\\\'' + cases[0][1] + '\\\\' : \\\\'other\\\\'';\\n            } else {\\n                return [].concat(_toConsumableArray(cases.map(function (c) {\\n                    return '(' + c[0] + ') ? \\\\'' + c[1] + '\\\\'';\\n                })), ['\\\\'other\\\\'']).join('\\\\n      : ');\\n            }\\n        }\\n    }, {\\n        key: 'buildFunction',\\n        value: function buildFunction(cardinals, ordinals) {\\n            var _this3 = this;\\n\\n            var compile = function compile(c) {\\n                return c ? (c[1] ? 'return ' : 'if (ord) return ') + _this3.compile.apply(_this3, _toConsumableArray(c)) : '';\\n            },\\n                fold = { vars: function vars(str) {\\n                    return ('  ' + str + ';').replace(/(.{1,78})(,|$) ?/g, '$1$2\\\\n      ');\\n                },\\n                cond: function cond(str) {\\n                    return ('  ' + str + ';').replace(/(.{1,78}) (\\\\|\\\\| |$) ?/gm, '$1\\\\n          $2');\\n                } },\\n                cond = [ordinals && ['ordinal', !cardinals], cardinals && ['cardinal', true]].map(compile).map(fold.cond),\\n                body = [fold.vars(this.parser.vars())].concat(_toConsumableArray(cond)).join('\\\\n').replace(/\\\\s+$/gm, '').replace(/^[\\\\s;]*[\\\\r\\\\n]+/gm, ''),\\n                args = ordinals && cardinals ? 'n, ord' : 'n';\\n            return new Function(args, body);\\n        }\\n    }, {\\n        key: 'fnToString',\\n        value: function fnToString(name) {\\n            return Function.prototype.toString.call(this.fn).replace(/^function( \\\\w+)?/, name ? 'function ' + name : 'function').replace('\\\\n/**/', '');\\n        }\\n    }], [{\\n        key: 'load',\\n        value: function load() {\\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n                args[_key] = arguments[_key];\\n            }\\n\\n            args.forEach(function (cldr) {\\n                var data = cldr && cldr.supplemental || null;\\n                if (!data) throw new Error('Data does not appear to be CLDR data');\\n                MakePlural.rules = {\\n                    cardinal: data['plurals-type-cardinal'] || MakePlural.rules.cardinal,\\n                    ordinal: data['plurals-type-ordinal'] || MakePlural.rules.ordinal\\n                };\\n            });\\n            return MakePlural;\\n        }\\n    }]);\\n\\n    return MakePlural;\\n})();\\n\\n\\n\\nMakePlural.cardinals = true;\\nMakePlural.ordinals = false;\\nMakePlural.rules = { cardinal: {}, ordinal: {} };\\n\\n\\nreturn MakePlural;\\n}());\\n/* jshint ignore:end */\\n\\n\\nvar validateParameterTypeNumber = function( value, name ) {\\n\\tvalidateParameterType(\\n\\t\\tvalue,\\n\\t\\tname,\\n\\t\\tvalue === undefined || typeof value === \\\"number\\\",\\n\\t\\t\\\"Number\\\"\\n\\t);\\n};\\n\\n\\n\\n\\nvar validateParameterTypePluralType = function( value, name ) {\\n\\tvalidateParameterType(\\n\\t\\tvalue,\\n\\t\\tname,\\n\\t\\tvalue === undefined || value === \\\"cardinal\\\" || value === \\\"ordinal\\\",\\n\\t\\t\\\"String \\\\\\\"cardinal\\\\\\\" or \\\\\\\"ordinal\\\\\\\"\\\"\\n\\t);\\n};\\n\\n\\n\\n\\nvar pluralGeneratorFn = function( plural ) {\\n\\treturn function pluralGenerator( value ) {\\n\\t\\tvalidateParameterPresence( value, \\\"value\\\" );\\n\\t\\tvalidateParameterTypeNumber( value, \\\"value\\\" );\\n\\n\\t\\treturn plural( value );\\n\\t};\\n};\\n\\n\\n\\n\\n/**\\n * .plural( value )\\n *\\n * @value [Number]\\n *\\n * Return the corresponding form (zero | one | two | few | many | other) of a\\n * value given locale.\\n */\\nGlobalize.plural =\\nGlobalize.prototype.plural = function( value, options ) {\\n\\tvalidateParameterPresence( value, \\\"value\\\" );\\n\\tvalidateParameterTypeNumber( value, \\\"value\\\" );\\n\\treturn this.pluralGenerator( options )( value );\\n};\\n\\n/**\\n * .pluralGenerator( [options] )\\n *\\n * Return a plural function (of the form below).\\n *\\n * fn( value )\\n *\\n * @value [Number]\\n *\\n * Return the corresponding form (zero | one | two | few | many | other) of a value given the\\n * default/instance locale.\\n */\\nGlobalize.pluralGenerator =\\nGlobalize.prototype.pluralGenerator = function( options ) {\\n\\tvar args, cldr, isOrdinal, plural, returnFn, type;\\n\\n\\tvalidateParameterTypePlainObject( options, \\\"options\\\" );\\n\\n\\toptions = options || {};\\n\\tcldr = this.cldr;\\n\\n\\targs = [ options ];\\n\\ttype = options.type || \\\"cardinal\\\";\\n\\n\\tvalidateParameterTypePluralType( options.type, \\\"options.type\\\" );\\n\\n\\tvalidateDefaultLocale( cldr );\\n\\n\\tisOrdinal = type === \\\"ordinal\\\";\\n\\n\\tcldr.on( \\\"get\\\", validateCldr );\\n\\ttry {\\n\\t\\tcldr.supplemental([ \\\"plurals-type-\\\" + type, \\\"{language}\\\" ]);\\n\\t} finally {\\n\\t\\tcldr.off( \\\"get\\\", validateCldr );\\n\\t}\\n\\n\\tMakePlural.rules = {};\\n\\tMakePlural.rules[ type ] = cldr.supplemental( \\\"plurals-type-\\\" + type );\\n\\n\\tplural = new MakePlural( cldr.attributes.language, {\\n\\t\\t\\\"ordinals\\\": isOrdinal,\\n\\t\\t\\\"cardinals\\\": !isOrdinal\\n\\t});\\n\\n\\treturnFn = pluralGeneratorFn( plural );\\n\\n\\truntimeBind( args, cldr, returnFn, [ plural ] );\\n\\n\\treturn returnFn;\\n};\\n\\nreturn Globalize;\\n\\n\\n\\n\\n}));\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3BsdXJhbC5qcz9jNGJjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKipcXG4gKiBHbG9iYWxpemUgdjEuNS4wXFxuICpcXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXFxuICpcXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIERhdGU6IDIwMjAtMDMtMjVUMTI6MTlaXFxuICovXFxuLyohXFxuICogR2xvYmFsaXplIHYxLjUuMCAyMDIwLTAzLTI1VDEyOjE5WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xcbiAqL1xcbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcXG5cXG5cXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xcblxcdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBkZWZpbmUuYW1kICkge1xcblxcblxcdFxcdC8vIEFNRFxcblxcdFxcdGRlZmluZShbXFxuXFx0XFx0XFx0XFxcImNsZHJcXFwiLFxcblxcdFxcdFxcdFxcXCIuLi9nbG9iYWxpemVcXFwiLFxcblxcdFxcdFxcdFxcXCJjbGRyL2V2ZW50XFxcIixcXG5cXHRcXHRcXHRcXFwiY2xkci9zdXBwbGVtZW50YWxcXFwiXFxuXFx0XFx0XSwgZmFjdG9yeSApO1xcblxcdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcXFwib2JqZWN0XFxcIiApIHtcXG5cXG5cXHRcXHQvLyBOb2RlLCBDb21tb25KU1xcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXFxcImNsZHJqc1xcXCIgKSwgcmVxdWlyZSggXFxcIi4uL2dsb2JhbGl6ZVxcXCIgKSApO1xcblxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0Ly8gR2xvYmFsXFxuXFx0XFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xcblxcdH1cXG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XFxuXFxudmFyIHJ1bnRpbWVCaW5kID0gR2xvYmFsaXplLl9ydW50aW1lQmluZCxcXG5cXHR2YWxpZGF0ZUNsZHIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlQ2xkcixcXG5cXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlRGVmYXVsdExvY2FsZSxcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlLFxcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlLFxcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdDtcXG52YXIgTWFrZVBsdXJhbDtcXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXFxuTWFrZVBsdXJhbCA9IChmdW5jdGlvbigpIHtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIF90b0FycmF5ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpID8gYXJyIDogQXJyYXkuZnJvbShhcnIpOyB9O1xcblxcbnZhciBfdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfTtcXG5cXG52YXIgX2NsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9O1xcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XFxuXFxuXFxuLyoqXFxuICogbWFrZS1wbHVyYWwuanMgLS0gaHR0cHM6Ly9naXRodWIuY29tL2VlbWVsaS9tYWtlLXBsdXJhbC5qcy9cXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSBieSBFZW1lbGkgQXJvIDxlZW1lbGlAZ21haWwuY29tPlxcbiAqXFxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XFxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXFxuICpcXG4gKiBUaGUgc29mdHdhcmUgaXMgcHJvdmlkZWQgXFxcImFzIGlzXFxcIiBhbmQgdGhlIGF1dGhvciBkaXNjbGFpbXMgYWxsIHdhcnJhbnRpZXNcXG4gKiB3aXRoIHJlZ2FyZCB0byB0aGlzIHNvZnR3YXJlIGluY2x1ZGluZyBhbGwgaW1wbGllZCB3YXJyYW50aWVzIG9mXFxuICogbWVyY2hhbnRhYmlsaXR5IGFuZCBmaXRuZXNzLiBJbiBubyBldmVudCBzaGFsbCB0aGUgYXV0aG9yIGJlIGxpYWJsZSBmb3JcXG4gKiBhbnkgc3BlY2lhbCwgZGlyZWN0LCBpbmRpcmVjdCwgb3IgY29uc2VxdWVudGlhbCBkYW1hZ2VzIG9yIGFueSBkYW1hZ2VzXFxuICogd2hhdHNvZXZlciByZXN1bHRpbmcgZnJvbSBsb3NzIG9mIHVzZSwgZGF0YSBvciBwcm9maXRzLCB3aGV0aGVyIGluIGFuXFxuICogYWN0aW9uIG9mIGNvbnRyYWN0LCBuZWdsaWdlbmNlIG9yIG90aGVyIHRvcnRpb3VzIGFjdGlvbiwgYXJpc2luZyBvdXQgb2ZcXG4gKiBvciBpbiBjb25uZWN0aW9uIHdpdGggdGhlIHVzZSBvciBwZXJmb3JtYW5jZSBvZiB0aGlzIHNvZnR3YXJlLlxcbiAqL1xcblxcbnZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBQYXJzZXIoKSB7XFxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2VyKTtcXG4gICAgfVxcblxcbiAgICBfY3JlYXRlQ2xhc3MoUGFyc2VyLCBbe1xcbiAgICAgICAga2V5OiAncGFyc2UnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGNvbmQpIHtcXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgICAgICAgIGlmIChjb25kID09PSAnaSA9IDAgb3IgbiA9IDEnKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAnbiA+PSAwICYmIG4gPD0gMSc7XFxuICAgICAgICAgICAgfWlmIChjb25kID09PSAnaSA9IDAsMScpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuICduID49IDAgJiYgbiA8IDInO1xcbiAgICAgICAgICAgIH1pZiAoY29uZCA9PT0gJ2kgPSAxIGFuZCB2ID0gMCcpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy52MCA9IDE7XFxuICAgICAgICAgICAgICAgIHJldHVybiAnbiA9PSAxICYmIHYwJztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGNvbmQucmVwbGFjZSgvKFt0dl0pICghPyk9IDAvZywgZnVuY3Rpb24gKG0sIHN5bSwgbm90ZXEpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHNuID0gc3ltICsgJzAnO1xcbiAgICAgICAgICAgICAgICBfdGhpc1tzbl0gPSAxO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90ZXEgPyAnIScgKyBzbiA6IHNuO1xcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxiW2ZpbnR2XVxcXFxiL2csIGZ1bmN0aW9uIChtKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzW21dID0gMTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XFxuICAgICAgICAgICAgfSkucmVwbGFjZSgvKFtmaW5dKSAlICgxMCspL2csIGZ1bmN0aW9uIChtLCBzeW0sIG51bSkge1xcbiAgICAgICAgICAgICAgICB2YXIgc24gPSBzeW0gKyBudW07XFxuICAgICAgICAgICAgICAgIF90aGlzW3NuXSA9IDE7XFxuICAgICAgICAgICAgICAgIHJldHVybiBzbjtcXG4gICAgICAgICAgICB9KS5yZXBsYWNlKC9uMTArID0gMC9nLCAndDAgJiYgJCYnKS5yZXBsYWNlKC8oXFxcXHcrICghPyk9ICkoWzAtOS5dKyxbMC05LixdKykvZywgZnVuY3Rpb24gKG0sIHNlLCBub3RlcSwgeCkge1xcbiAgICAgICAgICAgICAgICBpZiAobSA9PT0gJ24gPSAwLDEnKSByZXR1cm4gJyhuID09IDAgfHwgbiA9PSAxKSc7XFxuICAgICAgICAgICAgICAgIGlmIChub3RlcSkgcmV0dXJuIHNlICsgeC5zcGxpdCgnLCcpLmpvaW4oJyAmJiAnICsgc2UpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJygnICsgc2UgKyB4LnNwbGl0KCcsJykuam9pbignIHx8ICcgKyBzZSkgKyAnKSc7XFxuICAgICAgICAgICAgfSkucmVwbGFjZSgvKFxcXFx3KykgKCE/KT0gKFswLTldKylcXFxcLlxcXFwuKFswLTldKykvZywgZnVuY3Rpb24gKG0sIHN5bSwgbm90ZXEsIHgwLCB4MSkge1xcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyKHgwKSArIDEgPT09IE51bWJlcih4MSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChub3RlcSkgcmV0dXJuICcnICsgc3ltICsgJyAhPSAnICsgeDAgKyAnICYmICcgKyBzeW0gKyAnICE9ICcgKyB4MTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnKCcgKyBzeW0gKyAnID09ICcgKyB4MCArICcgfHwgJyArIHN5bSArICcgPT0gJyArIHgxICsgJyknO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChub3RlcSkgcmV0dXJuICcoJyArIHN5bSArICcgPCAnICsgeDAgKyAnIHx8ICcgKyBzeW0gKyAnID4gJyArIHgxICsgJyknO1xcbiAgICAgICAgICAgICAgICBpZiAoc3ltID09PSAnbicpIHtcXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnQwID0gMTtyZXR1cm4gJyh0MCAmJiBuID49ICcgKyB4MCArICcgJiYgbiA8PSAnICsgeDEgKyAnKSc7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuICcoJyArIHN5bSArICcgPj0gJyArIHgwICsgJyAmJiAnICsgc3ltICsgJyA8PSAnICsgeDEgKyAnKSc7XFxuICAgICAgICAgICAgfSkucmVwbGFjZSgvIGFuZCAvZywgJyAmJiAnKS5yZXBsYWNlKC8gb3IgL2csICcgfHwgJykucmVwbGFjZSgvID0gL2csICcgPT0gJyk7XFxuICAgICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAgIGtleTogJ3ZhcnMnLFxcbiAgICAgICAgdmFsdWU6IChmdW5jdGlvbiAoX3ZhcnMpIHtcXG4gICAgICAgICAgICBmdW5jdGlvbiB2YXJzKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZhcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdmFycy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF92YXJzLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgICByZXR1cm4gdmFycztcXG4gICAgICAgIH0pKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgdmFycyA9IFtdO1xcbiAgICAgICAgICAgIGlmICh0aGlzLmkpIHZhcnMucHVzaCgnaSA9IHNbMF0nKTtcXG4gICAgICAgICAgICBpZiAodGhpcy5mIHx8IHRoaXMudikgdmFycy5wdXNoKCdmID0gc1sxXSB8fCBcXFxcJ1xcXFwnJyk7XFxuICAgICAgICAgICAgaWYgKHRoaXMudCkgdmFycy5wdXNoKCd0ID0gKHNbMV0gfHwgXFxcXCdcXFxcJykucmVwbGFjZSgvMCskLywgXFxcXCdcXFxcJyknKTtcXG4gICAgICAgICAgICBpZiAodGhpcy52KSB2YXJzLnB1c2goJ3YgPSBmLmxlbmd0aCcpO1xcbiAgICAgICAgICAgIGlmICh0aGlzLnYwKSB2YXJzLnB1c2goJ3YwID0gIXNbMV0nKTtcXG4gICAgICAgICAgICBpZiAodGhpcy50MCB8fCB0aGlzLm4xMCB8fCB0aGlzLm4xMDApIHZhcnMucHVzaCgndDAgPSBOdW1iZXIoc1swXSkgPT0gbicpO1xcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcykge1xcbiAgICAgICAgICAgICAgICBpZiAoL14uMTArJC8udGVzdChrKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGswID0ga1swXSA9PT0gJ24nID8gJ3QwICYmIHNbMF0nIDoga1swXTtcXG4gICAgICAgICAgICAgICAgICAgIHZhcnMucHVzaCgnJyArIGsgKyAnID0gJyArIGswICsgJy5zbGljZSgtJyArIGsuc3Vic3RyKDIpLmxlbmd0aCArICcpJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9aWYgKCF2YXJzLmxlbmd0aCkgcmV0dXJuICcnO1xcbiAgICAgICAgICAgIHJldHVybiAndmFyICcgKyBbJ3MgPSBTdHJpbmcobikuc3BsaXQoXFxcXCcuXFxcXCcpJ10uY29uY2F0KHZhcnMpLmpvaW4oJywgJyk7XFxuICAgICAgICB9KVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBQYXJzZXI7XFxufSkoKTtcXG5cXG5cXG5cXG52YXIgTWFrZVBsdXJhbCA9IChmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIE1ha2VQbHVyYWwobGMpIHtcXG4gICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBNYWtlUGx1cmFsIDogYXJndW1lbnRzWzFdO1xcblxcbiAgICAgICAgdmFyIGNhcmRpbmFscyA9IF9yZWYuY2FyZGluYWxzO1xcbiAgICAgICAgdmFyIG9yZGluYWxzID0gX3JlZi5vcmRpbmFscztcXG5cXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYWtlUGx1cmFsKTtcXG5cXG4gICAgICAgIGlmICghY2FyZGluYWxzICYmICFvcmRpbmFscykgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgdHlwZSBvZiBwbHVyYWwgaXMgcmVxdWlyZWQnKTtcXG4gICAgICAgIHRoaXMubGMgPSBsYztcXG4gICAgICAgIHRoaXMuY2F0ZWdvcmllcyA9IHsgY2FyZGluYWw6IFtdLCBvcmRpbmFsOiBbXSB9O1xcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgUGFyc2VyKCk7XFxuICAgICAgICBcXG4gICAgICAgIHRoaXMuZm4gPSB0aGlzLmJ1aWxkRnVuY3Rpb24oY2FyZGluYWxzLCBvcmRpbmFscyk7XFxuICAgICAgICB0aGlzLmZuLl9vYmogPSB0aGlzO1xcbiAgICAgICAgdGhpcy5mbi5jYXRlZ29yaWVzID0gdGhpcy5jYXRlZ29yaWVzO1xcbiAgICAgICAgXFxuICAgICAgICB0aGlzLmZuLnRvU3RyaW5nID0gdGhpcy5mblRvU3RyaW5nLmJpbmQodGhpcyk7XFxuICAgICAgICByZXR1cm4gdGhpcy5mbjtcXG4gICAgfVxcblxcbiAgICBfY3JlYXRlQ2xhc3MoTWFrZVBsdXJhbCwgW3tcXG4gICAgICAgIGtleTogJ2NvbXBpbGUnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUodHlwZSwgcmVxKSB7XFxuICAgICAgICAgICAgdmFyIGNhc2VzID0gW107XFxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gTWFrZVBsdXJhbC5ydWxlc1t0eXBlXVt0aGlzLmxjXTtcXG4gICAgICAgICAgICBpZiAoIXJ1bGVzKSB7XFxuICAgICAgICAgICAgICAgIGlmIChyZXEpIHRocm93IG5ldyBFcnJvcignTG9jYWxlIFxcXCInICsgdGhpcy5sYyArICdcXFwiICcgKyB0eXBlICsgJyBydWxlcyBub3QgZm91bmQnKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5jYXRlZ29yaWVzW3R5cGVdID0gWydvdGhlciddO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFwnb3RoZXJcXFxcJyc7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGZvciAodmFyIHIgaW4gcnVsZXMpIHtcXG4gICAgICAgICAgICAgICAgdmFyIF9ydWxlcyRyJHRyaW0kc3BsaXQgPSBydWxlc1tyXS50cmltKCkuc3BsaXQoL1xcXFxzKkBcXFxcdyovKTtcXG5cXG4gICAgICAgICAgICAgICAgdmFyIF9ydWxlcyRyJHRyaW0kc3BsaXQyID0gX3RvQXJyYXkoX3J1bGVzJHIkdHJpbSRzcGxpdCk7XFxuXFxuICAgICAgICAgICAgICAgIHZhciBjb25kID0gX3J1bGVzJHIkdHJpbSRzcGxpdDJbMF07XFxuICAgICAgICAgICAgICAgIHZhciBleGFtcGxlcyA9IF9ydWxlcyRyJHRyaW0kc3BsaXQyLnNsaWNlKDEpO1xcbiAgICAgICAgICAgICAgICB2YXIgY2F0ID0gci5yZXBsYWNlKCdwbHVyYWxSdWxlLWNvdW50LScsICcnKTtcXG4gICAgICAgICAgICAgICAgaWYgKGNvbmQpIGNhc2VzLnB1c2goW3RoaXMucGFyc2VyLnBhcnNlKGNvbmQpLCBjYXRdKTtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoaXMuY2F0ZWdvcmllc1t0eXBlXSA9IGNhc2VzLm1hcChmdW5jdGlvbiAoYykge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gY1sxXTtcXG4gICAgICAgICAgICB9KS5jb25jYXQoJ290aGVyJyk7XFxuICAgICAgICAgICAgaWYgKGNhc2VzLmxlbmd0aCA9PT0gMSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gJygnICsgY2FzZXNbMF1bMF0gKyAnKSA/IFxcXFwnJyArIGNhc2VzWzBdWzFdICsgJ1xcXFwnIDogXFxcXCdvdGhlclxcXFwnJztcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnKCcgKyBjWzBdICsgJykgPyBcXFxcJycgKyBjWzFdICsgJ1xcXFwnJztcXG4gICAgICAgICAgICAgICAgfSkpLCBbJ1xcXFwnb3RoZXJcXFxcJyddKS5qb2luKCdcXFxcbiAgICAgIDogJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgICBrZXk6ICdidWlsZEZ1bmN0aW9uJyxcXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZEZ1bmN0aW9uKGNhcmRpbmFscywgb3JkaW5hbHMpIHtcXG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICAgICAgICB2YXIgY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUoYykge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gYyA/IChjWzFdID8gJ3JldHVybiAnIDogJ2lmIChvcmQpIHJldHVybiAnKSArIF90aGlzMy5jb21waWxlLmFwcGx5KF90aGlzMywgX3RvQ29uc3VtYWJsZUFycmF5KGMpKSA6ICcnO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIGZvbGQgPSB7IHZhcnM6IGZ1bmN0aW9uIHZhcnMoc3RyKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCcgICcgKyBzdHIgKyAnOycpLnJlcGxhY2UoLyguezEsNzh9KSgsfCQpID8vZywgJyQxJDJcXFxcbiAgICAgICcpO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBjb25kOiBmdW5jdGlvbiBjb25kKHN0cikge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnICAnICsgc3RyICsgJzsnKS5yZXBsYWNlKC8oLnsxLDc4fSkgKFxcXFx8XFxcXHwgfCQpID8vZ20sICckMVxcXFxuICAgICAgICAgICQyJyk7XFxuICAgICAgICAgICAgICAgIH0gfSxcXG4gICAgICAgICAgICAgICAgY29uZCA9IFtvcmRpbmFscyAmJiBbJ29yZGluYWwnLCAhY2FyZGluYWxzXSwgY2FyZGluYWxzICYmIFsnY2FyZGluYWwnLCB0cnVlXV0ubWFwKGNvbXBpbGUpLm1hcChmb2xkLmNvbmQpLFxcbiAgICAgICAgICAgICAgICBib2R5ID0gW2ZvbGQudmFycyh0aGlzLnBhcnNlci52YXJzKCkpXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGNvbmQpKS5qb2luKCdcXFxcbicpLnJlcGxhY2UoL1xcXFxzKyQvZ20sICcnKS5yZXBsYWNlKC9eW1xcXFxzO10qW1xcXFxyXFxcXG5dKy9nbSwgJycpLFxcbiAgICAgICAgICAgICAgICBhcmdzID0gb3JkaW5hbHMgJiYgY2FyZGluYWxzID8gJ24sIG9yZCcgOiAnbic7XFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihhcmdzLCBib2R5KTtcXG4gICAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgICAga2V5OiAnZm5Ub1N0cmluZycsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZm5Ub1N0cmluZyhuYW1lKSB7XFxuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuZm4pLnJlcGxhY2UoL15mdW5jdGlvbiggXFxcXHcrKT8vLCBuYW1lID8gJ2Z1bmN0aW9uICcgKyBuYW1lIDogJ2Z1bmN0aW9uJykucmVwbGFjZSgnXFxcXG4vKiovJywgJycpO1xcbiAgICAgICAgfVxcbiAgICB9XSwgW3tcXG4gICAgICAgIGtleTogJ2xvYWQnLFxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoKSB7XFxuICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcXG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChjbGRyKSB7XFxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gY2xkciAmJiBjbGRyLnN1cHBsZW1lbnRhbCB8fCBudWxsO1xcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHRocm93IG5ldyBFcnJvcignRGF0YSBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgQ0xEUiBkYXRhJyk7XFxuICAgICAgICAgICAgICAgIE1ha2VQbHVyYWwucnVsZXMgPSB7XFxuICAgICAgICAgICAgICAgICAgICBjYXJkaW5hbDogZGF0YVsncGx1cmFscy10eXBlLWNhcmRpbmFsJ10gfHwgTWFrZVBsdXJhbC5ydWxlcy5jYXJkaW5hbCxcXG4gICAgICAgICAgICAgICAgICAgIG9yZGluYWw6IGRhdGFbJ3BsdXJhbHMtdHlwZS1vcmRpbmFsJ10gfHwgTWFrZVBsdXJhbC5ydWxlcy5vcmRpbmFsXFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmV0dXJuIE1ha2VQbHVyYWw7XFxuICAgICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIE1ha2VQbHVyYWw7XFxufSkoKTtcXG5cXG5cXG5cXG5NYWtlUGx1cmFsLmNhcmRpbmFscyA9IHRydWU7XFxuTWFrZVBsdXJhbC5vcmRpbmFscyA9IGZhbHNlO1xcbk1ha2VQbHVyYWwucnVsZXMgPSB7IGNhcmRpbmFsOiB7fSwgb3JkaW5hbDoge30gfTtcXG5cXG5cXG5yZXR1cm4gTWFrZVBsdXJhbDtcXG59KCkpO1xcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXFxuXFxuXFxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXFxuXFx0XFx0dmFsdWUsXFxuXFx0XFx0bmFtZSxcXG5cXHRcXHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXFxcIm51bWJlclxcXCIsXFxuXFx0XFx0XFxcIk51bWJlclxcXCJcXG5cXHQpO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsdXJhbFR5cGUgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKFxcblxcdFxcdHZhbHVlLFxcblxcdFxcdG5hbWUsXFxuXFx0XFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gXFxcImNhcmRpbmFsXFxcIiB8fCB2YWx1ZSA9PT0gXFxcIm9yZGluYWxcXFwiLFxcblxcdFxcdFxcXCJTdHJpbmcgXFxcXFxcXCJjYXJkaW5hbFxcXFxcXFwiIG9yIFxcXFxcXFwib3JkaW5hbFxcXFxcXFwiXFxcIlxcblxcdCk7XFxufTtcXG5cXG5cXG5cXG5cXG52YXIgcGx1cmFsR2VuZXJhdG9yRm4gPSBmdW5jdGlvbiggcGx1cmFsICkge1xcblxcdHJldHVybiBmdW5jdGlvbiBwbHVyYWxHZW5lcmF0b3IoIHZhbHVlICkge1xcblxcdFxcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcXFwidmFsdWVcXFwiICk7XFxuXFx0XFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcblxcdFxcdHJldHVybiBwbHVyYWwoIHZhbHVlICk7XFxuXFx0fTtcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIC5wbHVyYWwoIHZhbHVlIClcXG4gKlxcbiAqIEB2YWx1ZSBbTnVtYmVyXVxcbiAqXFxuICogUmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIGZvcm0gKHplcm8gfCBvbmUgfCB0d28gfCBmZXcgfCBtYW55IHwgb3RoZXIpIG9mIGFcXG4gKiB2YWx1ZSBnaXZlbiBsb2NhbGUuXFxuICovXFxuR2xvYmFsaXplLnBsdXJhbCA9XFxuR2xvYmFsaXplLnByb3RvdHlwZS5wbHVyYWwgPSBmdW5jdGlvbiggdmFsdWUsIG9wdGlvbnMgKSB7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcXFwidmFsdWVcXFwiICk7XFxuXFx0cmV0dXJuIHRoaXMucGx1cmFsR2VuZXJhdG9yKCBvcHRpb25zICkoIHZhbHVlICk7XFxufTtcXG5cXG4vKipcXG4gKiAucGx1cmFsR2VuZXJhdG9yKCBbb3B0aW9uc10gKVxcbiAqXFxuICogUmV0dXJuIGEgcGx1cmFsIGZ1bmN0aW9uIChvZiB0aGUgZm9ybSBiZWxvdykuXFxuICpcXG4gKiBmbiggdmFsdWUgKVxcbiAqXFxuICogQHZhbHVlIFtOdW1iZXJdXFxuICpcXG4gKiBSZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgZm9ybSAoemVybyB8IG9uZSB8IHR3byB8IGZldyB8IG1hbnkgfCBvdGhlcikgb2YgYSB2YWx1ZSBnaXZlbiB0aGVcXG4gKiBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cXG4gKi9cXG5HbG9iYWxpemUucGx1cmFsR2VuZXJhdG9yID1cXG5HbG9iYWxpemUucHJvdG90eXBlLnBsdXJhbEdlbmVyYXRvciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xcblxcdHZhciBhcmdzLCBjbGRyLCBpc09yZGluYWwsIHBsdXJhbCwgcmV0dXJuRm4sIHR5cGU7XFxuXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFxcXCJvcHRpb25zXFxcIiApO1xcblxcblxcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcdGNsZHIgPSB0aGlzLmNsZHI7XFxuXFxuXFx0YXJncyA9IFsgb3B0aW9ucyBdO1xcblxcdHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgXFxcImNhcmRpbmFsXFxcIjtcXG5cXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbHVyYWxUeXBlKCBvcHRpb25zLnR5cGUsIFxcXCJvcHRpb25zLnR5cGVcXFwiICk7XFxuXFxuXFx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XFxuXFxuXFx0aXNPcmRpbmFsID0gdHlwZSA9PT0gXFxcIm9yZGluYWxcXFwiO1xcblxcblxcdGNsZHIub24oIFxcXCJnZXRcXFwiLCB2YWxpZGF0ZUNsZHIgKTtcXG5cXHR0cnkge1xcblxcdFxcdGNsZHIuc3VwcGxlbWVudGFsKFsgXFxcInBsdXJhbHMtdHlwZS1cXFwiICsgdHlwZSwgXFxcIntsYW5ndWFnZX1cXFwiIF0pO1xcblxcdH0gZmluYWxseSB7XFxuXFx0XFx0Y2xkci5vZmYoIFxcXCJnZXRcXFwiLCB2YWxpZGF0ZUNsZHIgKTtcXG5cXHR9XFxuXFxuXFx0TWFrZVBsdXJhbC5ydWxlcyA9IHt9O1xcblxcdE1ha2VQbHVyYWwucnVsZXNbIHR5cGUgXSA9IGNsZHIuc3VwcGxlbWVudGFsKCBcXFwicGx1cmFscy10eXBlLVxcXCIgKyB0eXBlICk7XFxuXFxuXFx0cGx1cmFsID0gbmV3IE1ha2VQbHVyYWwoIGNsZHIuYXR0cmlidXRlcy5sYW5ndWFnZSwge1xcblxcdFxcdFxcXCJvcmRpbmFsc1xcXCI6IGlzT3JkaW5hbCxcXG5cXHRcXHRcXFwiY2FyZGluYWxzXFxcIjogIWlzT3JkaW5hbFxcblxcdH0pO1xcblxcblxcdHJldHVybkZuID0gcGx1cmFsR2VuZXJhdG9yRm4oIHBsdXJhbCApO1xcblxcblxcdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBwbHVyYWwgXSApO1xcblxcblxcdHJldHVybiByZXR1cm5GbjtcXG59O1xcblxcbnJldHVybiBHbG9iYWxpemU7XFxuXFxuXFxuXFxuXFxufSkpO1xcblwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(33))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3JlbGF0aXZlLXRpbWUuanM/NWQxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXGdsb2JhbGl6ZVxcXFxkaXN0XFxcXGdsb2JhbGl6ZVxcXFxyZWxhdGl2ZS10aW1lLmpzXCIpKSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32\n")},function(module,exports){eval('module.exports = "/**\\n * Globalize v1.5.0\\n *\\n * http://github.com/jquery/globalize\\n *\\n * Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2020-03-25T12:19Z\\n */\\n/*!\\n * Globalize v1.5.0 2020-03-25T12:19Z Released under the MIT license\\n * http://git.io/TrdQbw\\n */\\n(function( root, factory ) {\\n\\n\\t// UMD returnExports\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\n\\t\\t// AMD\\n\\t\\tdefine([\\n\\t\\t\\t\\"cldr\\",\\n\\t\\t\\t\\"../globalize\\",\\n\\t\\t\\t\\"./number\\",\\n\\t\\t\\t\\"./plural\\",\\n\\t\\t\\t\\"cldr/event\\",\\n\\t\\t\\t\\"cldr/supplemental\\"\\n\\t\\t], factory );\\n\\t} else if ( typeof exports === \\"object\\" ) {\\n\\n\\t\\t// Node, CommonJS\\n\\t\\tmodule.exports = factory( require( \\"cldrjs\\" ), require( \\"../globalize\\" ) );\\n\\t} else {\\n\\n\\t\\t// Extend global\\n\\t\\tfactory( root.Cldr, root.Globalize );\\n\\t}\\n}(this, function( Cldr, Globalize ) {\\n\\nvar formatMessage = Globalize._formatMessage,\\n\\truntimeBind = Globalize._runtimeBind,\\n\\tvalidateCldr = Globalize._validateCldr,\\n\\tvalidateDefaultLocale = Globalize._validateDefaultLocale,\\n\\tvalidateParameterPresence = Globalize._validateParameterPresence,\\n\\tvalidateParameterTypeString = Globalize._validateParameterTypeString,\\n\\tvalidateParameterTypeNumber = Globalize._validateParameterTypeNumber;\\n\\n\\n/**\\n * format( value, numberFormatter, pluralGenerator, properties )\\n *\\n * @value [Number] The number to format\\n *\\n * @numberFormatter [String] A numberFormatter from Globalize.numberFormatter\\n *\\n * @pluralGenerator [String] A pluralGenerator from Globalize.pluralGenerator\\n *\\n * @properties [Object] containing relative time plural message.\\n *\\n * Format relative time.\\n */\\nvar relativeTimeFormat = function( value, numberFormatter, pluralGenerator, properties ) {\\n\\n\\tvar relativeTime,\\n\\t\\tmessage = properties[ \\"relative-type-\\" + value ];\\n\\n\\tif ( message ) {\\n\\t\\treturn message;\\n\\t}\\n\\n\\trelativeTime = value <= 0 ? properties[ \\"relativeTime-type-past\\" ]\\n\\t\\t: properties[ \\"relativeTime-type-future\\" ];\\n\\n\\tvalue = Math.abs( value );\\n\\n\\tmessage = relativeTime[ \\"relativeTimePattern-count-\\" + pluralGenerator( value ) ];\\n\\treturn formatMessage( message, [ numberFormatter( value ) ] );\\n};\\n\\n\\n\\n\\nvar relativeTimeFormatterFn = function( numberFormatter, pluralGenerator, properties ) {\\n\\treturn function relativeTimeFormatter( value ) {\\n\\t\\tvalidateParameterPresence( value, \\"value\\" );\\n\\t\\tvalidateParameterTypeNumber( value, \\"value\\" );\\n\\n\\t\\treturn relativeTimeFormat( value, numberFormatter, pluralGenerator, properties );\\n\\t};\\n\\n};\\n\\n\\n\\n\\n/**\\n * properties( unit, cldr, options )\\n *\\n * @unit [String] eg. \\"day\\", \\"week\\", \\"month\\", etc.\\n *\\n * @cldr [Cldr instance].\\n *\\n * @options [Object]\\n * - form: [String] eg. \\"short\\" or \\"narrow\\". Or falsy for default long form.\\n *\\n * Return relative time properties.\\n */\\nvar relativeTimeProperties = function( unit, cldr, options ) {\\n\\n\\tvar form = options.form,\\n\\t\\traw, properties, key, match;\\n\\n\\tif ( form ) {\\n\\t\\tunit = unit + \\"-\\" + form;\\n\\t}\\n\\n\\traw = cldr.main( [ \\"dates\\", \\"fields\\", unit ] );\\n\\tproperties = {\\n\\t\\t\\"relativeTime-type-future\\": raw[ \\"relativeTime-type-future\\" ],\\n\\t\\t\\"relativeTime-type-past\\": raw[ \\"relativeTime-type-past\\" ]\\n\\t};\\n\\tfor ( key in raw ) {\\n\\t\\tif ( raw.hasOwnProperty( key ) ) {\\n\\t\\t\\tmatch = /relative-type-(-?[0-9]+)/.exec( key );\\n\\t\\t\\tif ( match ) {\\n\\t\\t\\t\\tproperties[ key ] = raw[ key ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn properties;\\n};\\n\\n\\n\\n\\n/**\\n * .formatRelativeTime( value, unit [, options] )\\n *\\n * @value [Number] The number of unit to format.\\n *\\n * @unit [String] see .relativeTimeFormatter() for details.\\n *\\n * @options [Object] see .relativeTimeFormatter() for details.\\n *\\n * Formats a relative time according to the given unit, options, and the default/instance locale.\\n */\\nGlobalize.formatRelativeTime =\\nGlobalize.prototype.formatRelativeTime = function( value, unit, options ) {\\n\\tvalidateParameterPresence( value, \\"value\\" );\\n\\tvalidateParameterTypeNumber( value, \\"value\\" );\\n\\n\\treturn this.relativeTimeFormatter( unit, options )( value );\\n};\\n\\n/**\\n * .relativeTimeFormatter( unit [, options ])\\n *\\n * @unit [String] String value indicating the unit to be formatted. eg. \\"day\\", \\"week\\", \\"month\\", etc.\\n *\\n * @options [Object]\\n * - form: [String] eg. \\"short\\" or \\"narrow\\". Or falsy for default long form.\\n *\\n * Returns a function that formats a relative time according to the given unit, options, and the\\n * default/instance locale.\\n */\\nGlobalize.relativeTimeFormatter =\\nGlobalize.prototype.relativeTimeFormatter = function( unit, options ) {\\n\\tvar args, cldr, numberFormatter, pluralGenerator, properties, returnFn;\\n\\n\\tvalidateParameterPresence( unit, \\"unit\\" );\\n\\tvalidateParameterTypeString( unit, \\"unit\\" );\\n\\n\\tcldr = this.cldr;\\n\\toptions = options || {};\\n\\n\\targs = [ unit, options ];\\n\\n\\tvalidateDefaultLocale( cldr );\\n\\n\\tcldr.on( \\"get\\", validateCldr );\\n\\ttry {\\n\\t\\tproperties = relativeTimeProperties( unit, cldr, options );\\n\\t} finally {\\n\\t\\tcldr.off( \\"get\\", validateCldr );\\n\\t}\\n\\tnumberFormatter = this.numberFormatter( options );\\n\\tpluralGenerator = this.pluralGenerator();\\n\\n\\treturnFn = relativeTimeFormatterFn( numberFormatter, pluralGenerator, properties );\\n\\n\\truntimeBind( args, cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );\\n\\n\\treturn returnFn;\\n};\\n\\nreturn Globalize;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3JlbGF0aXZlLXRpbWUuanM/MjVkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqXFxuICogR2xvYmFsaXplIHYxLjUuMFxcbiAqXFxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxcbiAqXFxuICogQ29weXJpZ2h0IDIwMTAsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIERhdGU6IDIwMjAtMDMtMjVUMTI6MTlaXFxuICovXFxuLyohXFxuICogR2xvYmFsaXplIHYxLjUuMCAyMDIwLTAzLTI1VDEyOjE5WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xcbiAqL1xcbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcXG5cXG5cXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xcblxcdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBkZWZpbmUuYW1kICkge1xcblxcblxcdFxcdC8vIEFNRFxcblxcdFxcdGRlZmluZShbXFxuXFx0XFx0XFx0XFxcImNsZHJcXFwiLFxcblxcdFxcdFxcdFxcXCIuLi9nbG9iYWxpemVcXFwiLFxcblxcdFxcdFxcdFxcXCIuL251bWJlclxcXCIsXFxuXFx0XFx0XFx0XFxcIi4vcGx1cmFsXFxcIixcXG5cXHRcXHRcXHRcXFwiY2xkci9ldmVudFxcXCIsXFxuXFx0XFx0XFx0XFxcImNsZHIvc3VwcGxlbWVudGFsXFxcIlxcblxcdFxcdF0sIGZhY3RvcnkgKTtcXG5cXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0Ly8gTm9kZSwgQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFxcXCJjbGRyanNcXFwiICksIHJlcXVpcmUoIFxcXCIuLi9nbG9iYWxpemVcXFwiICkgKTtcXG5cXHR9IGVsc2Uge1xcblxcblxcdFxcdC8vIEV4dGVuZCBnbG9iYWxcXG5cXHRcXHRmYWN0b3J5KCByb290LkNsZHIsIHJvb3QuR2xvYmFsaXplICk7XFxuXFx0fVxcbn0odGhpcywgZnVuY3Rpb24oIENsZHIsIEdsb2JhbGl6ZSApIHtcXG5cXG52YXIgZm9ybWF0TWVzc2FnZSA9IEdsb2JhbGl6ZS5fZm9ybWF0TWVzc2FnZSxcXG5cXHRydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXFxuXFx0dmFsaWRhdGVDbGRyID0gR2xvYmFsaXplLl92YWxpZGF0ZUNsZHIsXFxuXFx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gR2xvYmFsaXplLl92YWxpZGF0ZURlZmF1bHRMb2NhbGUsXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSxcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyxcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlcjtcXG5cXG5cXG4vKipcXG4gKiBmb3JtYXQoIHZhbHVlLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApXFxuICpcXG4gKiBAdmFsdWUgW051bWJlcl0gVGhlIG51bWJlciB0byBmb3JtYXRcXG4gKlxcbiAqIEBudW1iZXJGb3JtYXR0ZXIgW1N0cmluZ10gQSBudW1iZXJGb3JtYXR0ZXIgZnJvbSBHbG9iYWxpemUubnVtYmVyRm9ybWF0dGVyXFxuICpcXG4gKiBAcGx1cmFsR2VuZXJhdG9yIFtTdHJpbmddIEEgcGx1cmFsR2VuZXJhdG9yIGZyb20gR2xvYmFsaXplLnBsdXJhbEdlbmVyYXRvclxcbiAqXFxuICogQHByb3BlcnRpZXMgW09iamVjdF0gY29udGFpbmluZyByZWxhdGl2ZSB0aW1lIHBsdXJhbCBtZXNzYWdlLlxcbiAqXFxuICogRm9ybWF0IHJlbGF0aXZlIHRpbWUuXFxuICovXFxudmFyIHJlbGF0aXZlVGltZUZvcm1hdCA9IGZ1bmN0aW9uKCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgKSB7XFxuXFxuXFx0dmFyIHJlbGF0aXZlVGltZSxcXG5cXHRcXHRtZXNzYWdlID0gcHJvcGVydGllc1sgXFxcInJlbGF0aXZlLXR5cGUtXFxcIiArIHZhbHVlIF07XFxuXFxuXFx0aWYgKCBtZXNzYWdlICkge1xcblxcdFxcdHJldHVybiBtZXNzYWdlO1xcblxcdH1cXG5cXG5cXHRyZWxhdGl2ZVRpbWUgPSB2YWx1ZSA8PSAwID8gcHJvcGVydGllc1sgXFxcInJlbGF0aXZlVGltZS10eXBlLXBhc3RcXFwiIF1cXG5cXHRcXHQ6IHByb3BlcnRpZXNbIFxcXCJyZWxhdGl2ZVRpbWUtdHlwZS1mdXR1cmVcXFwiIF07XFxuXFxuXFx0dmFsdWUgPSBNYXRoLmFicyggdmFsdWUgKTtcXG5cXG5cXHRtZXNzYWdlID0gcmVsYXRpdmVUaW1lWyBcXFwicmVsYXRpdmVUaW1lUGF0dGVybi1jb3VudC1cXFwiICsgcGx1cmFsR2VuZXJhdG9yKCB2YWx1ZSApIF07XFxuXFx0cmV0dXJuIGZvcm1hdE1lc3NhZ2UoIG1lc3NhZ2UsIFsgbnVtYmVyRm9ybWF0dGVyKCB2YWx1ZSApIF0gKTtcXG59O1xcblxcblxcblxcblxcbnZhciByZWxhdGl2ZVRpbWVGb3JtYXR0ZXJGbiA9IGZ1bmN0aW9uKCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApIHtcXG5cXHRyZXR1cm4gZnVuY3Rpb24gcmVsYXRpdmVUaW1lRm9ybWF0dGVyKCB2YWx1ZSApIHtcXG5cXHRcXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdFxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gcmVsYXRpdmVUaW1lRm9ybWF0KCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgKTtcXG5cXHR9O1xcblxcbn07XFxuXFxuXFxuXFxuXFxuLyoqXFxuICogcHJvcGVydGllcyggdW5pdCwgY2xkciwgb3B0aW9ucyApXFxuICpcXG4gKiBAdW5pdCBbU3RyaW5nXSBlZy4gXFxcImRheVxcXCIsIFxcXCJ3ZWVrXFxcIiwgXFxcIm1vbnRoXFxcIiwgZXRjLlxcbiAqXFxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxcbiAqXFxuICogQG9wdGlvbnMgW09iamVjdF1cXG4gKiAtIGZvcm06IFtTdHJpbmddIGVnLiBcXFwic2hvcnRcXFwiIG9yIFxcXCJuYXJyb3dcXFwiLiBPciBmYWxzeSBmb3IgZGVmYXVsdCBsb25nIGZvcm0uXFxuICpcXG4gKiBSZXR1cm4gcmVsYXRpdmUgdGltZSBwcm9wZXJ0aWVzLlxcbiAqL1xcbnZhciByZWxhdGl2ZVRpbWVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHVuaXQsIGNsZHIsIG9wdGlvbnMgKSB7XFxuXFxuXFx0dmFyIGZvcm0gPSBvcHRpb25zLmZvcm0sXFxuXFx0XFx0cmF3LCBwcm9wZXJ0aWVzLCBrZXksIG1hdGNoO1xcblxcblxcdGlmICggZm9ybSApIHtcXG5cXHRcXHR1bml0ID0gdW5pdCArIFxcXCItXFxcIiArIGZvcm07XFxuXFx0fVxcblxcblxcdHJhdyA9IGNsZHIubWFpbiggWyBcXFwiZGF0ZXNcXFwiLCBcXFwiZmllbGRzXFxcIiwgdW5pdCBdICk7XFxuXFx0cHJvcGVydGllcyA9IHtcXG5cXHRcXHRcXFwicmVsYXRpdmVUaW1lLXR5cGUtZnV0dXJlXFxcIjogcmF3WyBcXFwicmVsYXRpdmVUaW1lLXR5cGUtZnV0dXJlXFxcIiBdLFxcblxcdFxcdFxcXCJyZWxhdGl2ZVRpbWUtdHlwZS1wYXN0XFxcIjogcmF3WyBcXFwicmVsYXRpdmVUaW1lLXR5cGUtcGFzdFxcXCIgXVxcblxcdH07XFxuXFx0Zm9yICgga2V5IGluIHJhdyApIHtcXG5cXHRcXHRpZiAoIHJhdy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XFxuXFx0XFx0XFx0bWF0Y2ggPSAvcmVsYXRpdmUtdHlwZS0oLT9bMC05XSspLy5leGVjKCBrZXkgKTtcXG5cXHRcXHRcXHRpZiAoIG1hdGNoICkge1xcblxcdFxcdFxcdFxcdHByb3BlcnRpZXNbIGtleSBdID0gcmF3WyBrZXkgXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gcHJvcGVydGllcztcXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIC5mb3JtYXRSZWxhdGl2ZVRpbWUoIHZhbHVlLCB1bml0IFssIG9wdGlvbnNdIClcXG4gKlxcbiAqIEB2YWx1ZSBbTnVtYmVyXSBUaGUgbnVtYmVyIG9mIHVuaXQgdG8gZm9ybWF0LlxcbiAqXFxuICogQHVuaXQgW1N0cmluZ10gc2VlIC5yZWxhdGl2ZVRpbWVGb3JtYXR0ZXIoKSBmb3IgZGV0YWlscy5cXG4gKlxcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSAucmVsYXRpdmVUaW1lRm9ybWF0dGVyKCkgZm9yIGRldGFpbHMuXFxuICpcXG4gKiBGb3JtYXRzIGEgcmVsYXRpdmUgdGltZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHVuaXQsIG9wdGlvbnMsIGFuZCB0aGUgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXFxuICovXFxuR2xvYmFsaXplLmZvcm1hdFJlbGF0aXZlVGltZSA9XFxuR2xvYmFsaXplLnByb3RvdHlwZS5mb3JtYXRSZWxhdGl2ZVRpbWUgPSBmdW5jdGlvbiggdmFsdWUsIHVuaXQsIG9wdGlvbnMgKSB7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcXFwidmFsdWVcXFwiICk7XFxuXFxuXFx0cmV0dXJuIHRoaXMucmVsYXRpdmVUaW1lRm9ybWF0dGVyKCB1bml0LCBvcHRpb25zICkoIHZhbHVlICk7XFxufTtcXG5cXG4vKipcXG4gKiAucmVsYXRpdmVUaW1lRm9ybWF0dGVyKCB1bml0IFssIG9wdGlvbnMgXSlcXG4gKlxcbiAqIEB1bml0IFtTdHJpbmddIFN0cmluZyB2YWx1ZSBpbmRpY2F0aW5nIHRoZSB1bml0IHRvIGJlIGZvcm1hdHRlZC4gZWcuIFxcXCJkYXlcXFwiLCBcXFwid2Vla1xcXCIsIFxcXCJtb250aFxcXCIsIGV0Yy5cXG4gKlxcbiAqIEBvcHRpb25zIFtPYmplY3RdXFxuICogLSBmb3JtOiBbU3RyaW5nXSBlZy4gXFxcInNob3J0XFxcIiBvciBcXFwibmFycm93XFxcIi4gT3IgZmFsc3kgZm9yIGRlZmF1bHQgbG9uZyBmb3JtLlxcbiAqXFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhIHJlbGF0aXZlIHRpbWUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiB1bml0LCBvcHRpb25zLCBhbmQgdGhlXFxuICogZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXFxuICovXFxuR2xvYmFsaXplLnJlbGF0aXZlVGltZUZvcm1hdHRlciA9XFxuR2xvYmFsaXplLnByb3RvdHlwZS5yZWxhdGl2ZVRpbWVGb3JtYXR0ZXIgPSBmdW5jdGlvbiggdW5pdCwgb3B0aW9ucyApIHtcXG5cXHR2YXIgYXJncywgY2xkciwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMsIHJldHVybkZuO1xcblxcblxcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHVuaXQsIFxcXCJ1bml0XFxcIiApO1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdW5pdCwgXFxcInVuaXRcXFwiICk7XFxuXFxuXFx0Y2xkciA9IHRoaXMuY2xkcjtcXG5cXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG5cXHRhcmdzID0gWyB1bml0LCBvcHRpb25zIF07XFxuXFxuXFx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XFxuXFxuXFx0Y2xkci5vbiggXFxcImdldFxcXCIsIHZhbGlkYXRlQ2xkciApO1xcblxcdHRyeSB7XFxuXFx0XFx0cHJvcGVydGllcyA9IHJlbGF0aXZlVGltZVByb3BlcnRpZXMoIHVuaXQsIGNsZHIsIG9wdGlvbnMgKTtcXG5cXHR9IGZpbmFsbHkge1xcblxcdFxcdGNsZHIub2ZmKCBcXFwiZ2V0XFxcIiwgdmFsaWRhdGVDbGRyICk7XFxuXFx0fVxcblxcdG51bWJlckZvcm1hdHRlciA9IHRoaXMubnVtYmVyRm9ybWF0dGVyKCBvcHRpb25zICk7XFxuXFx0cGx1cmFsR2VuZXJhdG9yID0gdGhpcy5wbHVyYWxHZW5lcmF0b3IoKTtcXG5cXG5cXHRyZXR1cm5GbiA9IHJlbGF0aXZlVGltZUZvcm1hdHRlckZuKCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApO1xcblxcblxcdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyBdICk7XFxuXFxuXFx0cmV0dXJuIHJldHVybkZuO1xcbn07XFxuXFxucmV0dXJuIEdsb2JhbGl6ZTtcXG5cXG5cXG5cXG5cXG59KSk7XFxuXCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(35))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3VuaXQuanM/M2RmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxhZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhQzpcXFxcVXNlcnNcXFxccm9iZXJcXFxcRG9jdW1lbnRzXFxcXEtvb2xfcm9iZXJ0XFxcXGljZDAwMDktMjAxOXNcXFxcRGlzdHJpYnV0ZWRTeXN0ZW1zXFxcXFByb2plY3RcXFxcUGl6emFTb2x1dGlvblxcXFxXZWJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXGdsb2JhbGl6ZVxcXFxkaXN0XFxcXGdsb2JhbGl6ZVxcXFx1bml0LmpzXCIpKSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34\n")},function(module,exports){eval('module.exports = "/**\\n * Globalize v1.5.0\\n *\\n * http://github.com/jquery/globalize\\n *\\n * Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2020-03-25T12:19Z\\n */\\n/*!\\n * Globalize v1.5.0 2020-03-25T12:19Z Released under the MIT license\\n * http://git.io/TrdQbw\\n */\\n(function( root, factory ) {\\n\\n\\t// UMD returnExports\\n\\tif ( typeof define === \\"function\\" && define.amd ) {\\n\\n\\t\\t// AMD\\n\\t\\tdefine([\\n\\t\\t\\t\\"cldr\\",\\n\\t\\t\\t\\"../globalize\\",\\n\\t\\t\\t\\"./number\\",\\n\\t\\t\\t\\"./plural\\"\\n\\t\\t], factory );\\n\\t} else if ( typeof exports === \\"object\\" ) {\\n\\n\\t\\t// Node, CommonJS\\n\\t\\tmodule.exports = factory( require( \\"cldrjs\\" ), require( \\"../globalize\\" ) );\\n\\t} else {\\n\\n\\t\\t// Extend global\\n\\t\\tfactory( root.Cldr, root.Globalize );\\n\\t}\\n}(this, function( Cldr, Globalize ) {\\n\\nvar formatMessage = Globalize._formatMessage,\\n\\truntimeBind = Globalize._runtimeBind,\\n\\tvalidateParameterPresence = Globalize._validateParameterPresence,\\n\\tvalidateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,\\n\\tvalidateParameterTypeNumber = Globalize._validateParameterTypeNumber,\\n\\tvalidateParameterTypeString = Globalize._validateParameterTypeString;\\n\\n\\n/**\\n * format( value, numberFormatter, pluralGenerator, unitProperies )\\n *\\n * @value [Number]\\n *\\n * @numberFormatter [Object]: A numberFormatter from Globalize.numberFormatter.\\n *\\n * @pluralGenerator [Object]: A pluralGenerator from Globalize.pluralGenerator.\\n *\\n * @unitProperies [Object]: localized unit data from cldr.\\n *\\n * Format units such as seconds, minutes, days, weeks, etc.\\n *\\n * OBS:\\n *\\n * Unit Sequences are not implemented.\\n * http://www.unicode.org/reports/tr35/tr35-35/tr35-general.html#Unit_Sequences\\n *\\n * Duration Unit (for composed time unit durations) is not implemented.\\n * http://www.unicode.org/reports/tr35/tr35-35/tr35-general.html#durationUnit\\n */\\nvar unitFormat = function( value, numberFormatter, pluralGenerator, unitProperties ) {\\n\\tvar compoundUnitPattern = unitProperties.compoundUnitPattern, dividend, dividendProperties,\\n\\t\\tformattedValue, divisor, divisorProperties, message, pluralValue, oneProperty;\\n\\n\\tunitProperties = unitProperties.unitProperties;\\n\\tformattedValue = numberFormatter( value );\\n\\tpluralValue = pluralGenerator( value );\\n\\n\\t// computed compound unit, eg. \\"megabyte-per-second\\".\\n\\tif ( unitProperties instanceof Array ) {\\n\\t\\tdividendProperties = unitProperties[ 0 ];\\n\\t\\tdivisorProperties = unitProperties[ 1 ];\\n\\t\\toneProperty = divisorProperties.hasOwnProperty( \\"one\\" ) ? \\"one\\" : \\"other\\";\\n\\n\\t\\tdividend = formatMessage( dividendProperties[ pluralValue ], [ formattedValue ] );\\n\\t\\tdivisor = formatMessage( divisorProperties[oneProperty], [ \\"\\" ] ).trim();\\n\\n\\t\\treturn formatMessage( compoundUnitPattern, [ dividend, divisor ] );\\n\\t}\\n\\n\\tmessage = unitProperties[ pluralValue ];\\n\\n\\treturn formatMessage( message, [ formattedValue ] );\\n};\\n\\n\\n\\n\\nvar unitFormatterFn = function( numberFormatter, pluralGenerator, unitProperties ) {\\n\\treturn function unitFormatter( value ) {\\n\\t\\tvalidateParameterPresence( value, \\"value\\" );\\n\\t\\tvalidateParameterTypeNumber( value, \\"value\\" );\\n\\n\\t\\treturn unitFormat( value, numberFormatter, pluralGenerator, unitProperties );\\n\\t};\\n\\n};\\n\\n\\n\\n\\n/**\\n * categories()\\n *\\n * Return all unit categories.\\n */\\nvar unitCategories = [ \\"acceleration\\", \\"angle\\", \\"area\\", \\"digital\\", \\"duration\\", \\"length\\", \\"mass\\", \\"power\\",\\n\\"pressure\\", \\"speed\\", \\"temperature\\", \\"volume\\" ];\\n\\n\\n\\n\\nfunction stripPluralGarbage( data ) {\\n\\tvar aux, pluralCount;\\n\\n\\tif ( data ) {\\n\\t\\taux = {};\\n\\t\\tfor ( pluralCount in data ) {\\n\\t\\t\\taux[ pluralCount.replace( /unitPattern-count-/, \\"\\" ) ] = data[ pluralCount ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn aux;\\n}\\n\\n/**\\n * get( unit, form, cldr )\\n *\\n * @unit [String] The full type-unit name (eg. duration-second), or the short unit name\\n * (eg. second).\\n *\\n * @form [String] A string describing the form of the unit representation (eg. long,\\n * short, narrow).\\n *\\n * @cldr [Cldr instance].\\n *\\n * Return the plural map of a unit, eg: \\"second\\"\\n * { \\"one\\": \\"{0} second\\",\\n *   \\"other\\": \\"{0} seconds\\" }\\n * }\\n *\\n * Or the Array of plural maps of a compound-unit, eg: \\"foot-per-second\\"\\n * [ { \\"one\\": \\"{0} foot\\",\\n *     \\"other\\": \\"{0} feet\\" },\\n *   { \\"one\\": \\"{0} second\\",\\n *     \\"other\\": \\"{0} seconds\\" } ]\\n *\\n * Uses the precomputed form of a compound-unit if available, eg: \\"mile-per-hour\\"\\n * { \\"displayName\\": \\"miles per hour\\",\\n *    \\"unitPattern-count-one\\": \\"{0} mile per hour\\",\\n *    \\"unitPattern-count-other\\": \\"{0} miles per hour\\"\\n * },\\n *\\n * Also supports \\"/\\" instead of \\"-per-\\", eg. \\"foot/second\\", using the precomputed form if\\n * available.\\n *\\n * Or the Array of plural maps of a compound-unit, eg: \\"foot-per-second\\"\\n * [ { \\"one\\": \\"{0} foot\\",\\n *     \\"other\\": \\"{0} feet\\" },\\n *   { \\"one\\": \\"{0} second\\",\\n *     \\"other\\": \\"{0} seconds\\" } ]\\n *\\n * Or undefined in case the unit (or a unit of the compound-unit) doesn\'t exist.\\n */\\nvar get = function( unit, form, cldr ) {\\n\\tvar ret;\\n\\n\\t// Ensure that we get the \'precomputed\' form, if present.\\n\\tunit = unit.replace( /\\\\//, \\"-per-\\" );\\n\\n\\t// Get unit or <category>-unit (eg. \\"duration-second\\").\\n\\t[ \\"\\" ].concat( unitCategories ).some(function( category ) {\\n\\t\\treturn ret = cldr.main([\\n\\t\\t\\t\\"units\\",\\n\\t\\t\\tform,\\n\\t\\t\\tcategory.length ? category + \\"-\\" + unit : unit\\n\\t\\t]);\\n\\t});\\n\\n\\t// Rename keys s/unitPattern-count-//g.\\n\\tret = stripPluralGarbage( ret );\\n\\n\\t// Compound Unit, eg. \\"foot-per-second\\" or \\"foot/second\\".\\n\\tif ( !ret && ( /-per-/ ).test( unit ) ) {\\n\\n\\t\\t// \\"Some units already have \'precomputed\' forms, such as kilometer-per-hour;\\n\\t\\t// where such units exist, they should be used in preference\\" UTS#35.\\n\\t\\t// Note that precomputed form has already been handled above (!ret).\\n\\n\\t\\t// Get both recursively.\\n\\t\\tunit = unit.split( \\"-per-\\" );\\n\\t\\tret = unit.map(function( unit ) {\\n\\t\\t\\treturn get( unit, form, cldr );\\n\\t\\t});\\n\\t\\tif ( !ret[ 0 ] || !ret[ 1 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret;\\n};\\n\\nvar unitGet = get;\\n\\n\\n\\n\\n/**\\n * properties( unit, form, cldr )\\n *\\n * @unit [String] The full type-unit name (eg. duration-second), or the short unit name\\n * (eg. second).\\n *\\n * @form [String] A string describing the form of the unit representation (eg. long,\\n * short, narrow).\\n *\\n * @cldr [Cldr instance].\\n */\\nvar unitProperties = function( unit, form, cldr ) {\\n\\tvar compoundUnitPattern, unitProperties;\\n\\n\\tcompoundUnitPattern = cldr.main( [ \\"units\\", form, \\"per/compoundUnitPattern\\" ] );\\n\\tunitProperties = unitGet( unit, form, cldr );\\n\\n\\treturn {\\n\\t\\tcompoundUnitPattern: compoundUnitPattern,\\n\\t\\tunitProperties: unitProperties\\n\\t};\\n};\\n\\n\\n\\n\\n/**\\n * Globalize.formatUnit( value, unit, options )\\n *\\n * @value [Number]\\n *\\n * @unit [String]: The unit (e.g \\"second\\", \\"day\\", \\"year\\")\\n *\\n * @options [Object]\\n * - form: [String] \\"long\\", \\"short\\" (default), or \\"narrow\\".\\n *\\n * Format units such as seconds, minutes, days, weeks, etc.\\n */\\nGlobalize.formatUnit =\\nGlobalize.prototype.formatUnit = function( value, unit, options ) {\\n\\tvalidateParameterPresence( value, \\"value\\" );\\n\\tvalidateParameterTypeNumber( value, \\"value\\" );\\n\\n\\treturn this.unitFormatter( unit, options )( value );\\n};\\n\\n/**\\n * Globalize.unitFormatter( unit, options )\\n *\\n * @unit [String]: The unit (e.g \\"second\\", \\"day\\", \\"year\\")\\n *\\n * @options [Object]\\n * - form: [String] \\"long\\", \\"short\\" (default), or \\"narrow\\".\\n *\\n * - numberFormatter: [Function] a number formatter function. Defaults to Globalize\\n *   `.numberFormatter()` for the current locale using the default options.\\n */\\nGlobalize.unitFormatter =\\nGlobalize.prototype.unitFormatter = function( unit, options ) {\\n\\tvar args, form, numberFormatter, pluralGenerator, returnFn, properties;\\n\\n\\tvalidateParameterPresence( unit, \\"unit\\" );\\n\\tvalidateParameterTypeString( unit, \\"unit\\" );\\n\\n\\tvalidateParameterTypePlainObject( options, \\"options\\" );\\n\\n\\toptions = options || {};\\n\\n\\targs = [ unit, options ];\\n\\tform = options.form || \\"long\\";\\n\\tproperties = unitProperties( unit, form, this.cldr );\\n\\n\\tnumberFormatter = options.numberFormatter || this.numberFormatter();\\n\\tpluralGenerator = this.pluralGenerator();\\n\\treturnFn = unitFormatterFn( numberFormatter, pluralGenerator, properties );\\n\\n\\truntimeBind( args, this.cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );\\n\\n\\treturn returnFn;\\n};\\n\\nreturn Globalize;\\n\\n\\n\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3VuaXQuanM/NzI3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqXFxuICogR2xvYmFsaXplIHYxLjUuMFxcbiAqXFxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxcbiAqXFxuICogQ29weXJpZ2h0IDIwMTAsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIERhdGU6IDIwMjAtMDMtMjVUMTI6MTlaXFxuICovXFxuLyohXFxuICogR2xvYmFsaXplIHYxLjUuMCAyMDIwLTAzLTI1VDEyOjE5WiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xcbiAqL1xcbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcXG5cXG5cXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xcblxcdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBkZWZpbmUuYW1kICkge1xcblxcblxcdFxcdC8vIEFNRFxcblxcdFxcdGRlZmluZShbXFxuXFx0XFx0XFx0XFxcImNsZHJcXFwiLFxcblxcdFxcdFxcdFxcXCIuLi9nbG9iYWxpemVcXFwiLFxcblxcdFxcdFxcdFxcXCIuL251bWJlclxcXCIsXFxuXFx0XFx0XFx0XFxcIi4vcGx1cmFsXFxcIlxcblxcdFxcdF0sIGZhY3RvcnkgKTtcXG5cXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXFxcIm9iamVjdFxcXCIgKSB7XFxuXFxuXFx0XFx0Ly8gTm9kZSwgQ29tbW9uSlNcXG5cXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFxcXCJjbGRyanNcXFwiICksIHJlcXVpcmUoIFxcXCIuLi9nbG9iYWxpemVcXFwiICkgKTtcXG5cXHR9IGVsc2Uge1xcblxcblxcdFxcdC8vIEV4dGVuZCBnbG9iYWxcXG5cXHRcXHRmYWN0b3J5KCByb290LkNsZHIsIHJvb3QuR2xvYmFsaXplICk7XFxuXFx0fVxcbn0odGhpcywgZnVuY3Rpb24oIENsZHIsIEdsb2JhbGl6ZSApIHtcXG5cXG52YXIgZm9ybWF0TWVzc2FnZSA9IEdsb2JhbGl6ZS5fZm9ybWF0TWVzc2FnZSxcXG5cXHRydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSxcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QsXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIsXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmc7XFxuXFxuXFxuLyoqXFxuICogZm9ybWF0KCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHVuaXRQcm9wZXJpZXMgKVxcbiAqXFxuICogQHZhbHVlIFtOdW1iZXJdXFxuICpcXG4gKiBAbnVtYmVyRm9ybWF0dGVyIFtPYmplY3RdOiBBIG51bWJlckZvcm1hdHRlciBmcm9tIEdsb2JhbGl6ZS5udW1iZXJGb3JtYXR0ZXIuXFxuICpcXG4gKiBAcGx1cmFsR2VuZXJhdG9yIFtPYmplY3RdOiBBIHBsdXJhbEdlbmVyYXRvciBmcm9tIEdsb2JhbGl6ZS5wbHVyYWxHZW5lcmF0b3IuXFxuICpcXG4gKiBAdW5pdFByb3BlcmllcyBbT2JqZWN0XTogbG9jYWxpemVkIHVuaXQgZGF0YSBmcm9tIGNsZHIuXFxuICpcXG4gKiBGb3JtYXQgdW5pdHMgc3VjaCBhcyBzZWNvbmRzLCBtaW51dGVzLCBkYXlzLCB3ZWVrcywgZXRjLlxcbiAqXFxuICogT0JTOlxcbiAqXFxuICogVW5pdCBTZXF1ZW5jZXMgYXJlIG5vdCBpbXBsZW1lbnRlZC5cXG4gKiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LTM1L3RyMzUtZ2VuZXJhbC5odG1sI1VuaXRfU2VxdWVuY2VzXFxuICpcXG4gKiBEdXJhdGlvbiBVbml0IChmb3IgY29tcG9zZWQgdGltZSB1bml0IGR1cmF0aW9ucykgaXMgbm90IGltcGxlbWVudGVkLlxcbiAqIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtMzUvdHIzNS1nZW5lcmFsLmh0bWwjZHVyYXRpb25Vbml0XFxuICovXFxudmFyIHVuaXRGb3JtYXQgPSBmdW5jdGlvbiggdmFsdWUsIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCB1bml0UHJvcGVydGllcyApIHtcXG5cXHR2YXIgY29tcG91bmRVbml0UGF0dGVybiA9IHVuaXRQcm9wZXJ0aWVzLmNvbXBvdW5kVW5pdFBhdHRlcm4sIGRpdmlkZW5kLCBkaXZpZGVuZFByb3BlcnRpZXMsXFxuXFx0XFx0Zm9ybWF0dGVkVmFsdWUsIGRpdmlzb3IsIGRpdmlzb3JQcm9wZXJ0aWVzLCBtZXNzYWdlLCBwbHVyYWxWYWx1ZSwgb25lUHJvcGVydHk7XFxuXFxuXFx0dW5pdFByb3BlcnRpZXMgPSB1bml0UHJvcGVydGllcy51bml0UHJvcGVydGllcztcXG5cXHRmb3JtYXR0ZWRWYWx1ZSA9IG51bWJlckZvcm1hdHRlciggdmFsdWUgKTtcXG5cXHRwbHVyYWxWYWx1ZSA9IHBsdXJhbEdlbmVyYXRvciggdmFsdWUgKTtcXG5cXG5cXHQvLyBjb21wdXRlZCBjb21wb3VuZCB1bml0LCBlZy4gXFxcIm1lZ2FieXRlLXBlci1zZWNvbmRcXFwiLlxcblxcdGlmICggdW5pdFByb3BlcnRpZXMgaW5zdGFuY2VvZiBBcnJheSApIHtcXG5cXHRcXHRkaXZpZGVuZFByb3BlcnRpZXMgPSB1bml0UHJvcGVydGllc1sgMCBdO1xcblxcdFxcdGRpdmlzb3JQcm9wZXJ0aWVzID0gdW5pdFByb3BlcnRpZXNbIDEgXTtcXG5cXHRcXHRvbmVQcm9wZXJ0eSA9IGRpdmlzb3JQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCBcXFwib25lXFxcIiApID8gXFxcIm9uZVxcXCIgOiBcXFwib3RoZXJcXFwiO1xcblxcblxcdFxcdGRpdmlkZW5kID0gZm9ybWF0TWVzc2FnZSggZGl2aWRlbmRQcm9wZXJ0aWVzWyBwbHVyYWxWYWx1ZSBdLCBbIGZvcm1hdHRlZFZhbHVlIF0gKTtcXG5cXHRcXHRkaXZpc29yID0gZm9ybWF0TWVzc2FnZSggZGl2aXNvclByb3BlcnRpZXNbb25lUHJvcGVydHldLCBbIFxcXCJcXFwiIF0gKS50cmltKCk7XFxuXFxuXFx0XFx0cmV0dXJuIGZvcm1hdE1lc3NhZ2UoIGNvbXBvdW5kVW5pdFBhdHRlcm4sIFsgZGl2aWRlbmQsIGRpdmlzb3IgXSApO1xcblxcdH1cXG5cXG5cXHRtZXNzYWdlID0gdW5pdFByb3BlcnRpZXNbIHBsdXJhbFZhbHVlIF07XFxuXFxuXFx0cmV0dXJuIGZvcm1hdE1lc3NhZ2UoIG1lc3NhZ2UsIFsgZm9ybWF0dGVkVmFsdWUgXSApO1xcbn07XFxuXFxuXFxuXFxuXFxudmFyIHVuaXRGb3JtYXR0ZXJGbiA9IGZ1bmN0aW9uKCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgdW5pdFByb3BlcnRpZXMgKSB7XFxuXFx0cmV0dXJuIGZ1bmN0aW9uIHVuaXRGb3JtYXR0ZXIoIHZhbHVlICkge1xcblxcdFxcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcXFwidmFsdWVcXFwiICk7XFxuXFx0XFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcblxcdFxcdHJldHVybiB1bml0Rm9ybWF0KCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHVuaXRQcm9wZXJ0aWVzICk7XFxuXFx0fTtcXG5cXG59O1xcblxcblxcblxcblxcbi8qKlxcbiAqIGNhdGVnb3JpZXMoKVxcbiAqXFxuICogUmV0dXJuIGFsbCB1bml0IGNhdGVnb3JpZXMuXFxuICovXFxudmFyIHVuaXRDYXRlZ29yaWVzID0gWyBcXFwiYWNjZWxlcmF0aW9uXFxcIiwgXFxcImFuZ2xlXFxcIiwgXFxcImFyZWFcXFwiLCBcXFwiZGlnaXRhbFxcXCIsIFxcXCJkdXJhdGlvblxcXCIsIFxcXCJsZW5ndGhcXFwiLCBcXFwibWFzc1xcXCIsIFxcXCJwb3dlclxcXCIsXFxuXFxcInByZXNzdXJlXFxcIiwgXFxcInNwZWVkXFxcIiwgXFxcInRlbXBlcmF0dXJlXFxcIiwgXFxcInZvbHVtZVxcXCIgXTtcXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBzdHJpcFBsdXJhbEdhcmJhZ2UoIGRhdGEgKSB7XFxuXFx0dmFyIGF1eCwgcGx1cmFsQ291bnQ7XFxuXFxuXFx0aWYgKCBkYXRhICkge1xcblxcdFxcdGF1eCA9IHt9O1xcblxcdFxcdGZvciAoIHBsdXJhbENvdW50IGluIGRhdGEgKSB7XFxuXFx0XFx0XFx0YXV4WyBwbHVyYWxDb3VudC5yZXBsYWNlKCAvdW5pdFBhdHRlcm4tY291bnQtLywgXFxcIlxcXCIgKSBdID0gZGF0YVsgcGx1cmFsQ291bnQgXTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBhdXg7XFxufVxcblxcbi8qKlxcbiAqIGdldCggdW5pdCwgZm9ybSwgY2xkciApXFxuICpcXG4gKiBAdW5pdCBbU3RyaW5nXSBUaGUgZnVsbCB0eXBlLXVuaXQgbmFtZSAoZWcuIGR1cmF0aW9uLXNlY29uZCksIG9yIHRoZSBzaG9ydCB1bml0IG5hbWVcXG4gKiAoZWcuIHNlY29uZCkuXFxuICpcXG4gKiBAZm9ybSBbU3RyaW5nXSBBIHN0cmluZyBkZXNjcmliaW5nIHRoZSBmb3JtIG9mIHRoZSB1bml0IHJlcHJlc2VudGF0aW9uIChlZy4gbG9uZyxcXG4gKiBzaG9ydCwgbmFycm93KS5cXG4gKlxcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cXG4gKlxcbiAqIFJldHVybiB0aGUgcGx1cmFsIG1hcCBvZiBhIHVuaXQsIGVnOiBcXFwic2Vjb25kXFxcIlxcbiAqIHsgXFxcIm9uZVxcXCI6IFxcXCJ7MH0gc2Vjb25kXFxcIixcXG4gKiAgIFxcXCJvdGhlclxcXCI6IFxcXCJ7MH0gc2Vjb25kc1xcXCIgfVxcbiAqIH1cXG4gKlxcbiAqIE9yIHRoZSBBcnJheSBvZiBwbHVyYWwgbWFwcyBvZiBhIGNvbXBvdW5kLXVuaXQsIGVnOiBcXFwiZm9vdC1wZXItc2Vjb25kXFxcIlxcbiAqIFsgeyBcXFwib25lXFxcIjogXFxcInswfSBmb290XFxcIixcXG4gKiAgICAgXFxcIm90aGVyXFxcIjogXFxcInswfSBmZWV0XFxcIiB9LFxcbiAqICAgeyBcXFwib25lXFxcIjogXFxcInswfSBzZWNvbmRcXFwiLFxcbiAqICAgICBcXFwib3RoZXJcXFwiOiBcXFwiezB9IHNlY29uZHNcXFwiIH0gXVxcbiAqXFxuICogVXNlcyB0aGUgcHJlY29tcHV0ZWQgZm9ybSBvZiBhIGNvbXBvdW5kLXVuaXQgaWYgYXZhaWxhYmxlLCBlZzogXFxcIm1pbGUtcGVyLWhvdXJcXFwiXFxuICogeyBcXFwiZGlzcGxheU5hbWVcXFwiOiBcXFwibWlsZXMgcGVyIGhvdXJcXFwiLFxcbiAqICAgIFxcXCJ1bml0UGF0dGVybi1jb3VudC1vbmVcXFwiOiBcXFwiezB9IG1pbGUgcGVyIGhvdXJcXFwiLFxcbiAqICAgIFxcXCJ1bml0UGF0dGVybi1jb3VudC1vdGhlclxcXCI6IFxcXCJ7MH0gbWlsZXMgcGVyIGhvdXJcXFwiXFxuICogfSxcXG4gKlxcbiAqIEFsc28gc3VwcG9ydHMgXFxcIi9cXFwiIGluc3RlYWQgb2YgXFxcIi1wZXItXFxcIiwgZWcuIFxcXCJmb290L3NlY29uZFxcXCIsIHVzaW5nIHRoZSBwcmVjb21wdXRlZCBmb3JtIGlmXFxuICogYXZhaWxhYmxlLlxcbiAqXFxuICogT3IgdGhlIEFycmF5IG9mIHBsdXJhbCBtYXBzIG9mIGEgY29tcG91bmQtdW5pdCwgZWc6IFxcXCJmb290LXBlci1zZWNvbmRcXFwiXFxuICogWyB7IFxcXCJvbmVcXFwiOiBcXFwiezB9IGZvb3RcXFwiLFxcbiAqICAgICBcXFwib3RoZXJcXFwiOiBcXFwiezB9IGZlZXRcXFwiIH0sXFxuICogICB7IFxcXCJvbmVcXFwiOiBcXFwiezB9IHNlY29uZFxcXCIsXFxuICogICAgIFxcXCJvdGhlclxcXCI6IFxcXCJ7MH0gc2Vjb25kc1xcXCIgfSBdXFxuICpcXG4gKiBPciB1bmRlZmluZWQgaW4gY2FzZSB0aGUgdW5pdCAob3IgYSB1bml0IG9mIHRoZSBjb21wb3VuZC11bml0KSBkb2Vzbid0IGV4aXN0LlxcbiAqL1xcbnZhciBnZXQgPSBmdW5jdGlvbiggdW5pdCwgZm9ybSwgY2xkciApIHtcXG5cXHR2YXIgcmV0O1xcblxcblxcdC8vIEVuc3VyZSB0aGF0IHdlIGdldCB0aGUgJ3ByZWNvbXB1dGVkJyBmb3JtLCBpZiBwcmVzZW50LlxcblxcdHVuaXQgPSB1bml0LnJlcGxhY2UoIC9cXFxcLy8sIFxcXCItcGVyLVxcXCIgKTtcXG5cXG5cXHQvLyBHZXQgdW5pdCBvciA8Y2F0ZWdvcnk+LXVuaXQgKGVnLiBcXFwiZHVyYXRpb24tc2Vjb25kXFxcIikuXFxuXFx0WyBcXFwiXFxcIiBdLmNvbmNhdCggdW5pdENhdGVnb3JpZXMgKS5zb21lKGZ1bmN0aW9uKCBjYXRlZ29yeSApIHtcXG5cXHRcXHRyZXR1cm4gcmV0ID0gY2xkci5tYWluKFtcXG5cXHRcXHRcXHRcXFwidW5pdHNcXFwiLFxcblxcdFxcdFxcdGZvcm0sXFxuXFx0XFx0XFx0Y2F0ZWdvcnkubGVuZ3RoID8gY2F0ZWdvcnkgKyBcXFwiLVxcXCIgKyB1bml0IDogdW5pdFxcblxcdFxcdF0pO1xcblxcdH0pO1xcblxcblxcdC8vIFJlbmFtZSBrZXlzIHMvdW5pdFBhdHRlcm4tY291bnQtLy9nLlxcblxcdHJldCA9IHN0cmlwUGx1cmFsR2FyYmFnZSggcmV0ICk7XFxuXFxuXFx0Ly8gQ29tcG91bmQgVW5pdCwgZWcuIFxcXCJmb290LXBlci1zZWNvbmRcXFwiIG9yIFxcXCJmb290L3NlY29uZFxcXCIuXFxuXFx0aWYgKCAhcmV0ICYmICggLy1wZXItLyApLnRlc3QoIHVuaXQgKSApIHtcXG5cXG5cXHRcXHQvLyBcXFwiU29tZSB1bml0cyBhbHJlYWR5IGhhdmUgJ3ByZWNvbXB1dGVkJyBmb3Jtcywgc3VjaCBhcyBraWxvbWV0ZXItcGVyLWhvdXI7XFxuXFx0XFx0Ly8gd2hlcmUgc3VjaCB1bml0cyBleGlzdCwgdGhleSBzaG91bGQgYmUgdXNlZCBpbiBwcmVmZXJlbmNlXFxcIiBVVFMjMzUuXFxuXFx0XFx0Ly8gTm90ZSB0aGF0IHByZWNvbXB1dGVkIGZvcm0gaGFzIGFscmVhZHkgYmVlbiBoYW5kbGVkIGFib3ZlICghcmV0KS5cXG5cXG5cXHRcXHQvLyBHZXQgYm90aCByZWN1cnNpdmVseS5cXG5cXHRcXHR1bml0ID0gdW5pdC5zcGxpdCggXFxcIi1wZXItXFxcIiApO1xcblxcdFxcdHJldCA9IHVuaXQubWFwKGZ1bmN0aW9uKCB1bml0ICkge1xcblxcdFxcdFxcdHJldHVybiBnZXQoIHVuaXQsIGZvcm0sIGNsZHIgKTtcXG5cXHRcXHR9KTtcXG5cXHRcXHRpZiAoICFyZXRbIDAgXSB8fCAhcmV0WyAxIF0gKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHJldDtcXG59O1xcblxcbnZhciB1bml0R2V0ID0gZ2V0O1xcblxcblxcblxcblxcbi8qKlxcbiAqIHByb3BlcnRpZXMoIHVuaXQsIGZvcm0sIGNsZHIgKVxcbiAqXFxuICogQHVuaXQgW1N0cmluZ10gVGhlIGZ1bGwgdHlwZS11bml0IG5hbWUgKGVnLiBkdXJhdGlvbi1zZWNvbmQpLCBvciB0aGUgc2hvcnQgdW5pdCBuYW1lXFxuICogKGVnLiBzZWNvbmQpLlxcbiAqXFxuICogQGZvcm0gW1N0cmluZ10gQSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZm9ybSBvZiB0aGUgdW5pdCByZXByZXNlbnRhdGlvbiAoZWcuIGxvbmcsXFxuICogc2hvcnQsIG5hcnJvdykuXFxuICpcXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXFxuICovXFxudmFyIHVuaXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHVuaXQsIGZvcm0sIGNsZHIgKSB7XFxuXFx0dmFyIGNvbXBvdW5kVW5pdFBhdHRlcm4sIHVuaXRQcm9wZXJ0aWVzO1xcblxcblxcdGNvbXBvdW5kVW5pdFBhdHRlcm4gPSBjbGRyLm1haW4oIFsgXFxcInVuaXRzXFxcIiwgZm9ybSwgXFxcInBlci9jb21wb3VuZFVuaXRQYXR0ZXJuXFxcIiBdICk7XFxuXFx0dW5pdFByb3BlcnRpZXMgPSB1bml0R2V0KCB1bml0LCBmb3JtLCBjbGRyICk7XFxuXFxuXFx0cmV0dXJuIHtcXG5cXHRcXHRjb21wb3VuZFVuaXRQYXR0ZXJuOiBjb21wb3VuZFVuaXRQYXR0ZXJuLFxcblxcdFxcdHVuaXRQcm9wZXJ0aWVzOiB1bml0UHJvcGVydGllc1xcblxcdH07XFxufTtcXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBHbG9iYWxpemUuZm9ybWF0VW5pdCggdmFsdWUsIHVuaXQsIG9wdGlvbnMgKVxcbiAqXFxuICogQHZhbHVlIFtOdW1iZXJdXFxuICpcXG4gKiBAdW5pdCBbU3RyaW5nXTogVGhlIHVuaXQgKGUuZyBcXFwic2Vjb25kXFxcIiwgXFxcImRheVxcXCIsIFxcXCJ5ZWFyXFxcIilcXG4gKlxcbiAqIEBvcHRpb25zIFtPYmplY3RdXFxuICogLSBmb3JtOiBbU3RyaW5nXSBcXFwibG9uZ1xcXCIsIFxcXCJzaG9ydFxcXCIgKGRlZmF1bHQpLCBvciBcXFwibmFycm93XFxcIi5cXG4gKlxcbiAqIEZvcm1hdCB1bml0cyBzdWNoIGFzIHNlY29uZHMsIG1pbnV0ZXMsIGRheXMsIHdlZWtzLCBldGMuXFxuICovXFxuR2xvYmFsaXplLmZvcm1hdFVuaXQgPVxcbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0VW5pdCA9IGZ1bmN0aW9uKCB2YWx1ZSwgdW5pdCwgb3B0aW9ucyApIHtcXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXFxcInZhbHVlXFxcIiApO1xcblxcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFxcXCJ2YWx1ZVxcXCIgKTtcXG5cXG5cXHRyZXR1cm4gdGhpcy51bml0Rm9ybWF0dGVyKCB1bml0LCBvcHRpb25zICkoIHZhbHVlICk7XFxufTtcXG5cXG4vKipcXG4gKiBHbG9iYWxpemUudW5pdEZvcm1hdHRlciggdW5pdCwgb3B0aW9ucyApXFxuICpcXG4gKiBAdW5pdCBbU3RyaW5nXTogVGhlIHVuaXQgKGUuZyBcXFwic2Vjb25kXFxcIiwgXFxcImRheVxcXCIsIFxcXCJ5ZWFyXFxcIilcXG4gKlxcbiAqIEBvcHRpb25zIFtPYmplY3RdXFxuICogLSBmb3JtOiBbU3RyaW5nXSBcXFwibG9uZ1xcXCIsIFxcXCJzaG9ydFxcXCIgKGRlZmF1bHQpLCBvciBcXFwibmFycm93XFxcIi5cXG4gKlxcbiAqIC0gbnVtYmVyRm9ybWF0dGVyOiBbRnVuY3Rpb25dIGEgbnVtYmVyIGZvcm1hdHRlciBmdW5jdGlvbi4gRGVmYXVsdHMgdG8gR2xvYmFsaXplXFxuICogICBgLm51bWJlckZvcm1hdHRlcigpYCBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlIHVzaW5nIHRoZSBkZWZhdWx0IG9wdGlvbnMuXFxuICovXFxuR2xvYmFsaXplLnVuaXRGb3JtYXR0ZXIgPVxcbkdsb2JhbGl6ZS5wcm90b3R5cGUudW5pdEZvcm1hdHRlciA9IGZ1bmN0aW9uKCB1bml0LCBvcHRpb25zICkge1xcblxcdHZhciBhcmdzLCBmb3JtLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcmV0dXJuRm4sIHByb3BlcnRpZXM7XFxuXFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdW5pdCwgXFxcInVuaXRcXFwiICk7XFxuXFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB1bml0LCBcXFwidW5pdFxcXCIgKTtcXG5cXG5cXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXFxcIm9wdGlvbnNcXFwiICk7XFxuXFxuXFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuXFx0YXJncyA9IFsgdW5pdCwgb3B0aW9ucyBdO1xcblxcdGZvcm0gPSBvcHRpb25zLmZvcm0gfHwgXFxcImxvbmdcXFwiO1xcblxcdHByb3BlcnRpZXMgPSB1bml0UHJvcGVydGllcyggdW5pdCwgZm9ybSwgdGhpcy5jbGRyICk7XFxuXFxuXFx0bnVtYmVyRm9ybWF0dGVyID0gb3B0aW9ucy5udW1iZXJGb3JtYXR0ZXIgfHwgdGhpcy5udW1iZXJGb3JtYXR0ZXIoKTtcXG5cXHRwbHVyYWxHZW5lcmF0b3IgPSB0aGlzLnBsdXJhbEdlbmVyYXRvcigpO1xcblxcdHJldHVybkZuID0gdW5pdEZvcm1hdHRlckZuKCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApO1xcblxcblxcdHJ1bnRpbWVCaW5kKCBhcmdzLCB0aGlzLmNsZHIsIHJldHVybkZuLCBbIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzIF0gKTtcXG5cXG5cXHRyZXR1cm4gcmV0dXJuRm47XFxufTtcXG5cXG5yZXR1cm4gR2xvYmFsaXplO1xcblxcblxcblxcblxcbn0pKTtcXG5cIiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///35\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(37))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLm1pbi5qcz82YjhiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcZmxhdHBpY2tyXFxcXGRpc3RcXFxcZmxhdHBpY2tyLm1pbi5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36\n")},function(module,exports){eval('module.exports = "/* flatpickr v4.6.3,, @license MIT */\\n!function(e,t){\\"object\\"==typeof exports&&\\"undefined\\"!=typeof module?module.exports=t():\\"function\\"==typeof define&&define.amd?define(t):(e=e||self).flatpickr=t()}(this,function(){\\"use strict\\";var e=function(){return(e=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)},t=[\\"onChange\\",\\"onClose\\",\\"onDayCreate\\",\\"onDestroy\\",\\"onKeyDown\\",\\"onMonthChange\\",\\"onOpen\\",\\"onParseConfig\\",\\"onReady\\",\\"onValueUpdate\\",\\"onYearChange\\",\\"onPreCalendarPosition\\"],n={_disable:[],_enable:[],allowInput:!1,altFormat:\\"F j, Y\\",altInput:!1,altInputClass:\\"form-control input\\",animate:\\"object\\"==typeof window&&-1===window.navigator.userAgent.indexOf(\\"MSIE\\"),ariaDateFormat:\\"F j, Y\\",clickOpens:!0,closeOnSelect:!0,conjunction:\\", \\",dateFormat:\\"Y-m-d\\",defaultHour:12,defaultMinute:0,defaultSeconds:0,disable:[],disableMobile:!1,enable:[],enableSeconds:!1,enableTime:!1,errorHandler:function(e){return\\"undefined\\"!=typeof console&&console.warn(e)},getWeek:function(e){var t=new Date(e.getTime());t.setHours(0,0,0,0),t.setDate(t.getDate()+3-(t.getDay()+6)%7);var n=new Date(t.getFullYear(),0,4);return 1+Math.round(((t.getTime()-n.getTime())/864e5-3+(n.getDay()+6)%7)/7)},hourIncrement:1,ignoredFocusElements:[],inline:!1,locale:\\"default\\",minuteIncrement:5,mode:\\"single\\",monthSelectorType:\\"dropdown\\",nextArrow:\\"<svg version=\'1.1\' xmlns=\'http://www.w3.org/2000/svg\' xmlns:xlink=\'http://www.w3.org/1999/xlink\' viewBox=\'0 0 17 17\'><g></g><path d=\'M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z\' /></svg>\\",noCalendar:!1,now:new Date,onChange:[],onClose:[],onDayCreate:[],onDestroy:[],onKeyDown:[],onMonthChange:[],onOpen:[],onParseConfig:[],onReady:[],onValueUpdate:[],onYearChange:[],onPreCalendarPosition:[],plugins:[],position:\\"auto\\",positionElement:void 0,prevArrow:\\"<svg version=\'1.1\' xmlns=\'http://www.w3.org/2000/svg\' xmlns:xlink=\'http://www.w3.org/1999/xlink\' viewBox=\'0 0 17 17\'><g></g><path d=\'M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z\' /></svg>\\",shorthandCurrentMonth:!1,showMonths:1,static:!1,time_24hr:!1,weekNumbers:!1,wrap:!1},a={weekdays:{shorthand:[\\"Sun\\",\\"Mon\\",\\"Tue\\",\\"Wed\\",\\"Thu\\",\\"Fri\\",\\"Sat\\"],longhand:[\\"Sunday\\",\\"Monday\\",\\"Tuesday\\",\\"Wednesday\\",\\"Thursday\\",\\"Friday\\",\\"Saturday\\"]},months:{shorthand:[\\"Jan\\",\\"Feb\\",\\"Mar\\",\\"Apr\\",\\"May\\",\\"Jun\\",\\"Jul\\",\\"Aug\\",\\"Sep\\",\\"Oct\\",\\"Nov\\",\\"Dec\\"],longhand:[\\"January\\",\\"February\\",\\"March\\",\\"April\\",\\"May\\",\\"June\\",\\"July\\",\\"August\\",\\"September\\",\\"October\\",\\"November\\",\\"December\\"]},daysInMonth:[31,28,31,30,31,30,31,31,30,31,30,31],firstDayOfWeek:0,ordinal:function(e){var t=e%100;if(t>3&&t<21)return\\"th\\";switch(t%10){case 1:return\\"st\\";case 2:return\\"nd\\";case 3:return\\"rd\\";default:return\\"th\\"}},rangeSeparator:\\" to \\",weekAbbreviation:\\"Wk\\",scrollTitle:\\"Scroll to increment\\",toggleTitle:\\"Click to toggle\\",amPM:[\\"AM\\",\\"PM\\"],yearAriaLabel:\\"Year\\",hourAriaLabel:\\"Hour\\",minuteAriaLabel:\\"Minute\\",time_24hr:!1},i=function(e){return(\\"0\\"+e).slice(-2)},o=function(e){return!0===e?1:0};function r(e,t,n){var a;return void 0===n&&(n=!1),function(){var i=this,o=arguments;null!==a&&clearTimeout(a),a=window.setTimeout(function(){a=null,n||e.apply(i,o)},t),n&&!a&&e.apply(i,o)}}var l=function(e){return e instanceof Array?e:[e]};function c(e,t,n){if(!0===n)return e.classList.add(t);e.classList.remove(t)}function d(e,t,n){var a=window.document.createElement(e);return t=t||\\"\\",n=n||\\"\\",a.className=t,void 0!==n&&(a.textContent=n),a}function s(e){for(;e.firstChild;)e.removeChild(e.firstChild)}function u(e,t){var n=d(\\"div\\",\\"numInputWrapper\\"),a=d(\\"input\\",\\"numInput \\"+e),i=d(\\"span\\",\\"arrowUp\\"),o=d(\\"span\\",\\"arrowDown\\");if(-1===navigator.userAgent.indexOf(\\"MSIE 9.0\\")?a.type=\\"number\\":(a.type=\\"text\\",a.pattern=\\"\\\\\\\\d*\\"),void 0!==t)for(var r in t)a.setAttribute(r,t[r]);return n.appendChild(a),n.appendChild(i),n.appendChild(o),n}var f=function(){},m=function(e,t,n){return n.months[t?\\"shorthand\\":\\"longhand\\"][e]},g={D:f,F:function(e,t,n){e.setMonth(n.months.longhand.indexOf(t))},G:function(e,t){e.setHours(parseFloat(t))},H:function(e,t){e.setHours(parseFloat(t))},J:function(e,t){e.setDate(parseFloat(t))},K:function(e,t,n){e.setHours(e.getHours()%12+12*o(new RegExp(n.amPM[1],\\"i\\").test(t)))},M:function(e,t,n){e.setMonth(n.months.shorthand.indexOf(t))},S:function(e,t){e.setSeconds(parseFloat(t))},U:function(e,t){return new Date(1e3*parseFloat(t))},W:function(e,t,n){var a=parseInt(t),i=new Date(e.getFullYear(),0,2+7*(a-1),0,0,0,0);return i.setDate(i.getDate()-i.getDay()+n.firstDayOfWeek),i},Y:function(e,t){e.setFullYear(parseFloat(t))},Z:function(e,t){return new Date(t)},d:function(e,t){e.setDate(parseFloat(t))},h:function(e,t){e.setHours(parseFloat(t))},i:function(e,t){e.setMinutes(parseFloat(t))},j:function(e,t){e.setDate(parseFloat(t))},l:f,m:function(e,t){e.setMonth(parseFloat(t)-1)},n:function(e,t){e.setMonth(parseFloat(t)-1)},s:function(e,t){e.setSeconds(parseFloat(t))},u:function(e,t){return new Date(parseFloat(t))},w:f,y:function(e,t){e.setFullYear(2e3+parseFloat(t))}},p={D:\\"(\\\\\\\\w+)\\",F:\\"(\\\\\\\\w+)\\",G:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",H:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",J:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\\\\\\\w+\\",K:\\"\\",M:\\"(\\\\\\\\w+)\\",S:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",U:\\"(.+)\\",W:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",Y:\\"(\\\\\\\\d{4})\\",Z:\\"(.+)\\",d:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",h:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",i:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",j:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",l:\\"(\\\\\\\\w+)\\",m:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",n:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",s:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",u:\\"(.+)\\",w:\\"(\\\\\\\\d\\\\\\\\d|\\\\\\\\d)\\",y:\\"(\\\\\\\\d{2})\\"},h={Z:function(e){return e.toISOString()},D:function(e,t,n){return t.weekdays.shorthand[h.w(e,t,n)]},F:function(e,t,n){return m(h.n(e,t,n)-1,!1,t)},G:function(e,t,n){return i(h.h(e,t,n))},H:function(e){return i(e.getHours())},J:function(e,t){return void 0!==t.ordinal?e.getDate()+t.ordinal(e.getDate()):e.getDate()},K:function(e,t){return t.amPM[o(e.getHours()>11)]},M:function(e,t){return m(e.getMonth(),!0,t)},S:function(e){return i(e.getSeconds())},U:function(e){return e.getTime()/1e3},W:function(e,t,n){return n.getWeek(e)},Y:function(e){return e.getFullYear()},d:function(e){return i(e.getDate())},h:function(e){return e.getHours()%12?e.getHours()%12:12},i:function(e){return i(e.getMinutes())},j:function(e){return e.getDate()},l:function(e,t){return t.weekdays.longhand[e.getDay()]},m:function(e){return i(e.getMonth()+1)},n:function(e){return e.getMonth()+1},s:function(e){return e.getSeconds()},u:function(e){return e.getTime()},w:function(e){return e.getDay()},y:function(e){return String(e.getFullYear()).substring(2)}},v=function(e){var t=e.config,i=void 0===t?n:t,o=e.l10n,r=void 0===o?a:o;return function(e,t,n){var a=n||r;return void 0!==i.formatDate?i.formatDate(e,t,a):t.split(\\"\\").map(function(t,n,o){return h[t]&&\\"\\\\\\\\\\"!==o[n-1]?h[t](e,a,i):\\"\\\\\\\\\\"!==t?t:\\"\\"}).join(\\"\\")}},D=function(e){var t=e.config,i=void 0===t?n:t,o=e.l10n,r=void 0===o?a:o;return function(e,t,a,o){if(0===e||e){var l,c=o||r,d=e;if(e instanceof Date)l=new Date(e.getTime());else if(\\"string\\"!=typeof e&&void 0!==e.toFixed)l=new Date(e);else if(\\"string\\"==typeof e){var s=t||(i||n).dateFormat,u=String(e).trim();if(\\"today\\"===u)l=new Date,a=!0;else if(/Z$/.test(u)||/GMT$/.test(u))l=new Date(e);else if(i&&i.parseDate)l=i.parseDate(e,s);else{l=i&&i.noCalendar?new Date((new Date).setHours(0,0,0,0)):new Date((new Date).getFullYear(),0,1,0,0,0,0);for(var f=void 0,m=[],h=0,v=0,D=\\"\\";h<s.length;h++){var w=s[h],b=\\"\\\\\\\\\\"===w,C=\\"\\\\\\\\\\"===s[h-1]||b;if(p[w]&&!C){D+=p[w];var M=new RegExp(D).exec(e);M&&(f=!0)&&m[\\"Y\\"!==w?\\"push\\":\\"unshift\\"]({fn:g[w],val:M[++v]})}else b||(D+=\\".\\");m.forEach(function(e){var t=e.fn,n=e.val;return l=t(l,n,c)||l})}l=f?l:void 0}}if(l instanceof Date&&!isNaN(l.getTime()))return!0===a&&l.setHours(0,0,0,0),l;i.errorHandler(new Error(\\"Invalid date provided: \\"+d))}}};function w(e,t,n){return void 0===n&&(n=!0),!1!==n?new Date(e.getTime()).setHours(0,0,0,0)-new Date(t.getTime()).setHours(0,0,0,0):e.getTime()-t.getTime()}var b=function(e,t,n){return e>Math.min(t,n)&&e<Math.max(t,n)},C={DAY:864e5};\\"function\\"!=typeof Object.assign&&(Object.assign=function(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];if(!e)throw TypeError(\\"Cannot convert undefined or null to object\\");for(var a=function(t){t&&Object.keys(t).forEach(function(n){return e[n]=t[n]})},i=0,o=t;i<o.length;i++){a(o[i])}return e});var M=300;function y(f,g){var h={config:e({},n,E.defaultConfig),l10n:a};function y(e){return e.bind(h)}function x(){var e=h.config;!1===e.weekNumbers&&1===e.showMonths||!0!==e.noCalendar&&window.requestAnimationFrame(function(){if(void 0!==h.calendarContainer&&(h.calendarContainer.style.visibility=\\"hidden\\",h.calendarContainer.style.display=\\"block\\"),void 0!==h.daysContainer){var t=(h.days.offsetWidth+1)*e.showMonths;h.daysContainer.style.width=t+\\"px\\",h.calendarContainer.style.width=t+(void 0!==h.weekWrapper?h.weekWrapper.offsetWidth:0)+\\"px\\",h.calendarContainer.style.removeProperty(\\"visibility\\"),h.calendarContainer.style.removeProperty(\\"display\\")}})}function T(e){0===h.selectedDates.length&&ie(),void 0!==e&&\\"blur\\"!==e.type&&function(e){e.preventDefault();var t=\\"keydown\\"===e.type,n=e.target;void 0!==h.amPM&&e.target===h.amPM&&(h.amPM.textContent=h.l10n.amPM[o(h.amPM.textContent===h.l10n.amPM[0])]);var a=parseFloat(n.getAttribute(\\"min\\")),r=parseFloat(n.getAttribute(\\"max\\")),l=parseFloat(n.getAttribute(\\"step\\")),c=parseInt(n.value,10),d=e.delta||(t?38===e.which?1:-1:0),s=c+l*d;if(void 0!==n.value&&2===n.value.length){var u=n===h.hourElement,f=n===h.minuteElement;s<a?(s=r+s+o(!u)+(o(u)&&o(!h.amPM)),f&&j(void 0,-1,h.hourElement)):s>r&&(s=n===h.hourElement?s-r-o(!h.amPM):a,f&&j(void 0,1,h.hourElement)),h.amPM&&u&&(1===l?s+c===23:Math.abs(s-c)>l)&&(h.amPM.textContent=h.l10n.amPM[o(h.amPM.textContent===h.l10n.amPM[0])]),n.value=i(s)}}(e);var t=h._input.value;k(),we(),h._input.value!==t&&h._debouncedChange()}function k(){if(void 0!==h.hourElement&&void 0!==h.minuteElement){var e,t,n=(parseInt(h.hourElement.value.slice(-2),10)||0)%24,a=(parseInt(h.minuteElement.value,10)||0)%60,i=void 0!==h.secondElement?(parseInt(h.secondElement.value,10)||0)%60:0;void 0!==h.amPM&&(e=n,t=h.amPM.textContent,n=e%12+12*o(t===h.l10n.amPM[1]));var r=void 0!==h.config.minTime||h.config.minDate&&h.minDateHasTime&&h.latestSelectedDateObj&&0===w(h.latestSelectedDateObj,h.config.minDate,!0);if(void 0!==h.config.maxTime||h.config.maxDate&&h.maxDateHasTime&&h.latestSelectedDateObj&&0===w(h.latestSelectedDateObj,h.config.maxDate,!0)){var l=void 0!==h.config.maxTime?h.config.maxTime:h.config.maxDate;(n=Math.min(n,l.getHours()))===l.getHours()&&(a=Math.min(a,l.getMinutes())),a===l.getMinutes()&&(i=Math.min(i,l.getSeconds()))}if(r){var c=void 0!==h.config.minTime?h.config.minTime:h.config.minDate;(n=Math.max(n,c.getHours()))===c.getHours()&&(a=Math.max(a,c.getMinutes())),a===c.getMinutes()&&(i=Math.max(i,c.getSeconds()))}O(n,a,i)}}function I(e){var t=e||h.latestSelectedDateObj;t&&O(t.getHours(),t.getMinutes(),t.getSeconds())}function S(){var e=h.config.defaultHour,t=h.config.defaultMinute,n=h.config.defaultSeconds;if(void 0!==h.config.minDate){var a=h.config.minDate.getHours(),i=h.config.minDate.getMinutes();(e=Math.max(e,a))===a&&(t=Math.max(i,t)),e===a&&t===i&&(n=h.config.minDate.getSeconds())}if(void 0!==h.config.maxDate){var o=h.config.maxDate.getHours(),r=h.config.maxDate.getMinutes();(e=Math.min(e,o))===o&&(t=Math.min(r,t)),e===o&&t===r&&(n=h.config.maxDate.getSeconds())}O(e,t,n)}function O(e,t,n){void 0!==h.latestSelectedDateObj&&h.latestSelectedDateObj.setHours(e%24,t,n||0,0),h.hourElement&&h.minuteElement&&!h.isMobile&&(h.hourElement.value=i(h.config.time_24hr?e:(12+e)%12+12*o(e%12==0)),h.minuteElement.value=i(t),void 0!==h.amPM&&(h.amPM.textContent=h.l10n.amPM[o(e>=12)]),void 0!==h.secondElement&&(h.secondElement.value=i(n)))}function _(e){var t=parseInt(e.target.value)+(e.delta||0);(t/1e3>1||\\"Enter\\"===e.key&&!/[^\\\\d]/.test(t.toString()))&&Q(t)}function F(e,t,n,a){return t instanceof Array?t.forEach(function(t){return F(e,t,n,a)}):e instanceof Array?e.forEach(function(e){return F(e,t,n,a)}):(e.addEventListener(t,n,a),void h._handlers.push({element:e,event:t,handler:n,options:a}))}function N(e){return function(t){1===t.which&&e(t)}}function Y(){ge(\\"onChange\\")}function A(e,t){var n=void 0!==e?h.parseDate(e):h.latestSelectedDateObj||(h.config.minDate&&h.config.minDate>h.now?h.config.minDate:h.config.maxDate&&h.config.maxDate<h.now?h.config.maxDate:h.now),a=h.currentYear,i=h.currentMonth;try{void 0!==n&&(h.currentYear=n.getFullYear(),h.currentMonth=n.getMonth())}catch(e){e.message=\\"Invalid date supplied: \\"+n,h.config.errorHandler(e)}t&&h.currentYear!==a&&(ge(\\"onYearChange\\"),K()),!t||h.currentYear===a&&h.currentMonth===i||ge(\\"onMonthChange\\"),h.redraw()}function P(e){~e.target.className.indexOf(\\"arrow\\")&&j(e,e.target.classList.contains(\\"arrowUp\\")?1:-1)}function j(e,t,n){var a=e&&e.target,i=n||a&&a.parentNode&&a.parentNode.firstChild,o=pe(\\"increment\\");o.delta=t,i&&i.dispatchEvent(o)}function H(e,t,n,a){var i=X(t,!0),o=d(\\"span\\",\\"flatpickr-day \\"+e,t.getDate().toString());return o.dateObj=t,o.$i=a,o.setAttribute(\\"aria-label\\",h.formatDate(t,h.config.ariaDateFormat)),-1===e.indexOf(\\"hidden\\")&&0===w(t,h.now)&&(h.todayDateElem=o,o.classList.add(\\"today\\"),o.setAttribute(\\"aria-current\\",\\"date\\")),i?(o.tabIndex=-1,he(t)&&(o.classList.add(\\"selected\\"),h.selectedDateElem=o,\\"range\\"===h.config.mode&&(c(o,\\"startRange\\",h.selectedDates[0]&&0===w(t,h.selectedDates[0],!0)),c(o,\\"endRange\\",h.selectedDates[1]&&0===w(t,h.selectedDates[1],!0)),\\"nextMonthDay\\"===e&&o.classList.add(\\"inRange\\")))):o.classList.add(\\"flatpickr-disabled\\"),\\"range\\"===h.config.mode&&function(e){return!(\\"range\\"!==h.config.mode||h.selectedDates.length<2)&&w(e,h.selectedDates[0])>=0&&w(e,h.selectedDates[1])<=0}(t)&&!he(t)&&o.classList.add(\\"inRange\\"),h.weekNumbers&&1===h.config.showMonths&&\\"prevMonthDay\\"!==e&&n%7==1&&h.weekNumbers.insertAdjacentHTML(\\"beforeend\\",\\"<span class=\'flatpickr-day\'>\\"+h.config.getWeek(t)+\\"</span>\\"),ge(\\"onDayCreate\\",o),o}function L(e){e.focus(),\\"range\\"===h.config.mode&&ne(e)}function W(e){for(var t=e>0?0:h.config.showMonths-1,n=e>0?h.config.showMonths:-1,a=t;a!=n;a+=e)for(var i=h.daysContainer.children[a],o=e>0?0:i.children.length-1,r=e>0?i.children.length:-1,l=o;l!=r;l+=e){var c=i.children[l];if(-1===c.className.indexOf(\\"hidden\\")&&X(c.dateObj))return c}}function R(e,t){var n=ee(document.activeElement||document.body),a=void 0!==e?e:n?document.activeElement:void 0!==h.selectedDateElem&&ee(h.selectedDateElem)?h.selectedDateElem:void 0!==h.todayDateElem&&ee(h.todayDateElem)?h.todayDateElem:W(t>0?1:-1);return void 0===a?h._input.focus():n?void function(e,t){for(var n=-1===e.className.indexOf(\\"Month\\")?e.dateObj.getMonth():h.currentMonth,a=t>0?h.config.showMonths:-1,i=t>0?1:-1,o=n-h.currentMonth;o!=a;o+=i)for(var r=h.daysContainer.children[o],l=n-h.currentMonth===o?e.$i+t:t<0?r.children.length-1:0,c=r.children.length,d=l;d>=0&&d<c&&d!=(t>0?c:-1);d+=i){var s=r.children[d];if(-1===s.className.indexOf(\\"hidden\\")&&X(s.dateObj)&&Math.abs(e.$i-d)>=Math.abs(t))return L(s)}h.changeMonth(i),R(W(i),0)}(a,t):L(a)}function B(e,t){for(var n=(new Date(e,t,1).getDay()-h.l10n.firstDayOfWeek+7)%7,a=h.utils.getDaysInMonth((t-1+12)%12),i=h.utils.getDaysInMonth(t),o=window.document.createDocumentFragment(),r=h.config.showMonths>1,l=r?\\"prevMonthDay hidden\\":\\"prevMonthDay\\",c=r?\\"nextMonthDay hidden\\":\\"nextMonthDay\\",s=a+1-n,u=0;s<=a;s++,u++)o.appendChild(H(l,new Date(e,t-1,s),s,u));for(s=1;s<=i;s++,u++)o.appendChild(H(\\"\\",new Date(e,t,s),s,u));for(var f=i+1;f<=42-n&&(1===h.config.showMonths||u%7!=0);f++,u++)o.appendChild(H(c,new Date(e,t+1,f%i),f,u));var m=d(\\"div\\",\\"dayContainer\\");return m.appendChild(o),m}function J(){if(void 0!==h.daysContainer){s(h.daysContainer),h.weekNumbers&&s(h.weekNumbers);for(var e=document.createDocumentFragment(),t=0;t<h.config.showMonths;t++){var n=new Date(h.currentYear,h.currentMonth,1);n.setMonth(h.currentMonth+t),e.appendChild(B(n.getFullYear(),n.getMonth()))}h.daysContainer.appendChild(e),h.days=h.daysContainer.firstChild,\\"range\\"===h.config.mode&&1===h.selectedDates.length&&ne()}}function K(){if(!(h.config.showMonths>1||\\"dropdown\\"!==h.config.monthSelectorType)){var e=function(e){return!(void 0!==h.config.minDate&&h.currentYear===h.config.minDate.getFullYear()&&e<h.config.minDate.getMonth())&&!(void 0!==h.config.maxDate&&h.currentYear===h.config.maxDate.getFullYear()&&e>h.config.maxDate.getMonth())};h.monthsDropdownContainer.tabIndex=-1,h.monthsDropdownContainer.innerHTML=\\"\\";for(var t=0;t<12;t++)if(e(t)){var n=d(\\"option\\",\\"flatpickr-monthDropdown-month\\");n.value=new Date(h.currentYear,t).getMonth().toString(),n.textContent=m(t,h.config.shorthandCurrentMonth,h.l10n),n.tabIndex=-1,h.currentMonth===t&&(n.selected=!0),h.monthsDropdownContainer.appendChild(n)}}}function U(){var e,t=d(\\"div\\",\\"flatpickr-month\\"),n=window.document.createDocumentFragment();h.config.showMonths>1||\\"static\\"===h.config.monthSelectorType?e=d(\\"span\\",\\"cur-month\\"):(h.monthsDropdownContainer=d(\\"select\\",\\"flatpickr-monthDropdown-months\\"),F(h.monthsDropdownContainer,\\"change\\",function(e){var t=e.target,n=parseInt(t.value,10);h.changeMonth(n-h.currentMonth),ge(\\"onMonthChange\\")}),K(),e=h.monthsDropdownContainer);var a=u(\\"cur-year\\",{tabindex:\\"-1\\"}),i=a.getElementsByTagName(\\"input\\")[0];i.setAttribute(\\"aria-label\\",h.l10n.yearAriaLabel),h.config.minDate&&i.setAttribute(\\"min\\",h.config.minDate.getFullYear().toString()),h.config.maxDate&&(i.setAttribute(\\"max\\",h.config.maxDate.getFullYear().toString()),i.disabled=!!h.config.minDate&&h.config.minDate.getFullYear()===h.config.maxDate.getFullYear());var o=d(\\"div\\",\\"flatpickr-current-month\\");return o.appendChild(e),o.appendChild(a),n.appendChild(o),t.appendChild(n),{container:t,yearElement:i,monthElement:e}}function q(){s(h.monthNav),h.monthNav.appendChild(h.prevMonthNav),h.config.showMonths&&(h.yearElements=[],h.monthElements=[]);for(var e=h.config.showMonths;e--;){var t=U();h.yearElements.push(t.yearElement),h.monthElements.push(t.monthElement),h.monthNav.appendChild(t.container)}h.monthNav.appendChild(h.nextMonthNav)}function $(){h.weekdayContainer?s(h.weekdayContainer):h.weekdayContainer=d(\\"div\\",\\"flatpickr-weekdays\\");for(var e=h.config.showMonths;e--;){var t=d(\\"div\\",\\"flatpickr-weekdaycontainer\\");h.weekdayContainer.appendChild(t)}return z(),h.weekdayContainer}function z(){if(h.weekdayContainer){var e=h.l10n.firstDayOfWeek,t=h.l10n.weekdays.shorthand.slice();e>0&&e<t.length&&(t=t.splice(e,t.length).concat(t.splice(0,e)));for(var n=h.config.showMonths;n--;)h.weekdayContainer.children[n].innerHTML=\\"\\\\n      <span class=\'flatpickr-weekday\'>\\\\n        \\"+t.join(\\"</span><span class=\'flatpickr-weekday\'>\\")+\\"\\\\n      </span>\\\\n      \\"}}function G(e,t){void 0===t&&(t=!0);var n=t?e:e-h.currentMonth;n<0&&!0===h._hidePrevMonthArrow||n>0&&!0===h._hideNextMonthArrow||(h.currentMonth+=n,(h.currentMonth<0||h.currentMonth>11)&&(h.currentYear+=h.currentMonth>11?1:-1,h.currentMonth=(h.currentMonth+12)%12,ge(\\"onYearChange\\"),K()),J(),ge(\\"onMonthChange\\"),ve())}function V(e){return!(!h.config.appendTo||!h.config.appendTo.contains(e))||h.calendarContainer.contains(e)}function Z(e){if(h.isOpen&&!h.config.inline){var t=\\"function\\"==typeof(r=e).composedPath?r.composedPath()[0]:r.target,n=V(t),a=t===h.input||t===h.altInput||h.element.contains(t)||e.path&&e.path.indexOf&&(~e.path.indexOf(h.input)||~e.path.indexOf(h.altInput)),i=\\"blur\\"===e.type?a&&e.relatedTarget&&!V(e.relatedTarget):!a&&!n&&!V(e.relatedTarget),o=!h.config.ignoredFocusElements.some(function(e){return e.contains(t)});i&&o&&(void 0!==h.timeContainer&&void 0!==h.minuteElement&&void 0!==h.hourElement&&T(),h.close(),\\"range\\"===h.config.mode&&1===h.selectedDates.length&&(h.clear(!1),h.redraw()))}var r}function Q(e){if(!(!e||h.config.minDate&&e<h.config.minDate.getFullYear()||h.config.maxDate&&e>h.config.maxDate.getFullYear())){var t=e,n=h.currentYear!==t;h.currentYear=t||h.currentYear,h.config.maxDate&&h.currentYear===h.config.maxDate.getFullYear()?h.currentMonth=Math.min(h.config.maxDate.getMonth(),h.currentMonth):h.config.minDate&&h.currentYear===h.config.minDate.getFullYear()&&(h.currentMonth=Math.max(h.config.minDate.getMonth(),h.currentMonth)),n&&(h.redraw(),ge(\\"onYearChange\\"),K())}}function X(e,t){void 0===t&&(t=!0);var n=h.parseDate(e,void 0,t);if(h.config.minDate&&n&&w(n,h.config.minDate,void 0!==t?t:!h.minDateHasTime)<0||h.config.maxDate&&n&&w(n,h.config.maxDate,void 0!==t?t:!h.maxDateHasTime)>0)return!1;if(0===h.config.enable.length&&0===h.config.disable.length)return!0;if(void 0===n)return!1;for(var a=h.config.enable.length>0,i=a?h.config.enable:h.config.disable,o=0,r=void 0;o<i.length;o++){if(\\"function\\"==typeof(r=i[o])&&r(n))return a;if(r instanceof Date&&void 0!==n&&r.getTime()===n.getTime())return a;if(\\"string\\"==typeof r&&void 0!==n){var l=h.parseDate(r,void 0,!0);return l&&l.getTime()===n.getTime()?a:!a}if(\\"object\\"==typeof r&&void 0!==n&&r.from&&r.to&&n.getTime()>=r.from.getTime()&&n.getTime()<=r.to.getTime())return a}return!a}function ee(e){return void 0!==h.daysContainer&&(-1===e.className.indexOf(\\"hidden\\")&&h.daysContainer.contains(e))}function te(e){var t=e.target===h._input,n=h.config.allowInput,a=h.isOpen&&(!n||!t),i=h.config.inline&&t&&!n;if(13===e.keyCode&&t){if(n)return h.setDate(h._input.value,!0,e.target===h.altInput?h.config.altFormat:h.config.dateFormat),e.target.blur();h.open()}else if(V(e.target)||a||i){var o=!!h.timeContainer&&h.timeContainer.contains(e.target);switch(e.keyCode){case 13:o?(e.preventDefault(),T(),de()):se(e);break;case 27:e.preventDefault(),de();break;case 8:case 46:t&&!h.config.allowInput&&(e.preventDefault(),h.clear());break;case 37:case 39:if(o||t)h.hourElement&&h.hourElement.focus();else if(e.preventDefault(),void 0!==h.daysContainer&&(!1===n||document.activeElement&&ee(document.activeElement))){var r=39===e.keyCode?1:-1;e.ctrlKey?(e.stopPropagation(),G(r),R(W(1),0)):R(void 0,r)}break;case 38:case 40:e.preventDefault();var l=40===e.keyCode?1:-1;h.daysContainer&&void 0!==e.target.$i||e.target===h.input||e.target===h.altInput?e.ctrlKey?(e.stopPropagation(),Q(h.currentYear-l),R(W(1),0)):o||R(void 0,7*l):e.target===h.currentYearElement?Q(h.currentYear-l):h.config.enableTime&&(!o&&h.hourElement&&h.hourElement.focus(),T(e),h._debouncedChange());break;case 9:if(o){var c=[h.hourElement,h.minuteElement,h.secondElement,h.amPM].concat(h.pluginElements).filter(function(e){return e}),d=c.indexOf(e.target);if(-1!==d){var s=c[d+(e.shiftKey?-1:1)];e.preventDefault(),(s||h._input).focus()}}else!h.config.noCalendar&&h.daysContainer&&h.daysContainer.contains(e.target)&&e.shiftKey&&(e.preventDefault(),h._input.focus())}}if(void 0!==h.amPM&&e.target===h.amPM)switch(e.key){case h.l10n.amPM[0].charAt(0):case h.l10n.amPM[0].charAt(0).toLowerCase():h.amPM.textContent=h.l10n.amPM[0],k(),we();break;case h.l10n.amPM[1].charAt(0):case h.l10n.amPM[1].charAt(0).toLowerCase():h.amPM.textContent=h.l10n.amPM[1],k(),we()}(t||V(e.target))&&ge(\\"onKeyDown\\",e)}function ne(e){if(1===h.selectedDates.length&&(!e||e.classList.contains(\\"flatpickr-day\\")&&!e.classList.contains(\\"flatpickr-disabled\\"))){for(var t=e?e.dateObj.getTime():h.days.firstElementChild.dateObj.getTime(),n=h.parseDate(h.selectedDates[0],void 0,!0).getTime(),a=Math.min(t,h.selectedDates[0].getTime()),i=Math.max(t,h.selectedDates[0].getTime()),o=!1,r=0,l=0,c=a;c<i;c+=C.DAY)X(new Date(c),!0)||(o=o||c>a&&c<i,c<n&&(!r||c>r)?r=c:c>n&&(!l||c<l)&&(l=c));for(var d=0;d<h.config.showMonths;d++)for(var s=h.daysContainer.children[d],u=function(a,i){var c=s.children[a],d=c.dateObj.getTime(),u=r>0&&d<r||l>0&&d>l;return u?(c.classList.add(\\"notAllowed\\"),[\\"inRange\\",\\"startRange\\",\\"endRange\\"].forEach(function(e){c.classList.remove(e)}),\\"continue\\"):o&&!u?\\"continue\\":([\\"startRange\\",\\"inRange\\",\\"endRange\\",\\"notAllowed\\"].forEach(function(e){c.classList.remove(e)}),void(void 0!==e&&(e.classList.add(t<=h.selectedDates[0].getTime()?\\"startRange\\":\\"endRange\\"),n<t&&d===n?c.classList.add(\\"startRange\\"):n>t&&d===n&&c.classList.add(\\"endRange\\"),d>=r&&(0===l||d<=l)&&b(d,n,t)&&c.classList.add(\\"inRange\\"))))},f=0,m=s.children.length;f<m;f++)u(f)}}function ae(){!h.isOpen||h.config.static||h.config.inline||le()}function ie(){h.setDate(void 0!==h.config.minDate?new Date(h.config.minDate.getTime()):new Date,!0),S(),we()}function oe(e){return function(t){var n=h.config[\\"_\\"+e+\\"Date\\"]=h.parseDate(t,h.config.dateFormat),a=h.config[\\"_\\"+(\\"min\\"===e?\\"max\\":\\"min\\")+\\"Date\\"];void 0!==n&&(h[\\"min\\"===e?\\"minDateHasTime\\":\\"maxDateHasTime\\"]=n.getHours()>0||n.getMinutes()>0||n.getSeconds()>0),h.selectedDates&&(h.selectedDates=h.selectedDates.filter(function(e){return X(e)}),h.selectedDates.length||\\"min\\"!==e||I(n),we()),h.daysContainer&&(ce(),void 0!==n?h.currentYearElement[e]=n.getFullYear().toString():h.currentYearElement.removeAttribute(e),h.currentYearElement.disabled=!!a&&void 0!==n&&a.getFullYear()===n.getFullYear())}}function re(){\\"object\\"!=typeof h.config.locale&&void 0===E.l10ns[h.config.locale]&&h.config.errorHandler(new Error(\\"flatpickr: invalid locale \\"+h.config.locale)),h.l10n=e({},E.l10ns.default,\\"object\\"==typeof h.config.locale?h.config.locale:\\"default\\"!==h.config.locale?E.l10ns[h.config.locale]:void 0),p.K=\\"(\\"+h.l10n.amPM[0]+\\"|\\"+h.l10n.amPM[1]+\\"|\\"+h.l10n.amPM[0].toLowerCase()+\\"|\\"+h.l10n.amPM[1].toLowerCase()+\\")\\",void 0===e({},g,JSON.parse(JSON.stringify(f.dataset||{}))).time_24hr&&void 0===E.defaultConfig.time_24hr&&(h.config.time_24hr=h.l10n.time_24hr),h.formatDate=v(h),h.parseDate=D({config:h.config,l10n:h.l10n})}function le(e){if(void 0!==h.calendarContainer){ge(\\"onPreCalendarPosition\\");var t=e||h._positionElement,n=Array.prototype.reduce.call(h.calendarContainer.children,function(e,t){return e+t.offsetHeight},0),a=h.calendarContainer.offsetWidth,i=h.config.position.split(\\" \\"),o=i[0],r=i.length>1?i[1]:null,l=t.getBoundingClientRect(),d=window.innerHeight-l.bottom,s=\\"above\\"===o||\\"below\\"!==o&&d<n&&l.top>n,u=window.pageYOffset+l.top+(s?-n-2:t.offsetHeight+2);if(c(h.calendarContainer,\\"arrowTop\\",!s),c(h.calendarContainer,\\"arrowBottom\\",s),!h.config.inline){var f=window.pageXOffset+l.left-(null!=r&&\\"center\\"===r?(a-l.width)/2:0),m=window.document.body.offsetWidth-(window.pageXOffset+l.right),g=f+a>window.document.body.offsetWidth,p=m+a>window.document.body.offsetWidth;if(c(h.calendarContainer,\\"rightMost\\",g),!h.config.static)if(h.calendarContainer.style.top=u+\\"px\\",g)if(p){var v=document.styleSheets[0];if(void 0===v)return;var D=window.document.body.offsetWidth,w=Math.max(0,D/2-a/2),b=v.cssRules.length,C=\\"{left:\\"+l.left+\\"px;right:auto;}\\";c(h.calendarContainer,\\"rightMost\\",!1),c(h.calendarContainer,\\"centerMost\\",!0),v.insertRule(\\".flatpickr-calendar.centerMost:before,.flatpickr-calendar.centerMost:after\\"+C,b),h.calendarContainer.style.left=w+\\"px\\",h.calendarContainer.style.right=\\"auto\\"}else h.calendarContainer.style.left=\\"auto\\",h.calendarContainer.style.right=m+\\"px\\";else h.calendarContainer.style.left=f+\\"px\\",h.calendarContainer.style.right=\\"auto\\"}}}function ce(){h.config.noCalendar||h.isMobile||(ve(),J())}function de(){h._input.focus(),-1!==window.navigator.userAgent.indexOf(\\"MSIE\\")||void 0!==navigator.msMaxTouchPoints?setTimeout(h.close,0):h.close()}function se(e){e.preventDefault(),e.stopPropagation();var t=function e(t,n){return n(t)?t:t.parentNode?e(t.parentNode,n):void 0}(e.target,function(e){return e.classList&&e.classList.contains(\\"flatpickr-day\\")&&!e.classList.contains(\\"flatpickr-disabled\\")&&!e.classList.contains(\\"notAllowed\\")});if(void 0!==t){var n=t,a=h.latestSelectedDateObj=new Date(n.dateObj.getTime()),i=(a.getMonth()<h.currentMonth||a.getMonth()>h.currentMonth+h.config.showMonths-1)&&\\"range\\"!==h.config.mode;if(h.selectedDateElem=n,\\"single\\"===h.config.mode)h.selectedDates=[a];else if(\\"multiple\\"===h.config.mode){var o=he(a);o?h.selectedDates.splice(parseInt(o),1):h.selectedDates.push(a)}else\\"range\\"===h.config.mode&&(2===h.selectedDates.length&&h.clear(!1,!1),h.latestSelectedDateObj=a,h.selectedDates.push(a),0!==w(a,h.selectedDates[0],!0)&&h.selectedDates.sort(function(e,t){return e.getTime()-t.getTime()}));if(k(),i){var r=h.currentYear!==a.getFullYear();h.currentYear=a.getFullYear(),h.currentMonth=a.getMonth(),r&&(ge(\\"onYearChange\\"),K()),ge(\\"onMonthChange\\")}if(ve(),J(),we(),h.config.enableTime&&setTimeout(function(){return h.showTimeInput=!0},50),i||\\"range\\"===h.config.mode||1!==h.config.showMonths?void 0!==h.selectedDateElem&&void 0===h.hourElement&&h.selectedDateElem&&h.selectedDateElem.focus():L(n),void 0!==h.hourElement&&void 0!==h.hourElement&&h.hourElement.focus(),h.config.closeOnSelect){var l=\\"single\\"===h.config.mode&&!h.config.enableTime,c=\\"range\\"===h.config.mode&&2===h.selectedDates.length&&!h.config.enableTime;(l||c)&&de()}Y()}}h.parseDate=D({config:h.config,l10n:h.l10n}),h._handlers=[],h.pluginElements=[],h.loadedPlugins=[],h._bind=F,h._setHoursFromDate=I,h._positionCalendar=le,h.changeMonth=G,h.changeYear=Q,h.clear=function(e,t){void 0===e&&(e=!0);void 0===t&&(t=!0);h.input.value=\\"\\",void 0!==h.altInput&&(h.altInput.value=\\"\\");void 0!==h.mobileInput&&(h.mobileInput.value=\\"\\");h.selectedDates=[],h.latestSelectedDateObj=void 0,!0===t&&(h.currentYear=h._initialDate.getFullYear(),h.currentMonth=h._initialDate.getMonth());h.showTimeInput=!1,!0===h.config.enableTime&&S();h.redraw(),e&&ge(\\"onChange\\")},h.close=function(){h.isOpen=!1,h.isMobile||(void 0!==h.calendarContainer&&h.calendarContainer.classList.remove(\\"open\\"),void 0!==h._input&&h._input.classList.remove(\\"active\\"));ge(\\"onClose\\")},h._createElement=d,h.destroy=function(){void 0!==h.config&&ge(\\"onDestroy\\");for(var e=h._handlers.length;e--;){var t=h._handlers[e];t.element.removeEventListener(t.event,t.handler,t.options)}if(h._handlers=[],h.mobileInput)h.mobileInput.parentNode&&h.mobileInput.parentNode.removeChild(h.mobileInput),h.mobileInput=void 0;else if(h.calendarContainer&&h.calendarContainer.parentNode)if(h.config.static&&h.calendarContainer.parentNode){var n=h.calendarContainer.parentNode;if(n.lastChild&&n.removeChild(n.lastChild),n.parentNode){for(;n.firstChild;)n.parentNode.insertBefore(n.firstChild,n);n.parentNode.removeChild(n)}}else h.calendarContainer.parentNode.removeChild(h.calendarContainer);h.altInput&&(h.input.type=\\"text\\",h.altInput.parentNode&&h.altInput.parentNode.removeChild(h.altInput),delete h.altInput);h.input&&(h.input.type=h.input._type,h.input.classList.remove(\\"flatpickr-input\\"),h.input.removeAttribute(\\"readonly\\"),h.input.value=\\"\\");[\\"_showTimeInput\\",\\"latestSelectedDateObj\\",\\"_hideNextMonthArrow\\",\\"_hidePrevMonthArrow\\",\\"__hideNextMonthArrow\\",\\"__hidePrevMonthArrow\\",\\"isMobile\\",\\"isOpen\\",\\"selectedDateElem\\",\\"minDateHasTime\\",\\"maxDateHasTime\\",\\"days\\",\\"daysContainer\\",\\"_input\\",\\"_positionElement\\",\\"innerContainer\\",\\"rContainer\\",\\"monthNav\\",\\"todayDateElem\\",\\"calendarContainer\\",\\"weekdayContainer\\",\\"prevMonthNav\\",\\"nextMonthNav\\",\\"monthsDropdownContainer\\",\\"currentMonthElement\\",\\"currentYearElement\\",\\"navigationCurrentMonth\\",\\"selectedDateElem\\",\\"config\\"].forEach(function(e){try{delete h[e]}catch(e){}})},h.isEnabled=X,h.jumpToDate=A,h.open=function(e,t){void 0===t&&(t=h._positionElement);if(!0===h.isMobile)return e&&(e.preventDefault(),e.target&&e.target.blur()),void 0!==h.mobileInput&&(h.mobileInput.focus(),h.mobileInput.click()),void ge(\\"onOpen\\");if(h._input.disabled||h.config.inline)return;var n=h.isOpen;h.isOpen=!0,n||(h.calendarContainer.classList.add(\\"open\\"),h._input.classList.add(\\"active\\"),ge(\\"onOpen\\"),le(t));!0===h.config.enableTime&&!0===h.config.noCalendar&&(0===h.selectedDates.length&&ie(),!1!==h.config.allowInput||void 0!==e&&h.timeContainer.contains(e.relatedTarget)||setTimeout(function(){return h.hourElement.select()},50))},h.redraw=ce,h.set=function(e,n){if(null!==e&&\\"object\\"==typeof e)for(var a in Object.assign(h.config,e),e)void 0!==ue[a]&&ue[a].forEach(function(e){return e()});else h.config[e]=n,void 0!==ue[e]?ue[e].forEach(function(e){return e()}):t.indexOf(e)>-1&&(h.config[e]=l(n));h.redraw(),we(!1)},h.setDate=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=h.config.dateFormat);if(0!==e&&!e||e instanceof Array&&0===e.length)return h.clear(t);fe(e,n),h.showTimeInput=h.selectedDates.length>0,h.latestSelectedDateObj=h.selectedDates[h.selectedDates.length-1],h.redraw(),A(),I(),0===h.selectedDates.length&&h.clear(!1);we(t),t&&ge(\\"onChange\\")},h.toggle=function(e){if(!0===h.isOpen)return h.close();h.open(e)};var ue={locale:[re,z],showMonths:[q,x,$],minDate:[A],maxDate:[A]};function fe(e,t){var n=[];if(e instanceof Array)n=e.map(function(e){return h.parseDate(e,t)});else if(e instanceof Date||\\"number\\"==typeof e)n=[h.parseDate(e,t)];else if(\\"string\\"==typeof e)switch(h.config.mode){case\\"single\\":case\\"time\\":n=[h.parseDate(e,t)];break;case\\"multiple\\":n=e.split(h.config.conjunction).map(function(e){return h.parseDate(e,t)});break;case\\"range\\":n=e.split(h.l10n.rangeSeparator).map(function(e){return h.parseDate(e,t)})}else h.config.errorHandler(new Error(\\"Invalid date supplied: \\"+JSON.stringify(e)));h.selectedDates=n.filter(function(e){return e instanceof Date&&X(e,!1)}),\\"range\\"===h.config.mode&&h.selectedDates.sort(function(e,t){return e.getTime()-t.getTime()})}function me(e){return e.slice().map(function(e){return\\"string\\"==typeof e||\\"number\\"==typeof e||e instanceof Date?h.parseDate(e,void 0,!0):e&&\\"object\\"==typeof e&&e.from&&e.to?{from:h.parseDate(e.from,void 0),to:h.parseDate(e.to,void 0)}:e}).filter(function(e){return e})}function ge(e,t){if(void 0!==h.config){var n=h.config[e];if(void 0!==n&&n.length>0)for(var a=0;n[a]&&a<n.length;a++)n[a](h.selectedDates,h.input.value,h,t);\\"onChange\\"===e&&(h.input.dispatchEvent(pe(\\"change\\")),h.input.dispatchEvent(pe(\\"input\\")))}}function pe(e){var t=document.createEvent(\\"Event\\");return t.initEvent(e,!0,!0),t}function he(e){for(var t=0;t<h.selectedDates.length;t++)if(0===w(h.selectedDates[t],e))return\\"\\"+t;return!1}function ve(){h.config.noCalendar||h.isMobile||!h.monthNav||(h.yearElements.forEach(function(e,t){var n=new Date(h.currentYear,h.currentMonth,1);n.setMonth(h.currentMonth+t),h.config.showMonths>1||\\"static\\"===h.config.monthSelectorType?h.monthElements[t].textContent=m(n.getMonth(),h.config.shorthandCurrentMonth,h.l10n)+\\" \\":h.monthsDropdownContainer.value=n.getMonth().toString(),e.value=n.getFullYear().toString()}),h._hidePrevMonthArrow=void 0!==h.config.minDate&&(h.currentYear===h.config.minDate.getFullYear()?h.currentMonth<=h.config.minDate.getMonth():h.currentYear<h.config.minDate.getFullYear()),h._hideNextMonthArrow=void 0!==h.config.maxDate&&(h.currentYear===h.config.maxDate.getFullYear()?h.currentMonth+1>h.config.maxDate.getMonth():h.currentYear>h.config.maxDate.getFullYear()))}function De(e){return h.selectedDates.map(function(t){return h.formatDate(t,e)}).filter(function(e,t,n){return\\"range\\"!==h.config.mode||h.config.enableTime||n.indexOf(e)===t}).join(\\"range\\"!==h.config.mode?h.config.conjunction:h.l10n.rangeSeparator)}function we(e){void 0===e&&(e=!0),void 0!==h.mobileInput&&h.mobileFormatStr&&(h.mobileInput.value=void 0!==h.latestSelectedDateObj?h.formatDate(h.latestSelectedDateObj,h.mobileFormatStr):\\"\\"),h.input.value=De(h.config.dateFormat),void 0!==h.altInput&&(h.altInput.value=De(h.config.altFormat)),!1!==e&&ge(\\"onValueUpdate\\")}function be(e){var t=h.prevMonthNav.contains(e.target),n=h.nextMonthNav.contains(e.target);t||n?G(t?-1:1):h.yearElements.indexOf(e.target)>=0?e.target.select():e.target.classList.contains(\\"arrowUp\\")?h.changeYear(h.currentYear+1):e.target.classList.contains(\\"arrowDown\\")&&h.changeYear(h.currentYear-1)}return function(){h.element=h.input=f,h.isOpen=!1,function(){var a=[\\"wrap\\",\\"weekNumbers\\",\\"allowInput\\",\\"clickOpens\\",\\"time_24hr\\",\\"enableTime\\",\\"noCalendar\\",\\"altInput\\",\\"shorthandCurrentMonth\\",\\"inline\\",\\"static\\",\\"enableSeconds\\",\\"disableMobile\\"],i=e({},g,JSON.parse(JSON.stringify(f.dataset||{}))),o={};h.config.parseDate=i.parseDate,h.config.formatDate=i.formatDate,Object.defineProperty(h.config,\\"enable\\",{get:function(){return h.config._enable},set:function(e){h.config._enable=me(e)}}),Object.defineProperty(h.config,\\"disable\\",{get:function(){return h.config._disable},set:function(e){h.config._disable=me(e)}});var r=\\"time\\"===i.mode;if(!i.dateFormat&&(i.enableTime||r)){var c=E.defaultConfig.dateFormat||n.dateFormat;o.dateFormat=i.noCalendar||r?\\"H:i\\"+(i.enableSeconds?\\":S\\":\\"\\"):c+\\" H:i\\"+(i.enableSeconds?\\":S\\":\\"\\")}if(i.altInput&&(i.enableTime||r)&&!i.altFormat){var d=E.defaultConfig.altFormat||n.altFormat;o.altFormat=i.noCalendar||r?\\"h:i\\"+(i.enableSeconds?\\":S K\\":\\" K\\"):d+\\" h:i\\"+(i.enableSeconds?\\":S\\":\\"\\")+\\" K\\"}i.altInputClass||(h.config.altInputClass=h.input.className+\\" \\"+h.config.altInputClass),Object.defineProperty(h.config,\\"minDate\\",{get:function(){return h.config._minDate},set:oe(\\"min\\")}),Object.defineProperty(h.config,\\"maxDate\\",{get:function(){return h.config._maxDate},set:oe(\\"max\\")});var s=function(e){return function(t){h.config[\\"min\\"===e?\\"_minTime\\":\\"_maxTime\\"]=h.parseDate(t,\\"H:i:S\\")}};Object.defineProperty(h.config,\\"minTime\\",{get:function(){return h.config._minTime},set:s(\\"min\\")}),Object.defineProperty(h.config,\\"maxTime\\",{get:function(){return h.config._maxTime},set:s(\\"max\\")}),\\"time\\"===i.mode&&(h.config.noCalendar=!0,h.config.enableTime=!0),Object.assign(h.config,o,i);for(var u=0;u<a.length;u++)h.config[a[u]]=!0===h.config[a[u]]||\\"true\\"===h.config[a[u]];t.filter(function(e){return void 0!==h.config[e]}).forEach(function(e){h.config[e]=l(h.config[e]||[]).map(y)}),h.isMobile=!h.config.disableMobile&&!h.config.inline&&\\"single\\"===h.config.mode&&!h.config.disable.length&&!h.config.enable.length&&!h.config.weekNumbers&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);for(var u=0;u<h.config.plugins.length;u++){var m=h.config.plugins[u](h)||{};for(var p in m)t.indexOf(p)>-1?h.config[p]=l(m[p]).map(y).concat(h.config[p]):void 0===i[p]&&(h.config[p]=m[p])}ge(\\"onParseConfig\\")}(),re(),h.input=h.config.wrap?f.querySelector(\\"[data-input]\\"):f,h.input?(h.input._type=h.input.type,h.input.type=\\"text\\",h.input.classList.add(\\"flatpickr-input\\"),h._input=h.input,h.config.altInput&&(h.altInput=d(h.input.nodeName,h.config.altInputClass),h._input=h.altInput,h.altInput.placeholder=h.input.placeholder,h.altInput.disabled=h.input.disabled,h.altInput.required=h.input.required,h.altInput.tabIndex=h.input.tabIndex,h.altInput.type=\\"text\\",h.input.setAttribute(\\"type\\",\\"hidden\\"),!h.config.static&&h.input.parentNode&&h.input.parentNode.insertBefore(h.altInput,h.input.nextSibling)),h.config.allowInput||h._input.setAttribute(\\"readonly\\",\\"readonly\\"),h._positionElement=h.config.positionElement||h._input):h.config.errorHandler(new Error(\\"Invalid input element specified\\")),function(){h.selectedDates=[],h.now=h.parseDate(h.config.now)||new Date;var e=h.config.defaultDate||(\\"INPUT\\"!==h.input.nodeName&&\\"TEXTAREA\\"!==h.input.nodeName||!h.input.placeholder||h.input.value!==h.input.placeholder?h.input.value:null);e&&fe(e,h.config.dateFormat),h._initialDate=h.selectedDates.length>0?h.selectedDates[0]:h.config.minDate&&h.config.minDate.getTime()>h.now.getTime()?h.config.minDate:h.config.maxDate&&h.config.maxDate.getTime()<h.now.getTime()?h.config.maxDate:h.now,h.currentYear=h._initialDate.getFullYear(),h.currentMonth=h._initialDate.getMonth(),h.selectedDates.length>0&&(h.latestSelectedDateObj=h.selectedDates[0]),void 0!==h.config.minTime&&(h.config.minTime=h.parseDate(h.config.minTime,\\"H:i\\")),void 0!==h.config.maxTime&&(h.config.maxTime=h.parseDate(h.config.maxTime,\\"H:i\\")),h.minDateHasTime=!!h.config.minDate&&(h.config.minDate.getHours()>0||h.config.minDate.getMinutes()>0||h.config.minDate.getSeconds()>0),h.maxDateHasTime=!!h.config.maxDate&&(h.config.maxDate.getHours()>0||h.config.maxDate.getMinutes()>0||h.config.maxDate.getSeconds()>0),Object.defineProperty(h,\\"showTimeInput\\",{get:function(){return h._showTimeInput},set:function(e){h._showTimeInput=e,h.calendarContainer&&c(h.calendarContainer,\\"showTimeInput\\",e),h.isOpen&&le()}})}(),h.utils={getDaysInMonth:function(e,t){return void 0===e&&(e=h.currentMonth),void 0===t&&(t=h.currentYear),1===e&&(t%4==0&&t%100!=0||t%400==0)?29:h.l10n.daysInMonth[e]}},h.isMobile||function(){var e=window.document.createDocumentFragment();if(h.calendarContainer=d(\\"div\\",\\"flatpickr-calendar\\"),h.calendarContainer.tabIndex=-1,!h.config.noCalendar){if(e.appendChild((h.monthNav=d(\\"div\\",\\"flatpickr-months\\"),h.yearElements=[],h.monthElements=[],h.prevMonthNav=d(\\"span\\",\\"flatpickr-prev-month\\"),h.prevMonthNav.innerHTML=h.config.prevArrow,h.nextMonthNav=d(\\"span\\",\\"flatpickr-next-month\\"),h.nextMonthNav.innerHTML=h.config.nextArrow,q(),Object.defineProperty(h,\\"_hidePrevMonthArrow\\",{get:function(){return h.__hidePrevMonthArrow},set:function(e){h.__hidePrevMonthArrow!==e&&(c(h.prevMonthNav,\\"flatpickr-disabled\\",e),h.__hidePrevMonthArrow=e)}}),Object.defineProperty(h,\\"_hideNextMonthArrow\\",{get:function(){return h.__hideNextMonthArrow},set:function(e){h.__hideNextMonthArrow!==e&&(c(h.nextMonthNav,\\"flatpickr-disabled\\",e),h.__hideNextMonthArrow=e)}}),h.currentYearElement=h.yearElements[0],ve(),h.monthNav)),h.innerContainer=d(\\"div\\",\\"flatpickr-innerContainer\\"),h.config.weekNumbers){var t=function(){h.calendarContainer.classList.add(\\"hasWeeks\\");var e=d(\\"div\\",\\"flatpickr-weekwrapper\\");e.appendChild(d(\\"span\\",\\"flatpickr-weekday\\",h.l10n.weekAbbreviation));var t=d(\\"div\\",\\"flatpickr-weeks\\");return e.appendChild(t),{weekWrapper:e,weekNumbers:t}}(),n=t.weekWrapper,a=t.weekNumbers;h.innerContainer.appendChild(n),h.weekNumbers=a,h.weekWrapper=n}h.rContainer=d(\\"div\\",\\"flatpickr-rContainer\\"),h.rContainer.appendChild($()),h.daysContainer||(h.daysContainer=d(\\"div\\",\\"flatpickr-days\\"),h.daysContainer.tabIndex=-1),J(),h.rContainer.appendChild(h.daysContainer),h.innerContainer.appendChild(h.rContainer),e.appendChild(h.innerContainer)}h.config.enableTime&&e.appendChild(function(){h.calendarContainer.classList.add(\\"hasTime\\"),h.config.noCalendar&&h.calendarContainer.classList.add(\\"noCalendar\\"),h.timeContainer=d(\\"div\\",\\"flatpickr-time\\"),h.timeContainer.tabIndex=-1;var e=d(\\"span\\",\\"flatpickr-time-separator\\",\\":\\"),t=u(\\"flatpickr-hour\\",{\\"aria-label\\":h.l10n.hourAriaLabel});h.hourElement=t.getElementsByTagName(\\"input\\")[0];var n=u(\\"flatpickr-minute\\",{\\"aria-label\\":h.l10n.minuteAriaLabel});if(h.minuteElement=n.getElementsByTagName(\\"input\\")[0],h.hourElement.tabIndex=h.minuteElement.tabIndex=-1,h.hourElement.value=i(h.latestSelectedDateObj?h.latestSelectedDateObj.getHours():h.config.time_24hr?h.config.defaultHour:function(e){switch(e%24){case 0:case 12:return 12;default:return e%12}}(h.config.defaultHour)),h.minuteElement.value=i(h.latestSelectedDateObj?h.latestSelectedDateObj.getMinutes():h.config.defaultMinute),h.hourElement.setAttribute(\\"step\\",h.config.hourIncrement.toString()),h.minuteElement.setAttribute(\\"step\\",h.config.minuteIncrement.toString()),h.hourElement.setAttribute(\\"min\\",h.config.time_24hr?\\"0\\":\\"1\\"),h.hourElement.setAttribute(\\"max\\",h.config.time_24hr?\\"23\\":\\"12\\"),h.minuteElement.setAttribute(\\"min\\",\\"0\\"),h.minuteElement.setAttribute(\\"max\\",\\"59\\"),h.timeContainer.appendChild(t),h.timeContainer.appendChild(e),h.timeContainer.appendChild(n),h.config.time_24hr&&h.timeContainer.classList.add(\\"time24hr\\"),h.config.enableSeconds){h.timeContainer.classList.add(\\"hasSeconds\\");var a=u(\\"flatpickr-second\\");h.secondElement=a.getElementsByTagName(\\"input\\")[0],h.secondElement.value=i(h.latestSelectedDateObj?h.latestSelectedDateObj.getSeconds():h.config.defaultSeconds),h.secondElement.setAttribute(\\"step\\",h.minuteElement.getAttribute(\\"step\\")),h.secondElement.setAttribute(\\"min\\",\\"0\\"),h.secondElement.setAttribute(\\"max\\",\\"59\\"),h.timeContainer.appendChild(d(\\"span\\",\\"flatpickr-time-separator\\",\\":\\")),h.timeContainer.appendChild(a)}return h.config.time_24hr||(h.amPM=d(\\"span\\",\\"flatpickr-am-pm\\",h.l10n.amPM[o((h.latestSelectedDateObj?h.hourElement.value:h.config.defaultHour)>11)]),h.amPM.title=h.l10n.toggleTitle,h.amPM.tabIndex=-1,h.timeContainer.appendChild(h.amPM)),h.timeContainer}()),c(h.calendarContainer,\\"rangeMode\\",\\"range\\"===h.config.mode),c(h.calendarContainer,\\"animate\\",!0===h.config.animate),c(h.calendarContainer,\\"multiMonth\\",h.config.showMonths>1),h.calendarContainer.appendChild(e);var r=void 0!==h.config.appendTo&&void 0!==h.config.appendTo.nodeType;if((h.config.inline||h.config.static)&&(h.calendarContainer.classList.add(h.config.inline?\\"inline\\":\\"static\\"),h.config.inline&&(!r&&h.element.parentNode?h.element.parentNode.insertBefore(h.calendarContainer,h._input.nextSibling):void 0!==h.config.appendTo&&h.config.appendTo.appendChild(h.calendarContainer)),h.config.static)){var l=d(\\"div\\",\\"flatpickr-wrapper\\");h.element.parentNode&&h.element.parentNode.insertBefore(l,h.element),l.appendChild(h.element),h.altInput&&l.appendChild(h.altInput),l.appendChild(h.calendarContainer)}h.config.static||h.config.inline||(void 0!==h.config.appendTo?h.config.appendTo:window.document.body).appendChild(h.calendarContainer)}(),function(){if(h.config.wrap&&[\\"open\\",\\"close\\",\\"toggle\\",\\"clear\\"].forEach(function(e){Array.prototype.forEach.call(h.element.querySelectorAll(\\"[data-\\"+e+\\"]\\"),function(t){return F(t,\\"click\\",h[e])})}),h.isMobile)!function(){var e=h.config.enableTime?h.config.noCalendar?\\"time\\":\\"datetime-local\\":\\"date\\";h.mobileInput=d(\\"input\\",h.input.className+\\" flatpickr-mobile\\"),h.mobileInput.step=h.input.getAttribute(\\"step\\")||\\"any\\",h.mobileInput.tabIndex=1,h.mobileInput.type=e,h.mobileInput.disabled=h.input.disabled,h.mobileInput.required=h.input.required,h.mobileInput.placeholder=h.input.placeholder,h.mobileFormatStr=\\"datetime-local\\"===e?\\"Y-m-d\\\\\\\\TH:i:S\\":\\"date\\"===e?\\"Y-m-d\\":\\"H:i:S\\",h.selectedDates.length>0&&(h.mobileInput.defaultValue=h.mobileInput.value=h.formatDate(h.selectedDates[0],h.mobileFormatStr)),h.config.minDate&&(h.mobileInput.min=h.formatDate(h.config.minDate,\\"Y-m-d\\")),h.config.maxDate&&(h.mobileInput.max=h.formatDate(h.config.maxDate,\\"Y-m-d\\")),h.input.type=\\"hidden\\",void 0!==h.altInput&&(h.altInput.type=\\"hidden\\");try{h.input.parentNode&&h.input.parentNode.insertBefore(h.mobileInput,h.input.nextSibling)}catch(e){}F(h.mobileInput,\\"change\\",function(e){h.setDate(e.target.value,!1,h.mobileFormatStr),ge(\\"onChange\\"),ge(\\"onClose\\")})}();else{var e=r(ae,50);h._debouncedChange=r(Y,M),h.daysContainer&&!/iPhone|iPad|iPod/i.test(navigator.userAgent)&&F(h.daysContainer,\\"mouseover\\",function(e){\\"range\\"===h.config.mode&&ne(e.target)}),F(window.document.body,\\"keydown\\",te),h.config.inline||h.config.static||F(window,\\"resize\\",e),void 0!==window.ontouchstart?F(window.document,\\"touchstart\\",Z):F(window.document,\\"mousedown\\",N(Z)),F(window.document,\\"focus\\",Z,{capture:!0}),!0===h.config.clickOpens&&(F(h._input,\\"focus\\",h.open),F(h._input,\\"mousedown\\",N(h.open))),void 0!==h.daysContainer&&(F(h.monthNav,\\"mousedown\\",N(be)),F(h.monthNav,[\\"keyup\\",\\"increment\\"],_),F(h.daysContainer,\\"mousedown\\",N(se))),void 0!==h.timeContainer&&void 0!==h.minuteElement&&void 0!==h.hourElement&&(F(h.timeContainer,[\\"increment\\"],T),F(h.timeContainer,\\"blur\\",T,{capture:!0}),F(h.timeContainer,\\"mousedown\\",N(P)),F([h.hourElement,h.minuteElement],[\\"focus\\",\\"click\\"],function(e){return e.target.select()}),void 0!==h.secondElement&&F(h.secondElement,\\"focus\\",function(){return h.secondElement&&h.secondElement.select()}),void 0!==h.amPM&&F(h.amPM,\\"mousedown\\",N(function(e){T(e),Y()})))}}(),(h.selectedDates.length||h.config.noCalendar)&&(h.config.enableTime&&I(h.config.noCalendar?h.latestSelectedDateObj||h.config.minDate:void 0),we(!1)),x(),h.showTimeInput=h.selectedDates.length>0||h.config.noCalendar;var a=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);!h.isMobile&&a&&le(),ge(\\"onReady\\")}(),h}function x(e,t){for(var n=Array.prototype.slice.call(e).filter(function(e){return e instanceof HTMLElement}),a=[],i=0;i<n.length;i++){var o=n[i];try{if(null!==o.getAttribute(\\"data-fp-omit\\"))continue;void 0!==o._flatpickr&&(o._flatpickr.destroy(),o._flatpickr=void 0),o._flatpickr=y(o,t||{}),a.push(o._flatpickr)}catch(e){console.error(e)}}return 1===a.length?a[0]:a}\\"undefined\\"!=typeof HTMLElement&&\\"undefined\\"!=typeof HTMLCollection&&\\"undefined\\"!=typeof NodeList&&(HTMLCollection.prototype.flatpickr=NodeList.prototype.flatpickr=function(e){return x(this,e)},HTMLElement.prototype.flatpickr=function(e){return x([this],e)});var E=function(e,t){return\\"string\\"==typeof e?x(window.document.querySelectorAll(e),t):e instanceof Node?x([e],t):x(e,t)};return E.defaultConfig={},E.l10ns={en:e({},a),default:e({},a)},E.localize=function(t){E.l10ns.default=e({},E.l10ns.default,t)},E.setDefaults=function(t){E.defaultConfig=e({},E.defaultConfig,t)},E.parseDate=D({}),E.formatDate=v({}),E.compareDates=w,\\"undefined\\"!=typeof jQuery&&void 0!==jQuery.fn&&(jQuery.fn.flatpickr=function(e){return x(this,e)}),Date.prototype.fp_incr=function(e){return new Date(this.getFullYear(),this.getMonth(),this.getDate()+(\\"string\\"==typeof e?parseInt(e,10):e))},\\"undefined\\"!=typeof window&&(window.flatpickr=E),E});"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLm1pbi5qcz8yMTg2Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiBmbGF0cGlja3IgdjQuNi4zLCwgQGxpY2Vuc2UgTUlUICovXFxuIWZ1bmN0aW9uKGUsdCl7XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBleHBvcnRzJiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6KGU9ZXx8c2VsZikuZmxhdHBpY2tyPXQoKX0odGhpcyxmdW5jdGlvbigpe1xcXCJ1c2Ugc3RyaWN0XFxcIjt2YXIgZT1mdW5jdGlvbigpe3JldHVybihlPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxuPTEsYT1hcmd1bWVudHMubGVuZ3RoO248YTtuKyspZm9yKHZhciBpIGluIHQ9YXJndW1lbnRzW25dKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGkpJiYoZVtpXT10W2ldKTtyZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sdD1bXFxcIm9uQ2hhbmdlXFxcIixcXFwib25DbG9zZVxcXCIsXFxcIm9uRGF5Q3JlYXRlXFxcIixcXFwib25EZXN0cm95XFxcIixcXFwib25LZXlEb3duXFxcIixcXFwib25Nb250aENoYW5nZVxcXCIsXFxcIm9uT3BlblxcXCIsXFxcIm9uUGFyc2VDb25maWdcXFwiLFxcXCJvblJlYWR5XFxcIixcXFwib25WYWx1ZVVwZGF0ZVxcXCIsXFxcIm9uWWVhckNoYW5nZVxcXCIsXFxcIm9uUHJlQ2FsZW5kYXJQb3NpdGlvblxcXCJdLG49e19kaXNhYmxlOltdLF9lbmFibGU6W10sYWxsb3dJbnB1dDohMSxhbHRGb3JtYXQ6XFxcIkYgaiwgWVxcXCIsYWx0SW5wdXQ6ITEsYWx0SW5wdXRDbGFzczpcXFwiZm9ybS1jb250cm9sIGlucHV0XFxcIixhbmltYXRlOlxcXCJvYmplY3RcXFwiPT10eXBlb2Ygd2luZG93JiYtMT09PXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXFxcIk1TSUVcXFwiKSxhcmlhRGF0ZUZvcm1hdDpcXFwiRiBqLCBZXFxcIixjbGlja09wZW5zOiEwLGNsb3NlT25TZWxlY3Q6ITAsY29uanVuY3Rpb246XFxcIiwgXFxcIixkYXRlRm9ybWF0OlxcXCJZLW0tZFxcXCIsZGVmYXVsdEhvdXI6MTIsZGVmYXVsdE1pbnV0ZTowLGRlZmF1bHRTZWNvbmRzOjAsZGlzYWJsZTpbXSxkaXNhYmxlTW9iaWxlOiExLGVuYWJsZTpbXSxlbmFibGVTZWNvbmRzOiExLGVuYWJsZVRpbWU6ITEsZXJyb3JIYW5kbGVyOmZ1bmN0aW9uKGUpe3JldHVyblxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgY29uc29sZSYmY29uc29sZS53YXJuKGUpfSxnZXRXZWVrOmZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBEYXRlKGUuZ2V0VGltZSgpKTt0LnNldEhvdXJzKDAsMCwwLDApLHQuc2V0RGF0ZSh0LmdldERhdGUoKSszLSh0LmdldERheSgpKzYpJTcpO3ZhciBuPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDQpO3JldHVybiAxK01hdGgucm91bmQoKCh0LmdldFRpbWUoKS1uLmdldFRpbWUoKSkvODY0ZTUtMysobi5nZXREYXkoKSs2KSU3KS83KX0saG91ckluY3JlbWVudDoxLGlnbm9yZWRGb2N1c0VsZW1lbnRzOltdLGlubGluZTohMSxsb2NhbGU6XFxcImRlZmF1bHRcXFwiLG1pbnV0ZUluY3JlbWVudDo1LG1vZGU6XFxcInNpbmdsZVxcXCIsbW9udGhTZWxlY3RvclR5cGU6XFxcImRyb3Bkb3duXFxcIixuZXh0QXJyb3c6XFxcIjxzdmcgdmVyc2lvbj0nMS4xJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHhtbG5zOnhsaW5rPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyB2aWV3Qm94PScwIDAgMTcgMTcnPjxnPjwvZz48cGF0aCBkPSdNMTMuMjA3IDguNDcybC03Ljg1NCA3Ljg1NC0wLjcwNy0wLjcwNyA3LjE0Ni03LjE0Ni03LjE0Ni03LjE0OCAwLjcwNy0wLjcwNyA3Ljg1NCA3Ljg1NHonIC8+PC9zdmc+XFxcIixub0NhbGVuZGFyOiExLG5vdzpuZXcgRGF0ZSxvbkNoYW5nZTpbXSxvbkNsb3NlOltdLG9uRGF5Q3JlYXRlOltdLG9uRGVzdHJveTpbXSxvbktleURvd246W10sb25Nb250aENoYW5nZTpbXSxvbk9wZW46W10sb25QYXJzZUNvbmZpZzpbXSxvblJlYWR5OltdLG9uVmFsdWVVcGRhdGU6W10sb25ZZWFyQ2hhbmdlOltdLG9uUHJlQ2FsZW5kYXJQb3NpdGlvbjpbXSxwbHVnaW5zOltdLHBvc2l0aW9uOlxcXCJhdXRvXFxcIixwb3NpdGlvbkVsZW1lbnQ6dm9pZCAwLHByZXZBcnJvdzpcXFwiPHN2ZyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHZpZXdCb3g9JzAgMCAxNyAxNyc+PGc+PC9nPjxwYXRoIGQ9J001LjIwNyA4LjQ3MWw3LjE0NiA3LjE0Ny0wLjcwNyAwLjcwNy03Ljg1My03Ljg1NCA3Ljg1NC03Ljg1MyAwLjcwNyAwLjcwNy03LjE0NyA3LjE0NnonIC8+PC9zdmc+XFxcIixzaG9ydGhhbmRDdXJyZW50TW9udGg6ITEsc2hvd01vbnRoczoxLHN0YXRpYzohMSx0aW1lXzI0aHI6ITEsd2Vla051bWJlcnM6ITEsd3JhcDohMX0sYT17d2Vla2RheXM6e3Nob3J0aGFuZDpbXFxcIlN1blxcXCIsXFxcIk1vblxcXCIsXFxcIlR1ZVxcXCIsXFxcIldlZFxcXCIsXFxcIlRodVxcXCIsXFxcIkZyaVxcXCIsXFxcIlNhdFxcXCJdLGxvbmdoYW5kOltcXFwiU3VuZGF5XFxcIixcXFwiTW9uZGF5XFxcIixcXFwiVHVlc2RheVxcXCIsXFxcIldlZG5lc2RheVxcXCIsXFxcIlRodXJzZGF5XFxcIixcXFwiRnJpZGF5XFxcIixcXFwiU2F0dXJkYXlcXFwiXX0sbW9udGhzOntzaG9ydGhhbmQ6W1xcXCJKYW5cXFwiLFxcXCJGZWJcXFwiLFxcXCJNYXJcXFwiLFxcXCJBcHJcXFwiLFxcXCJNYXlcXFwiLFxcXCJKdW5cXFwiLFxcXCJKdWxcXFwiLFxcXCJBdWdcXFwiLFxcXCJTZXBcXFwiLFxcXCJPY3RcXFwiLFxcXCJOb3ZcXFwiLFxcXCJEZWNcXFwiXSxsb25naGFuZDpbXFxcIkphbnVhcnlcXFwiLFxcXCJGZWJydWFyeVxcXCIsXFxcIk1hcmNoXFxcIixcXFwiQXByaWxcXFwiLFxcXCJNYXlcXFwiLFxcXCJKdW5lXFxcIixcXFwiSnVseVxcXCIsXFxcIkF1Z3VzdFxcXCIsXFxcIlNlcHRlbWJlclxcXCIsXFxcIk9jdG9iZXJcXFwiLFxcXCJOb3ZlbWJlclxcXCIsXFxcIkRlY2VtYmVyXFxcIl19LGRheXNJbk1vbnRoOlszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sZmlyc3REYXlPZldlZWs6MCxvcmRpbmFsOmZ1bmN0aW9uKGUpe3ZhciB0PWUlMTAwO2lmKHQ+MyYmdDwyMSlyZXR1cm5cXFwidGhcXFwiO3N3aXRjaCh0JTEwKXtjYXNlIDE6cmV0dXJuXFxcInN0XFxcIjtjYXNlIDI6cmV0dXJuXFxcIm5kXFxcIjtjYXNlIDM6cmV0dXJuXFxcInJkXFxcIjtkZWZhdWx0OnJldHVyblxcXCJ0aFxcXCJ9fSxyYW5nZVNlcGFyYXRvcjpcXFwiIHRvIFxcXCIsd2Vla0FiYnJldmlhdGlvbjpcXFwiV2tcXFwiLHNjcm9sbFRpdGxlOlxcXCJTY3JvbGwgdG8gaW5jcmVtZW50XFxcIix0b2dnbGVUaXRsZTpcXFwiQ2xpY2sgdG8gdG9nZ2xlXFxcIixhbVBNOltcXFwiQU1cXFwiLFxcXCJQTVxcXCJdLHllYXJBcmlhTGFiZWw6XFxcIlllYXJcXFwiLGhvdXJBcmlhTGFiZWw6XFxcIkhvdXJcXFwiLG1pbnV0ZUFyaWFMYWJlbDpcXFwiTWludXRlXFxcIix0aW1lXzI0aHI6ITF9LGk9ZnVuY3Rpb24oZSl7cmV0dXJuKFxcXCIwXFxcIitlKS5zbGljZSgtMil9LG89ZnVuY3Rpb24oZSl7cmV0dXJuITA9PT1lPzE6MH07ZnVuY3Rpb24gcihlLHQsbil7dmFyIGE7cmV0dXJuIHZvaWQgMD09PW4mJihuPSExKSxmdW5jdGlvbigpe3ZhciBpPXRoaXMsbz1hcmd1bWVudHM7bnVsbCE9PWEmJmNsZWFyVGltZW91dChhKSxhPXdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YT1udWxsLG58fGUuYXBwbHkoaSxvKX0sdCksbiYmIWEmJmUuYXBwbHkoaSxvKX19dmFyIGw9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBBcnJheT9lOltlXX07ZnVuY3Rpb24gYyhlLHQsbil7aWYoITA9PT1uKXJldHVybiBlLmNsYXNzTGlzdC5hZGQodCk7ZS5jbGFzc0xpc3QucmVtb3ZlKHQpfWZ1bmN0aW9uIGQoZSx0LG4pe3ZhciBhPXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KGUpO3JldHVybiB0PXR8fFxcXCJcXFwiLG49bnx8XFxcIlxcXCIsYS5jbGFzc05hbWU9dCx2b2lkIDAhPT1uJiYoYS50ZXh0Q29udGVudD1uKSxhfWZ1bmN0aW9uIHMoZSl7Zm9yKDtlLmZpcnN0Q2hpbGQ7KWUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKX1mdW5jdGlvbiB1KGUsdCl7dmFyIG49ZChcXFwiZGl2XFxcIixcXFwibnVtSW5wdXRXcmFwcGVyXFxcIiksYT1kKFxcXCJpbnB1dFxcXCIsXFxcIm51bUlucHV0IFxcXCIrZSksaT1kKFxcXCJzcGFuXFxcIixcXFwiYXJyb3dVcFxcXCIpLG89ZChcXFwic3BhblxcXCIsXFxcImFycm93RG93blxcXCIpO2lmKC0xPT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNU0lFIDkuMFxcXCIpP2EudHlwZT1cXFwibnVtYmVyXFxcIjooYS50eXBlPVxcXCJ0ZXh0XFxcIixhLnBhdHRlcm49XFxcIlxcXFxcXFxcZCpcXFwiKSx2b2lkIDAhPT10KWZvcih2YXIgciBpbiB0KWEuc2V0QXR0cmlidXRlKHIsdFtyXSk7cmV0dXJuIG4uYXBwZW5kQ2hpbGQoYSksbi5hcHBlbmRDaGlsZChpKSxuLmFwcGVuZENoaWxkKG8pLG59dmFyIGY9ZnVuY3Rpb24oKXt9LG09ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBuLm1vbnRoc1t0P1xcXCJzaG9ydGhhbmRcXFwiOlxcXCJsb25naGFuZFxcXCJdW2VdfSxnPXtEOmYsRjpmdW5jdGlvbihlLHQsbil7ZS5zZXRNb250aChuLm1vbnRocy5sb25naGFuZC5pbmRleE9mKHQpKX0sRzpmdW5jdGlvbihlLHQpe2Uuc2V0SG91cnMocGFyc2VGbG9hdCh0KSl9LEg6ZnVuY3Rpb24oZSx0KXtlLnNldEhvdXJzKHBhcnNlRmxvYXQodCkpfSxKOmZ1bmN0aW9uKGUsdCl7ZS5zZXREYXRlKHBhcnNlRmxvYXQodCkpfSxLOmZ1bmN0aW9uKGUsdCxuKXtlLnNldEhvdXJzKGUuZ2V0SG91cnMoKSUxMisxMipvKG5ldyBSZWdFeHAobi5hbVBNWzFdLFxcXCJpXFxcIikudGVzdCh0KSkpfSxNOmZ1bmN0aW9uKGUsdCxuKXtlLnNldE1vbnRoKG4ubW9udGhzLnNob3J0aGFuZC5pbmRleE9mKHQpKX0sUzpmdW5jdGlvbihlLHQpe2Uuc2V0U2Vjb25kcyhwYXJzZUZsb2F0KHQpKX0sVTpmdW5jdGlvbihlLHQpe3JldHVybiBuZXcgRGF0ZSgxZTMqcGFyc2VGbG9hdCh0KSl9LFc6ZnVuY3Rpb24oZSx0LG4pe3ZhciBhPXBhcnNlSW50KHQpLGk9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMis3KihhLTEpLDAsMCwwLDApO3JldHVybiBpLnNldERhdGUoaS5nZXREYXRlKCktaS5nZXREYXkoKStuLmZpcnN0RGF5T2ZXZWVrKSxpfSxZOmZ1bmN0aW9uKGUsdCl7ZS5zZXRGdWxsWWVhcihwYXJzZUZsb2F0KHQpKX0sWjpmdW5jdGlvbihlLHQpe3JldHVybiBuZXcgRGF0ZSh0KX0sZDpmdW5jdGlvbihlLHQpe2Uuc2V0RGF0ZShwYXJzZUZsb2F0KHQpKX0saDpmdW5jdGlvbihlLHQpe2Uuc2V0SG91cnMocGFyc2VGbG9hdCh0KSl9LGk6ZnVuY3Rpb24oZSx0KXtlLnNldE1pbnV0ZXMocGFyc2VGbG9hdCh0KSl9LGo6ZnVuY3Rpb24oZSx0KXtlLnNldERhdGUocGFyc2VGbG9hdCh0KSl9LGw6ZixtOmZ1bmN0aW9uKGUsdCl7ZS5zZXRNb250aChwYXJzZUZsb2F0KHQpLTEpfSxuOmZ1bmN0aW9uKGUsdCl7ZS5zZXRNb250aChwYXJzZUZsb2F0KHQpLTEpfSxzOmZ1bmN0aW9uKGUsdCl7ZS5zZXRTZWNvbmRzKHBhcnNlRmxvYXQodCkpfSx1OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodCkpfSx3OmYseTpmdW5jdGlvbihlLHQpe2Uuc2V0RnVsbFllYXIoMmUzK3BhcnNlRmxvYXQodCkpfX0scD17RDpcXFwiKFxcXFxcXFxcdyspXFxcIixGOlxcXCIoXFxcXFxcXFx3KylcXFwiLEc6XFxcIihcXFxcXFxcXGRcXFxcXFxcXGR8XFxcXFxcXFxkKVxcXCIsSDpcXFwiKFxcXFxcXFxcZFxcXFxcXFxcZHxcXFxcXFxcXGQpXFxcIixKOlxcXCIoXFxcXFxcXFxkXFxcXFxcXFxkfFxcXFxcXFxcZClcXFxcXFxcXHcrXFxcIixLOlxcXCJcXFwiLE06XFxcIihcXFxcXFxcXHcrKVxcXCIsUzpcXFwiKFxcXFxcXFxcZFxcXFxcXFxcZHxcXFxcXFxcXGQpXFxcIixVOlxcXCIoLispXFxcIixXOlxcXCIoXFxcXFxcXFxkXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLFk6XFxcIihcXFxcXFxcXGR7NH0pXFxcIixaOlxcXCIoLispXFxcIixkOlxcXCIoXFxcXFxcXFxkXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLGg6XFxcIihcXFxcXFxcXGRcXFxcXFxcXGR8XFxcXFxcXFxkKVxcXCIsaTpcXFwiKFxcXFxcXFxcZFxcXFxcXFxcZHxcXFxcXFxcXGQpXFxcIixqOlxcXCIoXFxcXFxcXFxkXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLGw6XFxcIihcXFxcXFxcXHcrKVxcXCIsbTpcXFwiKFxcXFxcXFxcZFxcXFxcXFxcZHxcXFxcXFxcXGQpXFxcIixuOlxcXCIoXFxcXFxcXFxkXFxcXFxcXFxkfFxcXFxcXFxcZClcXFwiLHM6XFxcIihcXFxcXFxcXGRcXFxcXFxcXGR8XFxcXFxcXFxkKVxcXCIsdTpcXFwiKC4rKVxcXCIsdzpcXFwiKFxcXFxcXFxcZFxcXFxcXFxcZHxcXFxcXFxcXGQpXFxcIix5OlxcXCIoXFxcXFxcXFxkezJ9KVxcXCJ9LGg9e1o6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudG9JU09TdHJpbmcoKX0sRDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHQud2Vla2RheXMuc2hvcnRoYW5kW2gudyhlLHQsbildfSxGOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbShoLm4oZSx0LG4pLTEsITEsdCl9LEc6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBpKGguaChlLHQsbikpfSxIOmZ1bmN0aW9uKGUpe3JldHVybiBpKGUuZ2V0SG91cnMoKSl9LEo6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwIT09dC5vcmRpbmFsP2UuZ2V0RGF0ZSgpK3Qub3JkaW5hbChlLmdldERhdGUoKSk6ZS5nZXREYXRlKCl9LEs6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5hbVBNW28oZS5nZXRIb3VycygpPjExKV19LE06ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbShlLmdldE1vbnRoKCksITAsdCl9LFM6ZnVuY3Rpb24oZSl7cmV0dXJuIGkoZS5nZXRTZWNvbmRzKCkpfSxVOmZ1bmN0aW9uKGUpe3JldHVybiBlLmdldFRpbWUoKS8xZTN9LFc6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBuLmdldFdlZWsoZSl9LFk6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0RnVsbFllYXIoKX0sZDpmdW5jdGlvbihlKXtyZXR1cm4gaShlLmdldERhdGUoKSl9LGg6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0SG91cnMoKSUxMj9lLmdldEhvdXJzKCklMTI6MTJ9LGk6ZnVuY3Rpb24oZSl7cmV0dXJuIGkoZS5nZXRNaW51dGVzKCkpfSxqOmZ1bmN0aW9uKGUpe3JldHVybiBlLmdldERhdGUoKX0sbDpmdW5jdGlvbihlLHQpe3JldHVybiB0LndlZWtkYXlzLmxvbmdoYW5kW2UuZ2V0RGF5KCldfSxtOmZ1bmN0aW9uKGUpe3JldHVybiBpKGUuZ2V0TW9udGgoKSsxKX0sbjpmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXRNb250aCgpKzF9LHM6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0U2Vjb25kcygpfSx1OmZ1bmN0aW9uKGUpe3JldHVybiBlLmdldFRpbWUoKX0sdzpmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXREYXkoKX0seTpmdW5jdGlvbihlKXtyZXR1cm4gU3RyaW5nKGUuZ2V0RnVsbFllYXIoKSkuc3Vic3RyaW5nKDIpfX0sdj1mdW5jdGlvbihlKXt2YXIgdD1lLmNvbmZpZyxpPXZvaWQgMD09PXQ/bjp0LG89ZS5sMTBuLHI9dm9pZCAwPT09bz9hOm87cmV0dXJuIGZ1bmN0aW9uKGUsdCxuKXt2YXIgYT1ufHxyO3JldHVybiB2b2lkIDAhPT1pLmZvcm1hdERhdGU/aS5mb3JtYXREYXRlKGUsdCxhKTp0LnNwbGl0KFxcXCJcXFwiKS5tYXAoZnVuY3Rpb24odCxuLG8pe3JldHVybiBoW3RdJiZcXFwiXFxcXFxcXFxcXFwiIT09b1tuLTFdP2hbdF0oZSxhLGkpOlxcXCJcXFxcXFxcXFxcXCIhPT10P3Q6XFxcIlxcXCJ9KS5qb2luKFxcXCJcXFwiKX19LEQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jb25maWcsaT12b2lkIDA9PT10P246dCxvPWUubDEwbixyPXZvaWQgMD09PW8/YTpvO3JldHVybiBmdW5jdGlvbihlLHQsYSxvKXtpZigwPT09ZXx8ZSl7dmFyIGwsYz1vfHxyLGQ9ZTtpZihlIGluc3RhbmNlb2YgRGF0ZSlsPW5ldyBEYXRlKGUuZ2V0VGltZSgpKTtlbHNlIGlmKFxcXCJzdHJpbmdcXFwiIT10eXBlb2YgZSYmdm9pZCAwIT09ZS50b0ZpeGVkKWw9bmV3IERhdGUoZSk7ZWxzZSBpZihcXFwic3RyaW5nXFxcIj09dHlwZW9mIGUpe3ZhciBzPXR8fChpfHxuKS5kYXRlRm9ybWF0LHU9U3RyaW5nKGUpLnRyaW0oKTtpZihcXFwidG9kYXlcXFwiPT09dSlsPW5ldyBEYXRlLGE9ITA7ZWxzZSBpZigvWiQvLnRlc3QodSl8fC9HTVQkLy50ZXN0KHUpKWw9bmV3IERhdGUoZSk7ZWxzZSBpZihpJiZpLnBhcnNlRGF0ZSlsPWkucGFyc2VEYXRlKGUscyk7ZWxzZXtsPWkmJmkubm9DYWxlbmRhcj9uZXcgRGF0ZSgobmV3IERhdGUpLnNldEhvdXJzKDAsMCwwLDApKTpuZXcgRGF0ZSgobmV3IERhdGUpLmdldEZ1bGxZZWFyKCksMCwxLDAsMCwwLDApO2Zvcih2YXIgZj12b2lkIDAsbT1bXSxoPTAsdj0wLEQ9XFxcIlxcXCI7aDxzLmxlbmd0aDtoKyspe3ZhciB3PXNbaF0sYj1cXFwiXFxcXFxcXFxcXFwiPT09dyxDPVxcXCJcXFxcXFxcXFxcXCI9PT1zW2gtMV18fGI7aWYocFt3XSYmIUMpe0QrPXBbd107dmFyIE09bmV3IFJlZ0V4cChEKS5leGVjKGUpO00mJihmPSEwKSYmbVtcXFwiWVxcXCIhPT13P1xcXCJwdXNoXFxcIjpcXFwidW5zaGlmdFxcXCJdKHtmbjpnW3ddLHZhbDpNWysrdl19KX1lbHNlIGJ8fChEKz1cXFwiLlxcXCIpO20uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1lLmZuLG49ZS52YWw7cmV0dXJuIGw9dChsLG4sYyl8fGx9KX1sPWY/bDp2b2lkIDB9fWlmKGwgaW5zdGFuY2VvZiBEYXRlJiYhaXNOYU4obC5nZXRUaW1lKCkpKXJldHVybiEwPT09YSYmbC5zZXRIb3VycygwLDAsMCwwKSxsO2kuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcXFwiSW52YWxpZCBkYXRlIHByb3ZpZGVkOiBcXFwiK2QpKX19fTtmdW5jdGlvbiB3KGUsdCxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49ITApLCExIT09bj9uZXcgRGF0ZShlLmdldFRpbWUoKSkuc2V0SG91cnMoMCwwLDAsMCktbmV3IERhdGUodC5nZXRUaW1lKCkpLnNldEhvdXJzKDAsMCwwLDApOmUuZ2V0VGltZSgpLXQuZ2V0VGltZSgpfXZhciBiPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT5NYXRoLm1pbih0LG4pJiZlPE1hdGgubWF4KHQsbil9LEM9e0RBWTo4NjRlNX07XFxcImZ1bmN0aW9uXFxcIiE9dHlwZW9mIE9iamVjdC5hc3NpZ24mJihPYmplY3QuYXNzaWduPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W24tMV09YXJndW1lbnRzW25dO2lmKCFlKXRocm93IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XFxcIik7Zm9yKHZhciBhPWZ1bmN0aW9uKHQpe3QmJk9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24obil7cmV0dXJuIGVbbl09dFtuXX0pfSxpPTAsbz10O2k8by5sZW5ndGg7aSsrKXthKG9baV0pfXJldHVybiBlfSk7dmFyIE09MzAwO2Z1bmN0aW9uIHkoZixnKXt2YXIgaD17Y29uZmlnOmUoe30sbixFLmRlZmF1bHRDb25maWcpLGwxMG46YX07ZnVuY3Rpb24geShlKXtyZXR1cm4gZS5iaW5kKGgpfWZ1bmN0aW9uIHgoKXt2YXIgZT1oLmNvbmZpZzshMT09PWUud2Vla051bWJlcnMmJjE9PT1lLnNob3dNb250aHN8fCEwIT09ZS5ub0NhbGVuZGFyJiZ3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7aWYodm9pZCAwIT09aC5jYWxlbmRhckNvbnRhaW5lciYmKGguY2FsZW5kYXJDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eT1cXFwiaGlkZGVuXFxcIixoLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmRpc3BsYXk9XFxcImJsb2NrXFxcIiksdm9pZCAwIT09aC5kYXlzQ29udGFpbmVyKXt2YXIgdD0oaC5kYXlzLm9mZnNldFdpZHRoKzEpKmUuc2hvd01vbnRocztoLmRheXNDb250YWluZXIuc3R5bGUud2lkdGg9dCtcXFwicHhcXFwiLGguY2FsZW5kYXJDb250YWluZXIuc3R5bGUud2lkdGg9dCsodm9pZCAwIT09aC53ZWVrV3JhcHBlcj9oLndlZWtXcmFwcGVyLm9mZnNldFdpZHRoOjApK1xcXCJweFxcXCIsaC5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcXFwidmlzaWJpbGl0eVxcXCIpLGguY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXFxcImRpc3BsYXlcXFwiKX19KX1mdW5jdGlvbiBUKGUpezA9PT1oLnNlbGVjdGVkRGF0ZXMubGVuZ3RoJiZpZSgpLHZvaWQgMCE9PWUmJlxcXCJibHVyXFxcIiE9PWUudHlwZSYmZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpO3ZhciB0PVxcXCJrZXlkb3duXFxcIj09PWUudHlwZSxuPWUudGFyZ2V0O3ZvaWQgMCE9PWguYW1QTSYmZS50YXJnZXQ9PT1oLmFtUE0mJihoLmFtUE0udGV4dENvbnRlbnQ9aC5sMTBuLmFtUE1bbyhoLmFtUE0udGV4dENvbnRlbnQ9PT1oLmwxMG4uYW1QTVswXSldKTt2YXIgYT1wYXJzZUZsb2F0KG4uZ2V0QXR0cmlidXRlKFxcXCJtaW5cXFwiKSkscj1wYXJzZUZsb2F0KG4uZ2V0QXR0cmlidXRlKFxcXCJtYXhcXFwiKSksbD1wYXJzZUZsb2F0KG4uZ2V0QXR0cmlidXRlKFxcXCJzdGVwXFxcIikpLGM9cGFyc2VJbnQobi52YWx1ZSwxMCksZD1lLmRlbHRhfHwodD8zOD09PWUud2hpY2g/MTotMTowKSxzPWMrbCpkO2lmKHZvaWQgMCE9PW4udmFsdWUmJjI9PT1uLnZhbHVlLmxlbmd0aCl7dmFyIHU9bj09PWguaG91ckVsZW1lbnQsZj1uPT09aC5taW51dGVFbGVtZW50O3M8YT8ocz1yK3MrbyghdSkrKG8odSkmJm8oIWguYW1QTSkpLGYmJmoodm9pZCAwLC0xLGguaG91ckVsZW1lbnQpKTpzPnImJihzPW49PT1oLmhvdXJFbGVtZW50P3Mtci1vKCFoLmFtUE0pOmEsZiYmaih2b2lkIDAsMSxoLmhvdXJFbGVtZW50KSksaC5hbVBNJiZ1JiYoMT09PWw/cytjPT09MjM6TWF0aC5hYnMocy1jKT5sKSYmKGguYW1QTS50ZXh0Q29udGVudD1oLmwxMG4uYW1QTVtvKGguYW1QTS50ZXh0Q29udGVudD09PWgubDEwbi5hbVBNWzBdKV0pLG4udmFsdWU9aShzKX19KGUpO3ZhciB0PWguX2lucHV0LnZhbHVlO2soKSx3ZSgpLGguX2lucHV0LnZhbHVlIT09dCYmaC5fZGVib3VuY2VkQ2hhbmdlKCl9ZnVuY3Rpb24gaygpe2lmKHZvaWQgMCE9PWguaG91ckVsZW1lbnQmJnZvaWQgMCE9PWgubWludXRlRWxlbWVudCl7dmFyIGUsdCxuPShwYXJzZUludChoLmhvdXJFbGVtZW50LnZhbHVlLnNsaWNlKC0yKSwxMCl8fDApJTI0LGE9KHBhcnNlSW50KGgubWludXRlRWxlbWVudC52YWx1ZSwxMCl8fDApJTYwLGk9dm9pZCAwIT09aC5zZWNvbmRFbGVtZW50PyhwYXJzZUludChoLnNlY29uZEVsZW1lbnQudmFsdWUsMTApfHwwKSU2MDowO3ZvaWQgMCE9PWguYW1QTSYmKGU9bix0PWguYW1QTS50ZXh0Q29udGVudCxuPWUlMTIrMTIqbyh0PT09aC5sMTBuLmFtUE1bMV0pKTt2YXIgcj12b2lkIDAhPT1oLmNvbmZpZy5taW5UaW1lfHxoLmNvbmZpZy5taW5EYXRlJiZoLm1pbkRhdGVIYXNUaW1lJiZoLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiYmMD09PXcoaC5sYXRlc3RTZWxlY3RlZERhdGVPYmosaC5jb25maWcubWluRGF0ZSwhMCk7aWYodm9pZCAwIT09aC5jb25maWcubWF4VGltZXx8aC5jb25maWcubWF4RGF0ZSYmaC5tYXhEYXRlSGFzVGltZSYmaC5sYXRlc3RTZWxlY3RlZERhdGVPYmomJjA9PT13KGgubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLGguY29uZmlnLm1heERhdGUsITApKXt2YXIgbD12b2lkIDAhPT1oLmNvbmZpZy5tYXhUaW1lP2guY29uZmlnLm1heFRpbWU6aC5jb25maWcubWF4RGF0ZTsobj1NYXRoLm1pbihuLGwuZ2V0SG91cnMoKSkpPT09bC5nZXRIb3VycygpJiYoYT1NYXRoLm1pbihhLGwuZ2V0TWludXRlcygpKSksYT09PWwuZ2V0TWludXRlcygpJiYoaT1NYXRoLm1pbihpLGwuZ2V0U2Vjb25kcygpKSl9aWYocil7dmFyIGM9dm9pZCAwIT09aC5jb25maWcubWluVGltZT9oLmNvbmZpZy5taW5UaW1lOmguY29uZmlnLm1pbkRhdGU7KG49TWF0aC5tYXgobixjLmdldEhvdXJzKCkpKT09PWMuZ2V0SG91cnMoKSYmKGE9TWF0aC5tYXgoYSxjLmdldE1pbnV0ZXMoKSkpLGE9PT1jLmdldE1pbnV0ZXMoKSYmKGk9TWF0aC5tYXgoaSxjLmdldFNlY29uZHMoKSkpfU8obixhLGkpfX1mdW5jdGlvbiBJKGUpe3ZhciB0PWV8fGgubGF0ZXN0U2VsZWN0ZWREYXRlT2JqO3QmJk8odC5nZXRIb3VycygpLHQuZ2V0TWludXRlcygpLHQuZ2V0U2Vjb25kcygpKX1mdW5jdGlvbiBTKCl7dmFyIGU9aC5jb25maWcuZGVmYXVsdEhvdXIsdD1oLmNvbmZpZy5kZWZhdWx0TWludXRlLG49aC5jb25maWcuZGVmYXVsdFNlY29uZHM7aWYodm9pZCAwIT09aC5jb25maWcubWluRGF0ZSl7dmFyIGE9aC5jb25maWcubWluRGF0ZS5nZXRIb3VycygpLGk9aC5jb25maWcubWluRGF0ZS5nZXRNaW51dGVzKCk7KGU9TWF0aC5tYXgoZSxhKSk9PT1hJiYodD1NYXRoLm1heChpLHQpKSxlPT09YSYmdD09PWkmJihuPWguY29uZmlnLm1pbkRhdGUuZ2V0U2Vjb25kcygpKX1pZih2b2lkIDAhPT1oLmNvbmZpZy5tYXhEYXRlKXt2YXIgbz1oLmNvbmZpZy5tYXhEYXRlLmdldEhvdXJzKCkscj1oLmNvbmZpZy5tYXhEYXRlLmdldE1pbnV0ZXMoKTsoZT1NYXRoLm1pbihlLG8pKT09PW8mJih0PU1hdGgubWluKHIsdCkpLGU9PT1vJiZ0PT09ciYmKG49aC5jb25maWcubWF4RGF0ZS5nZXRTZWNvbmRzKCkpfU8oZSx0LG4pfWZ1bmN0aW9uIE8oZSx0LG4pe3ZvaWQgMCE9PWgubGF0ZXN0U2VsZWN0ZWREYXRlT2JqJiZoLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5zZXRIb3VycyhlJTI0LHQsbnx8MCwwKSxoLmhvdXJFbGVtZW50JiZoLm1pbnV0ZUVsZW1lbnQmJiFoLmlzTW9iaWxlJiYoaC5ob3VyRWxlbWVudC52YWx1ZT1pKGguY29uZmlnLnRpbWVfMjRocj9lOigxMitlKSUxMisxMipvKGUlMTI9PTApKSxoLm1pbnV0ZUVsZW1lbnQudmFsdWU9aSh0KSx2b2lkIDAhPT1oLmFtUE0mJihoLmFtUE0udGV4dENvbnRlbnQ9aC5sMTBuLmFtUE1bbyhlPj0xMildKSx2b2lkIDAhPT1oLnNlY29uZEVsZW1lbnQmJihoLnNlY29uZEVsZW1lbnQudmFsdWU9aShuKSkpfWZ1bmN0aW9uIF8oZSl7dmFyIHQ9cGFyc2VJbnQoZS50YXJnZXQudmFsdWUpKyhlLmRlbHRhfHwwKTsodC8xZTM+MXx8XFxcIkVudGVyXFxcIj09PWUua2V5JiYhL1teXFxcXGRdLy50ZXN0KHQudG9TdHJpbmcoKSkpJiZRKHQpfWZ1bmN0aW9uIEYoZSx0LG4sYSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBBcnJheT90LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIEYoZSx0LG4sYSl9KTplIGluc3RhbmNlb2YgQXJyYXk/ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBGKGUsdCxuLGEpfSk6KGUuYWRkRXZlbnRMaXN0ZW5lcih0LG4sYSksdm9pZCBoLl9oYW5kbGVycy5wdXNoKHtlbGVtZW50OmUsZXZlbnQ6dCxoYW5kbGVyOm4sb3B0aW9uczphfSkpfWZ1bmN0aW9uIE4oZSl7cmV0dXJuIGZ1bmN0aW9uKHQpezE9PT10LndoaWNoJiZlKHQpfX1mdW5jdGlvbiBZKCl7Z2UoXFxcIm9uQ2hhbmdlXFxcIil9ZnVuY3Rpb24gQShlLHQpe3ZhciBuPXZvaWQgMCE9PWU/aC5wYXJzZURhdGUoZSk6aC5sYXRlc3RTZWxlY3RlZERhdGVPYmp8fChoLmNvbmZpZy5taW5EYXRlJiZoLmNvbmZpZy5taW5EYXRlPmgubm93P2guY29uZmlnLm1pbkRhdGU6aC5jb25maWcubWF4RGF0ZSYmaC5jb25maWcubWF4RGF0ZTxoLm5vdz9oLmNvbmZpZy5tYXhEYXRlOmgubm93KSxhPWguY3VycmVudFllYXIsaT1oLmN1cnJlbnRNb250aDt0cnl7dm9pZCAwIT09biYmKGguY3VycmVudFllYXI9bi5nZXRGdWxsWWVhcigpLGguY3VycmVudE1vbnRoPW4uZ2V0TW9udGgoKSl9Y2F0Y2goZSl7ZS5tZXNzYWdlPVxcXCJJbnZhbGlkIGRhdGUgc3VwcGxpZWQ6IFxcXCIrbixoLmNvbmZpZy5lcnJvckhhbmRsZXIoZSl9dCYmaC5jdXJyZW50WWVhciE9PWEmJihnZShcXFwib25ZZWFyQ2hhbmdlXFxcIiksSygpKSwhdHx8aC5jdXJyZW50WWVhcj09PWEmJmguY3VycmVudE1vbnRoPT09aXx8Z2UoXFxcIm9uTW9udGhDaGFuZ2VcXFwiKSxoLnJlZHJhdygpfWZ1bmN0aW9uIFAoZSl7fmUudGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKFxcXCJhcnJvd1xcXCIpJiZqKGUsZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFxcXCJhcnJvd1VwXFxcIik/MTotMSl9ZnVuY3Rpb24gaihlLHQsbil7dmFyIGE9ZSYmZS50YXJnZXQsaT1ufHxhJiZhLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5maXJzdENoaWxkLG89cGUoXFxcImluY3JlbWVudFxcXCIpO28uZGVsdGE9dCxpJiZpLmRpc3BhdGNoRXZlbnQobyl9ZnVuY3Rpb24gSChlLHQsbixhKXt2YXIgaT1YKHQsITApLG89ZChcXFwic3BhblxcXCIsXFxcImZsYXRwaWNrci1kYXkgXFxcIitlLHQuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkpO3JldHVybiBvLmRhdGVPYmo9dCxvLiRpPWEsby5zZXRBdHRyaWJ1dGUoXFxcImFyaWEtbGFiZWxcXFwiLGguZm9ybWF0RGF0ZSh0LGguY29uZmlnLmFyaWFEYXRlRm9ybWF0KSksLTE9PT1lLmluZGV4T2YoXFxcImhpZGRlblxcXCIpJiYwPT09dyh0LGgubm93KSYmKGgudG9kYXlEYXRlRWxlbT1vLG8uY2xhc3NMaXN0LmFkZChcXFwidG9kYXlcXFwiKSxvLnNldEF0dHJpYnV0ZShcXFwiYXJpYS1jdXJyZW50XFxcIixcXFwiZGF0ZVxcXCIpKSxpPyhvLnRhYkluZGV4PS0xLGhlKHQpJiYoby5jbGFzc0xpc3QuYWRkKFxcXCJzZWxlY3RlZFxcXCIpLGguc2VsZWN0ZWREYXRlRWxlbT1vLFxcXCJyYW5nZVxcXCI9PT1oLmNvbmZpZy5tb2RlJiYoYyhvLFxcXCJzdGFydFJhbmdlXFxcIixoLnNlbGVjdGVkRGF0ZXNbMF0mJjA9PT13KHQsaC5zZWxlY3RlZERhdGVzWzBdLCEwKSksYyhvLFxcXCJlbmRSYW5nZVxcXCIsaC5zZWxlY3RlZERhdGVzWzFdJiYwPT09dyh0LGguc2VsZWN0ZWREYXRlc1sxXSwhMCkpLFxcXCJuZXh0TW9udGhEYXlcXFwiPT09ZSYmby5jbGFzc0xpc3QuYWRkKFxcXCJpblJhbmdlXFxcIikpKSk6by5jbGFzc0xpc3QuYWRkKFxcXCJmbGF0cGlja3ItZGlzYWJsZWRcXFwiKSxcXFwicmFuZ2VcXFwiPT09aC5jb25maWcubW9kZSYmZnVuY3Rpb24oZSl7cmV0dXJuIShcXFwicmFuZ2VcXFwiIT09aC5jb25maWcubW9kZXx8aC5zZWxlY3RlZERhdGVzLmxlbmd0aDwyKSYmdyhlLGguc2VsZWN0ZWREYXRlc1swXSk+PTAmJncoZSxoLnNlbGVjdGVkRGF0ZXNbMV0pPD0wfSh0KSYmIWhlKHQpJiZvLmNsYXNzTGlzdC5hZGQoXFxcImluUmFuZ2VcXFwiKSxoLndlZWtOdW1iZXJzJiYxPT09aC5jb25maWcuc2hvd01vbnRocyYmXFxcInByZXZNb250aERheVxcXCIhPT1lJiZuJTc9PTEmJmgud2Vla051bWJlcnMuaW5zZXJ0QWRqYWNlbnRIVE1MKFxcXCJiZWZvcmVlbmRcXFwiLFxcXCI8c3BhbiBjbGFzcz0nZmxhdHBpY2tyLWRheSc+XFxcIitoLmNvbmZpZy5nZXRXZWVrKHQpK1xcXCI8L3NwYW4+XFxcIiksZ2UoXFxcIm9uRGF5Q3JlYXRlXFxcIixvKSxvfWZ1bmN0aW9uIEwoZSl7ZS5mb2N1cygpLFxcXCJyYW5nZVxcXCI9PT1oLmNvbmZpZy5tb2RlJiZuZShlKX1mdW5jdGlvbiBXKGUpe2Zvcih2YXIgdD1lPjA/MDpoLmNvbmZpZy5zaG93TW9udGhzLTEsbj1lPjA/aC5jb25maWcuc2hvd01vbnRoczotMSxhPXQ7YSE9bjthKz1lKWZvcih2YXIgaT1oLmRheXNDb250YWluZXIuY2hpbGRyZW5bYV0sbz1lPjA/MDppLmNoaWxkcmVuLmxlbmd0aC0xLHI9ZT4wP2kuY2hpbGRyZW4ubGVuZ3RoOi0xLGw9bztsIT1yO2wrPWUpe3ZhciBjPWkuY2hpbGRyZW5bbF07aWYoLTE9PT1jLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJoaWRkZW5cXFwiKSYmWChjLmRhdGVPYmopKXJldHVybiBjfX1mdW5jdGlvbiBSKGUsdCl7dmFyIG49ZWUoZG9jdW1lbnQuYWN0aXZlRWxlbWVudHx8ZG9jdW1lbnQuYm9keSksYT12b2lkIDAhPT1lP2U6bj9kb2N1bWVudC5hY3RpdmVFbGVtZW50OnZvaWQgMCE9PWguc2VsZWN0ZWREYXRlRWxlbSYmZWUoaC5zZWxlY3RlZERhdGVFbGVtKT9oLnNlbGVjdGVkRGF0ZUVsZW06dm9pZCAwIT09aC50b2RheURhdGVFbGVtJiZlZShoLnRvZGF5RGF0ZUVsZW0pP2gudG9kYXlEYXRlRWxlbTpXKHQ+MD8xOi0xKTtyZXR1cm4gdm9pZCAwPT09YT9oLl9pbnB1dC5mb2N1cygpOm4/dm9pZCBmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0tMT09PWUuY2xhc3NOYW1lLmluZGV4T2YoXFxcIk1vbnRoXFxcIik/ZS5kYXRlT2JqLmdldE1vbnRoKCk6aC5jdXJyZW50TW9udGgsYT10PjA/aC5jb25maWcuc2hvd01vbnRoczotMSxpPXQ+MD8xOi0xLG89bi1oLmN1cnJlbnRNb250aDtvIT1hO28rPWkpZm9yKHZhciByPWguZGF5c0NvbnRhaW5lci5jaGlsZHJlbltvXSxsPW4taC5jdXJyZW50TW9udGg9PT1vP2UuJGkrdDp0PDA/ci5jaGlsZHJlbi5sZW5ndGgtMTowLGM9ci5jaGlsZHJlbi5sZW5ndGgsZD1sO2Q+PTAmJmQ8YyYmZCE9KHQ+MD9jOi0xKTtkKz1pKXt2YXIgcz1yLmNoaWxkcmVuW2RdO2lmKC0xPT09cy5jbGFzc05hbWUuaW5kZXhPZihcXFwiaGlkZGVuXFxcIikmJlgocy5kYXRlT2JqKSYmTWF0aC5hYnMoZS4kaS1kKT49TWF0aC5hYnModCkpcmV0dXJuIEwocyl9aC5jaGFuZ2VNb250aChpKSxSKFcoaSksMCl9KGEsdCk6TChhKX1mdW5jdGlvbiBCKGUsdCl7Zm9yKHZhciBuPShuZXcgRGF0ZShlLHQsMSkuZ2V0RGF5KCktaC5sMTBuLmZpcnN0RGF5T2ZXZWVrKzcpJTcsYT1oLnV0aWxzLmdldERheXNJbk1vbnRoKCh0LTErMTIpJTEyKSxpPWgudXRpbHMuZ2V0RGF5c0luTW9udGgodCksbz13aW5kb3cuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHI9aC5jb25maWcuc2hvd01vbnRocz4xLGw9cj9cXFwicHJldk1vbnRoRGF5IGhpZGRlblxcXCI6XFxcInByZXZNb250aERheVxcXCIsYz1yP1xcXCJuZXh0TW9udGhEYXkgaGlkZGVuXFxcIjpcXFwibmV4dE1vbnRoRGF5XFxcIixzPWErMS1uLHU9MDtzPD1hO3MrKyx1Kyspby5hcHBlbmRDaGlsZChIKGwsbmV3IERhdGUoZSx0LTEscykscyx1KSk7Zm9yKHM9MTtzPD1pO3MrKyx1Kyspby5hcHBlbmRDaGlsZChIKFxcXCJcXFwiLG5ldyBEYXRlKGUsdCxzKSxzLHUpKTtmb3IodmFyIGY9aSsxO2Y8PTQyLW4mJigxPT09aC5jb25maWcuc2hvd01vbnRoc3x8dSU3IT0wKTtmKyssdSsrKW8uYXBwZW5kQ2hpbGQoSChjLG5ldyBEYXRlKGUsdCsxLGYlaSksZix1KSk7dmFyIG09ZChcXFwiZGl2XFxcIixcXFwiZGF5Q29udGFpbmVyXFxcIik7cmV0dXJuIG0uYXBwZW5kQ2hpbGQobyksbX1mdW5jdGlvbiBKKCl7aWYodm9pZCAwIT09aC5kYXlzQ29udGFpbmVyKXtzKGguZGF5c0NvbnRhaW5lciksaC53ZWVrTnVtYmVycyYmcyhoLndlZWtOdW1iZXJzKTtmb3IodmFyIGU9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLHQ9MDt0PGguY29uZmlnLnNob3dNb250aHM7dCsrKXt2YXIgbj1uZXcgRGF0ZShoLmN1cnJlbnRZZWFyLGguY3VycmVudE1vbnRoLDEpO24uc2V0TW9udGgoaC5jdXJyZW50TW9udGgrdCksZS5hcHBlbmRDaGlsZChCKG4uZ2V0RnVsbFllYXIoKSxuLmdldE1vbnRoKCkpKX1oLmRheXNDb250YWluZXIuYXBwZW5kQ2hpbGQoZSksaC5kYXlzPWguZGF5c0NvbnRhaW5lci5maXJzdENoaWxkLFxcXCJyYW5nZVxcXCI9PT1oLmNvbmZpZy5tb2RlJiYxPT09aC5zZWxlY3RlZERhdGVzLmxlbmd0aCYmbmUoKX19ZnVuY3Rpb24gSygpe2lmKCEoaC5jb25maWcuc2hvd01vbnRocz4xfHxcXFwiZHJvcGRvd25cXFwiIT09aC5jb25maWcubW9udGhTZWxlY3RvclR5cGUpKXt2YXIgZT1mdW5jdGlvbihlKXtyZXR1cm4hKHZvaWQgMCE9PWguY29uZmlnLm1pbkRhdGUmJmguY3VycmVudFllYXI9PT1oLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkmJmU8aC5jb25maWcubWluRGF0ZS5nZXRNb250aCgpKSYmISh2b2lkIDAhPT1oLmNvbmZpZy5tYXhEYXRlJiZoLmN1cnJlbnRZZWFyPT09aC5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpJiZlPmguY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKSl9O2gubW9udGhzRHJvcGRvd25Db250YWluZXIudGFiSW5kZXg9LTEsaC5tb250aHNEcm9wZG93bkNvbnRhaW5lci5pbm5lckhUTUw9XFxcIlxcXCI7Zm9yKHZhciB0PTA7dDwxMjt0KyspaWYoZSh0KSl7dmFyIG49ZChcXFwib3B0aW9uXFxcIixcXFwiZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGhcXFwiKTtuLnZhbHVlPW5ldyBEYXRlKGguY3VycmVudFllYXIsdCkuZ2V0TW9udGgoKS50b1N0cmluZygpLG4udGV4dENvbnRlbnQ9bSh0LGguY29uZmlnLnNob3J0aGFuZEN1cnJlbnRNb250aCxoLmwxMG4pLG4udGFiSW5kZXg9LTEsaC5jdXJyZW50TW9udGg9PT10JiYobi5zZWxlY3RlZD0hMCksaC5tb250aHNEcm9wZG93bkNvbnRhaW5lci5hcHBlbmRDaGlsZChuKX19fWZ1bmN0aW9uIFUoKXt2YXIgZSx0PWQoXFxcImRpdlxcXCIsXFxcImZsYXRwaWNrci1tb250aFxcXCIpLG49d2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtoLmNvbmZpZy5zaG93TW9udGhzPjF8fFxcXCJzdGF0aWNcXFwiPT09aC5jb25maWcubW9udGhTZWxlY3RvclR5cGU/ZT1kKFxcXCJzcGFuXFxcIixcXFwiY3VyLW1vbnRoXFxcIik6KGgubW9udGhzRHJvcGRvd25Db250YWluZXI9ZChcXFwic2VsZWN0XFxcIixcXFwiZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGhzXFxcIiksRihoLm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyLFxcXCJjaGFuZ2VcXFwiLGZ1bmN0aW9uKGUpe3ZhciB0PWUudGFyZ2V0LG49cGFyc2VJbnQodC52YWx1ZSwxMCk7aC5jaGFuZ2VNb250aChuLWguY3VycmVudE1vbnRoKSxnZShcXFwib25Nb250aENoYW5nZVxcXCIpfSksSygpLGU9aC5tb250aHNEcm9wZG93bkNvbnRhaW5lcik7dmFyIGE9dShcXFwiY3VyLXllYXJcXFwiLHt0YWJpbmRleDpcXFwiLTFcXFwifSksaT1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJpbnB1dFxcXCIpWzBdO2kuc2V0QXR0cmlidXRlKFxcXCJhcmlhLWxhYmVsXFxcIixoLmwxMG4ueWVhckFyaWFMYWJlbCksaC5jb25maWcubWluRGF0ZSYmaS5zZXRBdHRyaWJ1dGUoXFxcIm1pblxcXCIsaC5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkpLGguY29uZmlnLm1heERhdGUmJihpLnNldEF0dHJpYnV0ZShcXFwibWF4XFxcIixoLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSksaS5kaXNhYmxlZD0hIWguY29uZmlnLm1pbkRhdGUmJmguY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKT09PWguY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSk7dmFyIG89ZChcXFwiZGl2XFxcIixcXFwiZmxhdHBpY2tyLWN1cnJlbnQtbW9udGhcXFwiKTtyZXR1cm4gby5hcHBlbmRDaGlsZChlKSxvLmFwcGVuZENoaWxkKGEpLG4uYXBwZW5kQ2hpbGQobyksdC5hcHBlbmRDaGlsZChuKSx7Y29udGFpbmVyOnQseWVhckVsZW1lbnQ6aSxtb250aEVsZW1lbnQ6ZX19ZnVuY3Rpb24gcSgpe3MoaC5tb250aE5hdiksaC5tb250aE5hdi5hcHBlbmRDaGlsZChoLnByZXZNb250aE5hdiksaC5jb25maWcuc2hvd01vbnRocyYmKGgueWVhckVsZW1lbnRzPVtdLGgubW9udGhFbGVtZW50cz1bXSk7Zm9yKHZhciBlPWguY29uZmlnLnNob3dNb250aHM7ZS0tOyl7dmFyIHQ9VSgpO2gueWVhckVsZW1lbnRzLnB1c2godC55ZWFyRWxlbWVudCksaC5tb250aEVsZW1lbnRzLnB1c2godC5tb250aEVsZW1lbnQpLGgubW9udGhOYXYuYXBwZW5kQ2hpbGQodC5jb250YWluZXIpfWgubW9udGhOYXYuYXBwZW5kQ2hpbGQoaC5uZXh0TW9udGhOYXYpfWZ1bmN0aW9uICQoKXtoLndlZWtkYXlDb250YWluZXI/cyhoLndlZWtkYXlDb250YWluZXIpOmgud2Vla2RheUNvbnRhaW5lcj1kKFxcXCJkaXZcXFwiLFxcXCJmbGF0cGlja3Itd2Vla2RheXNcXFwiKTtmb3IodmFyIGU9aC5jb25maWcuc2hvd01vbnRocztlLS07KXt2YXIgdD1kKFxcXCJkaXZcXFwiLFxcXCJmbGF0cGlja3Itd2Vla2RheWNvbnRhaW5lclxcXCIpO2gud2Vla2RheUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0KX1yZXR1cm4geigpLGgud2Vla2RheUNvbnRhaW5lcn1mdW5jdGlvbiB6KCl7aWYoaC53ZWVrZGF5Q29udGFpbmVyKXt2YXIgZT1oLmwxMG4uZmlyc3REYXlPZldlZWssdD1oLmwxMG4ud2Vla2RheXMuc2hvcnRoYW5kLnNsaWNlKCk7ZT4wJiZlPHQubGVuZ3RoJiYodD10LnNwbGljZShlLHQubGVuZ3RoKS5jb25jYXQodC5zcGxpY2UoMCxlKSkpO2Zvcih2YXIgbj1oLmNvbmZpZy5zaG93TW9udGhzO24tLTspaC53ZWVrZGF5Q29udGFpbmVyLmNoaWxkcmVuW25dLmlubmVySFRNTD1cXFwiXFxcXG4gICAgICA8c3BhbiBjbGFzcz0nZmxhdHBpY2tyLXdlZWtkYXknPlxcXFxuICAgICAgICBcXFwiK3Quam9pbihcXFwiPC9zcGFuPjxzcGFuIGNsYXNzPSdmbGF0cGlja3Itd2Vla2RheSc+XFxcIikrXFxcIlxcXFxuICAgICAgPC9zcGFuPlxcXFxuICAgICAgXFxcIn19ZnVuY3Rpb24gRyhlLHQpe3ZvaWQgMD09PXQmJih0PSEwKTt2YXIgbj10P2U6ZS1oLmN1cnJlbnRNb250aDtuPDAmJiEwPT09aC5faGlkZVByZXZNb250aEFycm93fHxuPjAmJiEwPT09aC5faGlkZU5leHRNb250aEFycm93fHwoaC5jdXJyZW50TW9udGgrPW4sKGguY3VycmVudE1vbnRoPDB8fGguY3VycmVudE1vbnRoPjExKSYmKGguY3VycmVudFllYXIrPWguY3VycmVudE1vbnRoPjExPzE6LTEsaC5jdXJyZW50TW9udGg9KGguY3VycmVudE1vbnRoKzEyKSUxMixnZShcXFwib25ZZWFyQ2hhbmdlXFxcIiksSygpKSxKKCksZ2UoXFxcIm9uTW9udGhDaGFuZ2VcXFwiKSx2ZSgpKX1mdW5jdGlvbiBWKGUpe3JldHVybiEoIWguY29uZmlnLmFwcGVuZFRvfHwhaC5jb25maWcuYXBwZW5kVG8uY29udGFpbnMoZSkpfHxoLmNhbGVuZGFyQ29udGFpbmVyLmNvbnRhaW5zKGUpfWZ1bmN0aW9uIFooZSl7aWYoaC5pc09wZW4mJiFoLmNvbmZpZy5pbmxpbmUpe3ZhciB0PVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZihyPWUpLmNvbXBvc2VkUGF0aD9yLmNvbXBvc2VkUGF0aCgpWzBdOnIudGFyZ2V0LG49Vih0KSxhPXQ9PT1oLmlucHV0fHx0PT09aC5hbHRJbnB1dHx8aC5lbGVtZW50LmNvbnRhaW5zKHQpfHxlLnBhdGgmJmUucGF0aC5pbmRleE9mJiYofmUucGF0aC5pbmRleE9mKGguaW5wdXQpfHx+ZS5wYXRoLmluZGV4T2YoaC5hbHRJbnB1dCkpLGk9XFxcImJsdXJcXFwiPT09ZS50eXBlP2EmJmUucmVsYXRlZFRhcmdldCYmIVYoZS5yZWxhdGVkVGFyZ2V0KTohYSYmIW4mJiFWKGUucmVsYXRlZFRhcmdldCksbz0haC5jb25maWcuaWdub3JlZEZvY3VzRWxlbWVudHMuc29tZShmdW5jdGlvbihlKXtyZXR1cm4gZS5jb250YWlucyh0KX0pO2kmJm8mJih2b2lkIDAhPT1oLnRpbWVDb250YWluZXImJnZvaWQgMCE9PWgubWludXRlRWxlbWVudCYmdm9pZCAwIT09aC5ob3VyRWxlbWVudCYmVCgpLGguY2xvc2UoKSxcXFwicmFuZ2VcXFwiPT09aC5jb25maWcubW9kZSYmMT09PWguc2VsZWN0ZWREYXRlcy5sZW5ndGgmJihoLmNsZWFyKCExKSxoLnJlZHJhdygpKSl9dmFyIHJ9ZnVuY3Rpb24gUShlKXtpZighKCFlfHxoLmNvbmZpZy5taW5EYXRlJiZlPGguY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKXx8aC5jb25maWcubWF4RGF0ZSYmZT5oLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpKXt2YXIgdD1lLG49aC5jdXJyZW50WWVhciE9PXQ7aC5jdXJyZW50WWVhcj10fHxoLmN1cnJlbnRZZWFyLGguY29uZmlnLm1heERhdGUmJmguY3VycmVudFllYXI9PT1oLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCk/aC5jdXJyZW50TW9udGg9TWF0aC5taW4oaC5jb25maWcubWF4RGF0ZS5nZXRNb250aCgpLGguY3VycmVudE1vbnRoKTpoLmNvbmZpZy5taW5EYXRlJiZoLmN1cnJlbnRZZWFyPT09aC5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpJiYoaC5jdXJyZW50TW9udGg9TWF0aC5tYXgoaC5jb25maWcubWluRGF0ZS5nZXRNb250aCgpLGguY3VycmVudE1vbnRoKSksbiYmKGgucmVkcmF3KCksZ2UoXFxcIm9uWWVhckNoYW5nZVxcXCIpLEsoKSl9fWZ1bmN0aW9uIFgoZSx0KXt2b2lkIDA9PT10JiYodD0hMCk7dmFyIG49aC5wYXJzZURhdGUoZSx2b2lkIDAsdCk7aWYoaC5jb25maWcubWluRGF0ZSYmbiYmdyhuLGguY29uZmlnLm1pbkRhdGUsdm9pZCAwIT09dD90OiFoLm1pbkRhdGVIYXNUaW1lKTwwfHxoLmNvbmZpZy5tYXhEYXRlJiZuJiZ3KG4saC5jb25maWcubWF4RGF0ZSx2b2lkIDAhPT10P3Q6IWgubWF4RGF0ZUhhc1RpbWUpPjApcmV0dXJuITE7aWYoMD09PWguY29uZmlnLmVuYWJsZS5sZW5ndGgmJjA9PT1oLmNvbmZpZy5kaXNhYmxlLmxlbmd0aClyZXR1cm4hMDtpZih2b2lkIDA9PT1uKXJldHVybiExO2Zvcih2YXIgYT1oLmNvbmZpZy5lbmFibGUubGVuZ3RoPjAsaT1hP2guY29uZmlnLmVuYWJsZTpoLmNvbmZpZy5kaXNhYmxlLG89MCxyPXZvaWQgMDtvPGkubGVuZ3RoO28rKyl7aWYoXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mKHI9aVtvXSkmJnIobikpcmV0dXJuIGE7aWYociBpbnN0YW5jZW9mIERhdGUmJnZvaWQgMCE9PW4mJnIuZ2V0VGltZSgpPT09bi5nZXRUaW1lKCkpcmV0dXJuIGE7aWYoXFxcInN0cmluZ1xcXCI9PXR5cGVvZiByJiZ2b2lkIDAhPT1uKXt2YXIgbD1oLnBhcnNlRGF0ZShyLHZvaWQgMCwhMCk7cmV0dXJuIGwmJmwuZ2V0VGltZSgpPT09bi5nZXRUaW1lKCk/YTohYX1pZihcXFwib2JqZWN0XFxcIj09dHlwZW9mIHImJnZvaWQgMCE9PW4mJnIuZnJvbSYmci50byYmbi5nZXRUaW1lKCk+PXIuZnJvbS5nZXRUaW1lKCkmJm4uZ2V0VGltZSgpPD1yLnRvLmdldFRpbWUoKSlyZXR1cm4gYX1yZXR1cm4hYX1mdW5jdGlvbiBlZShlKXtyZXR1cm4gdm9pZCAwIT09aC5kYXlzQ29udGFpbmVyJiYoLTE9PT1lLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJoaWRkZW5cXFwiKSYmaC5kYXlzQ29udGFpbmVyLmNvbnRhaW5zKGUpKX1mdW5jdGlvbiB0ZShlKXt2YXIgdD1lLnRhcmdldD09PWguX2lucHV0LG49aC5jb25maWcuYWxsb3dJbnB1dCxhPWguaXNPcGVuJiYoIW58fCF0KSxpPWguY29uZmlnLmlubGluZSYmdCYmIW47aWYoMTM9PT1lLmtleUNvZGUmJnQpe2lmKG4pcmV0dXJuIGguc2V0RGF0ZShoLl9pbnB1dC52YWx1ZSwhMCxlLnRhcmdldD09PWguYWx0SW5wdXQ/aC5jb25maWcuYWx0Rm9ybWF0OmguY29uZmlnLmRhdGVGb3JtYXQpLGUudGFyZ2V0LmJsdXIoKTtoLm9wZW4oKX1lbHNlIGlmKFYoZS50YXJnZXQpfHxhfHxpKXt2YXIgbz0hIWgudGltZUNvbnRhaW5lciYmaC50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KTtzd2l0Y2goZS5rZXlDb2RlKXtjYXNlIDEzOm8/KGUucHJldmVudERlZmF1bHQoKSxUKCksZGUoKSk6c2UoZSk7YnJlYWs7Y2FzZSAyNzplLnByZXZlbnREZWZhdWx0KCksZGUoKTticmVhaztjYXNlIDg6Y2FzZSA0Njp0JiYhaC5jb25maWcuYWxsb3dJbnB1dCYmKGUucHJldmVudERlZmF1bHQoKSxoLmNsZWFyKCkpO2JyZWFrO2Nhc2UgMzc6Y2FzZSAzOTppZihvfHx0KWguaG91ckVsZW1lbnQmJmguaG91ckVsZW1lbnQuZm9jdXMoKTtlbHNlIGlmKGUucHJldmVudERlZmF1bHQoKSx2b2lkIDAhPT1oLmRheXNDb250YWluZXImJighMT09PW58fGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQmJmVlKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSl7dmFyIHI9Mzk9PT1lLmtleUNvZGU/MTotMTtlLmN0cmxLZXk/KGUuc3RvcFByb3BhZ2F0aW9uKCksRyhyKSxSKFcoMSksMCkpOlIodm9pZCAwLHIpfWJyZWFrO2Nhc2UgMzg6Y2FzZSA0MDplLnByZXZlbnREZWZhdWx0KCk7dmFyIGw9NDA9PT1lLmtleUNvZGU/MTotMTtoLmRheXNDb250YWluZXImJnZvaWQgMCE9PWUudGFyZ2V0LiRpfHxlLnRhcmdldD09PWguaW5wdXR8fGUudGFyZ2V0PT09aC5hbHRJbnB1dD9lLmN0cmxLZXk/KGUuc3RvcFByb3BhZ2F0aW9uKCksUShoLmN1cnJlbnRZZWFyLWwpLFIoVygxKSwwKSk6b3x8Uih2b2lkIDAsNypsKTplLnRhcmdldD09PWguY3VycmVudFllYXJFbGVtZW50P1EoaC5jdXJyZW50WWVhci1sKTpoLmNvbmZpZy5lbmFibGVUaW1lJiYoIW8mJmguaG91ckVsZW1lbnQmJmguaG91ckVsZW1lbnQuZm9jdXMoKSxUKGUpLGguX2RlYm91bmNlZENoYW5nZSgpKTticmVhaztjYXNlIDk6aWYobyl7dmFyIGM9W2guaG91ckVsZW1lbnQsaC5taW51dGVFbGVtZW50LGguc2Vjb25kRWxlbWVudCxoLmFtUE1dLmNvbmNhdChoLnBsdWdpbkVsZW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KSxkPWMuaW5kZXhPZihlLnRhcmdldCk7aWYoLTEhPT1kKXt2YXIgcz1jW2QrKGUuc2hpZnRLZXk/LTE6MSldO2UucHJldmVudERlZmF1bHQoKSwoc3x8aC5faW5wdXQpLmZvY3VzKCl9fWVsc2UhaC5jb25maWcubm9DYWxlbmRhciYmaC5kYXlzQ29udGFpbmVyJiZoLmRheXNDb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpJiZlLnNoaWZ0S2V5JiYoZS5wcmV2ZW50RGVmYXVsdCgpLGguX2lucHV0LmZvY3VzKCkpfX1pZih2b2lkIDAhPT1oLmFtUE0mJmUudGFyZ2V0PT09aC5hbVBNKXN3aXRjaChlLmtleSl7Y2FzZSBoLmwxMG4uYW1QTVswXS5jaGFyQXQoMCk6Y2FzZSBoLmwxMG4uYW1QTVswXS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTpoLmFtUE0udGV4dENvbnRlbnQ9aC5sMTBuLmFtUE1bMF0saygpLHdlKCk7YnJlYWs7Y2FzZSBoLmwxMG4uYW1QTVsxXS5jaGFyQXQoMCk6Y2FzZSBoLmwxMG4uYW1QTVsxXS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTpoLmFtUE0udGV4dENvbnRlbnQ9aC5sMTBuLmFtUE1bMV0saygpLHdlKCl9KHR8fFYoZS50YXJnZXQpKSYmZ2UoXFxcIm9uS2V5RG93blxcXCIsZSl9ZnVuY3Rpb24gbmUoZSl7aWYoMT09PWguc2VsZWN0ZWREYXRlcy5sZW5ndGgmJighZXx8ZS5jbGFzc0xpc3QuY29udGFpbnMoXFxcImZsYXRwaWNrci1kYXlcXFwiKSYmIWUuY2xhc3NMaXN0LmNvbnRhaW5zKFxcXCJmbGF0cGlja3ItZGlzYWJsZWRcXFwiKSkpe2Zvcih2YXIgdD1lP2UuZGF0ZU9iai5nZXRUaW1lKCk6aC5kYXlzLmZpcnN0RWxlbWVudENoaWxkLmRhdGVPYmouZ2V0VGltZSgpLG49aC5wYXJzZURhdGUoaC5zZWxlY3RlZERhdGVzWzBdLHZvaWQgMCwhMCkuZ2V0VGltZSgpLGE9TWF0aC5taW4odCxoLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpKSxpPU1hdGgubWF4KHQsaC5zZWxlY3RlZERhdGVzWzBdLmdldFRpbWUoKSksbz0hMSxyPTAsbD0wLGM9YTtjPGk7Yys9Qy5EQVkpWChuZXcgRGF0ZShjKSwhMCl8fChvPW98fGM+YSYmYzxpLGM8biYmKCFyfHxjPnIpP3I9YzpjPm4mJighbHx8YzxsKSYmKGw9YykpO2Zvcih2YXIgZD0wO2Q8aC5jb25maWcuc2hvd01vbnRocztkKyspZm9yKHZhciBzPWguZGF5c0NvbnRhaW5lci5jaGlsZHJlbltkXSx1PWZ1bmN0aW9uKGEsaSl7dmFyIGM9cy5jaGlsZHJlblthXSxkPWMuZGF0ZU9iai5nZXRUaW1lKCksdT1yPjAmJmQ8cnx8bD4wJiZkPmw7cmV0dXJuIHU/KGMuY2xhc3NMaXN0LmFkZChcXFwibm90QWxsb3dlZFxcXCIpLFtcXFwiaW5SYW5nZVxcXCIsXFxcInN0YXJ0UmFuZ2VcXFwiLFxcXCJlbmRSYW5nZVxcXCJdLmZvckVhY2goZnVuY3Rpb24oZSl7Yy5jbGFzc0xpc3QucmVtb3ZlKGUpfSksXFxcImNvbnRpbnVlXFxcIik6byYmIXU/XFxcImNvbnRpbnVlXFxcIjooW1xcXCJzdGFydFJhbmdlXFxcIixcXFwiaW5SYW5nZVxcXCIsXFxcImVuZFJhbmdlXFxcIixcXFwibm90QWxsb3dlZFxcXCJdLmZvckVhY2goZnVuY3Rpb24oZSl7Yy5jbGFzc0xpc3QucmVtb3ZlKGUpfSksdm9pZCh2b2lkIDAhPT1lJiYoZS5jbGFzc0xpc3QuYWRkKHQ8PWguc2VsZWN0ZWREYXRlc1swXS5nZXRUaW1lKCk/XFxcInN0YXJ0UmFuZ2VcXFwiOlxcXCJlbmRSYW5nZVxcXCIpLG48dCYmZD09PW4/Yy5jbGFzc0xpc3QuYWRkKFxcXCJzdGFydFJhbmdlXFxcIik6bj50JiZkPT09biYmYy5jbGFzc0xpc3QuYWRkKFxcXCJlbmRSYW5nZVxcXCIpLGQ+PXImJigwPT09bHx8ZDw9bCkmJmIoZCxuLHQpJiZjLmNsYXNzTGlzdC5hZGQoXFxcImluUmFuZ2VcXFwiKSkpKX0sZj0wLG09cy5jaGlsZHJlbi5sZW5ndGg7ZjxtO2YrKyl1KGYpfX1mdW5jdGlvbiBhZSgpeyFoLmlzT3Blbnx8aC5jb25maWcuc3RhdGljfHxoLmNvbmZpZy5pbmxpbmV8fGxlKCl9ZnVuY3Rpb24gaWUoKXtoLnNldERhdGUodm9pZCAwIT09aC5jb25maWcubWluRGF0ZT9uZXcgRGF0ZShoLmNvbmZpZy5taW5EYXRlLmdldFRpbWUoKSk6bmV3IERhdGUsITApLFMoKSx3ZSgpfWZ1bmN0aW9uIG9lKGUpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj1oLmNvbmZpZ1tcXFwiX1xcXCIrZStcXFwiRGF0ZVxcXCJdPWgucGFyc2VEYXRlKHQsaC5jb25maWcuZGF0ZUZvcm1hdCksYT1oLmNvbmZpZ1tcXFwiX1xcXCIrKFxcXCJtaW5cXFwiPT09ZT9cXFwibWF4XFxcIjpcXFwibWluXFxcIikrXFxcIkRhdGVcXFwiXTt2b2lkIDAhPT1uJiYoaFtcXFwibWluXFxcIj09PWU/XFxcIm1pbkRhdGVIYXNUaW1lXFxcIjpcXFwibWF4RGF0ZUhhc1RpbWVcXFwiXT1uLmdldEhvdXJzKCk+MHx8bi5nZXRNaW51dGVzKCk+MHx8bi5nZXRTZWNvbmRzKCk+MCksaC5zZWxlY3RlZERhdGVzJiYoaC5zZWxlY3RlZERhdGVzPWguc2VsZWN0ZWREYXRlcy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIFgoZSl9KSxoLnNlbGVjdGVkRGF0ZXMubGVuZ3RofHxcXFwibWluXFxcIiE9PWV8fEkobiksd2UoKSksaC5kYXlzQ29udGFpbmVyJiYoY2UoKSx2b2lkIDAhPT1uP2guY3VycmVudFllYXJFbGVtZW50W2VdPW4uZ2V0RnVsbFllYXIoKS50b1N0cmluZygpOmguY3VycmVudFllYXJFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShlKSxoLmN1cnJlbnRZZWFyRWxlbWVudC5kaXNhYmxlZD0hIWEmJnZvaWQgMCE9PW4mJmEuZ2V0RnVsbFllYXIoKT09PW4uZ2V0RnVsbFllYXIoKSl9fWZ1bmN0aW9uIHJlKCl7XFxcIm9iamVjdFxcXCIhPXR5cGVvZiBoLmNvbmZpZy5sb2NhbGUmJnZvaWQgMD09PUUubDEwbnNbaC5jb25maWcubG9jYWxlXSYmaC5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcXFwiZmxhdHBpY2tyOiBpbnZhbGlkIGxvY2FsZSBcXFwiK2guY29uZmlnLmxvY2FsZSkpLGgubDEwbj1lKHt9LEUubDEwbnMuZGVmYXVsdCxcXFwib2JqZWN0XFxcIj09dHlwZW9mIGguY29uZmlnLmxvY2FsZT9oLmNvbmZpZy5sb2NhbGU6XFxcImRlZmF1bHRcXFwiIT09aC5jb25maWcubG9jYWxlP0UubDEwbnNbaC5jb25maWcubG9jYWxlXTp2b2lkIDApLHAuSz1cXFwiKFxcXCIraC5sMTBuLmFtUE1bMF0rXFxcInxcXFwiK2gubDEwbi5hbVBNWzFdK1xcXCJ8XFxcIitoLmwxMG4uYW1QTVswXS50b0xvd2VyQ2FzZSgpK1xcXCJ8XFxcIitoLmwxMG4uYW1QTVsxXS50b0xvd2VyQ2FzZSgpK1xcXCIpXFxcIix2b2lkIDA9PT1lKHt9LGcsSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShmLmRhdGFzZXR8fHt9KSkpLnRpbWVfMjRociYmdm9pZCAwPT09RS5kZWZhdWx0Q29uZmlnLnRpbWVfMjRociYmKGguY29uZmlnLnRpbWVfMjRocj1oLmwxMG4udGltZV8yNGhyKSxoLmZvcm1hdERhdGU9dihoKSxoLnBhcnNlRGF0ZT1EKHtjb25maWc6aC5jb25maWcsbDEwbjpoLmwxMG59KX1mdW5jdGlvbiBsZShlKXtpZih2b2lkIDAhPT1oLmNhbGVuZGFyQ29udGFpbmVyKXtnZShcXFwib25QcmVDYWxlbmRhclBvc2l0aW9uXFxcIik7dmFyIHQ9ZXx8aC5fcG9zaXRpb25FbGVtZW50LG49QXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKGguY2FsZW5kYXJDb250YWluZXIuY2hpbGRyZW4sZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSt0Lm9mZnNldEhlaWdodH0sMCksYT1oLmNhbGVuZGFyQ29udGFpbmVyLm9mZnNldFdpZHRoLGk9aC5jb25maWcucG9zaXRpb24uc3BsaXQoXFxcIiBcXFwiKSxvPWlbMF0scj1pLmxlbmd0aD4xP2lbMV06bnVsbCxsPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZD13aW5kb3cuaW5uZXJIZWlnaHQtbC5ib3R0b20scz1cXFwiYWJvdmVcXFwiPT09b3x8XFxcImJlbG93XFxcIiE9PW8mJmQ8biYmbC50b3A+bix1PXdpbmRvdy5wYWdlWU9mZnNldCtsLnRvcCsocz8tbi0yOnQub2Zmc2V0SGVpZ2h0KzIpO2lmKGMoaC5jYWxlbmRhckNvbnRhaW5lcixcXFwiYXJyb3dUb3BcXFwiLCFzKSxjKGguY2FsZW5kYXJDb250YWluZXIsXFxcImFycm93Qm90dG9tXFxcIixzKSwhaC5jb25maWcuaW5saW5lKXt2YXIgZj13aW5kb3cucGFnZVhPZmZzZXQrbC5sZWZ0LShudWxsIT1yJiZcXFwiY2VudGVyXFxcIj09PXI/KGEtbC53aWR0aCkvMjowKSxtPXdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoLSh3aW5kb3cucGFnZVhPZmZzZXQrbC5yaWdodCksZz1mK2E+d2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgscD1tK2E+d2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7aWYoYyhoLmNhbGVuZGFyQ29udGFpbmVyLFxcXCJyaWdodE1vc3RcXFwiLGcpLCFoLmNvbmZpZy5zdGF0aWMpaWYoaC5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS50b3A9dStcXFwicHhcXFwiLGcpaWYocCl7dmFyIHY9ZG9jdW1lbnQuc3R5bGVTaGVldHNbMF07aWYodm9pZCAwPT09dilyZXR1cm47dmFyIEQ9d2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgsdz1NYXRoLm1heCgwLEQvMi1hLzIpLGI9di5jc3NSdWxlcy5sZW5ndGgsQz1cXFwie2xlZnQ6XFxcIitsLmxlZnQrXFxcInB4O3JpZ2h0OmF1dG87fVxcXCI7YyhoLmNhbGVuZGFyQ29udGFpbmVyLFxcXCJyaWdodE1vc3RcXFwiLCExKSxjKGguY2FsZW5kYXJDb250YWluZXIsXFxcImNlbnRlck1vc3RcXFwiLCEwKSx2Lmluc2VydFJ1bGUoXFxcIi5mbGF0cGlja3ItY2FsZW5kYXIuY2VudGVyTW9zdDpiZWZvcmUsLmZsYXRwaWNrci1jYWxlbmRhci5jZW50ZXJNb3N0OmFmdGVyXFxcIitDLGIpLGguY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdD13K1xcXCJweFxcXCIsaC5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodD1cXFwiYXV0b1xcXCJ9ZWxzZSBoLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQ9XFxcImF1dG9cXFwiLGguY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQ9bStcXFwicHhcXFwiO2Vsc2UgaC5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5sZWZ0PWYrXFxcInB4XFxcIixoLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJpZ2h0PVxcXCJhdXRvXFxcIn19fWZ1bmN0aW9uIGNlKCl7aC5jb25maWcubm9DYWxlbmRhcnx8aC5pc01vYmlsZXx8KHZlKCksSigpKX1mdW5jdGlvbiBkZSgpe2guX2lucHV0LmZvY3VzKCksLTEhPT13aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNU0lFXFxcIil8fHZvaWQgMCE9PW5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzP3NldFRpbWVvdXQoaC5jbG9zZSwwKTpoLmNsb3NlKCl9ZnVuY3Rpb24gc2UoZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCk7dmFyIHQ9ZnVuY3Rpb24gZSh0LG4pe3JldHVybiBuKHQpP3Q6dC5wYXJlbnROb2RlP2UodC5wYXJlbnROb2RlLG4pOnZvaWQgMH0oZS50YXJnZXQsZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xhc3NMaXN0JiZlLmNsYXNzTGlzdC5jb250YWlucyhcXFwiZmxhdHBpY2tyLWRheVxcXCIpJiYhZS5jbGFzc0xpc3QuY29udGFpbnMoXFxcImZsYXRwaWNrci1kaXNhYmxlZFxcXCIpJiYhZS5jbGFzc0xpc3QuY29udGFpbnMoXFxcIm5vdEFsbG93ZWRcXFwiKX0pO2lmKHZvaWQgMCE9PXQpe3ZhciBuPXQsYT1oLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaj1uZXcgRGF0ZShuLmRhdGVPYmouZ2V0VGltZSgpKSxpPShhLmdldE1vbnRoKCk8aC5jdXJyZW50TW9udGh8fGEuZ2V0TW9udGgoKT5oLmN1cnJlbnRNb250aCtoLmNvbmZpZy5zaG93TW9udGhzLTEpJiZcXFwicmFuZ2VcXFwiIT09aC5jb25maWcubW9kZTtpZihoLnNlbGVjdGVkRGF0ZUVsZW09bixcXFwic2luZ2xlXFxcIj09PWguY29uZmlnLm1vZGUpaC5zZWxlY3RlZERhdGVzPVthXTtlbHNlIGlmKFxcXCJtdWx0aXBsZVxcXCI9PT1oLmNvbmZpZy5tb2RlKXt2YXIgbz1oZShhKTtvP2guc2VsZWN0ZWREYXRlcy5zcGxpY2UocGFyc2VJbnQobyksMSk6aC5zZWxlY3RlZERhdGVzLnB1c2goYSl9ZWxzZVxcXCJyYW5nZVxcXCI9PT1oLmNvbmZpZy5tb2RlJiYoMj09PWguc2VsZWN0ZWREYXRlcy5sZW5ndGgmJmguY2xlYXIoITEsITEpLGgubGF0ZXN0U2VsZWN0ZWREYXRlT2JqPWEsaC5zZWxlY3RlZERhdGVzLnB1c2goYSksMCE9PXcoYSxoLnNlbGVjdGVkRGF0ZXNbMF0sITApJiZoLnNlbGVjdGVkRGF0ZXMuc29ydChmdW5jdGlvbihlLHQpe3JldHVybiBlLmdldFRpbWUoKS10LmdldFRpbWUoKX0pKTtpZihrKCksaSl7dmFyIHI9aC5jdXJyZW50WWVhciE9PWEuZ2V0RnVsbFllYXIoKTtoLmN1cnJlbnRZZWFyPWEuZ2V0RnVsbFllYXIoKSxoLmN1cnJlbnRNb250aD1hLmdldE1vbnRoKCksciYmKGdlKFxcXCJvblllYXJDaGFuZ2VcXFwiKSxLKCkpLGdlKFxcXCJvbk1vbnRoQ2hhbmdlXFxcIil9aWYodmUoKSxKKCksd2UoKSxoLmNvbmZpZy5lbmFibGVUaW1lJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGguc2hvd1RpbWVJbnB1dD0hMH0sNTApLGl8fFxcXCJyYW5nZVxcXCI9PT1oLmNvbmZpZy5tb2RlfHwxIT09aC5jb25maWcuc2hvd01vbnRocz92b2lkIDAhPT1oLnNlbGVjdGVkRGF0ZUVsZW0mJnZvaWQgMD09PWguaG91ckVsZW1lbnQmJmguc2VsZWN0ZWREYXRlRWxlbSYmaC5zZWxlY3RlZERhdGVFbGVtLmZvY3VzKCk6TChuKSx2b2lkIDAhPT1oLmhvdXJFbGVtZW50JiZ2b2lkIDAhPT1oLmhvdXJFbGVtZW50JiZoLmhvdXJFbGVtZW50LmZvY3VzKCksaC5jb25maWcuY2xvc2VPblNlbGVjdCl7dmFyIGw9XFxcInNpbmdsZVxcXCI9PT1oLmNvbmZpZy5tb2RlJiYhaC5jb25maWcuZW5hYmxlVGltZSxjPVxcXCJyYW5nZVxcXCI9PT1oLmNvbmZpZy5tb2RlJiYyPT09aC5zZWxlY3RlZERhdGVzLmxlbmd0aCYmIWguY29uZmlnLmVuYWJsZVRpbWU7KGx8fGMpJiZkZSgpfVkoKX19aC5wYXJzZURhdGU9RCh7Y29uZmlnOmguY29uZmlnLGwxMG46aC5sMTBufSksaC5faGFuZGxlcnM9W10saC5wbHVnaW5FbGVtZW50cz1bXSxoLmxvYWRlZFBsdWdpbnM9W10saC5fYmluZD1GLGguX3NldEhvdXJzRnJvbURhdGU9SSxoLl9wb3NpdGlvbkNhbGVuZGFyPWxlLGguY2hhbmdlTW9udGg9RyxoLmNoYW5nZVllYXI9USxoLmNsZWFyPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09ZSYmKGU9ITApO3ZvaWQgMD09PXQmJih0PSEwKTtoLmlucHV0LnZhbHVlPVxcXCJcXFwiLHZvaWQgMCE9PWguYWx0SW5wdXQmJihoLmFsdElucHV0LnZhbHVlPVxcXCJcXFwiKTt2b2lkIDAhPT1oLm1vYmlsZUlucHV0JiYoaC5tb2JpbGVJbnB1dC52YWx1ZT1cXFwiXFxcIik7aC5zZWxlY3RlZERhdGVzPVtdLGgubGF0ZXN0U2VsZWN0ZWREYXRlT2JqPXZvaWQgMCwhMD09PXQmJihoLmN1cnJlbnRZZWFyPWguX2luaXRpYWxEYXRlLmdldEZ1bGxZZWFyKCksaC5jdXJyZW50TW9udGg9aC5faW5pdGlhbERhdGUuZ2V0TW9udGgoKSk7aC5zaG93VGltZUlucHV0PSExLCEwPT09aC5jb25maWcuZW5hYmxlVGltZSYmUygpO2gucmVkcmF3KCksZSYmZ2UoXFxcIm9uQ2hhbmdlXFxcIil9LGguY2xvc2U9ZnVuY3Rpb24oKXtoLmlzT3Blbj0hMSxoLmlzTW9iaWxlfHwodm9pZCAwIT09aC5jYWxlbmRhckNvbnRhaW5lciYmaC5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFxcXCJvcGVuXFxcIiksdm9pZCAwIT09aC5faW5wdXQmJmguX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoXFxcImFjdGl2ZVxcXCIpKTtnZShcXFwib25DbG9zZVxcXCIpfSxoLl9jcmVhdGVFbGVtZW50PWQsaC5kZXN0cm95PWZ1bmN0aW9uKCl7dm9pZCAwIT09aC5jb25maWcmJmdlKFxcXCJvbkRlc3Ryb3lcXFwiKTtmb3IodmFyIGU9aC5faGFuZGxlcnMubGVuZ3RoO2UtLTspe3ZhciB0PWguX2hhbmRsZXJzW2VdO3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHQuZXZlbnQsdC5oYW5kbGVyLHQub3B0aW9ucyl9aWYoaC5faGFuZGxlcnM9W10saC5tb2JpbGVJbnB1dCloLm1vYmlsZUlucHV0LnBhcmVudE5vZGUmJmgubW9iaWxlSW5wdXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChoLm1vYmlsZUlucHV0KSxoLm1vYmlsZUlucHV0PXZvaWQgMDtlbHNlIGlmKGguY2FsZW5kYXJDb250YWluZXImJmguY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZSlpZihoLmNvbmZpZy5zdGF0aWMmJmguY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZSl7dmFyIG49aC5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlO2lmKG4ubGFzdENoaWxkJiZuLnJlbW92ZUNoaWxkKG4ubGFzdENoaWxkKSxuLnBhcmVudE5vZGUpe2Zvcig7bi5maXJzdENoaWxkOyluLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG4uZmlyc3RDaGlsZCxuKTtuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobil9fWVsc2UgaC5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGguY2FsZW5kYXJDb250YWluZXIpO2guYWx0SW5wdXQmJihoLmlucHV0LnR5cGU9XFxcInRleHRcXFwiLGguYWx0SW5wdXQucGFyZW50Tm9kZSYmaC5hbHRJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGguYWx0SW5wdXQpLGRlbGV0ZSBoLmFsdElucHV0KTtoLmlucHV0JiYoaC5pbnB1dC50eXBlPWguaW5wdXQuX3R5cGUsaC5pbnB1dC5jbGFzc0xpc3QucmVtb3ZlKFxcXCJmbGF0cGlja3ItaW5wdXRcXFwiKSxoLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcXFwicmVhZG9ubHlcXFwiKSxoLmlucHV0LnZhbHVlPVxcXCJcXFwiKTtbXFxcIl9zaG93VGltZUlucHV0XFxcIixcXFwibGF0ZXN0U2VsZWN0ZWREYXRlT2JqXFxcIixcXFwiX2hpZGVOZXh0TW9udGhBcnJvd1xcXCIsXFxcIl9oaWRlUHJldk1vbnRoQXJyb3dcXFwiLFxcXCJfX2hpZGVOZXh0TW9udGhBcnJvd1xcXCIsXFxcIl9faGlkZVByZXZNb250aEFycm93XFxcIixcXFwiaXNNb2JpbGVcXFwiLFxcXCJpc09wZW5cXFwiLFxcXCJzZWxlY3RlZERhdGVFbGVtXFxcIixcXFwibWluRGF0ZUhhc1RpbWVcXFwiLFxcXCJtYXhEYXRlSGFzVGltZVxcXCIsXFxcImRheXNcXFwiLFxcXCJkYXlzQ29udGFpbmVyXFxcIixcXFwiX2lucHV0XFxcIixcXFwiX3Bvc2l0aW9uRWxlbWVudFxcXCIsXFxcImlubmVyQ29udGFpbmVyXFxcIixcXFwickNvbnRhaW5lclxcXCIsXFxcIm1vbnRoTmF2XFxcIixcXFwidG9kYXlEYXRlRWxlbVxcXCIsXFxcImNhbGVuZGFyQ29udGFpbmVyXFxcIixcXFwid2Vla2RheUNvbnRhaW5lclxcXCIsXFxcInByZXZNb250aE5hdlxcXCIsXFxcIm5leHRNb250aE5hdlxcXCIsXFxcIm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyXFxcIixcXFwiY3VycmVudE1vbnRoRWxlbWVudFxcXCIsXFxcImN1cnJlbnRZZWFyRWxlbWVudFxcXCIsXFxcIm5hdmlnYXRpb25DdXJyZW50TW9udGhcXFwiLFxcXCJzZWxlY3RlZERhdGVFbGVtXFxcIixcXFwiY29uZmlnXFxcIl0uZm9yRWFjaChmdW5jdGlvbihlKXt0cnl7ZGVsZXRlIGhbZV19Y2F0Y2goZSl7fX0pfSxoLmlzRW5hYmxlZD1YLGguanVtcFRvRGF0ZT1BLGgub3Blbj1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PWguX3Bvc2l0aW9uRWxlbWVudCk7aWYoITA9PT1oLmlzTW9iaWxlKXJldHVybiBlJiYoZS5wcmV2ZW50RGVmYXVsdCgpLGUudGFyZ2V0JiZlLnRhcmdldC5ibHVyKCkpLHZvaWQgMCE9PWgubW9iaWxlSW5wdXQmJihoLm1vYmlsZUlucHV0LmZvY3VzKCksaC5tb2JpbGVJbnB1dC5jbGljaygpKSx2b2lkIGdlKFxcXCJvbk9wZW5cXFwiKTtpZihoLl9pbnB1dC5kaXNhYmxlZHx8aC5jb25maWcuaW5saW5lKXJldHVybjt2YXIgbj1oLmlzT3BlbjtoLmlzT3Blbj0hMCxufHwoaC5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFxcXCJvcGVuXFxcIiksaC5faW5wdXQuY2xhc3NMaXN0LmFkZChcXFwiYWN0aXZlXFxcIiksZ2UoXFxcIm9uT3BlblxcXCIpLGxlKHQpKTshMD09PWguY29uZmlnLmVuYWJsZVRpbWUmJiEwPT09aC5jb25maWcubm9DYWxlbmRhciYmKDA9PT1oLnNlbGVjdGVkRGF0ZXMubGVuZ3RoJiZpZSgpLCExIT09aC5jb25maWcuYWxsb3dJbnB1dHx8dm9pZCAwIT09ZSYmaC50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCl8fHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gaC5ob3VyRWxlbWVudC5zZWxlY3QoKX0sNTApKX0saC5yZWRyYXc9Y2UsaC5zZXQ9ZnVuY3Rpb24oZSxuKXtpZihudWxsIT09ZSYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBlKWZvcih2YXIgYSBpbiBPYmplY3QuYXNzaWduKGguY29uZmlnLGUpLGUpdm9pZCAwIT09dWVbYV0mJnVlW2FdLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0pO2Vsc2UgaC5jb25maWdbZV09bix2b2lkIDAhPT11ZVtlXT91ZVtlXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KTp0LmluZGV4T2YoZSk+LTEmJihoLmNvbmZpZ1tlXT1sKG4pKTtoLnJlZHJhdygpLHdlKCExKX0saC5zZXREYXRlPWZ1bmN0aW9uKGUsdCxuKXt2b2lkIDA9PT10JiYodD0hMSk7dm9pZCAwPT09biYmKG49aC5jb25maWcuZGF0ZUZvcm1hdCk7aWYoMCE9PWUmJiFlfHxlIGluc3RhbmNlb2YgQXJyYXkmJjA9PT1lLmxlbmd0aClyZXR1cm4gaC5jbGVhcih0KTtmZShlLG4pLGguc2hvd1RpbWVJbnB1dD1oLnNlbGVjdGVkRGF0ZXMubGVuZ3RoPjAsaC5sYXRlc3RTZWxlY3RlZERhdGVPYmo9aC5zZWxlY3RlZERhdGVzW2guc2VsZWN0ZWREYXRlcy5sZW5ndGgtMV0saC5yZWRyYXcoKSxBKCksSSgpLDA9PT1oLnNlbGVjdGVkRGF0ZXMubGVuZ3RoJiZoLmNsZWFyKCExKTt3ZSh0KSx0JiZnZShcXFwib25DaGFuZ2VcXFwiKX0saC50b2dnbGU9ZnVuY3Rpb24oZSl7aWYoITA9PT1oLmlzT3BlbilyZXR1cm4gaC5jbG9zZSgpO2gub3BlbihlKX07dmFyIHVlPXtsb2NhbGU6W3JlLHpdLHNob3dNb250aHM6W3EseCwkXSxtaW5EYXRlOltBXSxtYXhEYXRlOltBXX07ZnVuY3Rpb24gZmUoZSx0KXt2YXIgbj1bXTtpZihlIGluc3RhbmNlb2YgQXJyYXkpbj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gaC5wYXJzZURhdGUoZSx0KX0pO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIERhdGV8fFxcXCJudW1iZXJcXFwiPT10eXBlb2YgZSluPVtoLnBhcnNlRGF0ZShlLHQpXTtlbHNlIGlmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZSlzd2l0Y2goaC5jb25maWcubW9kZSl7Y2FzZVxcXCJzaW5nbGVcXFwiOmNhc2VcXFwidGltZVxcXCI6bj1baC5wYXJzZURhdGUoZSx0KV07YnJlYWs7Y2FzZVxcXCJtdWx0aXBsZVxcXCI6bj1lLnNwbGl0KGguY29uZmlnLmNvbmp1bmN0aW9uKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGgucGFyc2VEYXRlKGUsdCl9KTticmVhaztjYXNlXFxcInJhbmdlXFxcIjpuPWUuc3BsaXQoaC5sMTBuLnJhbmdlU2VwYXJhdG9yKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGgucGFyc2VEYXRlKGUsdCl9KX1lbHNlIGguY29uZmlnLmVycm9ySGFuZGxlcihuZXcgRXJyb3IoXFxcIkludmFsaWQgZGF0ZSBzdXBwbGllZDogXFxcIitKU09OLnN0cmluZ2lmeShlKSkpO2guc2VsZWN0ZWREYXRlcz1uLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIERhdGUmJlgoZSwhMSl9KSxcXFwicmFuZ2VcXFwiPT09aC5jb25maWcubW9kZSYmaC5zZWxlY3RlZERhdGVzLnNvcnQoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5nZXRUaW1lKCktdC5nZXRUaW1lKCl9KX1mdW5jdGlvbiBtZShlKXtyZXR1cm4gZS5zbGljZSgpLm1hcChmdW5jdGlvbihlKXtyZXR1cm5cXFwic3RyaW5nXFxcIj09dHlwZW9mIGV8fFxcXCJudW1iZXJcXFwiPT10eXBlb2YgZXx8ZSBpbnN0YW5jZW9mIERhdGU/aC5wYXJzZURhdGUoZSx2b2lkIDAsITApOmUmJlxcXCJvYmplY3RcXFwiPT10eXBlb2YgZSYmZS5mcm9tJiZlLnRvP3tmcm9tOmgucGFyc2VEYXRlKGUuZnJvbSx2b2lkIDApLHRvOmgucGFyc2VEYXRlKGUudG8sdm9pZCAwKX06ZX0pLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZX0pfWZ1bmN0aW9uIGdlKGUsdCl7aWYodm9pZCAwIT09aC5jb25maWcpe3ZhciBuPWguY29uZmlnW2VdO2lmKHZvaWQgMCE9PW4mJm4ubGVuZ3RoPjApZm9yKHZhciBhPTA7blthXSYmYTxuLmxlbmd0aDthKyspblthXShoLnNlbGVjdGVkRGF0ZXMsaC5pbnB1dC52YWx1ZSxoLHQpO1xcXCJvbkNoYW5nZVxcXCI9PT1lJiYoaC5pbnB1dC5kaXNwYXRjaEV2ZW50KHBlKFxcXCJjaGFuZ2VcXFwiKSksaC5pbnB1dC5kaXNwYXRjaEV2ZW50KHBlKFxcXCJpbnB1dFxcXCIpKSl9fWZ1bmN0aW9uIHBlKGUpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUV2ZW50KFxcXCJFdmVudFxcXCIpO3JldHVybiB0LmluaXRFdmVudChlLCEwLCEwKSx0fWZ1bmN0aW9uIGhlKGUpe2Zvcih2YXIgdD0wO3Q8aC5zZWxlY3RlZERhdGVzLmxlbmd0aDt0KyspaWYoMD09PXcoaC5zZWxlY3RlZERhdGVzW3RdLGUpKXJldHVyblxcXCJcXFwiK3Q7cmV0dXJuITF9ZnVuY3Rpb24gdmUoKXtoLmNvbmZpZy5ub0NhbGVuZGFyfHxoLmlzTW9iaWxlfHwhaC5tb250aE5hdnx8KGgueWVhckVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZSx0KXt2YXIgbj1uZXcgRGF0ZShoLmN1cnJlbnRZZWFyLGguY3VycmVudE1vbnRoLDEpO24uc2V0TW9udGgoaC5jdXJyZW50TW9udGgrdCksaC5jb25maWcuc2hvd01vbnRocz4xfHxcXFwic3RhdGljXFxcIj09PWguY29uZmlnLm1vbnRoU2VsZWN0b3JUeXBlP2gubW9udGhFbGVtZW50c1t0XS50ZXh0Q29udGVudD1tKG4uZ2V0TW9udGgoKSxoLmNvbmZpZy5zaG9ydGhhbmRDdXJyZW50TW9udGgsaC5sMTBuKStcXFwiIFxcXCI6aC5tb250aHNEcm9wZG93bkNvbnRhaW5lci52YWx1ZT1uLmdldE1vbnRoKCkudG9TdHJpbmcoKSxlLnZhbHVlPW4uZ2V0RnVsbFllYXIoKS50b1N0cmluZygpfSksaC5faGlkZVByZXZNb250aEFycm93PXZvaWQgMCE9PWguY29uZmlnLm1pbkRhdGUmJihoLmN1cnJlbnRZZWFyPT09aC5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpP2guY3VycmVudE1vbnRoPD1oLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKCk6aC5jdXJyZW50WWVhcjxoLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpLGguX2hpZGVOZXh0TW9udGhBcnJvdz12b2lkIDAhPT1oLmNvbmZpZy5tYXhEYXRlJiYoaC5jdXJyZW50WWVhcj09PWguY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKT9oLmN1cnJlbnRNb250aCsxPmguY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKTpoLmN1cnJlbnRZZWFyPmguY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSkpfWZ1bmN0aW9uIERlKGUpe3JldHVybiBoLnNlbGVjdGVkRGF0ZXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBoLmZvcm1hdERhdGUodCxlKX0pLmZpbHRlcihmdW5jdGlvbihlLHQsbil7cmV0dXJuXFxcInJhbmdlXFxcIiE9PWguY29uZmlnLm1vZGV8fGguY29uZmlnLmVuYWJsZVRpbWV8fG4uaW5kZXhPZihlKT09PXR9KS5qb2luKFxcXCJyYW5nZVxcXCIhPT1oLmNvbmZpZy5tb2RlP2guY29uZmlnLmNvbmp1bmN0aW9uOmgubDEwbi5yYW5nZVNlcGFyYXRvcil9ZnVuY3Rpb24gd2UoZSl7dm9pZCAwPT09ZSYmKGU9ITApLHZvaWQgMCE9PWgubW9iaWxlSW5wdXQmJmgubW9iaWxlRm9ybWF0U3RyJiYoaC5tb2JpbGVJbnB1dC52YWx1ZT12b2lkIDAhPT1oLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaj9oLmZvcm1hdERhdGUoaC5sYXRlc3RTZWxlY3RlZERhdGVPYmosaC5tb2JpbGVGb3JtYXRTdHIpOlxcXCJcXFwiKSxoLmlucHV0LnZhbHVlPURlKGguY29uZmlnLmRhdGVGb3JtYXQpLHZvaWQgMCE9PWguYWx0SW5wdXQmJihoLmFsdElucHV0LnZhbHVlPURlKGguY29uZmlnLmFsdEZvcm1hdCkpLCExIT09ZSYmZ2UoXFxcIm9uVmFsdWVVcGRhdGVcXFwiKX1mdW5jdGlvbiBiZShlKXt2YXIgdD1oLnByZXZNb250aE5hdi5jb250YWlucyhlLnRhcmdldCksbj1oLm5leHRNb250aE5hdi5jb250YWlucyhlLnRhcmdldCk7dHx8bj9HKHQ/LTE6MSk6aC55ZWFyRWxlbWVudHMuaW5kZXhPZihlLnRhcmdldCk+PTA/ZS50YXJnZXQuc2VsZWN0KCk6ZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFxcXCJhcnJvd1VwXFxcIik/aC5jaGFuZ2VZZWFyKGguY3VycmVudFllYXIrMSk6ZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFxcXCJhcnJvd0Rvd25cXFwiKSYmaC5jaGFuZ2VZZWFyKGguY3VycmVudFllYXItMSl9cmV0dXJuIGZ1bmN0aW9uKCl7aC5lbGVtZW50PWguaW5wdXQ9ZixoLmlzT3Blbj0hMSxmdW5jdGlvbigpe3ZhciBhPVtcXFwid3JhcFxcXCIsXFxcIndlZWtOdW1iZXJzXFxcIixcXFwiYWxsb3dJbnB1dFxcXCIsXFxcImNsaWNrT3BlbnNcXFwiLFxcXCJ0aW1lXzI0aHJcXFwiLFxcXCJlbmFibGVUaW1lXFxcIixcXFwibm9DYWxlbmRhclxcXCIsXFxcImFsdElucHV0XFxcIixcXFwic2hvcnRoYW5kQ3VycmVudE1vbnRoXFxcIixcXFwiaW5saW5lXFxcIixcXFwic3RhdGljXFxcIixcXFwiZW5hYmxlU2Vjb25kc1xcXCIsXFxcImRpc2FibGVNb2JpbGVcXFwiXSxpPWUoe30sZyxKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGYuZGF0YXNldHx8e30pKSksbz17fTtoLmNvbmZpZy5wYXJzZURhdGU9aS5wYXJzZURhdGUsaC5jb25maWcuZm9ybWF0RGF0ZT1pLmZvcm1hdERhdGUsT2JqZWN0LmRlZmluZVByb3BlcnR5KGguY29uZmlnLFxcXCJlbmFibGVcXFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5jb25maWcuX2VuYWJsZX0sc2V0OmZ1bmN0aW9uKGUpe2guY29uZmlnLl9lbmFibGU9bWUoZSl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGguY29uZmlnLFxcXCJkaXNhYmxlXFxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguY29uZmlnLl9kaXNhYmxlfSxzZXQ6ZnVuY3Rpb24oZSl7aC5jb25maWcuX2Rpc2FibGU9bWUoZSl9fSk7dmFyIHI9XFxcInRpbWVcXFwiPT09aS5tb2RlO2lmKCFpLmRhdGVGb3JtYXQmJihpLmVuYWJsZVRpbWV8fHIpKXt2YXIgYz1FLmRlZmF1bHRDb25maWcuZGF0ZUZvcm1hdHx8bi5kYXRlRm9ybWF0O28uZGF0ZUZvcm1hdD1pLm5vQ2FsZW5kYXJ8fHI/XFxcIkg6aVxcXCIrKGkuZW5hYmxlU2Vjb25kcz9cXFwiOlNcXFwiOlxcXCJcXFwiKTpjK1xcXCIgSDppXFxcIisoaS5lbmFibGVTZWNvbmRzP1xcXCI6U1xcXCI6XFxcIlxcXCIpfWlmKGkuYWx0SW5wdXQmJihpLmVuYWJsZVRpbWV8fHIpJiYhaS5hbHRGb3JtYXQpe3ZhciBkPUUuZGVmYXVsdENvbmZpZy5hbHRGb3JtYXR8fG4uYWx0Rm9ybWF0O28uYWx0Rm9ybWF0PWkubm9DYWxlbmRhcnx8cj9cXFwiaDppXFxcIisoaS5lbmFibGVTZWNvbmRzP1xcXCI6UyBLXFxcIjpcXFwiIEtcXFwiKTpkK1xcXCIgaDppXFxcIisoaS5lbmFibGVTZWNvbmRzP1xcXCI6U1xcXCI6XFxcIlxcXCIpK1xcXCIgS1xcXCJ9aS5hbHRJbnB1dENsYXNzfHwoaC5jb25maWcuYWx0SW5wdXRDbGFzcz1oLmlucHV0LmNsYXNzTmFtZStcXFwiIFxcXCIraC5jb25maWcuYWx0SW5wdXRDbGFzcyksT2JqZWN0LmRlZmluZVByb3BlcnR5KGguY29uZmlnLFxcXCJtaW5EYXRlXFxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguY29uZmlnLl9taW5EYXRlfSxzZXQ6b2UoXFxcIm1pblxcXCIpfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGguY29uZmlnLFxcXCJtYXhEYXRlXFxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguY29uZmlnLl9tYXhEYXRlfSxzZXQ6b2UoXFxcIm1heFxcXCIpfSk7dmFyIHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2guY29uZmlnW1xcXCJtaW5cXFwiPT09ZT9cXFwiX21pblRpbWVcXFwiOlxcXCJfbWF4VGltZVxcXCJdPWgucGFyc2VEYXRlKHQsXFxcIkg6aTpTXFxcIil9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5jb25maWcsXFxcIm1pblRpbWVcXFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5jb25maWcuX21pblRpbWV9LHNldDpzKFxcXCJtaW5cXFwiKX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLmNvbmZpZyxcXFwibWF4VGltZVxcXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLmNvbmZpZy5fbWF4VGltZX0sc2V0OnMoXFxcIm1heFxcXCIpfSksXFxcInRpbWVcXFwiPT09aS5tb2RlJiYoaC5jb25maWcubm9DYWxlbmRhcj0hMCxoLmNvbmZpZy5lbmFibGVUaW1lPSEwKSxPYmplY3QuYXNzaWduKGguY29uZmlnLG8saSk7Zm9yKHZhciB1PTA7dTxhLmxlbmd0aDt1KyspaC5jb25maWdbYVt1XV09ITA9PT1oLmNvbmZpZ1thW3VdXXx8XFxcInRydWVcXFwiPT09aC5jb25maWdbYVt1XV07dC5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMCE9PWguY29uZmlnW2VdfSkuZm9yRWFjaChmdW5jdGlvbihlKXtoLmNvbmZpZ1tlXT1sKGguY29uZmlnW2VdfHxbXSkubWFwKHkpfSksaC5pc01vYmlsZT0haC5jb25maWcuZGlzYWJsZU1vYmlsZSYmIWguY29uZmlnLmlubGluZSYmXFxcInNpbmdsZVxcXCI9PT1oLmNvbmZpZy5tb2RlJiYhaC5jb25maWcuZGlzYWJsZS5sZW5ndGgmJiFoLmNvbmZpZy5lbmFibGUubGVuZ3RoJiYhaC5jb25maWcud2Vla051bWJlcnMmJi9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtmb3IodmFyIHU9MDt1PGguY29uZmlnLnBsdWdpbnMubGVuZ3RoO3UrKyl7dmFyIG09aC5jb25maWcucGx1Z2luc1t1XShoKXx8e307Zm9yKHZhciBwIGluIG0pdC5pbmRleE9mKHApPi0xP2guY29uZmlnW3BdPWwobVtwXSkubWFwKHkpLmNvbmNhdChoLmNvbmZpZ1twXSk6dm9pZCAwPT09aVtwXSYmKGguY29uZmlnW3BdPW1bcF0pfWdlKFxcXCJvblBhcnNlQ29uZmlnXFxcIil9KCkscmUoKSxoLmlucHV0PWguY29uZmlnLndyYXA/Zi5xdWVyeVNlbGVjdG9yKFxcXCJbZGF0YS1pbnB1dF1cXFwiKTpmLGguaW5wdXQ/KGguaW5wdXQuX3R5cGU9aC5pbnB1dC50eXBlLGguaW5wdXQudHlwZT1cXFwidGV4dFxcXCIsaC5pbnB1dC5jbGFzc0xpc3QuYWRkKFxcXCJmbGF0cGlja3ItaW5wdXRcXFwiKSxoLl9pbnB1dD1oLmlucHV0LGguY29uZmlnLmFsdElucHV0JiYoaC5hbHRJbnB1dD1kKGguaW5wdXQubm9kZU5hbWUsaC5jb25maWcuYWx0SW5wdXRDbGFzcyksaC5faW5wdXQ9aC5hbHRJbnB1dCxoLmFsdElucHV0LnBsYWNlaG9sZGVyPWguaW5wdXQucGxhY2Vob2xkZXIsaC5hbHRJbnB1dC5kaXNhYmxlZD1oLmlucHV0LmRpc2FibGVkLGguYWx0SW5wdXQucmVxdWlyZWQ9aC5pbnB1dC5yZXF1aXJlZCxoLmFsdElucHV0LnRhYkluZGV4PWguaW5wdXQudGFiSW5kZXgsaC5hbHRJbnB1dC50eXBlPVxcXCJ0ZXh0XFxcIixoLmlucHV0LnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsXFxcImhpZGRlblxcXCIpLCFoLmNvbmZpZy5zdGF0aWMmJmguaW5wdXQucGFyZW50Tm9kZSYmaC5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShoLmFsdElucHV0LGguaW5wdXQubmV4dFNpYmxpbmcpKSxoLmNvbmZpZy5hbGxvd0lucHV0fHxoLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXFxcInJlYWRvbmx5XFxcIixcXFwicmVhZG9ubHlcXFwiKSxoLl9wb3NpdGlvbkVsZW1lbnQ9aC5jb25maWcucG9zaXRpb25FbGVtZW50fHxoLl9pbnB1dCk6aC5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcXFwiSW52YWxpZCBpbnB1dCBlbGVtZW50IHNwZWNpZmllZFxcXCIpKSxmdW5jdGlvbigpe2guc2VsZWN0ZWREYXRlcz1bXSxoLm5vdz1oLnBhcnNlRGF0ZShoLmNvbmZpZy5ub3cpfHxuZXcgRGF0ZTt2YXIgZT1oLmNvbmZpZy5kZWZhdWx0RGF0ZXx8KFxcXCJJTlBVVFxcXCIhPT1oLmlucHV0Lm5vZGVOYW1lJiZcXFwiVEVYVEFSRUFcXFwiIT09aC5pbnB1dC5ub2RlTmFtZXx8IWguaW5wdXQucGxhY2Vob2xkZXJ8fGguaW5wdXQudmFsdWUhPT1oLmlucHV0LnBsYWNlaG9sZGVyP2guaW5wdXQudmFsdWU6bnVsbCk7ZSYmZmUoZSxoLmNvbmZpZy5kYXRlRm9ybWF0KSxoLl9pbml0aWFsRGF0ZT1oLnNlbGVjdGVkRGF0ZXMubGVuZ3RoPjA/aC5zZWxlY3RlZERhdGVzWzBdOmguY29uZmlnLm1pbkRhdGUmJmguY29uZmlnLm1pbkRhdGUuZ2V0VGltZSgpPmgubm93LmdldFRpbWUoKT9oLmNvbmZpZy5taW5EYXRlOmguY29uZmlnLm1heERhdGUmJmguY29uZmlnLm1heERhdGUuZ2V0VGltZSgpPGgubm93LmdldFRpbWUoKT9oLmNvbmZpZy5tYXhEYXRlOmgubm93LGguY3VycmVudFllYXI9aC5faW5pdGlhbERhdGUuZ2V0RnVsbFllYXIoKSxoLmN1cnJlbnRNb250aD1oLl9pbml0aWFsRGF0ZS5nZXRNb250aCgpLGguc2VsZWN0ZWREYXRlcy5sZW5ndGg+MCYmKGgubGF0ZXN0U2VsZWN0ZWREYXRlT2JqPWguc2VsZWN0ZWREYXRlc1swXSksdm9pZCAwIT09aC5jb25maWcubWluVGltZSYmKGguY29uZmlnLm1pblRpbWU9aC5wYXJzZURhdGUoaC5jb25maWcubWluVGltZSxcXFwiSDppXFxcIikpLHZvaWQgMCE9PWguY29uZmlnLm1heFRpbWUmJihoLmNvbmZpZy5tYXhUaW1lPWgucGFyc2VEYXRlKGguY29uZmlnLm1heFRpbWUsXFxcIkg6aVxcXCIpKSxoLm1pbkRhdGVIYXNUaW1lPSEhaC5jb25maWcubWluRGF0ZSYmKGguY29uZmlnLm1pbkRhdGUuZ2V0SG91cnMoKT4wfHxoLmNvbmZpZy5taW5EYXRlLmdldE1pbnV0ZXMoKT4wfHxoLmNvbmZpZy5taW5EYXRlLmdldFNlY29uZHMoKT4wKSxoLm1heERhdGVIYXNUaW1lPSEhaC5jb25maWcubWF4RGF0ZSYmKGguY29uZmlnLm1heERhdGUuZ2V0SG91cnMoKT4wfHxoLmNvbmZpZy5tYXhEYXRlLmdldE1pbnV0ZXMoKT4wfHxoLmNvbmZpZy5tYXhEYXRlLmdldFNlY29uZHMoKT4wKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcXFwic2hvd1RpbWVJbnB1dFxcXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLl9zaG93VGltZUlucHV0fSxzZXQ6ZnVuY3Rpb24oZSl7aC5fc2hvd1RpbWVJbnB1dD1lLGguY2FsZW5kYXJDb250YWluZXImJmMoaC5jYWxlbmRhckNvbnRhaW5lcixcXFwic2hvd1RpbWVJbnB1dFxcXCIsZSksaC5pc09wZW4mJmxlKCl9fSl9KCksaC51dGlscz17Z2V0RGF5c0luTW9udGg6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9aC5jdXJyZW50TW9udGgpLHZvaWQgMD09PXQmJih0PWguY3VycmVudFllYXIpLDE9PT1lJiYodCU0PT0wJiZ0JTEwMCE9MHx8dCU0MDA9PTApPzI5OmgubDEwbi5kYXlzSW5Nb250aFtlXX19LGguaXNNb2JpbGV8fGZ1bmN0aW9uKCl7dmFyIGU9d2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtpZihoLmNhbGVuZGFyQ29udGFpbmVyPWQoXFxcImRpdlxcXCIsXFxcImZsYXRwaWNrci1jYWxlbmRhclxcXCIpLGguY2FsZW5kYXJDb250YWluZXIudGFiSW5kZXg9LTEsIWguY29uZmlnLm5vQ2FsZW5kYXIpe2lmKGUuYXBwZW5kQ2hpbGQoKGgubW9udGhOYXY9ZChcXFwiZGl2XFxcIixcXFwiZmxhdHBpY2tyLW1vbnRoc1xcXCIpLGgueWVhckVsZW1lbnRzPVtdLGgubW9udGhFbGVtZW50cz1bXSxoLnByZXZNb250aE5hdj1kKFxcXCJzcGFuXFxcIixcXFwiZmxhdHBpY2tyLXByZXYtbW9udGhcXFwiKSxoLnByZXZNb250aE5hdi5pbm5lckhUTUw9aC5jb25maWcucHJldkFycm93LGgubmV4dE1vbnRoTmF2PWQoXFxcInNwYW5cXFwiLFxcXCJmbGF0cGlja3ItbmV4dC1tb250aFxcXCIpLGgubmV4dE1vbnRoTmF2LmlubmVySFRNTD1oLmNvbmZpZy5uZXh0QXJyb3cscSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLFxcXCJfaGlkZVByZXZNb250aEFycm93XFxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguX19oaWRlUHJldk1vbnRoQXJyb3d9LHNldDpmdW5jdGlvbihlKXtoLl9faGlkZVByZXZNb250aEFycm93IT09ZSYmKGMoaC5wcmV2TW9udGhOYXYsXFxcImZsYXRwaWNrci1kaXNhYmxlZFxcXCIsZSksaC5fX2hpZGVQcmV2TW9udGhBcnJvdz1lKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaCxcXFwiX2hpZGVOZXh0TW9udGhBcnJvd1xcXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBoLl9faGlkZU5leHRNb250aEFycm93fSxzZXQ6ZnVuY3Rpb24oZSl7aC5fX2hpZGVOZXh0TW9udGhBcnJvdyE9PWUmJihjKGgubmV4dE1vbnRoTmF2LFxcXCJmbGF0cGlja3ItZGlzYWJsZWRcXFwiLGUpLGguX19oaWRlTmV4dE1vbnRoQXJyb3c9ZSl9fSksaC5jdXJyZW50WWVhckVsZW1lbnQ9aC55ZWFyRWxlbWVudHNbMF0sdmUoKSxoLm1vbnRoTmF2KSksaC5pbm5lckNvbnRhaW5lcj1kKFxcXCJkaXZcXFwiLFxcXCJmbGF0cGlja3ItaW5uZXJDb250YWluZXJcXFwiKSxoLmNvbmZpZy53ZWVrTnVtYmVycyl7dmFyIHQ9ZnVuY3Rpb24oKXtoLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXFxcImhhc1dlZWtzXFxcIik7dmFyIGU9ZChcXFwiZGl2XFxcIixcXFwiZmxhdHBpY2tyLXdlZWt3cmFwcGVyXFxcIik7ZS5hcHBlbmRDaGlsZChkKFxcXCJzcGFuXFxcIixcXFwiZmxhdHBpY2tyLXdlZWtkYXlcXFwiLGgubDEwbi53ZWVrQWJicmV2aWF0aW9uKSk7dmFyIHQ9ZChcXFwiZGl2XFxcIixcXFwiZmxhdHBpY2tyLXdlZWtzXFxcIik7cmV0dXJuIGUuYXBwZW5kQ2hpbGQodCkse3dlZWtXcmFwcGVyOmUsd2Vla051bWJlcnM6dH19KCksbj10LndlZWtXcmFwcGVyLGE9dC53ZWVrTnVtYmVycztoLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKG4pLGgud2Vla051bWJlcnM9YSxoLndlZWtXcmFwcGVyPW59aC5yQ29udGFpbmVyPWQoXFxcImRpdlxcXCIsXFxcImZsYXRwaWNrci1yQ29udGFpbmVyXFxcIiksaC5yQ29udGFpbmVyLmFwcGVuZENoaWxkKCQoKSksaC5kYXlzQ29udGFpbmVyfHwoaC5kYXlzQ29udGFpbmVyPWQoXFxcImRpdlxcXCIsXFxcImZsYXRwaWNrci1kYXlzXFxcIiksaC5kYXlzQ29udGFpbmVyLnRhYkluZGV4PS0xKSxKKCksaC5yQ29udGFpbmVyLmFwcGVuZENoaWxkKGguZGF5c0NvbnRhaW5lciksaC5pbm5lckNvbnRhaW5lci5hcHBlbmRDaGlsZChoLnJDb250YWluZXIpLGUuYXBwZW5kQ2hpbGQoaC5pbm5lckNvbnRhaW5lcil9aC5jb25maWcuZW5hYmxlVGltZSYmZS5hcHBlbmRDaGlsZChmdW5jdGlvbigpe2guY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcXFwiaGFzVGltZVxcXCIpLGguY29uZmlnLm5vQ2FsZW5kYXImJmguY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcXFwibm9DYWxlbmRhclxcXCIpLGgudGltZUNvbnRhaW5lcj1kKFxcXCJkaXZcXFwiLFxcXCJmbGF0cGlja3ItdGltZVxcXCIpLGgudGltZUNvbnRhaW5lci50YWJJbmRleD0tMTt2YXIgZT1kKFxcXCJzcGFuXFxcIixcXFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXFxcIixcXFwiOlxcXCIpLHQ9dShcXFwiZmxhdHBpY2tyLWhvdXJcXFwiLHtcXFwiYXJpYS1sYWJlbFxcXCI6aC5sMTBuLmhvdXJBcmlhTGFiZWx9KTtoLmhvdXJFbGVtZW50PXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImlucHV0XFxcIilbMF07dmFyIG49dShcXFwiZmxhdHBpY2tyLW1pbnV0ZVxcXCIse1xcXCJhcmlhLWxhYmVsXFxcIjpoLmwxMG4ubWludXRlQXJpYUxhYmVsfSk7aWYoaC5taW51dGVFbGVtZW50PW4uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImlucHV0XFxcIilbMF0saC5ob3VyRWxlbWVudC50YWJJbmRleD1oLm1pbnV0ZUVsZW1lbnQudGFiSW5kZXg9LTEsaC5ob3VyRWxlbWVudC52YWx1ZT1pKGgubGF0ZXN0U2VsZWN0ZWREYXRlT2JqP2gubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldEhvdXJzKCk6aC5jb25maWcudGltZV8yNGhyP2guY29uZmlnLmRlZmF1bHRIb3VyOmZ1bmN0aW9uKGUpe3N3aXRjaChlJTI0KXtjYXNlIDA6Y2FzZSAxMjpyZXR1cm4gMTI7ZGVmYXVsdDpyZXR1cm4gZSUxMn19KGguY29uZmlnLmRlZmF1bHRIb3VyKSksaC5taW51dGVFbGVtZW50LnZhbHVlPWkoaC5sYXRlc3RTZWxlY3RlZERhdGVPYmo/aC5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0TWludXRlcygpOmguY29uZmlnLmRlZmF1bHRNaW51dGUpLGguaG91ckVsZW1lbnQuc2V0QXR0cmlidXRlKFxcXCJzdGVwXFxcIixoLmNvbmZpZy5ob3VySW5jcmVtZW50LnRvU3RyaW5nKCkpLGgubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXFxcInN0ZXBcXFwiLGguY29uZmlnLm1pbnV0ZUluY3JlbWVudC50b1N0cmluZygpKSxoLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcXFwibWluXFxcIixoLmNvbmZpZy50aW1lXzI0aHI/XFxcIjBcXFwiOlxcXCIxXFxcIiksaC5ob3VyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXFxcIm1heFxcXCIsaC5jb25maWcudGltZV8yNGhyP1xcXCIyM1xcXCI6XFxcIjEyXFxcIiksaC5taW51dGVFbGVtZW50LnNldEF0dHJpYnV0ZShcXFwibWluXFxcIixcXFwiMFxcXCIpLGgubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXFxcIm1heFxcXCIsXFxcIjU5XFxcIiksaC50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHQpLGgudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChlKSxoLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQobiksaC5jb25maWcudGltZV8yNGhyJiZoLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcXFwidGltZTI0aHJcXFwiKSxoLmNvbmZpZy5lbmFibGVTZWNvbmRzKXtoLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcXFwiaGFzU2Vjb25kc1xcXCIpO3ZhciBhPXUoXFxcImZsYXRwaWNrci1zZWNvbmRcXFwiKTtoLnNlY29uZEVsZW1lbnQ9YS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiaW5wdXRcXFwiKVswXSxoLnNlY29uZEVsZW1lbnQudmFsdWU9aShoLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaj9oLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5nZXRTZWNvbmRzKCk6aC5jb25maWcuZGVmYXVsdFNlY29uZHMpLGguc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXFxcInN0ZXBcXFwiLGgubWludXRlRWxlbWVudC5nZXRBdHRyaWJ1dGUoXFxcInN0ZXBcXFwiKSksaC5zZWNvbmRFbGVtZW50LnNldEF0dHJpYnV0ZShcXFwibWluXFxcIixcXFwiMFxcXCIpLGguc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXFxcIm1heFxcXCIsXFxcIjU5XFxcIiksaC50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKGQoXFxcInNwYW5cXFwiLFxcXCJmbGF0cGlja3ItdGltZS1zZXBhcmF0b3JcXFwiLFxcXCI6XFxcIikpLGgudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChhKX1yZXR1cm4gaC5jb25maWcudGltZV8yNGhyfHwoaC5hbVBNPWQoXFxcInNwYW5cXFwiLFxcXCJmbGF0cGlja3ItYW0tcG1cXFwiLGgubDEwbi5hbVBNW28oKGgubGF0ZXN0U2VsZWN0ZWREYXRlT2JqP2guaG91ckVsZW1lbnQudmFsdWU6aC5jb25maWcuZGVmYXVsdEhvdXIpPjExKV0pLGguYW1QTS50aXRsZT1oLmwxMG4udG9nZ2xlVGl0bGUsaC5hbVBNLnRhYkluZGV4PS0xLGgudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChoLmFtUE0pKSxoLnRpbWVDb250YWluZXJ9KCkpLGMoaC5jYWxlbmRhckNvbnRhaW5lcixcXFwicmFuZ2VNb2RlXFxcIixcXFwicmFuZ2VcXFwiPT09aC5jb25maWcubW9kZSksYyhoLmNhbGVuZGFyQ29udGFpbmVyLFxcXCJhbmltYXRlXFxcIiwhMD09PWguY29uZmlnLmFuaW1hdGUpLGMoaC5jYWxlbmRhckNvbnRhaW5lcixcXFwibXVsdGlNb250aFxcXCIsaC5jb25maWcuc2hvd01vbnRocz4xKSxoLmNhbGVuZGFyQ29udGFpbmVyLmFwcGVuZENoaWxkKGUpO3ZhciByPXZvaWQgMCE9PWguY29uZmlnLmFwcGVuZFRvJiZ2b2lkIDAhPT1oLmNvbmZpZy5hcHBlbmRUby5ub2RlVHlwZTtpZigoaC5jb25maWcuaW5saW5lfHxoLmNvbmZpZy5zdGF0aWMpJiYoaC5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGguY29uZmlnLmlubGluZT9cXFwiaW5saW5lXFxcIjpcXFwic3RhdGljXFxcIiksaC5jb25maWcuaW5saW5lJiYoIXImJmguZWxlbWVudC5wYXJlbnROb2RlP2guZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShoLmNhbGVuZGFyQ29udGFpbmVyLGguX2lucHV0Lm5leHRTaWJsaW5nKTp2b2lkIDAhPT1oLmNvbmZpZy5hcHBlbmRUbyYmaC5jb25maWcuYXBwZW5kVG8uYXBwZW5kQ2hpbGQoaC5jYWxlbmRhckNvbnRhaW5lcikpLGguY29uZmlnLnN0YXRpYykpe3ZhciBsPWQoXFxcImRpdlxcXCIsXFxcImZsYXRwaWNrci13cmFwcGVyXFxcIik7aC5lbGVtZW50LnBhcmVudE5vZGUmJmguZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsLGguZWxlbWVudCksbC5hcHBlbmRDaGlsZChoLmVsZW1lbnQpLGguYWx0SW5wdXQmJmwuYXBwZW5kQ2hpbGQoaC5hbHRJbnB1dCksbC5hcHBlbmRDaGlsZChoLmNhbGVuZGFyQ29udGFpbmVyKX1oLmNvbmZpZy5zdGF0aWN8fGguY29uZmlnLmlubGluZXx8KHZvaWQgMCE9PWguY29uZmlnLmFwcGVuZFRvP2guY29uZmlnLmFwcGVuZFRvOndpbmRvdy5kb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChoLmNhbGVuZGFyQ29udGFpbmVyKX0oKSxmdW5jdGlvbigpe2lmKGguY29uZmlnLndyYXAmJltcXFwib3BlblxcXCIsXFxcImNsb3NlXFxcIixcXFwidG9nZ2xlXFxcIixcXFwiY2xlYXJcXFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe0FycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoaC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltkYXRhLVxcXCIrZStcXFwiXVxcXCIpLGZ1bmN0aW9uKHQpe3JldHVybiBGKHQsXFxcImNsaWNrXFxcIixoW2VdKX0pfSksaC5pc01vYmlsZSkhZnVuY3Rpb24oKXt2YXIgZT1oLmNvbmZpZy5lbmFibGVUaW1lP2guY29uZmlnLm5vQ2FsZW5kYXI/XFxcInRpbWVcXFwiOlxcXCJkYXRldGltZS1sb2NhbFxcXCI6XFxcImRhdGVcXFwiO2gubW9iaWxlSW5wdXQ9ZChcXFwiaW5wdXRcXFwiLGguaW5wdXQuY2xhc3NOYW1lK1xcXCIgZmxhdHBpY2tyLW1vYmlsZVxcXCIpLGgubW9iaWxlSW5wdXQuc3RlcD1oLmlucHV0LmdldEF0dHJpYnV0ZShcXFwic3RlcFxcXCIpfHxcXFwiYW55XFxcIixoLm1vYmlsZUlucHV0LnRhYkluZGV4PTEsaC5tb2JpbGVJbnB1dC50eXBlPWUsaC5tb2JpbGVJbnB1dC5kaXNhYmxlZD1oLmlucHV0LmRpc2FibGVkLGgubW9iaWxlSW5wdXQucmVxdWlyZWQ9aC5pbnB1dC5yZXF1aXJlZCxoLm1vYmlsZUlucHV0LnBsYWNlaG9sZGVyPWguaW5wdXQucGxhY2Vob2xkZXIsaC5tb2JpbGVGb3JtYXRTdHI9XFxcImRhdGV0aW1lLWxvY2FsXFxcIj09PWU/XFxcIlktbS1kXFxcXFxcXFxUSDppOlNcXFwiOlxcXCJkYXRlXFxcIj09PWU/XFxcIlktbS1kXFxcIjpcXFwiSDppOlNcXFwiLGguc2VsZWN0ZWREYXRlcy5sZW5ndGg+MCYmKGgubW9iaWxlSW5wdXQuZGVmYXVsdFZhbHVlPWgubW9iaWxlSW5wdXQudmFsdWU9aC5mb3JtYXREYXRlKGguc2VsZWN0ZWREYXRlc1swXSxoLm1vYmlsZUZvcm1hdFN0cikpLGguY29uZmlnLm1pbkRhdGUmJihoLm1vYmlsZUlucHV0Lm1pbj1oLmZvcm1hdERhdGUoaC5jb25maWcubWluRGF0ZSxcXFwiWS1tLWRcXFwiKSksaC5jb25maWcubWF4RGF0ZSYmKGgubW9iaWxlSW5wdXQubWF4PWguZm9ybWF0RGF0ZShoLmNvbmZpZy5tYXhEYXRlLFxcXCJZLW0tZFxcXCIpKSxoLmlucHV0LnR5cGU9XFxcImhpZGRlblxcXCIsdm9pZCAwIT09aC5hbHRJbnB1dCYmKGguYWx0SW5wdXQudHlwZT1cXFwiaGlkZGVuXFxcIik7dHJ5e2guaW5wdXQucGFyZW50Tm9kZSYmaC5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShoLm1vYmlsZUlucHV0LGguaW5wdXQubmV4dFNpYmxpbmcpfWNhdGNoKGUpe31GKGgubW9iaWxlSW5wdXQsXFxcImNoYW5nZVxcXCIsZnVuY3Rpb24oZSl7aC5zZXREYXRlKGUudGFyZ2V0LnZhbHVlLCExLGgubW9iaWxlRm9ybWF0U3RyKSxnZShcXFwib25DaGFuZ2VcXFwiKSxnZShcXFwib25DbG9zZVxcXCIpfSl9KCk7ZWxzZXt2YXIgZT1yKGFlLDUwKTtoLl9kZWJvdW5jZWRDaGFuZ2U9cihZLE0pLGguZGF5c0NvbnRhaW5lciYmIS9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmRihoLmRheXNDb250YWluZXIsXFxcIm1vdXNlb3ZlclxcXCIsZnVuY3Rpb24oZSl7XFxcInJhbmdlXFxcIj09PWguY29uZmlnLm1vZGUmJm5lKGUudGFyZ2V0KX0pLEYod2luZG93LmRvY3VtZW50LmJvZHksXFxcImtleWRvd25cXFwiLHRlKSxoLmNvbmZpZy5pbmxpbmV8fGguY29uZmlnLnN0YXRpY3x8Rih3aW5kb3csXFxcInJlc2l6ZVxcXCIsZSksdm9pZCAwIT09d2luZG93Lm9udG91Y2hzdGFydD9GKHdpbmRvdy5kb2N1bWVudCxcXFwidG91Y2hzdGFydFxcXCIsWik6Rih3aW5kb3cuZG9jdW1lbnQsXFxcIm1vdXNlZG93blxcXCIsTihaKSksRih3aW5kb3cuZG9jdW1lbnQsXFxcImZvY3VzXFxcIixaLHtjYXB0dXJlOiEwfSksITA9PT1oLmNvbmZpZy5jbGlja09wZW5zJiYoRihoLl9pbnB1dCxcXFwiZm9jdXNcXFwiLGgub3BlbiksRihoLl9pbnB1dCxcXFwibW91c2Vkb3duXFxcIixOKGgub3BlbikpKSx2b2lkIDAhPT1oLmRheXNDb250YWluZXImJihGKGgubW9udGhOYXYsXFxcIm1vdXNlZG93blxcXCIsTihiZSkpLEYoaC5tb250aE5hdixbXFxcImtleXVwXFxcIixcXFwiaW5jcmVtZW50XFxcIl0sXyksRihoLmRheXNDb250YWluZXIsXFxcIm1vdXNlZG93blxcXCIsTihzZSkpKSx2b2lkIDAhPT1oLnRpbWVDb250YWluZXImJnZvaWQgMCE9PWgubWludXRlRWxlbWVudCYmdm9pZCAwIT09aC5ob3VyRWxlbWVudCYmKEYoaC50aW1lQ29udGFpbmVyLFtcXFwiaW5jcmVtZW50XFxcIl0sVCksRihoLnRpbWVDb250YWluZXIsXFxcImJsdXJcXFwiLFQse2NhcHR1cmU6ITB9KSxGKGgudGltZUNvbnRhaW5lcixcXFwibW91c2Vkb3duXFxcIixOKFApKSxGKFtoLmhvdXJFbGVtZW50LGgubWludXRlRWxlbWVudF0sW1xcXCJmb2N1c1xcXCIsXFxcImNsaWNrXFxcIl0sZnVuY3Rpb24oZSl7cmV0dXJuIGUudGFyZ2V0LnNlbGVjdCgpfSksdm9pZCAwIT09aC5zZWNvbmRFbGVtZW50JiZGKGguc2Vjb25kRWxlbWVudCxcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGguc2Vjb25kRWxlbWVudCYmaC5zZWNvbmRFbGVtZW50LnNlbGVjdCgpfSksdm9pZCAwIT09aC5hbVBNJiZGKGguYW1QTSxcXFwibW91c2Vkb3duXFxcIixOKGZ1bmN0aW9uKGUpe1QoZSksWSgpfSkpKX19KCksKGguc2VsZWN0ZWREYXRlcy5sZW5ndGh8fGguY29uZmlnLm5vQ2FsZW5kYXIpJiYoaC5jb25maWcuZW5hYmxlVGltZSYmSShoLmNvbmZpZy5ub0NhbGVuZGFyP2gubGF0ZXN0U2VsZWN0ZWREYXRlT2JqfHxoLmNvbmZpZy5taW5EYXRlOnZvaWQgMCksd2UoITEpKSx4KCksaC5zaG93VGltZUlucHV0PWguc2VsZWN0ZWREYXRlcy5sZW5ndGg+MHx8aC5jb25maWcubm9DYWxlbmRhcjt2YXIgYT0vXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyFoLmlzTW9iaWxlJiZhJiZsZSgpLGdlKFxcXCJvblJlYWR5XFxcIil9KCksaH1mdW5jdGlvbiB4KGUsdCl7Zm9yKHZhciBuPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUpLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50fSksYT1bXSxpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciBvPW5baV07dHJ5e2lmKG51bGwhPT1vLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1mcC1vbWl0XFxcIikpY29udGludWU7dm9pZCAwIT09by5fZmxhdHBpY2tyJiYoby5fZmxhdHBpY2tyLmRlc3Ryb3koKSxvLl9mbGF0cGlja3I9dm9pZCAwKSxvLl9mbGF0cGlja3I9eShvLHR8fHt9KSxhLnB1c2goby5fZmxhdHBpY2tyKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKGUpfX1yZXR1cm4gMT09PWEubGVuZ3RoP2FbMF06YX1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIEhUTUxFbGVtZW50JiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIEhUTUxDb2xsZWN0aW9uJiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIE5vZGVMaXN0JiYoSFRNTENvbGxlY3Rpb24ucHJvdG90eXBlLmZsYXRwaWNrcj1Ob2RlTGlzdC5wcm90b3R5cGUuZmxhdHBpY2tyPWZ1bmN0aW9uKGUpe3JldHVybiB4KHRoaXMsZSl9LEhUTUxFbGVtZW50LnByb3RvdHlwZS5mbGF0cGlja3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHgoW3RoaXNdLGUpfSk7dmFyIEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cXFwic3RyaW5nXFxcIj09dHlwZW9mIGU/eCh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKSx0KTplIGluc3RhbmNlb2YgTm9kZT94KFtlXSx0KTp4KGUsdCl9O3JldHVybiBFLmRlZmF1bHRDb25maWc9e30sRS5sMTBucz17ZW46ZSh7fSxhKSxkZWZhdWx0OmUoe30sYSl9LEUubG9jYWxpemU9ZnVuY3Rpb24odCl7RS5sMTBucy5kZWZhdWx0PWUoe30sRS5sMTBucy5kZWZhdWx0LHQpfSxFLnNldERlZmF1bHRzPWZ1bmN0aW9uKHQpe0UuZGVmYXVsdENvbmZpZz1lKHt9LEUuZGVmYXVsdENvbmZpZyx0KX0sRS5wYXJzZURhdGU9RCh7fSksRS5mb3JtYXREYXRlPXYoe30pLEUuY29tcGFyZURhdGVzPXcsXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBqUXVlcnkmJnZvaWQgMCE9PWpRdWVyeS5mbiYmKGpRdWVyeS5mbi5mbGF0cGlja3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHgodGhpcyxlKX0pLERhdGUucHJvdG90eXBlLmZwX2luY3I9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSx0aGlzLmdldE1vbnRoKCksdGhpcy5nZXREYXRlKCkrKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZT9wYXJzZUludChlLDEwKTplKSl9LFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93JiYod2luZG93LmZsYXRwaWNrcj1FKSxFfSk7XCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(39))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvbDEwbi9ydS5qcz81NmE3Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcZmxhdHBpY2tyXFxcXGRpc3RcXFxcbDEwblxcXFxydS5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///38\n")},function(module,exports){eval('module.exports = "(function (global, factory) {\\n  typeof exports === \'object\' && typeof module !== \'undefined\' ? factory(exports) :\\n  typeof define === \'function\' && define.amd ? define([\'exports\'], factory) :\\n  (global = global || self, factory(global.ru = {}));\\n}(this, function (exports) { \'use strict\';\\n\\n  var fp = typeof window !== \\"undefined\\" && window.flatpickr !== undefined\\n      ? window.flatpickr\\n      : {\\n          l10ns: {}\\n      };\\n  var Russian = {\\n      weekdays: {\\n          shorthand: [\\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\", \\"\\"],\\n          longhand: [\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n          ]\\n      },\\n      months: {\\n          shorthand: [\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n          ],\\n          longhand: [\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n              \\"\\",\\n          ]\\n      },\\n      firstDayOfWeek: 1,\\n      ordinal: function () {\\n          return \\"\\";\\n      },\\n      rangeSeparator: \\"  \\",\\n      weekAbbreviation: \\".\\",\\n      scrollTitle: \\"  \\",\\n      toggleTitle: \\"  \\",\\n      amPM: [\\"\\", \\"\\"],\\n      yearAriaLabel: \\"\\",\\n      time_24hr: true\\n  };\\n  fp.l10ns.ru = Russian;\\n  var ru = fp.l10ns;\\n\\n  exports.Russian = Russian;\\n  exports.default = ru;\\n\\n  Object.defineProperty(exports, \'__esModule\', { value: true });\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvbDEwbi9ydS5qcz8xMTFlIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XFxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcXG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwucnUgPSB7fSkpO1xcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xcblxcbiAgdmFyIGZwID0gdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgd2luZG93LmZsYXRwaWNrciAhPT0gdW5kZWZpbmVkXFxuICAgICAgPyB3aW5kb3cuZmxhdHBpY2tyXFxuICAgICAgOiB7XFxuICAgICAgICAgIGwxMG5zOiB7fVxcbiAgICAgIH07XFxuICB2YXIgUnVzc2lhbiA9IHtcXG4gICAgICB3ZWVrZGF5czoge1xcbiAgICAgICAgICBzaG9ydGhhbmQ6IFtcXFwi0JLRgVxcXCIsIFxcXCLQn9C9XFxcIiwgXFxcItCS0YJcXFwiLCBcXFwi0KHRgFxcXCIsIFxcXCLQp9GCXFxcIiwgXFxcItCf0YJcXFwiLCBcXFwi0KHQsVxcXCJdLFxcbiAgICAgICAgICBsb25naGFuZDogW1xcbiAgICAgICAgICAgICAgXFxcItCS0L7RgdC60YDQtdGB0LXQvdGM0LVcXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCf0L7QvdC10LTQtdC70YzQvdC40LpcXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCS0YLQvtGA0L3QuNC6XFxcIixcXG4gICAgICAgICAgICAgIFxcXCLQodGA0LXQtNCwXFxcIixcXG4gICAgICAgICAgICAgIFxcXCLQp9C10YLQstC10YDQs1xcXCIsXFxuICAgICAgICAgICAgICBcXFwi0J/Rj9GC0L3QuNGG0LBcXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCh0YPQsdCx0L7RgtCwXFxcIixcXG4gICAgICAgICAgXVxcbiAgICAgIH0sXFxuICAgICAgbW9udGhzOiB7XFxuICAgICAgICAgIHNob3J0aGFuZDogW1xcbiAgICAgICAgICAgICAgXFxcItCv0L3QslxcXCIsXFxuICAgICAgICAgICAgICBcXFwi0KTQtdCyXFxcIixcXG4gICAgICAgICAgICAgIFxcXCLQnNCw0YDRglxcXCIsXFxuICAgICAgICAgICAgICBcXFwi0JDQv9GAXFxcIixcXG4gICAgICAgICAgICAgIFxcXCLQnNCw0LlcXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCY0Y7QvdGMXFxcIixcXG4gICAgICAgICAgICAgIFxcXCLQmNGO0LvRjFxcXCIsXFxuICAgICAgICAgICAgICBcXFwi0JDQstCzXFxcIixcXG4gICAgICAgICAgICAgIFxcXCLQodC10L1cXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCe0LrRglxcXCIsXFxuICAgICAgICAgICAgICBcXFwi0J3QvtGPXFxcIixcXG4gICAgICAgICAgICAgIFxcXCLQlNC10LpcXFwiLFxcbiAgICAgICAgICBdLFxcbiAgICAgICAgICBsb25naGFuZDogW1xcbiAgICAgICAgICAgICAgXFxcItCv0L3QstCw0YDRjFxcXCIsXFxuICAgICAgICAgICAgICBcXFwi0KTQtdCy0YDQsNC70YxcXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCc0LDRgNGCXFxcIixcXG4gICAgICAgICAgICAgIFxcXCLQkNC/0YDQtdC70YxcXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCc0LDQuVxcXCIsXFxuICAgICAgICAgICAgICBcXFwi0JjRjtC90YxcXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCY0Y7Qu9GMXFxcIixcXG4gICAgICAgICAgICAgIFxcXCLQkNCy0LPRg9GB0YJcXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCh0LXQvdGC0Y/QsdGA0YxcXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCe0LrRgtGP0LHRgNGMXFxcIixcXG4gICAgICAgICAgICAgIFxcXCLQndC+0Y/QsdGA0YxcXFwiLFxcbiAgICAgICAgICAgICAgXFxcItCU0LXQutCw0LHRgNGMXFxcIixcXG4gICAgICAgICAgXVxcbiAgICAgIH0sXFxuICAgICAgZmlyc3REYXlPZldlZWs6IDEsXFxuICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gXFxcIlxcXCI7XFxuICAgICAgfSxcXG4gICAgICByYW5nZVNlcGFyYXRvcjogXFxcIiDigJQgXFxcIixcXG4gICAgICB3ZWVrQWJicmV2aWF0aW9uOiBcXFwi0J3QtdC0LlxcXCIsXFxuICAgICAgc2Nyb2xsVGl0bGU6IFxcXCLQn9GA0L7QutGA0YPRgtC40YLQtSDQtNC70Y8g0YPQstC10LvQuNGH0LXQvdC40Y9cXFwiLFxcbiAgICAgIHRvZ2dsZVRpdGxlOiBcXFwi0J3QsNC20LzQuNGC0LUg0LTQu9GPINC/0LXRgNC10LrQu9GO0YfQtdC90LjRj1xcXCIsXFxuICAgICAgYW1QTTogW1xcXCLQlNCfXFxcIiwgXFxcItCf0J9cXFwiXSxcXG4gICAgICB5ZWFyQXJpYUxhYmVsOiBcXFwi0JPQvtC0XFxcIixcXG4gICAgICB0aW1lXzI0aHI6IHRydWVcXG4gIH07XFxuICBmcC5sMTBucy5ydSA9IFJ1c3NpYW47XFxuICB2YXIgcnUgPSBmcC5sMTBucztcXG5cXG4gIGV4cG9ydHMuUnVzc2lhbiA9IFJ1c3NpYW47XFxuICBleHBvcnRzLmRlZmF1bHQgPSBydTtcXG5cXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XFxuXFxufSkpO1xcblwiIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(0)(__webpack_require__(41))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvbDEwbi9ldC5qcz9lZmE1Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXHJvYmVyXFxcXERvY3VtZW50c1xcXFxLb29sX3JvYmVydFxcXFxpY2QwMDA5LTIwMTlzXFxcXERpc3RyaWJ1dGVkU3lzdGVtc1xcXFxQcm9qZWN0XFxcXFBpenphU29sdXRpb25cXFxcV2ViQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxyb2JlclxcXFxEb2N1bWVudHNcXFxcS29vbF9yb2JlcnRcXFxcaWNkMDAwOS0yMDE5c1xcXFxEaXN0cmlidXRlZFN5c3RlbXNcXFxcUHJvamVjdFxcXFxQaXp6YVNvbHV0aW9uXFxcXFdlYkFwcFxcXFxub2RlX21vZHVsZXNcXFxcZmxhdHBpY2tyXFxcXGRpc3RcXFxcbDEwblxcXFxldC5qc1wiKSkiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40\n")},function(module,exports){eval('module.exports = "(function (global, factory) {\\n  typeof exports === \'object\' && typeof module !== \'undefined\' ? factory(exports) :\\n  typeof define === \'function\' && define.amd ? define([\'exports\'], factory) :\\n  (global = global || self, factory(global.et = {}));\\n}(this, function (exports) { \'use strict\';\\n\\n  var fp = typeof window !== \\"undefined\\" && window.flatpickr !== undefined\\n      ? window.flatpickr\\n      : {\\n          l10ns: {}\\n      };\\n  var Estonian = {\\n      weekdays: {\\n          shorthand: [\\"P\\", \\"E\\", \\"T\\", \\"K\\", \\"N\\", \\"R\\", \\"L\\"],\\n          longhand: [\\n              \\"Phapev\\",\\n              \\"Esmaspev\\",\\n              \\"Teisipev\\",\\n              \\"Kolmapev\\",\\n              \\"Neljapev\\",\\n              \\"Reede\\",\\n              \\"Laupev\\",\\n          ]\\n      },\\n      months: {\\n          shorthand: [\\n              \\"Jaan\\",\\n              \\"Veebr\\",\\n              \\"Mrts\\",\\n              \\"Apr\\",\\n              \\"Mai\\",\\n              \\"Juuni\\",\\n              \\"Juuli\\",\\n              \\"Aug\\",\\n              \\"Sept\\",\\n              \\"Okt\\",\\n              \\"Nov\\",\\n              \\"Dets\\",\\n          ],\\n          longhand: [\\n              \\"Jaanuar\\",\\n              \\"Veebruar\\",\\n              \\"Mrts\\",\\n              \\"Aprill\\",\\n              \\"Mai\\",\\n              \\"Juuni\\",\\n              \\"Juuli\\",\\n              \\"August\\",\\n              \\"September\\",\\n              \\"Oktoober\\",\\n              \\"November\\",\\n              \\"Detsember\\",\\n          ]\\n      },\\n      firstDayOfWeek: 1,\\n      ordinal: function () {\\n          return \\".\\";\\n      },\\n      weekAbbreviation: \\"Nd\\",\\n      rangeSeparator: \\" kuni \\",\\n      scrollTitle: \\"Keri, et suurendada\\",\\n      toggleTitle: \\"Klpsa, et vahetada\\",\\n      time_24hr: true\\n  };\\n  fp.l10ns.et = Estonian;\\n  var et = fp.l10ns;\\n\\n  exports.Estonian = Estonian;\\n  exports.default = et;\\n\\n  Object.defineProperty(exports, \'__esModule\', { value: true });\\n\\n}));\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvbDEwbi9ldC5qcz9hZDBjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XFxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcXG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZXQgPSB7fSkpO1xcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xcblxcbiAgdmFyIGZwID0gdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgd2luZG93LmZsYXRwaWNrciAhPT0gdW5kZWZpbmVkXFxuICAgICAgPyB3aW5kb3cuZmxhdHBpY2tyXFxuICAgICAgOiB7XFxuICAgICAgICAgIGwxMG5zOiB7fVxcbiAgICAgIH07XFxuICB2YXIgRXN0b25pYW4gPSB7XFxuICAgICAgd2Vla2RheXM6IHtcXG4gICAgICAgICAgc2hvcnRoYW5kOiBbXFxcIlBcXFwiLCBcXFwiRVxcXCIsIFxcXCJUXFxcIiwgXFxcIktcXFwiLCBcXFwiTlxcXCIsIFxcXCJSXFxcIiwgXFxcIkxcXFwiXSxcXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcXG4gICAgICAgICAgICAgIFxcXCJQw7xoYXDDpGV2XFxcIixcXG4gICAgICAgICAgICAgIFxcXCJFc21hc3DDpGV2XFxcIixcXG4gICAgICAgICAgICAgIFxcXCJUZWlzaXDDpGV2XFxcIixcXG4gICAgICAgICAgICAgIFxcXCJLb2xtYXDDpGV2XFxcIixcXG4gICAgICAgICAgICAgIFxcXCJOZWxqYXDDpGV2XFxcIixcXG4gICAgICAgICAgICAgIFxcXCJSZWVkZVxcXCIsXFxuICAgICAgICAgICAgICBcXFwiTGF1cMOkZXZcXFwiLFxcbiAgICAgICAgICBdXFxuICAgICAgfSxcXG4gICAgICBtb250aHM6IHtcXG4gICAgICAgICAgc2hvcnRoYW5kOiBbXFxuICAgICAgICAgICAgICBcXFwiSmFhblxcXCIsXFxuICAgICAgICAgICAgICBcXFwiVmVlYnJcXFwiLFxcbiAgICAgICAgICAgICAgXFxcIk3DpHJ0c1xcXCIsXFxuICAgICAgICAgICAgICBcXFwiQXByXFxcIixcXG4gICAgICAgICAgICAgIFxcXCJNYWlcXFwiLFxcbiAgICAgICAgICAgICAgXFxcIkp1dW5pXFxcIixcXG4gICAgICAgICAgICAgIFxcXCJKdXVsaVxcXCIsXFxuICAgICAgICAgICAgICBcXFwiQXVnXFxcIixcXG4gICAgICAgICAgICAgIFxcXCJTZXB0XFxcIixcXG4gICAgICAgICAgICAgIFxcXCJPa3RcXFwiLFxcbiAgICAgICAgICAgICAgXFxcIk5vdlxcXCIsXFxuICAgICAgICAgICAgICBcXFwiRGV0c1xcXCIsXFxuICAgICAgICAgIF0sXFxuICAgICAgICAgIGxvbmdoYW5kOiBbXFxuICAgICAgICAgICAgICBcXFwiSmFhbnVhclxcXCIsXFxuICAgICAgICAgICAgICBcXFwiVmVlYnJ1YXJcXFwiLFxcbiAgICAgICAgICAgICAgXFxcIk3DpHJ0c1xcXCIsXFxuICAgICAgICAgICAgICBcXFwiQXByaWxsXFxcIixcXG4gICAgICAgICAgICAgIFxcXCJNYWlcXFwiLFxcbiAgICAgICAgICAgICAgXFxcIkp1dW5pXFxcIixcXG4gICAgICAgICAgICAgIFxcXCJKdXVsaVxcXCIsXFxuICAgICAgICAgICAgICBcXFwiQXVndXN0XFxcIixcXG4gICAgICAgICAgICAgIFxcXCJTZXB0ZW1iZXJcXFwiLFxcbiAgICAgICAgICAgICAgXFxcIk9rdG9vYmVyXFxcIixcXG4gICAgICAgICAgICAgIFxcXCJOb3ZlbWJlclxcXCIsXFxuICAgICAgICAgICAgICBcXFwiRGV0c2VtYmVyXFxcIixcXG4gICAgICAgICAgXVxcbiAgICAgIH0sXFxuICAgICAgZmlyc3REYXlPZldlZWs6IDEsXFxuICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gXFxcIi5cXFwiO1xcbiAgICAgIH0sXFxuICAgICAgd2Vla0FiYnJldmlhdGlvbjogXFxcIk7DpGRcXFwiLFxcbiAgICAgIHJhbmdlU2VwYXJhdG9yOiBcXFwiIGt1bmkgXFxcIixcXG4gICAgICBzY3JvbGxUaXRsZTogXFxcIktlcmksIGV0IHN1dXJlbmRhZGFcXFwiLFxcbiAgICAgIHRvZ2dsZVRpdGxlOiBcXFwiS2zDtXBzYSwgZXQgdmFoZXRhZGFcXFwiLFxcbiAgICAgIHRpbWVfMjRocjogdHJ1ZVxcbiAgfTtcXG4gIGZwLmwxMG5zLmV0ID0gRXN0b25pYW47XFxuICB2YXIgZXQgPSBmcC5sMTBucztcXG5cXG4gIGV4cG9ydHMuRXN0b25pYW4gPSBFc3RvbmlhbjtcXG4gIGV4cG9ydHMuZGVmYXVsdCA9IGV0O1xcblxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcXG5cXG59KSk7XFxuXCIiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///41\n')},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLm1pbi5jc3M/NDZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///42\n")}]);